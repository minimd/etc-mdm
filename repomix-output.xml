This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  src/
    androidTest/
      java/
        com/
          hmdm/
            launcher/
              ExampleInstrumentedTest.java
    main/
      aidl/
        com/
          hmdm/
            IMdmApi.aidl
      assets/
        isrg_root_x1.pem
      java/
        com/
          github/
            anrwatchdog/
              ANRError.java
              ANRWatchDog.java
          hmdm/
            launcher/
              databinding/
                ViewBindingUtils.java
              db/
                DatabaseHelper.java
                DownloadTable.java
                InfoHistoryTable.java
                LocationTable.java
                LogConfigTable.java
                LogTable.java
                RemoteFileTable.java
              helper/
                CertInstaller.java
                ConfigUpdater.java
                CryptoHelper.java
                Initializer.java
                MigrationHelper.java
                SettingsHelper.java
              json/
                Action.java
                Application.java
                ApplicationSetting.java
                DetailedInfo.java
                DetailedInfoConfig.java
                DetailedInfoConfigResponse.java
                DeviceCreateOptions.java
                DeviceEnrollOptions.java
                DeviceInfo.java
                Download.java
                PushMessage.java
                PushMessageJson.java
                PushResponse.java
                RemoteFile.java
                RemoteLogConfig.java
                RemoteLogConfigResponse.java
                RemoteLogItem.java
                ServerConfig.java
                ServerConfigResponse.java
                ServerResponse.java
              pro/
                service/
                  CheckForegroundAppAccessibilityService.java
                  CheckForegroundApplicationService.java
                worker/
                  DetailedInfoWorker.java
                ProUtils.java
              receiver/
                BootReceiver.java
                ShutdownReceiver.java
                SimChangedReceiver.java
              server/
                ServerService.java
                ServerServiceKeeper.java
                ServerUrl.java
                UnsafeOkHttpClient.java
              service/
                LocationService.java
                PluginApiService.java
                PushLongPollingService.java
                StatusControlService.java
              task/
                ConfirmDeviceResetTask.java
                ConfirmPasswordResetTask.java
                ConfirmRebootTask.java
                GetRemoteLogConfigTask.java
                GetServerConfigTask.java
                SendDeviceInfoTask.java
              ui/
                custom/
                  BatteryStateView.java
                  BlockingBar.java
                  StatusBarUpdater.java
                AdminActivity.java
                AdminModeRequestActivity.java
                AppShortcutManager.java
                BaseActivity.java
                BaseAppListAdapter.java
                BottomAppListAdapter.java
                ErrorDetailsActivity.java
                InitialSetupActivity.java
                MainActivity.java
                MainAppListAdapter.java
                MdmChoiceSetupActivity.java
              util/
                AppInfo.java
                ConnectionWaiter.java
                CrashLoopProtection.java
                CryptoUtils.java
                DeviceInfoProvider.java
                InstallUtils.java
                LegacyUtils.java
                PreferenceLogger.java
                PushNotificationMqttWrapper.java
                RemoteLogger.java
                SystemUtils.java
                Utils.java
                XapkUtils.java
              worker/
                PushNotificationProcessor.java
                PushNotificationWorker.java
                RemoteLogWorker.java
                ScheduledAppUpdateWorker.java
                SendDeviceInfoWorker.java
              AdminReceiver.java
              App.java
              Const.java
        org/
          eclipse/
            paho/
              android/
                service/
                  AlarmPingSender.java
                  DatabaseMessageStore.java
                  MessageStore.java
                  MqttAndroidClient.java
                  MqttAndroidConnectOptions.java
                  MqttConnection.java
                  MqttDeliveryTokenAndroid.java
                  MqttService.java
                  MqttServiceBinder.java
                  MqttServiceConstants.java
                  MqttTokenAndroid.java
                  MqttTraceHandler.java
                  ParcelableMqttMessage.java
                  PingDeathDetector.java
                  Status.java
                  WorkerPingSender.java
      res/
        drawable/
          ic_android_white_50dp.xml
          ic_arrow_back_white_24dp.xml
          ic_battery_1_red.xml
          ic_battery_2_black.xml
          ic_battery_2_white.xml
          ic_battery_3_black.xml
          ic_battery_3_white.xml
          ic_battery_4_black.xml
          ic_battery_4_white.xml
          ic_battery_5_black.xml
          ic_battery_5_white.xml
          ic_battery_6_black.xml
          ic_battery_6_white.xml
          ic_charger_black.xml
          ic_charger_white.xml
          ic_info_black_24dp.xml
          ic_info_opaque_24dp.xml
          ic_system_update_black_24dp.xml
          ic_system_update_opaque_24dp.xml
          ic_vpn_key_black_24dp.xml
          ic_vpn_key_opaque_24dp.xml
          ic_vpn_key_transparent_24dp.xml
        layout/
          activity_admin.xml
          activity_error_details.xml
          activity_initial_setup.xml
          activity_main.xml
          activity_mdm_choice.xml
          dialog_accessibility_service.xml
          dialog_administrator_mode.xml
          dialog_device_info.xml
          dialog_enter_device_id.xml
          dialog_enter_password.xml
          dialog_enter_server.xml
          dialog_file_downloading_failed.xml
          dialog_history_settings.xml
          dialog_manage_storage.xml
          dialog_miui_permissions.xml
          dialog_network_error.xml
          dialog_overlay_settings.xml
          dialog_permissions.xml
          dialog_system_settings.xml
          dialog_unknown_sources.xml
          item_app.xml
          layout_application_not_allowed.xml
        values/
          colors.xml
          dimens.xml
          strings.xml
          styles.xml
        values-ar/
          strings.xml
        values-cs/
          strings.xml
        values-de/
          strings.xml
        values-es/
          strings.xml
        values-fr/
          strings.xml
        values-it/
          strings.xml
        values-ja/
          strings.xml
        values-pl-rPL/
          strings.xml
        values-pt/
          strings.xml
        values-ru/
          strings.xml
        values-tr/
          strings.xml
        values-vi/
          strings.xml
        values-w400dp/
          dimens.xml
        values-w820dp/
          dimens.xml
        values-zh-rCN/
          strings.xml
        values-zh-rHK/
          strings.xml
        values-zh-rTW/
          strings.xml
        xml/
          accessibility_service_config.xml
          device_admin.xml
          network_security_config.xml
          provider_paths.xml
      AndroidManifest.xml
    test/
      java/
        com/
          hmdm/
            launcher/
              ExampleUnitTest.java
  .gitignore
  build.gradle
  proguard-rules.pro
fastlane/
  metadata/
    android/
      ca/
        short_description.txt
      cs/
        short_description.txt
      de/
        short_description.txt
      en-US/
        full_description.txt
        short_description.txt
        title.txt
      es/
        short_description.txt
      et/
        short_description.txt
      fr/
        short_description.txt
      ga/
        short_description.txt
      he/
        short_description.txt
      ja/
        short_description.txt
      pl/
        short_description.txt
      pt/
        short_description.txt
      pt-BR/
        short_description.txt
      pt-PT/
        short_description.txt
      ro/
        short_description.txt
      ru/
        short_description.txt
      sr/
        short_description.txt
      sw/
        short_description.txt
      tr/
        short_description.txt
      uk/
        short_description.txt
      zh-CN/
        short_description.txt
gradle/
  wrapper/
    gradle-wrapper.properties
lib/
  src/
    androidTest/
      java/
        com/
          hmdm/
            ExampleInstrumentedTest.java
    main/
      aidl/
        com/
          hmdm/
            IMdmApi.aidl
      java/
        com/
          hmdm/
            Const.java
            HeadwindMDM.java
            MDMError.java
            MDMException.java
            MDMPushHandler.java
            MDMPushMessage.java
            MDMService.java
      res/
        values/
          strings.xml
      AndroidManifest.xml
    test/
      java/
        com/
          hmdm/
            ExampleUnitTest.java
  .gitignore
  build.gradle
  proguard-rules.pro
.gitignore
build.gradle
etc-mdm.xml
gradle.properties
gradlew
gradlew.bat
LICENSE
lint.xml
NOTICE
README.md
settings.gradle
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/src/androidTest/java/com/hmdm/launcher/ExampleInstrumentedTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import android.content.Context;
import android.support.test.InstrumentationRegistry;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumentation test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getTargetContext();

//        assertEquals("com.hmdm.launcher", appContext.getPackageName());
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/databinding/ViewBindingUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.databinding;

import androidx.databinding.BindingAdapter;
import android.view.View;

public class ViewBindingUtils {

    @BindingAdapter( { "boolToVisible" } )
    public static void boolToVisible( View view, boolean boolToVisible ) {
        view.setVisibility( boolToVisible ? View.VISIBLE : View.GONE );
    }

    @BindingAdapter( { "boolToDisable" } )
    public static void boolToDisable( View view, boolean boolToDisable ) {
        view.setEnabled( !boolToDisable );
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LogConfigTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteLogConfig;
import com.hmdm.launcher.json.RemoteLogItem;

import java.util.List;

public class LogConfigTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE log_rules (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "packageId TEXT, " +
                    "level INTEGER, " +
                    "filter TEXT " +
                    ")";
    private static final String DELETE_ALL =
            "DELETE FROM log_rules";
    private static final String INSERT_RULE =
            "INSERT OR IGNORE INTO log_rules(packageId, level, filter) VALUES (?, ?, ?)";
    private static final String FIND_MATCHING =
            "SELECT * FROM log_rules WHERE packageId = ? AND level >= ? AND (filter IS NULL OR filter = '' OR ? LIKE ('%' || filter || '%')) LIMIT 1";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void replaceAll(SQLiteDatabase db, List<RemoteLogConfig> items) {
        db.beginTransaction();
        try {
            db.execSQL(DELETE_ALL);
            for (RemoteLogConfig item : items) {
                db.execSQL(INSERT_RULE, new String[]{
                        item.getPackageId(),
                        Integer.toString(item.getLogLevel()),
                        item.getFilter()
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static boolean match(SQLiteDatabase db, RemoteLogItem item) {
        Cursor cursor = db.rawQuery(FIND_MATCHING, new String[] {
                item.getPackageId(),
                Integer.toString(item.getLogLevel()),
                item.getMessage()
        });
        boolean ret = cursor.moveToFirst();
        cursor.close();
        return ret;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ApplicationSetting.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ApplicationSetting {

    private String packageId;
    private String name;
    private int type;
    private String value;
    private boolean readOnly;
    private long lastUpdate;

    public ApplicationSetting() {}

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public boolean isReadOnly() {
        return readOnly;
    }

    public void setReadOnly(boolean readOnly) {
        this.readOnly = readOnly;
    }

    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfoConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfoConfig {
    private Boolean sendData;
    private Integer intervalMins;

    public Boolean getSendData() {
        return sendData;
    }

    public void setSendData(Boolean sendData) {
        this.sendData = sendData;
    }

    public Integer getIntervalMins() {
        return intervalMins;
    }

    public void setIntervalMins(Integer intervalMins) {
        this.intervalMins = intervalMins;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfoConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfoConfigResponse extends ServerResponse {
    private DetailedInfoConfig data;

    public DetailedInfoConfigResponse() {}

    public DetailedInfoConfig getData() {
        return data;
    }

    public void setData( DetailedInfoConfig data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushMessageJson.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import org.json.JSONObject;

public class PushMessageJson extends PushMessage {
    private JSONObject payloadJSON;

    public PushMessageJson() {
    }

    public PushMessageJson(String messageType, JSONObject payloadJSON) {
        setMessageType(messageType);
        this.payloadJSON = payloadJSON;
    }

    @Override
    public JSONObject getPayloadJSON() {
        return payloadJSON;
    }

    public void setPayloadJSON(JSONObject payloadJSON) {
        this.payloadJSON = payloadJSON;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class PushResponse {
    private String status;
    private List<PushMessage> data;

    public PushResponse() {}

    public String getStatus() {
        return status;
    }

    public void setStatus( String status ) {
        this.status = status;
    }

    public List<PushMessage> getData() {
        return data;
    }

    public void setData( List<PushMessage> data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogConfig {
    private String packageId;
    private int logLevel;
    private String filter;

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getFilter() {
        return filter;
    }

    public void setFilter(String filter) {
        this.filter = filter;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogConfigResponse extends ServerResponse {

    private List<RemoteLogConfig> data;

    public RemoteLogConfigResponse() {}

    public List<RemoteLogConfig> getData() {
        return data;
    }

    public void setData( List<RemoteLogConfig> data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogItem.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogItem {
    @JsonIgnore
    private long _id;

    private long timestamp;
    private int logLevel;
    private String packageId;
    private String message;

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerConfigResponse extends ServerResponse {
    private ServerConfig data;

    public ServerConfig getData() {
        return data;
    }

    public void setData( ServerConfig data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerResponse {

    private String status;
    private String message;

    public ServerResponse() {}

    public String getStatus() {
        return status;
    }

    public void setStatus( String status ) {
        this.status = status;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage( String message ) {
        this.message = message;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/service/CheckForegroundApplicationService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

/**
 * In open-source version, the service checking foreground apps is just a stub;
 * this option is available in Pro-version only
 */
public class CheckForegroundApplicationService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        // Stub
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/worker/DetailedInfoWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.worker;

import android.content.Context;

/**
 * These functions are available in Pro-version only
 * In a free version, the class contains stubs
 */
public class DetailedInfoWorker {
    public static void schedule(Context context) {
        // stub
    }

    public static void requestConfigUpdate(Context context) {
        // stub
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/ShutdownReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

public class ShutdownReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        RemoteLogger.log(context, Const.LOG_INFO, "Shutting down the device");
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/SimChangedReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.RemoteLogger;

public class SimChangedReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        // SIM card changed, log the new IMSI and number
        String phoneNumber = null;
        try {
            phoneNumber = DeviceInfoProvider.getPhoneNumber(context);
        } catch (Exception e) {
        }

        String simState = intent.getExtras().getString("ss");

        String message = null;
        if (simState.equals("LOADED")) {
            message = "SIM card loaded";
            if (phoneNumber != null && phoneNumber.length() > 0) {
                message += ". New phone number: " + phoneNumber;
            }
        } else if (simState.equals("ABSENT")) {
            message = "SIM card removed";
        }

        if (message != null) {
            RemoteLogger.log(context, Const.LOG_INFO, message);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmDeviceResetTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmDeviceResetTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmDeviceResetTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmDeviceReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmDeviceReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmPasswordResetTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmPasswordResetTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmPasswordResetTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmPasswordReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmPasswordReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmRebootTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmRebootTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmRebootTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmReboot(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmReboot(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/GetRemoteLogConfigTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogConfigResponse;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.RemoteLogger;

import retrofit2.Response;

public class GetRemoteLogConfigTask extends AsyncTask< Void, Integer, Integer > {
    private Context context;
    private SettingsHelper settingsHelper;

    public GetRemoteLogConfigTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( Void... voids ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<RemoteLogConfigResponse> response = null;

        try {
            response = serverService.
                    getRemoteLogConfig(settingsHelper.getServerProject(), settingsHelper.getDeviceId()).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        getRemoteLogConfig(settingsHelper.getServerProject(), settingsHelper.getDeviceId()).execute();
            }

            if ( response.isSuccessful() ) {
                if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                    RemoteLogger.updateConfig(context, response.body().getData());

                    return Const.TASK_SUCCESS;
                } else {
                    return Const.TASK_ERROR;
                }
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }

        return Const.TASK_NETWORK_ERROR;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/SendDeviceInfoTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class SendDeviceInfoTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public SendDeviceInfoTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.sendDevice(settingsHelper.getServerProject(), info[ 0 ]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.sendDevice(settingsHelper.getServerProject(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/BlockingBar.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.LinearLayout;

import androidx.annotation.Nullable;

/**
 * This view is a transparent bar intended to block user interaction with swipeable system areas (status bar etc.)
 */
public class BlockingBar extends LinearLayout {

    public BlockingBar(Context context ) {
        super( context );
    }

    public BlockingBar(Context context, @Nullable AttributeSet attrs ) {
        super( context, attrs );
    }

    public BlockingBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr ) {
        super( context, attrs, defStyleAttr );
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // Intercepted touch!
        return true;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/CrashLoopProtection.java">
package com.hmdm.launcher.util;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Log;

import com.hmdm.launcher.Const;

public class CrashLoopProtection {
    // Crash loop protection
    // We consider it to be an unrecoverable fault if Headwind MDM crashes 5 times or more within a minute
    private static final long LOOP_TIME_SPAN = 60000;
    private static final long LOOP_CRASHES = 3;
    private static final String FAULT_PREFERENCE_NAME = "com.hmdm.launcher.fault";
    private static final String LAST_FAULT_TIME_PREFERENCE = "last_fault_time";
    private static final String FAULT_COUNTER_PREFERENCE = "fault_counter";

    // Register crash
    public static void registerFault(Context context) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(FAULT_PREFERENCE_NAME, Context.MODE_PRIVATE);
        long faultTime = System.currentTimeMillis();
        long lastFaultTime = preferences.getLong(LAST_FAULT_TIME_PREFERENCE, 0);
        if (faultTime - lastFaultTime > LOOP_TIME_SPAN) {
            Log.i(Const.LOG_TAG, "Crash registered once");
            preferences.edit()
                    .putInt(FAULT_COUNTER_PREFERENCE, 1)
                    .putLong(LAST_FAULT_TIME_PREFERENCE, faultTime)
                    .commit();
            return;
        }
        int crashCounter = preferences.getInt(FAULT_COUNTER_PREFERENCE, 0);
        crashCounter++;

        Log.i(Const.LOG_TAG, "Crash registered " + crashCounter + " times within " + LOOP_TIME_SPAN + " ms");
        preferences.edit().putInt(FAULT_COUNTER_PREFERENCE, crashCounter).commit();
    }

    // Protection against looping
    // Returns false if loop is detected
    public static boolean isCrashLoopDetected(Context context) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(FAULT_PREFERENCE_NAME, Context.MODE_PRIVATE);
        long faultTime = System.currentTimeMillis();
        long lastFaultTime = preferences.getLong(LAST_FAULT_TIME_PREFERENCE, 0);
        if (lastFaultTime == 0) {
            return false;
        }
        if (faultTime - lastFaultTime > LOOP_TIME_SPAN) {
            Log.i(Const.LOG_TAG, "No recent crashes registered");
            preferences.edit()
                    .putInt(FAULT_COUNTER_PREFERENCE, 0)
                    .putLong(LAST_FAULT_TIME_PREFERENCE, 0)
                    .commit();
            return false;
        }
        int crashCounter = preferences.getInt(FAULT_COUNTER_PREFERENCE, 0);
        if (crashCounter > LOOP_CRASHES) {
            Log.i(Const.LOG_TAG, "Crash loop detected!");
            return true;
        }
        return false;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/CryptoUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class CryptoUtils {
    public static String calculateChecksum(InputStream fileContent) {
        // Calculate checksum
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
        try (InputStream is = new BufferedInputStream(fileContent);
             DigestInputStream dis = new DigestInputStream(is, md)) {
            /* Read decorated stream (dis) to EOF as normal... */
            int b;
            while ((b = dis.read()) != -1) {
                // digest will consume the content when read() called
            }
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        // to calculate message digest of the input string
        // returned as array of byte
        byte[] digest = md.digest();

        // Convert byte array into signum representation
        BigInteger no = new BigInteger(1, digest);

        // Convert message digest into hex value
        String hashtext = no.toString(16);

        // Add preceding 0s to make it 32 bit
        while (hashtext.length() < 32) {
            hashtext = "0" + hashtext;
        }

        return hashtext;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/LegacyUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.ComponentName;
import android.content.Context;

import com.hmdm.launcher.AdminReceiver;

/**
 * For compatibility with old builds
 * Legacy admin receiver is ru.headwind.kiosk.AdminReceiver, it is replaced in legacy build variants
 */
public class LegacyUtils {
    public static ComponentName getAdminComponentName(Context context) {
        return new ComponentName(context.getApplicationContext(), AdminReceiver.class);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/App.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import android.app.Application;

import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.Picasso;

public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        Picasso.Builder builder = new Picasso.Builder(this);
        builder.downloader(new OkHttp3Downloader(this,Integer.MAX_VALUE));
        Picasso built = builder.build();
        //built.setIndicatorsEnabled(true);
        //built.setLoggingEnabled(true);
        Picasso.setSingletonInstance(built);
    }

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MessageStore.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import java.util.Iterator;

/**
 * <p>
 * Mechanism for persisting messages until we know they have been received
 * </p>
 * <ul>
 * <li>A Service should store messages as they arrive via
 * {@link #storeArrived(String, String, MqttMessage)}.
 * <li>When a message has been passed to the consuming entity,
 * {@link #discardArrived(String, String)} should be called.
 * <li>To recover messages which have not been definitely passed to the
 * consumer, {@link MessageStore#getAllArrivedMessages(String)} is used.
 * <li>When a clean session is started {@link #clearArrivedMessages(String)} is
 * used.
 * </ul>
 */
interface MessageStore {

	/**
	 * External representation of a stored message
	 */
	interface StoredMessage {
		/**
		 * @return the identifier for the message within the store
		 */
		String getMessageId();

		/**
		 * @return the identifier of the client which stored this message
		 */
		String getClientHandle();

		/**
		 * @return the topic on which the message was received
		 */
		String getTopic();

		/**
		 * @return the identifier of the client which stored this message
		 */
		MqttMessage getMessage();
	}

	/**
	 * Store a message and return an identifier for it
	 * 
	 * @param clientHandle
	 *            identifier for the client
	 * @param message
	 *            message to be stored
	 * @return a unique identifier for it
	 */
	String storeArrived(String clientHandle, String Topic,
						MqttMessage message);

	/**
	 * Discard a message - called when we are certain that an arrived message
	 * has reached the application.
	 * 
	 * @param clientHandle
	 *            identifier for the client
	 * @param id
	 *            id of message to be discarded
	 */
	boolean discardArrived(String clientHandle, String id);

	/**
	 * Get all the stored messages, usually for a specific client
	 * 
	 * @param clientHandle
	 *            identifier for the client - if null, then messages for all
	 *            clients are returned
	 */
	Iterator<StoredMessage> getAllArrivedMessages(String clientHandle);

	/**
	 * Discard stored messages, usually for a specific client
	 * 
	 * @param clientHandle
	 *            identifier for the client - if null, then messages for all
	 *            clients are discarded
	 */
	void clearArrivedMessages(String clientHandle);

	void close();
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttAndroidConnectOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;

public class MqttAndroidConnectOptions extends MqttConnectOptions {
    public static final int PING_ALARM = 0;
    public static final int PING_WORKER = 1;

    private int pingType;

    public int getPingType() {
        return pingType;
    }

    public void setPingType(int pingType) {
        this.pingType = pingType;
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttDeliveryTokenAndroid.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

/**
 * <p>
 * Implementation of the IMqttDeliveryToken interface for use from within the
 * MqttAndroidClient implementation
 */
class MqttDeliveryTokenAndroid extends MqttTokenAndroid
		implements IMqttDeliveryToken {

	// The message which is being tracked by this token
	private MqttMessage message;

	MqttDeliveryTokenAndroid(MqttAndroidClient client,
			Object userContext, IMqttActionListener listener, MqttMessage message) {
		super(client, userContext, listener);
		this.message = message;
	}

	/**
	 * @see org.eclipse.paho.client.mqttv3.IMqttDeliveryToken#getMessage()
	 */
	@Override
	public MqttMessage getMessage() throws MqttException {
		return message;
	}

	void setMessage(MqttMessage message) {
		this.message = message;
	}

	void notifyDelivery(MqttMessage delivered) {
		message = delivered;
		super.notifyComplete();
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttServiceBinder.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.os.Binder;

/**
 * What the Service passes to the Activity on binding:-
 * <ul>
 * <li>a reference to the Service
 * <li>the activityToken provided when the Service was started
 * </ul>
 * 
 */
class MqttServiceBinder extends Binder {

	private MqttService mqttService;
	private String activityToken;

	MqttServiceBinder(MqttService mqttService) {
		this.mqttService = mqttService;
	}

	/**
	 * @return a reference to the Service
	 */
	public MqttService getService() {
		return mqttService;
	}

	void setActivityToken(String activityToken) {
		this.activityToken = activityToken;
	}

	/**
	 * @return the activityToken provided when the Service was started
	 */
	public String getActivityToken() {
		return activityToken;
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttServiceConstants.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Various strings used to identify operations or data in the Android MQTT
 * service, mainly used in Intents passed between Activities and the Service.
 */
interface MqttServiceConstants {

	/*
	 * Version information
	 */
	
	String VERSION = "v0";
	
  /*
   * Attributes of messages <p> Used for the column names in the database
   */
  String DUPLICATE = "duplicate";
  String RETAINED = "retained";
  String QOS = "qos";
  String PAYLOAD = "payload";
  String DESTINATION_NAME = "destinationName";
  String CLIENT_HANDLE = "clientHandle";
  String MESSAGE_ID = "messageId";

  /* Tags for actions passed between the Activity and the Service */
  String SEND_ACTION = "send";
  String UNSUBSCRIBE_ACTION = "unsubscribe";
  String SUBSCRIBE_ACTION = "subscribe";
  String DISCONNECT_ACTION = "disconnect";
  String CONNECT_ACTION = "connect";
  String CONNECT_EXTENDED_ACTION = "connectExtended";
  String MESSAGE_ARRIVED_ACTION = "messageArrived";
  String MESSAGE_DELIVERED_ACTION = "messageDelivered";
  String ON_CONNECTION_LOST_ACTION = "onConnectionLost";
  String TRACE_ACTION = "trace";

  /* Identifies an Intent which calls back to the Activity */
  String CALLBACK_TO_ACTIVITY = MqttService.TAG
                                             + ".callbackToActivity"+"."+VERSION;

  /* Identifiers for extra data on Intents broadcast to the Activity */
  String CALLBACK_ACTION = MqttService.TAG + ".callbackAction";
  String CALLBACK_STATUS = MqttService.TAG + ".callbackStatus";
  String CALLBACK_CLIENT_HANDLE = MqttService.TAG + "."
                                               + CLIENT_HANDLE;
  String CALLBACK_ERROR_MESSAGE = MqttService.TAG
                                               + ".errorMessage";
  String CALLBACK_EXCEPTION_STACK = MqttService.TAG
                                                 + ".exceptionStack";
  String CALLBACK_INVOCATION_CONTEXT = MqttService.TAG + "."
                                                    + "invocationContext";
  String CALLBACK_ACTIVITY_TOKEN = MqttService.TAG + "."
                                                + "activityToken";
  String CALLBACK_DESTINATION_NAME = MqttService.TAG + '.'
                                                  + DESTINATION_NAME;
  String CALLBACK_MESSAGE_ID = MqttService.TAG + '.'
                                            + MESSAGE_ID;
  String CALLBACK_RECONNECT = MqttService.TAG + ".reconnect";
  String CALLBACK_SERVER_URI = MqttService.TAG + ".serverURI";
  String CALLBACK_MESSAGE_PARCEL = MqttService.TAG + ".PARCEL";
  String CALLBACK_TRACE_SEVERITY = MqttService.TAG
                                                + ".traceSeverity";
  String CALLBACK_TRACE_TAG = MqttService.TAG + ".traceTag";
  String CALLBACK_TRACE_ID = MqttService.TAG + ".traceId";
  String CALLBACK_ERROR_NUMBER = MqttService.TAG
                                              + ".ERROR_NUMBER";

  String CALLBACK_EXCEPTION = MqttService.TAG + ".exception";
  
  //Intent prefix for Ping sender.
  String PING_SENDER = MqttService.TAG + ".pingSender.";
  
  //Constant for wakelock
  String PING_WAKELOCK = MqttService.TAG + ".client.";
  String WAKELOCK_NETWORK_INTENT = MqttService.TAG + "";

  //Trace severity levels  
  String TRACE_ERROR = "error";
  String TRACE_DEBUG = "debug";
  String TRACE_EXCEPTION = "exception";
  
  
  //exception code for non MqttExceptions
  int NON_MQTT_EXCEPTION = -1;

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttTokenAndroid.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;
import org.eclipse.paho.client.mqttv3.internal.wire.MqttWireMessage;

/**
 * <p>
 * Implementation of the IMqttToken interface for use from within the
 * MqttAndroidClient implementation
 */

class MqttTokenAndroid implements IMqttToken {

  private IMqttActionListener listener;

  private volatile boolean isComplete;

  private volatile MqttException lastException;

  private Object waitObject = new Object();

  private MqttAndroidClient client;

  private Object userContext;

  private String[] topics;

  private IMqttToken delegate; // specifically for getMessageId

  private MqttException pendingException;

  /**
   * Standard constructor
   * 
   * @param client used to pass MqttAndroidClient object
   * @param userContext used to pass context
   * @param listener optional listener that will be notified when the action completes. Use null if not required.
   */
  MqttTokenAndroid(MqttAndroidClient client,
      Object userContext, IMqttActionListener listener) {
    this(client, userContext, listener, null);
  }

  /**
   * Constructor for use with subscribe operations
   * 
   * @param client used to pass MqttAndroidClient object
   * @param userContext used to pass context
   * @param listener optional listener that will be notified when the action completes. Use null if not required.
   * @param topics topics to subscribe to, which can include wildcards.
   */
  MqttTokenAndroid(MqttAndroidClient client,
      Object userContext, IMqttActionListener listener, String[] topics) {
    this.client = client;
    this.userContext = userContext;
    this.listener = listener;
    this.topics = topics;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#waitForCompletion()
   */
  @Override
  public void waitForCompletion() throws MqttException, MqttSecurityException {
    synchronized (waitObject) {
      try {
        waitObject.wait();
      }
      catch (InterruptedException e) {
        // do nothing
      }
    }
    if (pendingException != null) {
      throw pendingException;
    }
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#waitForCompletion(long)
   */
  @Override
  public void waitForCompletion(long timeout) throws MqttException,
      MqttSecurityException {
    synchronized (waitObject) {
      try {
        waitObject.wait(timeout);
      }
      catch (InterruptedException e) {
        // do nothing
      }
      if (!isComplete) {
        throw new MqttException(MqttException.REASON_CODE_CLIENT_TIMEOUT);
      }
      if (pendingException != null) {
        throw pendingException;
      }
    }
  }

  /**
   * notify successful completion of the operation
   */
  void notifyComplete() {
    synchronized (waitObject) {
      isComplete = true;
      waitObject.notifyAll();
      if (listener != null) {
        listener.onSuccess(this);
      }
    }
  }

  /**
   * notify unsuccessful completion of the operation
   */
  void notifyFailure(Throwable exception) {
    synchronized (waitObject) {
      isComplete = true;
      if (exception instanceof MqttException) {
        pendingException = (MqttException) exception;
      }
      else {
        pendingException = new MqttException(exception);
      }
      waitObject.notifyAll();
      if (exception instanceof MqttException) {
        lastException = (MqttException) exception;
      }
      if (listener != null) {
        listener.onFailure(this, exception);
      }
    }

  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#isComplete()
   */
  @Override
  public boolean isComplete() {
    return isComplete;
  }

  void setComplete(boolean complete) {
    isComplete = complete;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getException()
   */
  @Override
  public MqttException getException() {
    return lastException;
  }

  void setException(MqttException exception) {
    lastException = exception;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getClient()
   */
  @Override
  public IMqttAsyncClient getClient() {
    return client;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#setActionCallback(IMqttActionListener)
   */
  @Override
  public void setActionCallback(IMqttActionListener listener) {
    this.listener = listener;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getActionCallback()
   */
  @Override
  public IMqttActionListener getActionCallback() {
    return listener;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getTopics()
   */
  @Override
  public String[] getTopics() {
    return topics;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#setUserContext(Object)
   */
  @Override
  public void setUserContext(Object userContext) {
    this.userContext = userContext;

  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getUserContext()
   */
  @Override
  public Object getUserContext() {
    return userContext;
  }

  void setDelegate(IMqttToken delegate) {
    this.delegate = delegate;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getMessageId()
   */
  @Override
  public int getMessageId() {
    return (delegate != null) ? delegate.getMessageId() : 0;
  }
  
  @Override
  public MqttWireMessage getResponse() {
    return delegate.getResponse();
  }
  
  @Override
  public boolean getSessionPresent() {
    return delegate.getSessionPresent();
  }
  
  @Override
  public int[] getGrantedQos() {
    return delegate.getGrantedQos();
  }
  
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttTraceHandler.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Interface for simple trace handling, pass the trace message to trace
 * callback.
 * 
 */

public interface MqttTraceHandler {

	/**
	 * Trace debugging information
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 */
	void traceDebug(String tag, String message);

	/**
	 * Trace error information
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 */
	void traceError(String tag, String message);

	/**
	 * trace exceptions
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 * @param e
	 *            the exception
	 */
	void traceException(String tag, String message,
						Exception e);

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/ParcelableMqttMessage.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import android.os.Parcel;
import android.os.Parcelable;

/**
 * <p>
 * A way to flow MqttMessages via Bundles/Intents
 * </p>
 * 
 * <p>
 * An application will probably use this only when receiving a message from a
 * Service in a Bundle - the necessary code will be something like this :-
 * </p>
 * <pre>
 * <code>
 * 	private void messageArrivedAction(Bundle data) {
 * 		ParcelableMqttMessage message = (ParcelableMqttMessage) data
 * 			.getParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL);
 *		<i>Use the normal {@link MqttMessage} methods on the the message object.</i>
 * 	}
 * 
 * </code>
 * </pre>
 *
 * <p>
 * It is unlikely that an application will directly use the methods which are
 * specific to this class.
 * </p>
 */

public class ParcelableMqttMessage extends MqttMessage implements Parcelable {

  String messageId = null;

  ParcelableMqttMessage(MqttMessage original) {
    super(original.getPayload());
    setQos(original.getQos());
    setRetained(original.isRetained());
    setDuplicate(original.isDuplicate());
  }

  ParcelableMqttMessage(Parcel parcel) {
    super(parcel.createByteArray());
    setQos(parcel.readInt());
    boolean[] flags = parcel.createBooleanArray();
    setRetained(flags[0]);
    setDuplicate(flags[1]);
    messageId = parcel.readString();
  }

  /**
   * @return the messageId
   */
  public String getMessageId() {
    return messageId;
  }

  /**
   * Describes the contents of this object
   */
  @Override
  public int describeContents() {
    return 0;
  }

  /**
   * Writes the contents of this object to a parcel
   * 
   * @param parcel
   *            The parcel to write the data to.
   * @param flags
   *            this parameter is ignored
   */
  @Override
  public void writeToParcel(Parcel parcel, int flags) {
    parcel.writeByteArray(getPayload());
    parcel.writeInt(getQos());
    parcel.writeBooleanArray(new boolean[]{isRetained(), isDuplicate()});
    parcel.writeString(messageId);
  }

	/**
	 * A creator which creates the message object from a parcel
	 */
	public static final Parcelable.Creator<ParcelableMqttMessage> CREATOR = new Parcelable.Creator<ParcelableMqttMessage>() {

		/**
		 * Creates a message from the parcel object
		 */
		@Override
		public ParcelableMqttMessage createFromParcel(Parcel parcel) {
			return new ParcelableMqttMessage(parcel);
		}

		/**
		 * creates an array of type {@link ParcelableMqttMessage}[]
		 * 
		 */
		@Override
		public ParcelableMqttMessage[] newArray(int size) {
			return new ParcelableMqttMessage[size];
		}
	};
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/Status.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Enumeration representing the success or failure of an operation
 */
enum Status {
	/**
	 * Indicates that the operation succeeded
	 */
	OK, 
	
	/**
	 * Indicates that the operation failed
	 */
	ERROR,
	
	/**
	 * Indicates that the operation's result may be returned asynchronously
	 */
	NO_RESULT
}
</file>

<file path="app/src/main/res/drawable/ic_android_white_50dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector android:height="50dp" android:viewportHeight="24.0"
    android:viewportWidth="24.0" android:width="50dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#ffffff" android:pathData="M6,18c0,0.55 0.45,1 1,1h1v3.5c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5L11,19h2v3.5c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5L16,19h1c0.55,0 1,-0.45 1,-1L18,8L6,8v10zM3.5,8C2.67,8 2,8.67 2,9.5v7c0,0.83 0.67,1.5 1.5,1.5S5,17.33 5,16.5v-7C5,8.67 4.33,8 3.5,8zM20.5,8c-0.83,0 -1.5,0.67 -1.5,1.5v7c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5v-7c0,-0.83 -0.67,-1.5 -1.5,-1.5zM15.53,2.16l1.3,-1.3c0.2,-0.2 0.2,-0.51 0,-0.71 -0.2,-0.2 -0.51,-0.2 -0.71,0l-1.48,1.48C13.85,1.23 12.95,1 12,1c-0.96,0 -1.86,0.23 -2.66,0.63L7.85,0.15c-0.2,-0.2 -0.51,-0.2 -0.71,0 -0.2,0.2 -0.2,0.51 0,0.71l1.31,1.31C6.97,3.26 6,5.01 6,7h12c0,-1.99 -0.97,-3.75 -2.47,-4.84zM10,5L9,5L9,4h1v1zM15,5h-1L14,4h1v1z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_arrow_back_white_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#ffffff"
        android:pathData="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_info_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_info_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_system_update_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M17,1.01L7,1c-1.1,0 -2,0.9 -2,2v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2L19,3c0,-1.1 -0.9,-1.99 -2,-1.99zM17,19L7,19L7,5h10v14zM16,13h-3L13,8h-2v5L8,13l4,4 4,-4z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_system_update_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M17,1.01L7,1c-1.1,0 -2,0.9 -2,2v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2L19,3c0,-1.1 -0.9,-1.99 -2,-1.99zM17,19L7,19L7,5h10v14zM16,13h-3L13,8h-2v5L8,13l4,4 4,-4z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_transparent_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#05ffffff"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/layout/dialog_system_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <data>
        <variable name="message" type="String"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@{message}"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:id="@+id/continueButton"
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_unknown_sources.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_unknown_sources_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_unknown_sources_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueUnknownSources"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/values-w400dp/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <dimen name="dialog_enter_device_id_width">350dp</dimen>
    <dimen name="button_text_size">14dp</dimen>
    <dimen name="button_text_size_small">12dp</dimen>
</resources>
</file>

<file path="app/src/main/res/values-w820dp/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
<!-- Example customization of dimensions originally defined in res/values/dimens.xml
         (such as screen margins) for screens with more than 820dp of available width. This
         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
    <dimen name="activity_horizontal_margin">64dp</dimen>
</resources>
</file>

<file path="app/src/main/res/xml/accessibility_service_config.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="typeWindowStateChanged"
    android:accessibilityFlags="flagDefault"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:description="@string/accessibility_service_description"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true"/>
</file>

<file path="app/src/main/res/xml/device_admin.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<device-admin xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-policies>
        <wipe-data />
        <limit-password />
    </uses-policies>
</device-admin>
</file>

<file path="app/src/main/res/xml/provider_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<paths><external-path name="external_files" path="."/></paths>
</file>

<file path="app/src/test/java/com/hmdm/launcher/ExampleUnitTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="app/.gitignore">
/build
</file>

<file path="app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in C:\Android\sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}
-keep class !ru.headwind.kiosk.**{ *; }
-keep class ru.headwind.kiosk.sdk.UpdateError {*;}
</file>

<file path="lib/src/main/java/com/hmdm/MDMException.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

public class MDMException extends Exception {
    public MDMError mdmError;
    public String comment;
    public MDMException(int code) {
        super(MDMError.getMessage(code));
        mdmError = new MDMError(code);
    }
    public MDMException(int code, String comment) {
        super(MDMError.getMessage(code) + ": " + comment);
        mdmError = new MDMError(code);
        this.comment = comment;
    }
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMPushMessage.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.os.Bundle;

import org.json.JSONException;
import org.json.JSONObject;

public class MDMPushMessage {
    private String type;
    private JSONObject data;

    public static final String MessageConfigUpdated = "configUpdated";

    public MDMPushMessage(String action, Bundle bundle) throws MDMException {
        if (!action.startsWith(Const.INTENT_PUSH_NOTIFICATION_PREFIX)) {
            throw new MDMException(MDMError.ERROR_INVALID_PARAMETER);
        }
        type = action.substring(Const.INTENT_PUSH_NOTIFICATION_PREFIX.length());
        if (bundle != null) {
            String packedPayload = bundle.getString(Const.INTENT_PUSH_NOTIFICATION_EXTRA);
            if (packedPayload != null) {
                try {
                    data = new JSONObject(packedPayload);
                } catch (JSONException e) {
                    throw new MDMException(MDMError.ERROR_INVALID_PARAMETER);
                }
            }
        }
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public JSONObject getData() {
        return data;
    }

    public void setData(JSONObject data) {
        this.data = data;
    }
}
</file>

<file path="lib/src/main/res/values/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="app_name">PluginLibrary</string>
</resources>
</file>

<file path="lib/src/test/java/com/hmdm/ExampleUnitTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="lib/.gitignore">
/build
</file>

<file path="lib/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Vsevolod Mayorov

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="NOTICE">
=========================================================================
==  NOTICE file corresponding to the section 4 d of                    ==
==  the Apache License, Version 2.0                                    ==
=========================================================================

Headwind MDM: Open Source Android Mobile Device Management Software

Project website: https://h-mdm.com

(c) 2019 Headwind Solutions LLC (http://www.h-sms.com)
</file>

<file path="app/src/main/assets/isrg_root_x1.pem">
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
-----END CERTIFICATE-----
</file>

<file path="app/src/main/java/com/github/anrwatchdog/ANRError.java">
package com.github.anrwatchdog;

import android.os.Looper;

import java.io.Serializable;
import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;

/**
 * Error thrown by {@link com.github.anrwatchdog.ANRWatchDog} when an ANR is detected.
 * Contains the stack trace of the frozen UI thread.
 * <p>
 * It is important to notice that, in an ANRError, all the "Caused by" are not really the cause
 * of the exception. Each "Caused by" is the stack trace of a running thread. Note that the main
 * thread always comes first.
 */
public class ANRError extends Error {

    private static class $ implements Serializable {
        private final String _name;
        private final StackTraceElement[] _stackTrace;

        private class _Thread extends Throwable {
            private _Thread(_Thread other) {
                super(_name, other);
            }

            @Override
            public Throwable fillInStackTrace() {
                setStackTrace(_stackTrace);
                return this;
            }
        }

        private $(String name, StackTraceElement[] stackTrace) {
            _name = name;
            _stackTrace = stackTrace;
        }
    }

    private static final long serialVersionUID = 1L;

    /**
     * The minimum duration, in ms, for which the main thread has been blocked. May be more.
     */
    @SuppressWarnings("WeakerAccess")
    public final long duration;

    private ANRError($._Thread st, long duration) {
        super("Application Not Responding for at least " + duration + " ms.", st);
        this.duration = duration;
    }

    @Override
    public Throwable fillInStackTrace() {
        setStackTrace(new StackTraceElement[] {});
        return this;
    }

    static ANRError New(long duration, String prefix, boolean logThreadsWithoutStackTrace) {
        final Thread mainThread = Looper.getMainLooper().getThread();

        final Map<Thread, StackTraceElement[]> stackTraces = new TreeMap<Thread, StackTraceElement[]>(new Comparator<Thread>() {
            @Override
            public int compare(Thread lhs, Thread rhs) {
                if (lhs == rhs)
                    return 0;
                if (lhs == mainThread)
                    return 1;
                if (rhs == mainThread)
                    return -1;
                return rhs.getName().compareTo(lhs.getName());
            }
        });

        for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet())
            if (
                    entry.getKey() == mainThread
                ||  (
                        entry.getKey().getName().startsWith(prefix)
                    &&  (
                            logThreadsWithoutStackTrace
                        ||
                            entry.getValue().length > 0
                        )
                    )
                )
                stackTraces.put(entry.getKey(), entry.getValue());

        // Sometimes main is not returned in getAllStackTraces() - ensure that we list it
        if (!stackTraces.containsKey(mainThread)) {
            stackTraces.put(mainThread, mainThread.getStackTrace());
        }

        $._Thread tst = null;
        for (Map.Entry<Thread, StackTraceElement[]> entry : stackTraces.entrySet())
            tst = new $(getThreadTitle(entry.getKey()), entry.getValue()).new _Thread(tst);

        return new ANRError(tst, duration);
    }

    static ANRError NewMainOnly(long duration) {
        final Thread mainThread = Looper.getMainLooper().getThread();
        final StackTraceElement[] mainStackTrace = mainThread.getStackTrace();

        return new ANRError(new $(getThreadTitle(mainThread), mainStackTrace).new _Thread(null), duration);
    }

    private static String getThreadTitle(Thread thread) {
        return thread.getName() + " (state = " + thread.getState() + ")";
    }
}
</file>

<file path="app/src/main/java/com/github/anrwatchdog/ANRWatchDog.java">
package com.github.anrwatchdog;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Salomon BRYS
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import android.os.Debug;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

/**
 * A watchdog timer thread that detects when the UI thread has frozen.
 */
@SuppressWarnings("UnusedReturnValue")
public class ANRWatchDog extends Thread {

    public interface ANRListener {
        /**
         * Called when an ANR is detected.
         *
         * @param error The error describing the ANR.
         */
        void onAppNotResponding(ANRError error);
    }

    public interface ANRInterceptor {
        /**
         * Called when main thread has froze more time than defined by the timeout.
         *
         * @param duration The minimum time (in ms) the main thread has been frozen (may be more).
         * @return 0 or negative if the ANR should be reported immediately. A positive number of ms to postpone the reporting.
         */
        long intercept(long duration);
    }

    public interface InterruptionListener {
        void onInterrupted(InterruptedException exception);
    }

    private static final int DEFAULT_ANR_TIMEOUT = 5000;

    private static final ANRListener DEFAULT_ANR_LISTENER = new ANRListener() {
        @Override public void onAppNotResponding(ANRError error) {
            throw error;
        }
    };

    private static final ANRInterceptor DEFAULT_ANR_INTERCEPTOR = new ANRInterceptor() {
        @Override public long intercept(long duration) {
            return 0;
        }
    };

    private static final InterruptionListener DEFAULT_INTERRUPTION_LISTENER = new InterruptionListener() {
        @Override public void onInterrupted(InterruptedException exception) {
            Log.w("ANRWatchdog", "Interrupted: " + exception.getMessage());
        }
    };

    private ANRListener _anrListener = DEFAULT_ANR_LISTENER;
    private ANRInterceptor _anrInterceptor = DEFAULT_ANR_INTERCEPTOR;
    private InterruptionListener _interruptionListener = DEFAULT_INTERRUPTION_LISTENER;

    private final Handler _uiHandler = new Handler(Looper.getMainLooper());
    private final int _timeoutInterval;

    private String _namePrefix = "";
    private boolean _logThreadsWithoutStackTrace = false;
    private boolean _ignoreDebugger = true;

    private volatile long _tick = 0;
    private volatile boolean _reported = false;

    private final Runnable _ticker = new Runnable() {
        @Override public void run() {
            _tick = 0;
            _reported = false;
        }
    };

    /**
     * Constructs a watchdog that checks the ui thread every {@value #DEFAULT_ANR_TIMEOUT} milliseconds
     */
    public ANRWatchDog() {
        this(DEFAULT_ANR_TIMEOUT);
    }

    /**
     * Constructs a watchdog that checks the ui thread every given interval
     *
     * @param timeoutInterval The interval, in milliseconds, between to checks of the UI thread.
     *                        It is therefore the maximum time the UI may freeze before being reported as ANR.
     */
    public ANRWatchDog(int timeoutInterval) {
        super();
        _timeoutInterval = timeoutInterval;
    }

    /**
     * @return The interval the WatchDog
     */
    public int getTimeoutInterval() {
        return _timeoutInterval;
    }

    /**
     * Sets an interface for when an ANR is detected.
     * If not set, the default behavior is to throw an error and crash the application.
     *
     * @param listener The new listener or null
     * @return itself for chaining.
     */
    public ANRWatchDog setANRListener(ANRListener listener) {
        if (listener == null) {
            _anrListener = DEFAULT_ANR_LISTENER;
        } else {
            _anrListener = listener;
        }
        return this;
    }

    /**
     * Sets an interface to intercept ANRs before they are reported.
     * If set, you can define if, given the current duration of the detected ANR and external context, it is necessary to report the ANR.
     *
     * @param interceptor The new interceptor or null
     * @return itself for chaining.
     */
    public ANRWatchDog setANRInterceptor(ANRInterceptor interceptor) {
        if (interceptor == null) {
            _anrInterceptor = DEFAULT_ANR_INTERCEPTOR;
        } else {
            _anrInterceptor = interceptor;
        }
        return this;
    }

    /**
     * Sets an interface for when the watchdog thread is interrupted.
     * If not set, the default behavior is to just log the interruption message.
     *
     * @param listener The new listener or null.
     * @return itself for chaining.
     */
    public ANRWatchDog setInterruptionListener(InterruptionListener listener) {
        if (listener == null) {
            _interruptionListener = DEFAULT_INTERRUPTION_LISTENER;
        } else {
            _interruptionListener = listener;
        }
        return this;
    }

    /**
     * Set the prefix that a thread's name must have for the thread to be reported.
     * Note that the main thread is always reported.
     * Default "".
     *
     * @param prefix The thread name's prefix for a thread to be reported.
     * @return itself for chaining.
     */
    public ANRWatchDog setReportThreadNamePrefix(String prefix) {
        if (prefix == null) {
            prefix = "";
        }
        _namePrefix = prefix;
        return this;
    }

    /**
     * Set that only the main thread will be reported.
     *
     * @return itself for chaining.
     */
    public ANRWatchDog setReportMainThreadOnly() {
        _namePrefix = null;
        return this;
    }

    /**
     * Set that all threads will be reported (default behaviour).
     *
     * @return itself for chaining.
     */
    public ANRWatchDog setReportAllThreads() {
        _namePrefix = "";
        return this;
    }

    /**
     * Set that all running threads will be reported,
     * even those from which no stack trace could be extracted.
     * Default false.
     *
     * @param logThreadsWithoutStackTrace Whether or not all running threads should be reported
     * @return itself for chaining.
     */
    public ANRWatchDog setLogThreadsWithoutStackTrace(boolean logThreadsWithoutStackTrace) {
        _logThreadsWithoutStackTrace = logThreadsWithoutStackTrace;
        return this;
    }

    /**
     * Set whether to ignore the debugger when detecting ANRs.
     * When ignoring the debugger, ANRWatchdog will detect ANRs even if the debugger is connected.
     * By default, it does not, to avoid interpreting debugging pauses as ANRs.
     * Default false.
     *
     * @param ignoreDebugger Whether to ignore the debugger.
     * @return itself for chaining.
     */
    public ANRWatchDog setIgnoreDebugger(boolean ignoreDebugger) {
        _ignoreDebugger = ignoreDebugger;
        return this;
    }

    @SuppressWarnings("NonAtomicOperationOnVolatileField")
    @Override
    public void run() {
        setName("|ANR-WatchDog|");

        long interval = _timeoutInterval;
        while (!isInterrupted()) {
            boolean needPost = _tick == 0;
            _tick += interval;
            if (needPost) {
                _uiHandler.post(_ticker);
            }

            try {
                Thread.sleep(interval);
            } catch (InterruptedException e) {
                _interruptionListener.onInterrupted(e);
                return ;
            }

            // If the main thread has not handled _ticker, it is blocked. ANR.
            if (_tick != 0 && !_reported) {
                //noinspection ConstantConditions
                if (!_ignoreDebugger && (Debug.isDebuggerConnected() || Debug.waitingForDebugger())) {
                    Log.w("ANRWatchdog", "An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))");
                    _reported = true;
                    continue ;
                }

                interval = _anrInterceptor.intercept(_tick);
                if (interval > 0) {
                    continue;
                }

                final ANRError error;
                if (_namePrefix != null) {
                    error = ANRError.New(_tick, _namePrefix, _logThreadsWithoutStackTrace);
                } else {
                    error = ANRError.NewMainOnly(_tick);
                }
                _anrListener.onAppNotResponding(error);
                interval = _timeoutInterval;
                _reported = true;
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/DownloadTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.Download;

import java.util.LinkedList;
import java.util.List;

public class DownloadTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE downloads (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "url TEXT, " +
                    "path TEXT UNIQUE, " +
                    "attempts INTEGER, " +
                    "lastAttemptTime INTEGER, " +
                    "downloaded INTEGER, " +
                    "installed INTEGER " +
                    ")";
    private static final String INSERT_DOWNLOAD =
            "INSERT OR REPLACE INTO downloads(url, path, attempts, lastAttemptTime, downloaded, installed) VALUES (?, ?, ?, ?, ?, ?)";
    private static final String DELETE_DOWNLOAD =
            "DELETE FROM downloads WHERE _id=?";
    private static final String DELETE_DOWNLOAD_BY_PATH =
            "DELETE FROM downloads WHERE path=?";
    private static final String SELECT_ALL_DOWNLOADS =
            "SELECT * FROM downloads";
    private static final String SELECT_DOWNLOAD_BY_PATH =
            "SELECT * FROM downloads WHERE path=?";
    private static final String DELETE_ALL_DOWNLOADS =
            "DELETE FROM downloads";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, Download item) {
        try {
            db.execSQL(INSERT_DOWNLOAD, new String[]{
                    item.getUrl(),
                    item.getPath(),
                    Long.toString(item.getAttempts()),
                    Long.toString(item.getLastAttemptTime()),
                    item.isDownloaded() ? "1" : "0",
                    item.isInstalled() ? "1" : "0"
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteByPath(SQLiteDatabase db, String path) {
        try {
            db.execSQL(DELETE_DOWNLOAD_BY_PATH, new String[]{ path });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteAll(SQLiteDatabase db) {
        try {
            db.execSQL(DELETE_ALL_DOWNLOADS, new String[]{ });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @SuppressLint("Range")
    public static List<Download> selectAll(SQLiteDatabase db) {
        Cursor cursor = db.rawQuery(SELECT_ALL_DOWNLOADS, new String[] {});
        List<Download> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            Download item = new Download(cursor);
            result.add(item);

            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }

    @SuppressLint("Range")
    public static Download selectByPath(SQLiteDatabase db, String path) {
        Cursor cursor = db.rawQuery(SELECT_DOWNLOAD_BY_PATH, new String[] { path });

        Download item = null;
        if (cursor.moveToFirst()) {
            item = new Download(cursor);
        }
        cursor.close();

        return item;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/InfoHistoryTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.DetailedInfo;

import java.util.LinkedList;
import java.util.List;

public class InfoHistoryTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE info_history (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "deviceBatteryLevel INTEGER, " +
                    "deviceBatteryCharging TEXT, " +
                    "deviceWifi INTEGER, " +
                    "deviceGps INTEGER, " +
                    "deviceIp TEXT, " +
                    "deviceKeyguard INTEGER, " +
                    "deviceRingVolume INTEGER, " +
                    "deviceMobileData INTEGER, " +
                    "deviceBluetooth INTEGER, " +
                    "deviceUsbStorage INTEGER, " +
                    "wifiRssi INTEGER, " +
                    "wifiSsid TEXT, " +
                    "wifiSecurity TEXT, " +
                    "wifiState TEXT, " +
                    "wifiIp TEXT, " +
                    "wifiTx INTEGER, " +
                    "wifiRx INTEGER, " +
                    "gpsState TEXT, " +
                    "gpsProvider TEXT, " +
                    "gpsLat REAL, " +
                    "gpsLon REAL, " +
                    "gpsAlt REAL, " +
                    "gpsSpeed REAL, " +
                    "gpsCourse REAL, " +
                    "mobileRssi INTEGER, " +
                    "mobileCarrier TEXT, " +
                    "mobileNumber TEXT, " +
                    "mobileImsi TEXT, " +
                    "mobileData INTEGER, " +
                    "mobileIp TEXT, " +
                    "mobileState TEXT, " +
                    "mobileSimState TEXT, " +
                    "mobileTx INTEGER, " +
                    "mobileRx INTEGER, " +
                    "mobile2Rssi INTEGER, " +
                    "mobile2Carrier TEXT, " +
                    "mobile2Number TEXT, " +
                    "mobile2Imsi TEXT, " +
                    "mobile2Data INTEGER, " +
                    "mobile2Ip TEXT, " +
                    "mobile2State TEXT, " +
                    "mobile2SimState TEXT, " +
                    "mobile2Tx INTEGER, " +
                    "mobile2Rx INTEGER, " +
                    "deviceMemoryTotal INTEGER, " +
                    "deviceMemoryAvailable INTEGER " +
                    ")";
    private static final String ALTER_TABLE_ADD_MEMORY_TOTAL = "ALTER TABLE info_history ADD deviceMemoryTotal INT";
    private static final String ALTER_TABLE_ADD_MEMORY_AVAILABLE = "ALTER TABLE info_history ADD deviceMemoryAvailable INT";
    private static final String SELECT_LAST_INFO =
            "SELECT * FROM info_history ORDER BY ts LIMIT ?";
    private static final String INSERT_INFO =
            "INSERT OR IGNORE INTO info_history(ts, deviceBatteryLevel, deviceBatteryCharging, deviceWifi, " +
            "deviceGps, deviceIp, deviceKeyguard, deviceRingVolume, deviceMobileData, deviceBluetooth, deviceUsbStorage, " +
            "wifiRssi, wifiSsid, wifiSecurity, wifiState, wifiIp, wifiTx, wifiRx, " +
            "gpsState, gpsProvider, gpsLat, gpsLon, gpsAlt, gpsSpeed, gpsCourse, " +
            "mobileRssi, mobileCarrier, mobileNumber, mobileImsi, mobileData, mobileIp, mobileState, mobileSimState, mobileTx, mobileRx, " +
            "mobile2Rssi, mobile2Carrier, mobile2Number, mobile2Imsi, mobile2Data, mobile2Ip, mobile2State, mobile2SimState, mobile2Tx, mobile2Rx," +
            "deviceMemoryTotal, deviceMemoryAvailable" +
            ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, " +
            "?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    private static final String DELETE_FROM_INFO =
            "DELETE FROM info_history WHERE _id=?";
    private static final String DELETE_OLD_ITEMS =
            "DELETE FROM info_history WHERE ts < ?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static String getAlterTableAddMemoryTotalSql() {
        return ALTER_TABLE_ADD_MEMORY_TOTAL;
    }

    public static String getAlterTableAddMemoryAvailableSql() {
        return ALTER_TABLE_ADD_MEMORY_AVAILABLE;
    }

    public static void insert(SQLiteDatabase db, DetailedInfo item) {
        try {
            DetailedInfo.Device device = item.getDevice();
            DetailedInfo.Wifi wifi = item.getWifi();
            DetailedInfo.Gps gps = item.getGps();
            DetailedInfo.Mobile mobile = item.getMobile();
            DetailedInfo.Mobile mobile2 = item.getMobile2();

            db.execSQL(INSERT_INFO, new String[]{
                    Long.toString(item.getTs()),

                    device != null && device.getBatteryLevel() != null ? device.getBatteryLevel().toString() : null,
                    device != null ? device.getBatteryCharging() : null,
                    device != null && device.getWifi() != null ? (device.getWifi() ? "1" : "0") : null,
                    device != null && device.getGps() != null ? (device.getGps() ? "1" : "0") : null,
                    device != null ? device.getIp() : null,
                    device != null && device.getKeyguard() != null ? (device.getKeyguard() ? "1" : "0") : null,
                    device != null && device.getRingVolume() != null ? device.getRingVolume().toString() : null,
                    device != null && device.getMobileData() != null ? (device.getMobileData() ? "1" : "0") : null,
                    device != null && device.getBluetooth() != null ? (device.getBluetooth() ? "1" : "0") : null,
                    device != null && device.getUsbStorage() != null ? (device.getUsbStorage() ? "1" : "0") : null,

                    wifi != null && wifi.getRssi() != null ? wifi.getRssi().toString() : null,
                    wifi != null ? wifi.getSsid() : null,
                    wifi != null ? wifi.getSecurity() : null,
                    wifi != null ? wifi.getState() : null,
                    wifi != null ? wifi.getIp() : null,
                    wifi != null && wifi.getTx() != null ? wifi.getTx().toString() : null,
                    wifi != null && wifi.getRx() != null ? wifi.getRx().toString() : null,

                    gps != null ? gps.getState() : null,
                    gps != null ? gps.getProvider() : null,
                    gps != null && gps.getLat() != null ? gps.getLat().toString() : null,
                    gps != null && gps.getLon() != null ? gps.getLon().toString() : null,
                    gps != null && gps.getAlt() != null ? gps.getAlt().toString() : null,
                    gps != null && gps.getSpeed() != null ? gps.getSpeed().toString() : null,
                    gps != null && gps.getCourse() != null ? gps.getCourse().toString() : null,

                    mobile != null && mobile.getRssi() != null ? mobile.getRssi().toString() : null,
                    mobile != null ? mobile.getCarrier() : null,
                    mobile != null ? mobile.getNumber() : null,
                    mobile != null ? mobile.getImsi() : null,
                    mobile != null && mobile.getData() != null ? (mobile.getData() ? "1" : "0") : null,
                    mobile != null ? mobile.getIp() : null,
                    mobile != null ? mobile.getState() : null,
                    mobile != null ? mobile.getSimState() : null,
                    mobile != null && mobile.getTx() != null ? mobile.getTx().toString() : null,
                    mobile != null && mobile.getRx() != null ? mobile.getRx().toString() : null,

                    mobile2 != null && mobile2.getRssi() != null ? mobile2.getRssi().toString() : null,
                    mobile2 != null ? mobile2.getCarrier() : null,
                    mobile2 != null ? mobile2.getNumber() : null,
                    mobile2 != null ? mobile2.getImsi() : null,
                    mobile2 != null && mobile2.getData() != null ? (mobile2.getData() ? "1" : "0") : null,
                    mobile2 != null ? mobile2.getIp() : null,
                    mobile2 != null ? mobile2.getState() : null,
                    mobile2 != null ? mobile2.getSimState() : null,
                    mobile2 != null && mobile2.getTx() != null ? mobile2.getTx().toString() : null,
                    mobile2 != null && mobile2.getRx() != null ? mobile2.getRx().toString() : null,

                    device != null && device.getMemoryTotal() != null ? device.getMemoryTotal().toString() : null,
                    device != null && device.getMemoryAvailable() != null ? device.getMemoryAvailable().toString() : null,
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_OLD_ITEMS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<DetailedInfo> items) {
        db.beginTransaction();
        try {
            for (DetailedInfo item : items) {
                db.execSQL(DELETE_FROM_INFO, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static List<DetailedInfo> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_INFO, new String[] {
                Integer.toString(limit)
        });
        List<DetailedInfo> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            DetailedInfo item = new DetailedInfo(cursor);
            result.add(item);
            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LogTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteLogItem;

import java.util.LinkedList;
import java.util.List;

public class LogTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE logs (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "level INTEGER, " +
                    "packageId TEXT, " +
                    "message TEXT" +
                    ")";
    private static final String SELECT_LAST_LOGS =
            "SELECT * FROM logs ORDER BY ts LIMIT ?";
    private static final String INSERT_LOG =
            "INSERT OR IGNORE INTO logs(ts, level, packageId, message) VALUES (?, ?, ?, ?)";
    private static final String DELETE_FROM_LOGS =
            "DELETE FROM logs WHERE _id=?";
    private static final String DELETE_OLD_LOGS =
            "DELETE FROM logs WHERE ts < ?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, RemoteLogItem item) {
        try {
            db.execSQL(INSERT_LOG, new String[]{
                    Long.toString(item.getTimestamp()),
                    Integer.toString(item.getLogLevel()),
                    item.getPackageId(),
                    item.getMessage()
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_FROM_LOGS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<RemoteLogItem> items) {
        db.beginTransaction();
        try {
            for (RemoteLogItem item : items) {
                db.execSQL(DELETE_FROM_LOGS, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    @SuppressLint("Range")
    public static List<RemoteLogItem> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_LOGS, new String[] {
            Integer.toString(limit)
        });
        List<RemoteLogItem> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            RemoteLogItem item = new RemoteLogItem();
            item.setId(cursor.getLong(cursor.getColumnIndex("_id")));
            item.setTimestamp(cursor.getLong(cursor.getColumnIndex("ts")));
            item.setLogLevel(cursor.getInt(cursor.getColumnIndex("level")));
            item.setPackageId(cursor.getString(cursor.getColumnIndex("packageId")));
            item.setMessage(cursor.getString(cursor.getColumnIndex("message")));
            result.add(item);

            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/RemoteFileTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteFile;

public class RemoteFileTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE files (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "lastUpdate INTEGER, " +
                    "url TEXT, " +
                    "checksum TEXT, " +
                    "path TEXT UNIQUE, " +
                    "description TEXT " +
                    ")";
    private static final String INSERT_FILE =
            "INSERT OR REPLACE INTO files(lastUpdate, url, checksum, path, description) VALUES (?, ?, ?, ?, ?)";
    private static final String DELETE_FILE =
            "DELETE FROM files WHERE _id=?";
    private static final String DELETE_FILE_BY_PATH =
            "DELETE FROM files WHERE path=?";
    private static final String SELECT_FILE_BY_PATH =
            "SELECT * FROM files WHERE path=?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, RemoteFile item) {
        try {
            db.execSQL(INSERT_FILE, new String[]{
                    Long.toString(item.getLastUpdate()),
                    item.getUrl(),
                    item.getChecksum(),
                    item.getPath(),
                    item.getDescription()
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteByPath(SQLiteDatabase db, String path) {
        try {
            db.execSQL(DELETE_FILE_BY_PATH, new String[]{ path });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @SuppressLint("Range")
    public static RemoteFile selectByPath(SQLiteDatabase db, String path) {
        Cursor cursor = db.rawQuery(SELECT_FILE_BY_PATH, new String[] { path });

        RemoteFile item = null;
        if (cursor.moveToFirst()) {
            item = new RemoteFile();
            item.setId(cursor.getLong(cursor.getColumnIndex("_id")));
            item.setLastUpdate(cursor.getLong(cursor.getColumnIndex("lastUpdate")));
            item.setUrl(cursor.getString(cursor.getColumnIndex("url")));
            item.setChecksum(cursor.getString(cursor.getColumnIndex("checksum")));
            item.setPath(cursor.getString(cursor.getColumnIndex("path")));
            item.setDescription(cursor.getString(cursor.getColumnIndex("description")));
        }
        cursor.close();

        return item;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/CryptoHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.helper;

import java.security.MessageDigest;

public class CryptoHelper {

    private final static String MD5 = "MD5";
    private final static String UTF8 = "UTF-8";

    private final static char[] hexArray = "0123456789abcdef".toCharArray();

    public static String getMD5String( String value ) {
        try {
            MessageDigest md = MessageDigest.getInstance( MD5 );
            md.update( value.getBytes( UTF8 ) );
            byte[] digest = md.digest();

            char[] hexChars = new char[ digest.length * 2 ];
            for ( int i = 0; i < digest.length; i++ ) {
                int v = digest[ i ] & 0xFF;
                hexChars[ i * 2 ] = hexArray[ v >>> 4 ];
                hexChars[ i * 2 + 1 ] = hexArray[ v & 0x0F ];
            }
            return new String( hexChars ).toUpperCase();
        } catch ( Exception e ) { throw new RuntimeException( e ); }
    }

    public static String getSHA1String( String value ) {
        try {
            MessageDigest md = MessageDigest.getInstance( "SHA-1" );
            md.update( value.getBytes( UTF8 ) );
            byte[] digest = md.digest();

            char[] hexChars = new char[ digest.length * 2 ];
            for ( int i = 0; i < digest.length; i++ ) {
                int v = digest[ i ] & 0xFF;
                hexChars[ i * 2 ] = hexArray[ v >>> 4 ];
                hexChars[ i * 2 + 1 ] = hexArray[ v & 0x0F ];
            }
            return new String( hexChars ).toUpperCase();
        } catch ( Exception e ) { throw new RuntimeException( e ); }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Action.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Action {
    private String action;
    private String categories;
    private String packageId;
    private String activity;
    private String schemes;
    private String hosts;
    private String mimeTypes;

    public Action() {}

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getCategories() {
        return categories;
    }

    public void setCategories(String categories) {
        this.categories = categories;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public String getActivity() {
        return activity;
    }

    public void setActivity(String activity) {
        this.activity = activity;
    }

    public String getSchemes() {
        return schemes;
    }

    public void setSchemes(String schemes) {
        this.schemes = schemes;
    }

    public String getHosts() {
        return hosts;
    }

    public void setHosts(String hosts) {
        this.hosts = hosts;
    }

    public String getMimeTypes() {
        return mimeTypes;
    }

    public void setMimeTypes(String mimeTypes) {
        this.mimeTypes = mimeTypes;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceCreateOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DeviceCreateOptions {
    private String customer;
    private String configuration;
    private List<String> groups;

    public DeviceCreateOptions() {}

    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }

    public String getConfiguration() {
        return configuration;
    }

    public void setConfiguration(String configuration) {
        this.configuration = configuration;
    }

    public List<String> getGroups() {
        return groups;
    }

    public void setGroups(List<String> groups) {
        this.groups = groups;
    }

    public void setGroups(String[] groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(Set<String> groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(String groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        String[] groupArray = groups.split(",");
        setGroups(groupArray);
    }

    public Set<String> getGroupSet() {
        if (groups == null) {
            return null;
        }
        Set<String> result = new HashSet<>();
        for (String group : groups) {
            result.add(group);
        }
        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceEnrollOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DeviceEnrollOptions {
    private String customer;
    private String configuration;
    private List<String> groups;

    public DeviceEnrollOptions() {}

    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }

    public String getConfiguration() {
        return configuration;
    }

    public void setConfiguration(String configuration) {
        this.configuration = configuration;
    }

    public List<String> getGroups() {
        return groups;
    }

    public void setGroups(List<String> groups) {
        this.groups = groups;
    }

    public void setGroups(String[] groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(Set<String> groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(String groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        String[] groupArray = groups.split(",");
        setGroups(groupArray);
    }

    public Set<String> getGroupSet() {
        if (groups == null) {
            return null;
        }
        Set<String> result = new HashSet<>();
        for (String group : groups) {
            result.add(group);
        }
        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Download.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import android.annotation.SuppressLint;
import android.database.Cursor;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Download {
    @JsonIgnore
    private long _id;

    private String url;
    private String path;
    private long attempts;
    private long lastAttemptTime;
    private boolean downloaded;
    private boolean installed;

    public Download() {}

    public Download(Download download) {
        _id = download._id;
        url = download.url;
        path = download.path;
        attempts = download.attempts;
        lastAttemptTime = download.lastAttemptTime;
        downloaded = download.downloaded;
        installed = download.installed;
    }

    @SuppressLint("Range")
    public Download(Cursor cursor) {
        setId(cursor.getLong(cursor.getColumnIndex("_id")));
        setUrl(cursor.getString(cursor.getColumnIndex("url")));
        setPath(cursor.getString(cursor.getColumnIndex("path")));
        setAttempts(cursor.getLong(cursor.getColumnIndex("attempts")));
        setLastAttemptTime(cursor.getLong(cursor.getColumnIndex("lastAttemptTime")));
        setDownloaded(cursor.getInt(cursor.getColumnIndex("downloaded")) != 0);
        setInstalled(cursor.getInt(cursor.getColumnIndex("installed")) != 0);
    }

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public long getAttempts() {
        return attempts;
    }

    public void setAttempts(long attempts) {
        this.attempts = attempts;
    }

    public long getLastAttemptTime() {
        return lastAttemptTime;
    }

    public void setLastAttemptTime(long lastAttemptTime) {
        this.lastAttemptTime = lastAttemptTime;
    }

    public boolean isDownloaded() {
        return downloaded;
    }

    public void setDownloaded(boolean downloaded) {
        this.downloaded = downloaded;
    }

    public boolean isInstalled() {
        return installed;
    }

    public void setInstalled(boolean installed) {
        this.installed = installed;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/service/CheckForegroundAppAccessibilityService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

/**
 * In open-source version, the service checking foreground apps is just a stub;
 * this option is available in Pro-version only
 */
public class CheckForegroundAppAccessibilityService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        // Stub
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerUrl.java">
package com.hmdm.launcher.server;

import java.net.MalformedURLException;
import java.net.URL;

public class ServerUrl {
    public String baseUrl;
    public String serverProject;

    public ServerUrl(String serverUrl) throws MalformedURLException {
        URL url;
         url = new URL(serverUrl);

        baseUrl = url.getProtocol() + "://" + url.getHost();
        if (url.getPort() != -1) {
            baseUrl += ":" + url.getPort();
        }
        serverProject = url.getPath();
        if (serverProject.endsWith("/")) {
            serverProject = serverProject.substring(0, serverProject.length() - 1);
        }
        if (serverProject.startsWith("/")) {
            serverProject = serverProject.substring(1);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/UnsafeOkHttpClient.java">
package com.hmdm.launcher.server;

import com.hmdm.launcher.Const;

import java.security.cert.CertificateException;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import okhttp3.OkHttpClient;

public class UnsafeOkHttpClient {
    public static OkHttpClient getUnsafeOkHttpClient() {
        try {
            // Create a trust manager that does not validate certificate chains
            final TrustManager[] trustAllCerts = new TrustManager[] {
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
            };

            // Install the all-trusting trust manager
            final SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());

            // Create an ssl socket factory with our all-trusting manager
            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            OkHttpClient.Builder builder = new OkHttpClient.Builder().
                    connectTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS ).
                    readTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS ).
                    writeTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS );
            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager)trustAllCerts[0]);
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

            OkHttpClient okHttpClient = builder.build();
            return okHttpClient;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/StatusControlService.java">
package com.hmdm.launcher.service;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiManager;
import android.os.IBinder;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.Utils;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class StatusControlService extends Service {

    private SettingsHelper settingsHelper;
    private ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor( 1 );
    private boolean controlDisabled = false;
    private Timer disableControlTimer;

    private final long ENABLE_CONTROL_DELAY = 60;

    private final long STATUS_CHECK_INTERVAL_MS = 10000;

    private static class PackageInfo {
        public String packageName;
        public String className;

        public PackageInfo(String packageName, String className) {
            this.packageName = packageName;
            this.className = className;
        }
    }

    private BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            switch ( intent.getAction() ) {
                case Const.ACTION_SERVICE_STOP:
                    stopSelf();
                    break;
                case Const.ACTION_STOP_CONTROL:
                    disableControl();
                    break;
            }
        }
    };

    @Override
    public void onDestroy() {
        LocalBroadcastManager.getInstance( this ).unregisterReceiver( receiver );

        threadPoolExecutor.shutdownNow();
        threadPoolExecutor = new ScheduledThreadPoolExecutor( 1 );

        Log.i(Const.LOG_TAG, "StatusControlService: service stopped");

        super.onDestroy();
    }

    @Override
    public int onStartCommand( Intent intent, int flags, int startId) {
        settingsHelper = SettingsHelper.getInstance(this);

        Log.i(Const.LOG_TAG, "StatusControlService: service started.");

        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);

        IntentFilter intentFilter = new IntentFilter(Const.ACTION_SERVICE_STOP);
        intentFilter.addAction(Const.ACTION_STOP_CONTROL);
        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, intentFilter);

        threadPoolExecutor.shutdownNow();

        threadPoolExecutor = new ScheduledThreadPoolExecutor(1);
        threadPoolExecutor.scheduleWithFixedDelay(() -> controlStatus(),
                STATUS_CHECK_INTERVAL_MS, STATUS_CHECK_INTERVAL_MS, TimeUnit.MILLISECONDS);

        return Service.START_STICKY;
    }


    private void disableControl() {
        Log.i(Const.LOG_TAG, "StatusControlService: request to disable control");

        if (disableControlTimer != null) {
            try {
                disableControlTimer.cancel();
            } catch (Exception e) {
            }
            disableControlTimer = null;
        }
        controlDisabled = true;
        disableControlTimer = new Timer();
        disableControlTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                controlDisabled = false;
                Log.i(Const.LOG_TAG, "StatusControlService: control enabled");
            }
        }, ENABLE_CONTROL_DELAY * 1000);
        Log.i(Const.LOG_TAG, "StatusControlService: control disabled for 60 sec");
    }

    private void controlStatus() {
        ServerConfig config = settingsHelper.getConfig();
        if (config == null || controlDisabled) {
            return;
        }

        if (config.getBluetooth() != null) {
            try {
                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                if (bluetoothAdapter != null) {
                    boolean enabled = bluetoothAdapter.isEnabled();
                    if (config.getBluetooth() && !enabled) {
                        bluetoothAdapter.enable();
                    } else if (!config.getBluetooth() && enabled) {
                        bluetoothAdapter.disable();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // Note: SecurityException here on Mediatek
        // Looks like com.mediatek.permission.CTA_ENABLE_WIFI needs to be explicitly granted
        // or even available to system apps only
        // By now, let's just ignore this issue
        if (config.getWifi() != null) {
            try {
                WifiManager wifiManager = (WifiManager) this.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
                if (wifiManager != null) {
                    boolean enabled = wifiManager.isWifiEnabled();
                    if (config.getWifi() && !enabled) {
                        wifiManager.setWifiEnabled(true);
                    } else if (!config.getWifi() && enabled) {
                        wifiManager.setWifiEnabled(false);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (config.getGps() != null) {
            LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
            if (lm != null) {
                boolean enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
                if (config.getGps() && !enabled) {
                    notifyStatusViolation(Const.GPS_ON_REQUIRED);
                    return;
                } else if (!config.getGps() && enabled) {
                    notifyStatusViolation(Const.GPS_OFF_REQUIRED);
                    return;
                }
            }
        }

        if (config.getMobileData() != null) {
            ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm != null) {
                try {
                    boolean enabled = Utils.isMobileDataEnabled(this);
                    if (config.getMobileData() && !enabled) {
                        notifyStatusViolation(Const.MOBILE_DATA_ON_REQUIRED);
                    } else if (!config.getMobileData() && enabled) {
                        notifyStatusViolation(Const.MOBILE_DATA_OFF_REQUIRED);
                    }
                } catch (Exception e) {
                    // Some problem access private API
                }
            }
        }
    }

    private void notifyStatusViolation(int cause) {
        Intent intent = new Intent(Const.ACTION_POLICY_VIOLATION);
        intent.putExtra(Const.POLICY_VIOLATION_CAUSE, cause);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/BatteryStateView.java">
package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.Nullable;

import com.hmdm.launcher.R;

public class BatteryStateView extends LinearLayout {
    private Context context;
    private TextView percentView;
    private ImageView pluggedView;
    private ImageView batteryView;
    private boolean darkBackground = true;
    private int chargePercent = 100;
    private boolean plugged = false;

    private int[] lightImages = {
            R.drawable.ic_battery_1_red,
            R.drawable.ic_battery_2_white,
            R.drawable.ic_battery_3_white,
            R.drawable.ic_battery_4_white,
            R.drawable.ic_battery_5_white,
            R.drawable.ic_battery_6_white
    };

    private int[] darkImages = {
            R.drawable.ic_battery_1_red,
            R.drawable.ic_battery_2_black,
            R.drawable.ic_battery_3_black,
            R.drawable.ic_battery_4_black,
            R.drawable.ic_battery_5_black,
            R.drawable.ic_battery_6_black
    };

    public BatteryStateView(Context context) {
        super(context);
        init(context);
    }

    public BatteryStateView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public BatteryStateView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context);
    }

    private void init(Context context) {
        this.context = context;

        setOrientation(HORIZONTAL);
        setGravity(Gravity.RIGHT | Gravity.CENTER_VERTICAL);

        percentView = new TextView(context);
        pluggedView = new ImageView(context);
        batteryView = new ImageView(context);

        LayoutParams textParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        LayoutParams imageParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);

        percentView.setLayoutParams(textParams);
        pluggedView.setLayoutParams(imageParams);
        batteryView.setLayoutParams(imageParams);

        addView(percentView);
        addView(pluggedView);
        addView(batteryView);

        pluggedView.setVisibility(View.GONE);
    }

    public void setDarkBackground(boolean darkBackground) {
        if (this.darkBackground != darkBackground) {
            this.darkBackground = darkBackground;
            updateControls();
        }
    }

    public void setChargePercent(int chargePercent) {
        if (this.chargePercent != chargePercent) {
            this.chargePercent = chargePercent;
            updateControls();
        }
    }

    public void setPlugged(boolean plugged) {
        if (this.plugged != plugged) {
            this.plugged = plugged;
            updateControls();
        }
    }

    private void updateControls() {
        percentView.setTextColor(context.getResources().getColor(darkBackground ? R.color.statusBarLight : R.color.statusBarDark));
        percentView.setText(chargePercent + "%");
        int imageIndex = chargePercent / 18;
        batteryView.setImageResource(darkBackground ? lightImages[imageIndex] : darkImages[imageIndex]);
        pluggedView.setImageResource(darkBackground ? R.drawable.ic_charger_white : R.drawable.ic_charger_black);
        if (plugged) {
            percentView.setVisibility(View.GONE);
            pluggedView.setVisibility(View.VISIBLE);
        } else {
            percentView.setVisibility(View.VISIBLE);
            pluggedView.setVisibility(View.GONE);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/StatusBarUpdater.java">
package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Handler;
import android.view.View;
import android.widget.TextView;

import com.hmdm.launcher.R;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class StatusBarUpdater {
    private Context context;
    private TextView clockView;
    private BatteryStateView batteryStateView;
    private final Handler handler = new Handler();
    private final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
    private boolean visible = false;

    private final Runnable updateRunnable = new Runnable() {
        @Override
        public void run() {
            if (visible) {
                updateStatusBar();
            }
            handler.postDelayed(this, 5000);
        }
    };

    private void updateStatusBar() {
        String currentTime = timeFormat.format(new Date());
        clockView.setText(currentTime);

        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);

        Intent batteryStatus = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                context.registerReceiver(null, ifilter, Context.RECEIVER_EXPORTED) :
                context.registerReceiver(null, ifilter);
        int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL) {
            int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            batteryStateView.setPlugged(chargePlug == BatteryManager.BATTERY_PLUGGED_USB ||
                chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
        } else {
            batteryStateView.setPlugged(false);
        }

        int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
        int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        batteryStateView.setChargePercent(level * 100 / scale);
    }

    public void startUpdating(Context context, TextView clockView, BatteryStateView batteryStateView) {
        this.context = context;
        this.clockView = clockView;
        this.batteryStateView = batteryStateView;
        handler.post(updateRunnable);
    }

    public void stopUpdating() {
        handler.removeCallbacks(updateRunnable);
    }

    public void updateControlsState(boolean visible, boolean darkBackground) {
        this.visible = visible;
        if (clockView != null) {
            clockView.setVisibility(visible ? View.VISIBLE : View.GONE);
            clockView.setTextColor(context.getResources().getColor(darkBackground ? R.color.statusBarLight : R.color.statusBarDark));
        }
        if (batteryStateView != null) {
            batteryStateView.setVisibility(visible ? View.VISIBLE : View.GONE);
            batteryStateView.setDarkBackground(darkBackground);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/ConnectionWaiter.java">
package com.hmdm.launcher.util;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import com.hmdm.launcher.Const;

public class ConnectionWaiter {
    private static Handler handler = new Handler(Looper.getMainLooper());

    public static boolean waitForConnect(Context context, Runnable uiCallback) {
        for (int n = 0; n < 10; n++) {
            if (isNetworkAvailable(context)) {
                if (n > 0) {
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                Log.d(Const.LOG_TAG, "Network is available, resuming flow");
                handler.post(uiCallback);
                return true;
            }
            Log.d(Const.LOG_TAG, "Network is unavailable, waiting, attempts: " + (9 - n));
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        Log.d(Const.LOG_TAG, "Proceed without network!");
        handler.post(uiCallback);
        return false;
    }

    public static boolean isNetworkAvailable(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (cm == null) {
            return false;
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Network network = cm.getActiveNetwork();
            if (network == null) return false;

            NetworkCapabilities capabilities = cm.getNetworkCapabilities(network);
            return capabilities != null &&
                    (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ||
                            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET));
        } else {
            android.net.NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
            return activeNetwork != null && activeNetwork.isConnected();
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/PreferenceLogger.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.SharedPreferences;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.SimpleDateFormat;
import java.util.Date;

public class PreferenceLogger {

    private static boolean DEBUG = BuildConfig.DEVICE_ADMIN_DEBUG;

    private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    private static void _log(SharedPreferences preferences, String message) {
        Log.d(Const.LOG_TAG, message);
        if (DEBUG) {
            String logString = preferences.getString(Const.PREFERENCES_LOG_STRING, "");
            logString += sdf.format(new Date()) + " " + message;
            logString += "\n";
            preferences.edit().putString(Const.PREFERENCES_LOG_STRING, logString).commit();
        }
    }

    public synchronized static void log(SharedPreferences preferences, String message) {
        _log(preferences, message);
    }

    public synchronized static String getLogString(SharedPreferences preferences) {
        if (DEBUG) {
            return preferences.getString(Const.PREFERENCES_LOG_STRING, "");
        }
        return "";
    }

    public synchronized static void clearLogString(SharedPreferences preferences) {
        if (DEBUG) {
            preferences.edit().putString(Const.PREFERENCES_LOG_STRING, "").commit();
        }
    }

    public synchronized static void printStackTrace(SharedPreferences preferences, Exception e) {
        StringWriter errors = new StringWriter();
        e.printStackTrace(new PrintWriter(errors));
        _log(preferences, errors.toString());
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/RemoteLogger.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.LogConfigTable;
import com.hmdm.launcher.db.LogTable;
import com.hmdm.launcher.json.RemoteLogConfig;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.worker.RemoteLogWorker;

import java.util.List;

/**
 * Remote logging engine which uses SQLite for configuration
 * and storing unsent logs
 */
public class RemoteLogger {
    public static long lastLogRemoval = 0;

    public static void updateConfig(Context context, List<RemoteLogConfig> rules) {
        LogConfigTable.replaceAll(DatabaseHelper.instance(context).getWritableDatabase(), rules);
    }

    public static void log(Context context, int level, String message) {
        switch (level) {
            case Const.LOG_VERBOSE:
                Log.v(Const.LOG_TAG, message);
                break;
            case Const.LOG_DEBUG:
                Log.d(Const.LOG_TAG, message);
                break;
            case Const.LOG_INFO:
                Log.i(Const.LOG_TAG, message);
                break;
            case Const.LOG_WARN:
                Log.w(Const.LOG_TAG, message);
                break;
            case Const.LOG_ERROR:
                Log.e(Const.LOG_TAG, message);
                break;
        }

        RemoteLogItem item = new RemoteLogItem();
        item.setTimestamp(System.currentTimeMillis());
        item.setLogLevel(level);
        item.setPackageId(context.getPackageName());
        item.setMessage(message);
        postLog(context, item);
    }

    public static void postLog(Context context, RemoteLogItem item) {
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        if (LogConfigTable.match(db, item)) {
            db = dbHelper.getWritableDatabase();
            LogTable.insert(db, item);
            sendLogsToServer(context);
        }

        // Remove old logs once per hour
        long now = System.currentTimeMillis();
        if (now > lastLogRemoval + 3600000L) {
            db = dbHelper.getWritableDatabase();
            LogTable.deleteOldItems(db);
            lastLogRemoval = now;
        }
    }

    public static void resetState() {
        RemoteLogWorker.resetState();
    }

    public static void sendLogsToServer(Context context) {
        RemoteLogWorker.scheduleUpload(context);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/RemoteLogWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.LogTable;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import java.util.List;
import java.util.concurrent.TimeUnit;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class RemoteLogWorker extends Worker {

    // Amount of log messages sent to server at once
    public static final int MAX_UPLOADED_MESSAGES = 10;

    // Logs are sent once per minute to reduce the server load
    public static final int FIRE_PERIOD_MINS = 1;

    // If there's no Internet, retry in 15 minutes
    public static final int FIRE_PERIOD_RETRY_MINS = 15;

    private static final String WORK_TAG_REMOTE_LOG = "com.hmdm.launcher.WORK_TAG_REMOTE_LOG";

    private static boolean uploadScheduled = false;

    private Context context;
    private SettingsHelper settingsHelper;

    public static void resetState() {
        uploadScheduled = false;
    }

    public static void scheduleUpload(Context context) {
        scheduleUpload(context, 0);
    }

    public static void scheduleUpload(Context context, int delayMins) {
        Log.i(Const.LOG_TAG, "RemoteLogWorker scheduled");
        OneTimeWorkRequest.Builder builder = new OneTimeWorkRequest.Builder(RemoteLogWorker.class);
        builder.addTag(Const.WORK_TAG_COMMON);
        if (delayMins > 0) {
            builder.setInitialDelay(delayMins, TimeUnit.MINUTES);
        }
        OneTimeWorkRequest uploadWorkRequest = builder.build();
        if (!uploadScheduled) {
            uploadScheduled = true;
            WorkManager.getInstance(context).enqueueUniqueWork(WORK_TAG_REMOTE_LOG, ExistingWorkPolicy.REPLACE, uploadWorkRequest);
        }
    }

    public RemoteLogWorker(
            @NonNull Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        try {
            DatabaseHelper dbHelper = DatabaseHelper.instance(context);

            while (true) {
                List<RemoteLogItem> unsentItems = LogTable.select(dbHelper.getReadableDatabase(), MAX_UPLOADED_MESSAGES);
                Log.i(Const.LOG_TAG, "Remote logger: unsent items: " + unsentItems.size());
                if (unsentItems.size() == 0) {
                    uploadScheduled = false;
                    return Result.success();
                }
                if (!upload(unsentItems)) {
                    // There was an error: retry!
                    // XXX: we do not use Result.retry() here because new logs may come
                    Log.i(Const.LOG_TAG, "Failed to upload logs: retry in " + FIRE_PERIOD_RETRY_MINS + " mins");
                    uploadScheduled = false;
                    scheduleUpload(context, FIRE_PERIOD_RETRY_MINS);
                    return Result.failure();
                } else {
                    Log.i(Const.LOG_TAG, "Logs are uploaded");
                    // Mark items as sent and query next items
                    LogTable.delete(DatabaseHelper.instance(context).getWritableDatabase(), unsentItems);
                }
            }
        } catch (Exception e) {
            // Oops... WTF? We need to retry!
            e.printStackTrace();
            uploadScheduled = false;
            scheduleUpload(context, FIRE_PERIOD_MINS);
            return Result.failure();
        }
    }

    // Returns true on success and false on failure
    public boolean upload(List<RemoteLogItem> logItems) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<ResponseBody> response = null;

        try {
            response = serverService.sendLogs(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), logItems).execute();
            return response.isSuccessful();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        sendLogs(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), logItems).execute();
                return response.isSuccessful();
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        return false;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/ScheduledAppUpdateWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.util.RemoteLogger;

import java.util.concurrent.TimeUnit;

public class ScheduledAppUpdateWorker extends Worker {

    // Minimal interval is 15 minutes as per docs
    public static final int FIRE_PERIOD_MINS = 15;

    private static final String WORK_TAG_SCHEDULED_UPDATES = "com.hmdm.launcher.WORK_TAG_SCHEDULED_UPDATES";

    public static void schedule(Context context) {
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (settingsHelper.getConfig() != null) {
            settingsHelper.setLastAppUpdateState(ConfigUpdater.checkAppUpdateTimeRestriction(settingsHelper.getConfig()));
        }
        Log.d(Const.LOG_TAG, "Scheduled app updates worker runs each " + FIRE_PERIOD_MINS + " mins");
        PeriodicWorkRequest queryRequest =
                new PeriodicWorkRequest.Builder(ScheduledAppUpdateWorker.class, FIRE_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_SCHEDULED_UPDATES,
                ExistingPeriodicWorkPolicy.REPLACE, queryRequest);
    }

    private Context context;
    private SettingsHelper settingsHelper;

    public ScheduledAppUpdateWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper.getConfig() == null) {
            Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: config=null");
            return Result.failure();
        }
        if (settingsHelper.getConfig().getAppUpdateFrom() == null || settingsHelper.getConfig().getAppUpdateTo() == null) {
            // No need to do anything
            Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: scheduled app update not set");
            return Result.success();
        }

        boolean lastAppUpdateState = settingsHelper.getLastAppUpdateState();
        boolean canUpdateAppsNow = ConfigUpdater.checkAppUpdateTimeRestriction(settingsHelper.getConfig());
        Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: lastAppUpdateState=" + lastAppUpdateState + ", canUpdateAppsNow=" + canUpdateAppsNow);
        if (lastAppUpdateState == canUpdateAppsNow) {
            // App update state not changed
            return Result.success();
        }

        if (!lastAppUpdateState && canUpdateAppsNow) {
            // Need to update apps now
            RemoteLogger.log(context, Const.LOG_DEBUG, "Running scheduled app update");
            settingsHelper.setConfigUpdateTimestamp(System.currentTimeMillis());
            ConfigUpdater.forceConfigUpdate(context);
        }
        settingsHelper.setLastAppUpdateState(canUpdateAppsNow);
        return Result.success();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/SendDeviceInfoWorker.java">
package com.hmdm.launcher.worker;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.DeviceInfoProvider;

import java.util.concurrent.TimeUnit;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class SendDeviceInfoWorker extends Worker {

    private static final int SEND_DEVICE_INFO_PERIOD_MINS = 15;

    private static final String WORK_TAG_DEVICEINFO = "com.hmdm.launcher.WORK_TAG_DEVICEINFO";

    private Context context;
    private SettingsHelper settingsHelper;

    public SendDeviceInfoWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper == null || settingsHelper.getConfig() == null) {
            return Result.failure();
        }

        DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);

        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<ResponseBody> response = null;

        try {
            response = serverService.sendDevice(settingsHelper.getServerProject(), deviceInfo).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.sendDevice(settingsHelper.getServerProject(), deviceInfo).execute();
            }
            if ( response.isSuccessful() ) {
                SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
                return Result.success();
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Result.failure();
    }

    public static void scheduleDeviceInfoSending(Context context) {
        PeriodicWorkRequest request =
                new PeriodicWorkRequest.Builder(SendDeviceInfoWorker.class, SEND_DEVICE_INFO_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(SEND_DEVICE_INFO_PERIOD_MINS, TimeUnit.MINUTES)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_DEVICEINFO, ExistingPeriodicWorkPolicy.REPLACE, request);
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/DatabaseMessageStore.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *   Contributors:
 *     James Sutton - Removing SQL Injection vunerability (bug 467378)
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import java.util.Iterator;

/**
 * Implementation of the {@link MessageStore} interface, using a SQLite database
 * 
 */
class DatabaseMessageStore implements MessageStore {

	// TAG used for indentify trace data etc.
	private static final String TAG = "DatabaseMessageStore";

	// One "private" database column name
	// The other database column names are defined in MqttServiceConstants
	private static final String MTIMESTAMP = "mtimestamp";

	// the name of the table in the database to which we will save messages
	private static final String ARRIVED_MESSAGE_TABLE_NAME = "MqttArrivedMessageTable";

	// the database
	private SQLiteDatabase db = null;

	// a SQLiteOpenHelper specific for this database
	private MQTTDatabaseHelper mqttDb = null;

	// a place to send trace data
	private MqttTraceHandler traceHandler = null;

	/**
	 * We need a SQLiteOpenHelper to handle database creation and updating
	 * 
	 */
	private static class MQTTDatabaseHelper extends SQLiteOpenHelper {
		// TAG used for indentify trace data etc.
		private static final String TAG = "MQTTDatabaseHelper";

		private static final String DATABASE_NAME = "mqttAndroidService.db";

		// database version, used to recognise when we need to upgrade
		// (delete and recreate)
		private static final int DATABASE_VERSION = 1;

		// a place to send trace data
		private MqttTraceHandler traceHandler = null;

		/**
		 * Constructor.
		 * 
		 * @param traceHandler
		 * @param context
		 */
		public MQTTDatabaseHelper(MqttTraceHandler traceHandler, Context context) {
			super(context, DATABASE_NAME, null, DATABASE_VERSION);
			this.traceHandler = traceHandler;
		}

		/**
		 * When the database is (re)created, create our table
		 * 
		 * @param database
		 */
		@Override
		public void onCreate(SQLiteDatabase database) {
			String createArrivedTableStatement = "CREATE TABLE "
					+ ARRIVED_MESSAGE_TABLE_NAME + "("
					+ MqttServiceConstants.MESSAGE_ID + " TEXT PRIMARY KEY, "
					+ MqttServiceConstants.CLIENT_HANDLE + " TEXT, "
					+ MqttServiceConstants.DESTINATION_NAME + " TEXT, "
					+ MqttServiceConstants.PAYLOAD + " BLOB, "
					+ MqttServiceConstants.QOS + " INTEGER, "
					+ MqttServiceConstants.RETAINED + " TEXT, "
					+ MqttServiceConstants.DUPLICATE + " TEXT, " + MTIMESTAMP
					+ " INTEGER" + ");";
			traceHandler.traceDebug(TAG, "onCreate {"
					+ createArrivedTableStatement + "}");
			try {
				database.execSQL(createArrivedTableStatement);
				traceHandler.traceDebug(TAG, "created the table");
			} catch (SQLException e) {
				traceHandler.traceException(TAG, "onCreate", e);
				throw e;
			}
		}

		/**
		 * To upgrade the database, drop and recreate our table
		 * 
		 * @param db
		 *            the database
		 * @param oldVersion
		 *            ignored
		 * @param newVersion
		 *            ignored
		 */

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			traceHandler.traceDebug(TAG, "onUpgrade");
			try {
				db.execSQL("DROP TABLE IF EXISTS " + ARRIVED_MESSAGE_TABLE_NAME);
			} catch (SQLException e) {
				traceHandler.traceException(TAG, "onUpgrade", e);
				throw e;
			}
			onCreate(db);
			traceHandler.traceDebug(TAG, "onUpgrade complete");
		}
	}

	/**
	 * Constructor - create a DatabaseMessageStore to store arrived MQTT message
	 * 
	 * @param service
	 *            our parent MqttService
	 * @param context
	 *            a context to use for android calls
	 */
	public DatabaseMessageStore(MqttService service, Context context) {
		this.traceHandler = service;

		// Open message database
		mqttDb = new MQTTDatabaseHelper(traceHandler, context);

		// Android documentation suggests that this perhaps
		// could/should be done in another thread, but as the
		// database is only one table, I doubt it matters...
		
		traceHandler.traceDebug(TAG, "DatabaseMessageStore<init> complete");
	}

	/**
	 * Store an MQTT message
	 * 
	 * @param clientHandle
	 *            identifier for the client storing the message
	 * @param topic
	 *            The topic on which the message was published
	 * @param message
	 *            the arrived MQTT message
	 * @return an identifier for the message, so that it can be removed when appropriate
	 */
	@Override
	public String storeArrived(String clientHandle, String topic,
			MqttMessage message) {
		
		db = mqttDb.getWritableDatabase();
		
		traceHandler.traceDebug(TAG, "storeArrived{" + clientHandle + "}, {"
				+ message.toString() + "}");

		byte[] payload = message.getPayload();
		int qos = message.getQos();
		boolean retained = message.isRetained();
		boolean duplicate = message.isDuplicate();

		ContentValues values = new ContentValues();
		String id = java.util.UUID.randomUUID().toString();
		values.put(MqttServiceConstants.MESSAGE_ID, id);
		values.put(MqttServiceConstants.CLIENT_HANDLE, clientHandle);
		values.put(MqttServiceConstants.DESTINATION_NAME, topic);
		values.put(MqttServiceConstants.PAYLOAD, payload);
		values.put(MqttServiceConstants.QOS, qos);
		values.put(MqttServiceConstants.RETAINED, retained);
		values.put(MqttServiceConstants.DUPLICATE, duplicate);
		values.put(MTIMESTAMP, System.currentTimeMillis());
		try {
			db.insertOrThrow(ARRIVED_MESSAGE_TABLE_NAME, null, values);
		} catch (SQLException e) {
			traceHandler.traceException(TAG, "onUpgrade", e);
			throw e;
		}
		int count = getArrivedRowCount(clientHandle);
		traceHandler
				.traceDebug(
						TAG,
						"storeArrived: inserted message with id of {"
								+ id
								+ "} - Number of messages in database for this clientHandle = "
								+ count);
		return id;
	}

	private int getArrivedRowCount(String clientHandle) {
        int count = 0;
        String[] projection = {
                MqttServiceConstants.MESSAGE_ID,
        };
  		String selection =  MqttServiceConstants.CLIENT_HANDLE + "=?";
        String[] selectionArgs = new String[1];
        selectionArgs[0] = clientHandle;
		Cursor c = db.query(
                ARRIVED_MESSAGE_TABLE_NAME, // Table Name
                projection, // The columns to return;
                selection, // Columns for WHERE Clause
                selectionArgs , // The values for the WHERE Cause
				null,  //Don't group the rows
                null,  // Don't filter by row groups
                null   // The sort order
        );

		if (c.moveToFirst()) {
			count = c.getInt(0);
		}
		c.close();
		return count;
	}

	/**
	 * Delete an MQTT message.
	 * 
	 * @param clientHandle
	 *            identifier for the client which stored the message
	 * @param id
	 *            the identifying string returned when the message was stored
	 * 
	 * @return true if the message was found and deleted
	 */
	@Override
	public boolean discardArrived(String clientHandle, String id) {
		
		db = mqttDb.getWritableDatabase();
		
		traceHandler.traceDebug(TAG, "discardArrived{" + clientHandle + "}, {"
				+ id + "}");
		int rows;
        String[] selectionArgs = new String[2];
        selectionArgs[0] = id;
        selectionArgs[1] = clientHandle;

		try {
			rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME,
					MqttServiceConstants.MESSAGE_ID + "=? AND "
							+ MqttServiceConstants.CLIENT_HANDLE + "=?",
                    selectionArgs);
		} catch (SQLException e) {
			traceHandler.traceException(TAG, "discardArrived", e);
			throw e;
		}
		if (rows != 1) {
			traceHandler.traceError(TAG,
					"discardArrived - Error deleting message {" + id
							+ "} from database: Rows affected = " + rows);
			return false;
		}
		int count = getArrivedRowCount(clientHandle);
		traceHandler
				.traceDebug(
						TAG,
						"discardArrived - Message deleted successfully. - messages in db for this clientHandle "
								+ count);
		return true;
	}

	/**
	 * Get an iterator over all messages stored (optionally for a specific client)
	 * 
	 * @param clientHandle
	 *            identifier for the client.<br>
	 *            If null, all messages are retrieved
	 * @return iterator of all the arrived MQTT messages
	 */
	@Override
	public Iterator<StoredMessage> getAllArrivedMessages(
			final String clientHandle) {
		return new Iterator<StoredMessage>() {
			private Cursor c;
			private boolean hasNext;
            private final String[] selectionArgs = {
                    clientHandle,
            };


			{
				db = mqttDb.getWritableDatabase();
				// anonymous initialiser to start a suitable query
				// and position at the first row, if one exists
				if (clientHandle == null) {
					c = db.query(ARRIVED_MESSAGE_TABLE_NAME,
                            null,
                            null,
                            null,
							null,
                            null,
                            "mtimestamp ASC");
				} else {
					c = db.query(ARRIVED_MESSAGE_TABLE_NAME,
                            null,
							MqttServiceConstants.CLIENT_HANDLE + "=?",
                            selectionArgs,
                            null,
                            null,
							"mtimestamp ASC");
				}
				hasNext = c.moveToFirst();
			}

			@Override
			public boolean hasNext() {
		        if (!hasNext){
		          	c.close();
				}
				return hasNext;
			}

			@Override
			@SuppressLint("Range")
			public StoredMessage next() {
				String messageId = c.getString(c
						.getColumnIndex(MqttServiceConstants.MESSAGE_ID));
				String clientHandle = c.getString(c
						.getColumnIndex(MqttServiceConstants.CLIENT_HANDLE));
				String topic = c.getString(c
						.getColumnIndex(MqttServiceConstants.DESTINATION_NAME));
				byte[] payload = c.getBlob(c
						.getColumnIndex(MqttServiceConstants.PAYLOAD));
				int qos = c.getInt(c.getColumnIndex(MqttServiceConstants.QOS));
				boolean retained = Boolean.parseBoolean(c.getString(c
						.getColumnIndex(MqttServiceConstants.RETAINED)));
				boolean dup = Boolean.parseBoolean(c.getString(c
						.getColumnIndex(MqttServiceConstants.DUPLICATE)));

				// build the result
				MqttMessageHack message = new MqttMessageHack(payload);
				message.setQos(qos);
				message.setRetained(retained);
				message.setDuplicate(dup);

				// move on
				hasNext = c.moveToNext();
				return new DbStoredData(messageId, clientHandle, topic, message);
			}

			@Override
			public void remove() {
				throw new UnsupportedOperationException();
			}

      /* (non-Javadoc)
       * @see java.lang.Object#finalize()
       */
      @Override
      protected void finalize() throws Throwable {
        c.close();
        super.finalize();
      }

    };
  }

	/**
	 * Delete all messages (optionally for a specific client)
	 * 
	 * @param clientHandle
	 *            identifier for the client.<br>
	 *            If null, all messages are deleted
	 */
	@Override
	public void clearArrivedMessages(String clientHandle) {
		
		db = mqttDb.getWritableDatabase();
        String[] selectionArgs = new String[1];
        selectionArgs[0] = clientHandle;
		
		int rows = 0;
		if (clientHandle == null) {
			traceHandler.traceDebug(TAG,
					"clearArrivedMessages: clearing the table");
			rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME, null, null);
		} else {
			traceHandler.traceDebug(TAG,
					"clearArrivedMessages: clearing the table of "
							+ clientHandle + " messages");
            rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME,
                    MqttServiceConstants.CLIENT_HANDLE + "=?",
                    selectionArgs);

		}
		traceHandler.traceDebug(TAG, "clearArrivedMessages: rows affected = "
				+ rows);
	}

	private class DbStoredData implements StoredMessage {
		private String messageId;
		private String clientHandle;
		private String topic;
		private MqttMessage message;

		DbStoredData(String messageId, String clientHandle, String topic,
				MqttMessage message) {
			this.messageId = messageId;
			this.topic = topic;
			this.message = message;
		}

		@Override
		public String getMessageId() {
			return messageId;
		}

		@Override
		public String getClientHandle() {
			return clientHandle;
		}

		@Override
		public String getTopic() {
			return topic;
		}

		@Override
		public MqttMessage getMessage() {
			return message;
		}
	}

	/**
	 * A way to get at the "setDuplicate" method of MqttMessage
	 */
	private class MqttMessageHack extends MqttMessage {

		public MqttMessageHack(byte[] payload) {
			super(payload);
		}

		@Override
		protected void setDuplicate(boolean dup) {
			super.setDuplicate(dup);
		}
	}

	@Override
	public void close() {
		if (this.db!=null)
			this.db.close();
		
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttConnection.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.app.Service;
import android.content.Context;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

import org.eclipse.paho.android.service.MessageStore.StoredMessage;
import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.persist.MqttDefaultFilePersistence;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * <p>
 * MqttConnection holds a MqttAsyncClient {host,port,clientId} instance to perform 
 * MQTT operations to MQTT broker.
 * </p>
 * <p>
 * Most of the major API here is intended to implement the most general forms of
 * the methods in IMqttAsyncClient, with slight adjustments for the Android
 * environment<br>
 * These adjustments usually consist of adding two parameters to each method :-
 * <ul>
 * <li>invocationContext - a string passed from the application to identify the
 * context of the operation (mainly included for support of the javascript API
 * implementation)</li>
 * <li>activityToken - a string passed from the Activity to relate back to a
 * callback method or other context-specific data</li>
 * </ul>
 * </p>
 * <p>
 * Operations are very much asynchronous, so success and failure are notified by
 * packing the relevant data into Intent objects which are broadcast back to the
 * Activity via the MqttService.callbackToActivity() method.
 * </p>
 */
class MqttConnection implements MqttCallbackExtended {

	// Strings for Intents etc..
	private static final String TAG = "MqttConnection";
	// Error status messages
	private static final String NOT_CONNECTED = "not connected";

	// fields for the connection definition
	private String serverURI;
	public String getServerURI() {
		return serverURI;
	}

	public void setServerURI(String serverURI) {
		this.serverURI = serverURI;
	}

	public String getClientId() {
		return clientId;
	}

	public void setClientId(String clientId) {
		this.clientId = clientId;
	}

	private String clientId;
	private MqttClientPersistence persistence = null;
	private MqttConnectOptions connectOptions;

	public MqttConnectOptions getConnectOptions() {
		return connectOptions;
	}

	public void setConnectOptions(MqttConnectOptions connectOptions) {
		this.connectOptions = connectOptions;
	}

	// Client handle, used for callbacks...
	private String clientHandle;

	public String getClientHandle() {
		return clientHandle;
	}

	public void setClientHandle(String clientHandle) {
		this.clientHandle = clientHandle;
	}

	//store connect ActivityToken for reconnect
	private String reconnectActivityToken = null;

	// our client object - instantiated on connect
	private MqttAsyncClient myClient = null;

	private MqttPingSender pingSender = null;

	// our (parent) service object
	private MqttService service = null;

	private IMqttMessageListener defaultMessageListener = null;

	private volatile boolean disconnected = true;
	private boolean cleanSession = true;

	// Indicate this connection is connecting or not.
	// This variable uses to avoid reconnect multiple times.
	private volatile boolean isConnecting = false;

	// Saved sent messages and their corresponding Topics, activityTokens and
	// invocationContexts, so we can handle "deliveryComplete" callbacks
	// from the mqttClient
	private Map<IMqttDeliveryToken, String /* Topic */> savedTopics = new HashMap<>();
	private Map<IMqttDeliveryToken, MqttMessage> savedSentMessages = new HashMap<>();
	private Map<IMqttDeliveryToken, String> savedActivityTokens = new HashMap<>();
	private Map<IMqttDeliveryToken, String> savedInvocationContexts = new HashMap<>();

	private WakeLock wakelock = null;
	private String wakeLockTag = null;

	private DisconnectedBufferOptions bufferOpts = null;

	/**
	 * Constructor - create an MqttConnection to communicate with MQTT server
	 * 
	 * @param service
	 *            our "parent" service - we make callbacks to it
	 * @param serverURI
	 *            the URI of the MQTT server to which we will connect
	 * @param clientId
	 *            the name by which we will identify ourselves to the MQTT
	 *            server
	 * @param persistence
	 *            the persistence class to use to store in-flight message. If
	 *            null then the default persistence mechanism is used
	 * @param clientHandle
	 *            the "handle" by which the activity will identify us
	 */
	MqttConnection(MqttService service, String serverURI, String clientId,
			MqttClientPersistence persistence, String clientHandle, IMqttMessageListener defaultMessageListener) {
		this.serverURI = serverURI;
		this.service = service;
		this.clientId = clientId;
		this.persistence = persistence;
		this.clientHandle = clientHandle;
		this.defaultMessageListener = defaultMessageListener;

		StringBuilder stringBuilder = new StringBuilder(this.getClass().getCanonicalName());
		stringBuilder.append(" ");
		stringBuilder.append(clientId);
		stringBuilder.append(" ");
		stringBuilder.append("on host ");
		stringBuilder.append(serverURI);
		wakeLockTag = stringBuilder.toString();
	}

	// The major API implementation follows
	/**
	 * Connect to the server specified when we were instantiated
	 * 
	 * @param options
	 *            timeout, etc
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void connect(MqttConnectOptions options, String invocationContext,
			String activityToken) {
		
		connectOptions = options;
		reconnectActivityToken = activityToken;

		if (options != null) {
			cleanSession = options.isCleanSession();
		}

		if (connectOptions.isCleanSession()) { // if it's a clean session,
			// discard old data
			service.messageStore.clearArrivedMessages(clientHandle);
		}

		service.traceDebug(TAG, "Connecting {" + serverURI + "} as {" + clientId + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_ACTION);
		
				
		try {
			if (persistence == null) {
				// ask Android where we can put files
				File myDir = service.getExternalFilesDir(TAG);

				if (myDir == null) {
					// No external storage, use internal storage instead.
					myDir = service.getDir(TAG, Context.MODE_PRIVATE);
					
					if(myDir == null){
						//Shouldn't happen.
						resultBundle.putString(
								MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
								"Error! No external and internal storage available");
						resultBundle.putSerializable(
								MqttServiceConstants.CALLBACK_EXCEPTION, new MqttPersistenceException());
						service.callbackToActivity(clientHandle, Status.ERROR,
								resultBundle);
						return;
					}
				}

				// use that to setup MQTT client persistence storage
				persistence = new MqttDefaultFilePersistence(
						myDir.getAbsolutePath());
			}
			
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle) {

				@Override
				public void onSuccess(IMqttToken asyncActionToken) {
					doAfterConnectSuccess(resultBundle);
					service.traceDebug(TAG, "connect success!");
				}

				@Override
				public void onFailure(IMqttToken asyncActionToken,
						Throwable exception) {
					resultBundle.putString(
							MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
							exception.getLocalizedMessage());
					resultBundle.putSerializable(
							MqttServiceConstants.CALLBACK_EXCEPTION, exception);
					service.traceError(TAG,
							"connect fail, call connect to reconnect.reason:"
									+ exception.getMessage());

					doAfterConnectFail(resultBundle);

				}
			};
			
			if (myClient != null) {
				if (isConnecting ) {
					service.traceDebug(TAG,
							"myClient != null and the client is connecting. Connect return directly.");
					service.traceDebug(TAG,"Connect return:isConnecting:"+isConnecting+".disconnected:"+disconnected);
				}else if(!disconnected){
					service.traceDebug(TAG,"myClient != null and the client is connected and notify!");
					doAfterConnectSuccess(resultBundle);
				}
				else {					
					service.traceDebug(TAG, "myClient != null and the client is not connected");
					service.traceDebug(TAG,"Do Real connect!");
					setConnectingState(true);
					myClient.connect(connectOptions, invocationContext, listener);
				}
			}
			
			// if myClient is null, then create a new connection
			else {
			    pingSender = instantiatePingSender(service);
				myClient = new MqttAsyncClient(serverURI, clientId,
						persistence, pingSender);
				myClient.setCallback(this);

				service.traceDebug(TAG,"Do Real connect!");
				setConnectingState(true);
				myClient.connect(connectOptions, invocationContext, listener);
			}
		} catch (Exception e) {
			service.traceError(TAG, "Exception occurred attempting to connect: " + e.getMessage());
			setConnectingState(false);
			handleException(resultBundle, e);
		}
	}

	private MqttPingSender instantiatePingSender(MqttService service) {
	    if (connectOptions instanceof MqttAndroidConnectOptions) {
            MqttAndroidConnectOptions extendedOptions = (MqttAndroidConnectOptions) connectOptions;
            switch (extendedOptions.getPingType()) {
                case MqttAndroidConnectOptions.PING_WORKER:
                    return WorkerPingSender.getInstance(service);
            }
        }
	    // Default is Alarm sender
        return new AlarmPingSender(service);
    }

	private void doAfterConnectSuccess(final Bundle resultBundle) {
		//since the device's cpu can go to sleep, acquire a wakelock and drop it later.
		acquireWakeLock();
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		deliverBacklog();
		setConnectingState(false);
		disconnected = false;
		releaseWakeLock();
	}

	@Override
	public void connectComplete(boolean reconnect, String serverURI) {
		Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_EXTENDED_ACTION);
		resultBundle.putBoolean(MqttServiceConstants.CALLBACK_RECONNECT, reconnect);
		resultBundle.putString(MqttServiceConstants.CALLBACK_SERVER_URI, serverURI);
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
	}

	private void doAfterConnectFail(final Bundle resultBundle){
		//
		acquireWakeLock();
		disconnected = true;
		setConnectingState(false);
		service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		releaseWakeLock();
	}
	
	private void handleException(final Bundle resultBundle, Exception e) {
		resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
				e.getLocalizedMessage());

		resultBundle.putSerializable(MqttServiceConstants.CALLBACK_EXCEPTION, e);

		service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
	}

	/**
	 * Attempt to deliver any outstanding messages we've received but which the
	 * application hasn't acknowledged. If "cleanSession" was specified, we'll
	 * have already purged any such messages from our messageStore.
	 */
	private void deliverBacklog() {
		Iterator<StoredMessage> backlog = service.messageStore
				.getAllArrivedMessages(clientHandle);
		while (backlog.hasNext()) {
			StoredMessage msgArrived = backlog.next();
			Bundle resultBundle = messageToBundle(msgArrived.getMessageId(),
					msgArrived.getTopic(), msgArrived.getMessage());
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.MESSAGE_ARRIVED_ACTION);
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}
	}

	/**
	 * Create a bundle containing all relevant data pertaining to a message
	 * 
	 * @param messageId
	 *            the message's identifier in the messageStore, so that a
	 *            callback can be made to remove it once delivered
	 * @param topic
	 *            the topic on which the message was delivered
	 * @param message
	 *            the message itself
	 * @return the bundle
	 */
	private Bundle messageToBundle(String messageId, String topic,
			MqttMessage message) {
		Bundle result = new Bundle();
		result.putString(MqttServiceConstants.CALLBACK_MESSAGE_ID, messageId);
		result.putString(MqttServiceConstants.CALLBACK_DESTINATION_NAME, topic);
		result.putParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL,
				new ParcelableMqttMessage(message));
		return result;
	}
	
	/**
	 * Close connection from the server
	 * 
	 */
	void close() {
		service.traceDebug(TAG, "close()");
		try {
			if (myClient != null) {
				myClient.close();
			}
		} catch (MqttException e) {
			// Pass a new bundle, let handleException stores error messages.
			handleException(new Bundle(), e);
		}
	}

	/**
	 * Disconnect from the server
	 * 
	 * @param quiesceTimeout
	 *            in milliseconds
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 */
	void disconnect(long quiesceTimeout, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "disconnect()");
		disconnected = true;
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.DISCONNECT_ACTION);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.disconnect(quiesceTimeout, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.DISCONNECT_ACTION,
					NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		if (connectOptions != null && connectOptions.isCleanSession()) {
			// assume we'll clear the stored messages at this point
			service.messageStore.clearArrivedMessages(clientHandle);
		}

		releaseWakeLock();
	}

	/**
	 * Disconnect from the server
	 * 
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 */
	void disconnect(String invocationContext, String activityToken) {
		service.traceDebug(TAG, "disconnect()");
		disconnected = true;
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.DISCONNECT_ACTION);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.disconnect(invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.DISCONNECT_ACTION,
					NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		if (connectOptions != null && connectOptions.isCleanSession()) {
			// assume we'll clear the stored messages at this point
			service.messageStore.clearArrivedMessages(clientHandle);
		}
		releaseWakeLock();
	}

	/**
	 * @return true if we are connected to an MQTT server
	 */
	public boolean isConnected() {
		return myClient != null && myClient.isConnected();
	}

	/**
	 * Publish a message on a topic
	 * 
	 * @param topic
	 *            the topic on which to publish - represented as a string, not
	 *            an MqttTopic object
	 * @param payload
	 *            the content of the message to publish
	 * @param qos
	 *            the quality of service requested
	 * @param retained
	 *            whether the MQTT server should retain this message
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 * @return token for tracking the operation
	 */
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained, String invocationContext, String activityToken) {
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SEND_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		IMqttDeliveryToken sendToken = null;

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				MqttMessage message = new MqttMessage(payload);
				message.setQos(qos);
				message.setRetained(retained);
				sendToken = myClient.publish(topic, payload, qos, retained,
						invocationContext, listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.SEND_ACTION, NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		return sendToken;
	}

	/**
	 * Publish a message on a topic
	 * 
	 * @param topic
	 *            the topic on which to publish - represented as a string, not
	 *            an MqttTopic object
	 * @param message
	 *            the message to publish
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 * @return token for tracking the operation
	 */
	public IMqttDeliveryToken publish(String topic, MqttMessage message,
			String invocationContext, String activityToken) {
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SEND_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		IMqttDeliveryToken sendToken = null;

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				sendToken = myClient.publish(topic, message, invocationContext,
						listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else if ((myClient !=null) && (this.bufferOpts != null) && (this.bufferOpts.isBufferEnabled())){
			// Client is not connected, but buffer is enabled, so sending message
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				sendToken = myClient.publish(topic, message, invocationContext,
						listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		}  else {
			Log.i(TAG, "Client is not connected, so not sending message");
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.SEND_ACTION, NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
		return sendToken;
	}

	/**
	 * Subscribe to a topic
	 * 
	 * @param topic
	 *            a possibly wildcarded topic name
	 * @param qos
	 *            requested quality of service for the topic
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void subscribe(final String topic, final int qos,
			String invocationContext, String activityToken) {
		service.traceDebug(TAG, "subscribe({" + topic + "}," + qos + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.subscribe(topic, qos, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Subscribe to one or more topics
	 * 
	 * @param topic
	 *            a list of possibly wildcarded topic names
	 * @param qos
	 *            requested quality of service for each topic
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void subscribe(final String[] topic, final int[] qos,
			String invocationContext, String activityToken) {
		service.traceDebug(TAG, "subscribe({" + Arrays.toString(topic) + "}," + Arrays.toString(qos) + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.subscribe(topic, qos, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	public void subscribe(String[] topicFilters, int[] qos, String invocationContext, String activityToken, IMqttMessageListener[] messageListeners) {
		service.traceDebug(TAG, "subscribe({" + Arrays.toString(topicFilters) + "}," + Arrays.toString(qos) + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN, activityToken);
		resultBundle.putString(MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, invocationContext);
		if((myClient != null) && (myClient.isConnected())){
			IMqttActionListener listener = new MqttConnectionListener(resultBundle);
			try {

				myClient.subscribe(topicFilters, qos,messageListeners);
			} catch (Exception e){
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE, NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

		/**
         * Unsubscribe from a topic
         *
         * @param topic
         *            a possibly wildcarded topic name
         * @param invocationContext
         *            arbitrary data to be passed back to the application
         * @param activityToken
         *            arbitrary identifier to be passed back to the Activity
         */
	void unsubscribe(final String topic, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "unsubscribe({" + topic + "},{"
				+ invocationContext + "}, {" + activityToken + "})");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.UNSUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.unsubscribe(topic, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);

			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Unsubscribe from one or more topics
	 * 
	 * @param topic
	 *            a list of possibly wildcarded topic names
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	void unsubscribe(final String[] topic, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "unsubscribe({" + Arrays.toString(topic) + "},{"
				+ invocationContext + "}, {" + activityToken + "})");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.UNSUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.unsubscribe(topic, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);

			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Get tokens for all outstanding deliveries for a client
	 * 
	 * @return an array (possibly empty) of tokens
	 */
	public IMqttDeliveryToken[] getPendingDeliveryTokens() {
		return myClient.getPendingDeliveryTokens();
	}

	// Implement MqttCallback
	/**
	 * Callback for connectionLost
	 * 
	 * @param why
	 *            the exeception causing the break in communications
	 */
	@Override
	public void connectionLost(Throwable why) {
		service.traceDebug(TAG, "connectionLost(" + why.getMessage() + ")");
		disconnected = true;
		try {
			if(!this.connectOptions.isAutomaticReconnect()) {
				myClient.disconnect(null, new IMqttActionListener() {

					@Override
					public void onSuccess(IMqttToken asyncActionToken) {
						// No action
					}

					@Override
					public void onFailure(IMqttToken asyncActionToken,
										  Throwable exception) {
						// No action
					}
				});
			} else {
				// Using the new Automatic reconnect functionality.
				// We can't force a disconnection, but we can speed one up
				pingSender.schedule(10000);

			}
		} catch (Exception e) {
			// ignore it - we've done our best
		}

		Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.ON_CONNECTION_LOST_ACTION);
		if (why != null) {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					why.getMessage());
			if (why instanceof MqttException) {
				resultBundle.putSerializable(
						MqttServiceConstants.CALLBACK_EXCEPTION, why);
			}
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_EXCEPTION_STACK,
					Log.getStackTraceString(why));
		}
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		// client has lost connection no need for wake lock
		releaseWakeLock();
	}

	/**
	 * Callback to indicate a message has been delivered (the exact meaning of
	 * "has been delivered" is dependent on the QOS value)
	 * 
	 * @param messageToken
	 *            the messge token provided when the message was originally sent
	 */
	@Override
	public void deliveryComplete(IMqttDeliveryToken messageToken) {

		service.traceDebug(TAG, "deliveryComplete(" + messageToken + ")");

		MqttMessage message = savedSentMessages.remove(messageToken);
		if (message != null) { // If I don't know about the message, it's
			// irrelevant
			String topic = savedTopics.remove(messageToken);
			String activityToken = savedActivityTokens.remove(messageToken);
			String invocationContext = savedInvocationContexts
					.remove(messageToken);

			Bundle resultBundle = messageToBundle(null, topic, message);
			if (activityToken != null) {
				resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
						MqttServiceConstants.SEND_ACTION);
				resultBundle.putString(
						MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
						activityToken);
				resultBundle.putString(
						MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
						invocationContext);
		
				service.callbackToActivity(clientHandle, Status.OK,
						resultBundle);
			}
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.MESSAGE_DELIVERED_ACTION);
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}

		// this notification will have kept the connection alive but send the previously sechudled ping anyway
	}

	/**
	 * Callback when a message is received
	 * 
	 * @param topic
	 *            the topic on which the message was received
	 * @param message
	 *            the message itself
	 */
	@Override
	public void messageArrived(String topic, MqttMessage message)
			throws Exception {

		service.traceDebug(TAG,
				"messageArrived(" + topic + ",{" + message.toString() + "})");

		if (defaultMessageListener != null) {
			defaultMessageListener.messageArrived(topic, message);
			return;
		}

		// Default action if no application-level listener is setup
		String messageId = service.messageStore.storeArrived(clientHandle,
				topic, message);
	
		Bundle resultBundle = messageToBundle(messageId, topic, message);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.MESSAGE_ARRIVED_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_MESSAGE_ID,
				messageId);
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
				
	}



	/**
	 * Store details of sent messages so we can handle "deliveryComplete"
	 * callbacks from the mqttClient
	 * 
	 * @param topic
	 * @param msg
	 * @param messageToken
	 * @param invocationContext
	 * @param activityToken
	 */
	private void storeSendDetails(final String topic, final MqttMessage msg,
			final IMqttDeliveryToken messageToken,
			final String invocationContext, final String activityToken) {
		savedTopics.put(messageToken, topic);
		savedSentMessages.put(messageToken, msg);
		savedActivityTokens.put(messageToken, activityToken);
		savedInvocationContexts.put(messageToken, invocationContext);
	}

	/**
	 * Acquires a partial wake lock for this client
	 */
	private void acquireWakeLock() {
		if (wakelock == null) {
			PowerManager pm = (PowerManager) service
					.getSystemService(Service.POWER_SERVICE);
			wakelock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
					wakeLockTag);
		}
		wakelock.acquire();

	}

	/**
	 * Releases the currently held wake lock for this client
	 */
	private void releaseWakeLock() {
		if(wakelock != null && wakelock.isHeld()){
			wakelock.release();
		}
	}



	/**
	 * General-purpose IMqttActionListener for the Client context
	 * <p>
	 * Simply handles the basic success/failure cases for operations which don't
	 * return results
	 * 
	 */
	private class MqttConnectionListener implements IMqttActionListener {

		private final Bundle resultBundle;

		private MqttConnectionListener(Bundle resultBundle) {
			this.resultBundle = resultBundle;
		}

		@Override
		public void onSuccess(IMqttToken asyncActionToken) {
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}

		@Override
		public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					exception.getLocalizedMessage());

			resultBundle.putSerializable(
					MqttServiceConstants.CALLBACK_EXCEPTION, exception);

			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Receive notification that we are offline<br>
	 * if cleanSession is true, we need to regard this as a disconnection
	 */
	void offline() {
		
		if (!disconnected && !cleanSession) {
			Exception e = new Exception("Android offline");
			connectionLost(e);
		}
	}
	
	/**
	* Reconnect<br>
	* Only appropriate if cleanSession is false and we were connected.
	* Declare as synchronized to avoid multiple calls to this method to send connect 
	* multiple times 
	*/
	synchronized void reconnect() {

		if (myClient == null) {
			service.traceError(TAG,"Reconnect myClient = null. Will not do reconnect");
			return;
		}

		if (isConnecting) {
			service.traceDebug(TAG, "The client is connecting. Reconnect return directly.");
			return ;
		}
		
		if(!service.isOnline()){
			service.traceDebug(TAG,
					"The network is not reachable. Will not do reconnect");
			return;
		}

		if(connectOptions.isAutomaticReconnect()){
			//The Automatic reconnect functionality is enabled here
			Log.i(TAG, "Requesting Automatic reconnect using New Java AC");
			final Bundle resultBundle = new Bundle();
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
					reconnectActivityToken);
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, null);
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.CONNECT_ACTION);
			try {
				myClient.disconnect();
			} catch (MqttException ex){
			}
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
			}
			try {
				myClient.reconnect();
			} catch (MqttException ex){
				if (ex.getReasonCode() != MqttException.REASON_CODE_CLIENT_CONNECTED) {
					Log.e(TAG, "Exception occurred attempting to reconnect: " + ex.getMessage());
					setConnectingState(false);
					handleException(resultBundle, ex);
				} else {
					// Do nothing, we are already connected
				}
			}
		} else if (disconnected && !cleanSession) {
			// use the activityToke the same with action connect
			service.traceDebug(TAG,"Do Real Reconnect!");
			final Bundle resultBundle = new Bundle();
			resultBundle.putString(
				MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				reconnectActivityToken);
			resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, null);
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_ACTION);
			
			try {
				
				IMqttActionListener listener = new MqttConnectionListener(resultBundle) {
					@Override
					public void onSuccess(IMqttToken asyncActionToken) {
						// since the device's cpu can go to sleep, acquire a
						// wakelock and drop it later.
						service.traceDebug(TAG,"Reconnect Success!");
						service.traceDebug(TAG,"DeliverBacklog when reconnect.");
						doAfterConnectSuccess(resultBundle);
					}
					
					@Override
					public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
						resultBundle.putString(
								MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
								exception.getLocalizedMessage());
						resultBundle.putSerializable(
								MqttServiceConstants.CALLBACK_EXCEPTION,
								exception);
						service.callbackToActivity(clientHandle, Status.ERROR,
								resultBundle);

						doAfterConnectFail(resultBundle);
						
					}
				};
				
				myClient.connect(connectOptions, null, listener);
				setConnectingState(true);
			} catch (MqttException e) {
				service.traceError(TAG, "Cannot reconnect to remote server." + e.getMessage());
				setConnectingState(false);
				handleException(resultBundle, e);
			} catch (Exception e){
				/*  TODO: Added Due to: https://github.com/eclipse/paho.mqtt.android/issues/101
				    For some reason in a small number of cases, myClient is null here and so
				    a NullPointer Exception is thrown. This is a workaround to pass the exception
				    up to the application. myClient should not be null so more investigation is
				    required.
				*/
				service.traceError(TAG, "Cannot reconnect to remote server." + e.getMessage());
				setConnectingState(false);
				MqttException newEx = new MqttException(MqttException.REASON_CODE_UNEXPECTED_ERROR, e.getCause());
				handleException(resultBundle, newEx);
			}
		}
	}
	
	/**
	 * 
	 * @param isConnecting
	 */
	private synchronized void setConnectingState(boolean isConnecting){
		this.isConnecting = isConnecting; 
	}

	/**
	 * Sets the DisconnectedBufferOptions for this client
	 * @param bufferOpts
	 */
	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
		this.bufferOpts = bufferOpts;
		myClient.setBufferOpts(bufferOpts);
	}

	public int getBufferedMessageCount(){
		return myClient.getBufferedMessageCount();
	}

	public MqttMessage getBufferedMessage(int bufferIndex){
		return myClient.getBufferedMessage(bufferIndex);
	}

	public void deleteBufferedMessage(int bufferIndex){
		myClient.deleteBufferedMessage(bufferIndex);
	}
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/WorkerPingSender.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.eclipse.paho.android.service;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.internal.ClientComms;

import java.util.concurrent.TimeUnit;

public class WorkerPingSender implements MqttPingSender {

    // Identifier for Intents, log messages, etc..
    private static final String TAG = "WorkerPingSender";

    private static final String WORKER_TAG_MQTT = "com.hmdm.launcher.WORK_TAG_MQTT";

    private ClientComms comms;
    private MqttService service;

    private static WorkerPingSender instance;

    private WorkerPingSender(MqttService service) {
        if (service == null) {
            throw new IllegalArgumentException(
                    "Neither service nor client can be null.");
        }
        this.service = service;
    }

    public static WorkerPingSender getInstance(MqttService service) {
        if (instance == null) {
            instance = new WorkerPingSender(service);
        }
        instance.service = service;
        return instance;
    }

    @Override
    public void init(ClientComms comms) {
        this.comms = comms;
    }

    @Override
    public void start() {
        schedule(comms.getKeepAlive());
    }

    @Override
    public void stop() {
        WorkManager.getInstance(service.getApplicationContext()).cancelUniqueWork(WORKER_TAG_MQTT);
        RemoteLogger.log(service, Const.LOG_DEBUG, "MQTT ping cancelled");
    }

    @Override
    public void schedule(long delayInMilliseconds) {
        // Minimal interval is 15 mins
        // If delay is less than 15 mins, just schedule it right now
        long sec = delayInMilliseconds / 1000l;
        RemoteLogger.log(service, Const.LOG_DEBUG, "MQTT ping scheduled: " + sec + " sec");
        OneTimeWorkRequest queryRequest =
                new OneTimeWorkRequest.Builder(WorkerPingSender.InternalWorker.class)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(sec, TimeUnit.SECONDS)
                        .build();
        WorkManager.getInstance(service.getApplicationContext()).enqueueUniqueWork(WORKER_TAG_MQTT, ExistingWorkPolicy.REPLACE, queryRequest);
    }

    public static class InternalWorker extends Worker {

        private Context context;

        public InternalWorker(
                @NonNull final Context context,
                @NonNull WorkerParameters params) {
            super(context, params);
            this.context = context;
        }

        @NonNull
        @Override
        public Result doWork() {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Sending MQTT Ping at:" + System.currentTimeMillis());
            PingDeathDetector.getInstance().registerPing();
            WorkerPingSender.instance.comms.checkForActivity(null);
            return null;
        }
    }
}
</file>

<file path="app/src/main/res/drawable/ic_battery_1_red.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aaff0000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,720L600,720L600,240L360,240L360,720Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_2_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,640L600,640L600,240L360,240L360,640Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_2_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,640L600,640L600,240L360,240L360,640Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_3_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,560L600,560L600,240L360,240L360,560Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_3_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,560L600,560L600,240L360,240L360,560Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_4_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,480L600,480L600,240L360,240L360,480Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_4_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,480L600,480L600,240L360,240L360,480Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_5_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,320L600,320L600,240L360,240L360,320Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_5_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,320L600,320L600,240L360,240L360,320Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_6_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aa000000"
      android:pathData="M200,680Q183,680 171.5,668.5Q160,657 160,640L160,560L80,560L80,400L160,400L160,320Q160,303 171.5,291.5Q183,280 200,280L840,280Q857,280 868.5,291.5Q880,303 880,320L880,640Q880,657 868.5,668.5Q857,680 840,680L200,680Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_6_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M200,680Q183,680 171.5,668.5Q160,657 160,640L160,560L80,560L80,400L160,400L160,320Q160,303 171.5,291.5Q183,280 200,280L840,280Q857,280 868.5,291.5Q880,303 880,320L880,640Q880,657 868.5,668.5Q857,680 840,680L200,680Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_charger_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aa000000"
      android:pathData="M452,800L652,410L512,410L512,160L312,550L452,550L452,800Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_charger_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aaffffff"
      android:pathData="M452,800L652,410L512,410L512,160L312,550L452,550L452,800Z"/>
</vector>
</file>

<file path="app/src/main/res/layout/activity_initial_setup.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
        <variable name="loading" type="Boolean"/>
    </data>

    <RelativeLayout 
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.InitialSetupActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:orientation="vertical"
            android:layout_centerInParent="true"
            android:gravity="center">

            <ProgressBar
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                bind:boolToVisible="@{loading}"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{message}"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:textAppearance="?android:textAppearanceMedium"
                android:gravity="center"/>

        </LinearLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_accessibility_service.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_accessibility_service_message"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_administrator_mode_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="skipAccessibilityService"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="setAccessibilityService"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_administrator_mode.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_administrator_mode_message"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_administrator_mode_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="skipAdminMode"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="setAdminMode"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_device_info.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="serverUrl" type="String"/>
        <variable name="deviceId" type="String"/>
        <variable name="imei" type="String"/>
        <variable name="serialNumber" type="String"/>
        <variable name="phone" type="String"/>
        <variable name="version" type="String"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:textStyle="bold"
            android:text="@{serverUrl}"/>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/device_id"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{deviceId}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/imei"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{imei}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/serial_number"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{serialNumber}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/phone_number"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{phone}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="16dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/launcher_version"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{version}"/>

        </LinearLayout>

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/close"
            android:onClick="closeDeviceInfoDialog"/>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_password.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
        <variable name="loading" type="Boolean"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/wrong_password"/>

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{!error}"
            android:text="@string/enter_admin_password"/>

        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/password"
            android:inputType="textPassword"
            bind:boolToDisable="@{loading}"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="@dimen/activity_vertical_margin"
                android:text="@string/dialog_enter_password_login"
                bind:boolToDisable="@{loading}"
                android:onClick="checkAdministratorPassword"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/dialog_enter_password_cancel"
                android:onClick="closeEnterPasswordDialog"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_file_downloading_failed.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:id="@+id/title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="@dimen/activity_vertical_margin"
                android:text="@string/main_activity_repeat"
                android:onClick="repeatDownloadClicked"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/main_activity_cancel"
                android:onClick="confirmDownloadFailureClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_history_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_history_settings_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_history_settings_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="historyWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_history_settings_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueHistory"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_manage_storage.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_manage_storage_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_history_settings_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="storageWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_history_settings_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueStorage"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_miui_permissions.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/title"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_miui_permissions_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_unknown_sources_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueMiuiPermissions"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_overlay_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_overlay_settings_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_accessibility_service_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="overlayWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_accessibility_service_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueOverlay"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_permissions.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/dialog_permission_title"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical|center_horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_repeat"
                android:onClick="permissionsRetryClicked"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:layout_marginLeft="8dp"
                android:text="@string/main_activity_exit"
                android:onClick="permissionsExitClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/item_app.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center_horizontal"
    tools:ignore="UseCompoundDrawables"
    android:id="@+id/root_linearLayout"
    android:layout_margin="5dp">

    <ImageView
        android:layout_width="@dimen/app_icon_size"
        android:layout_height="@dimen/app_icon_size"
        android:layout_marginTop="16dp"
        android:id="@+id/imageView"
        tools:ignore="ContentDescription" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/textView"
        android:gravity="center"
        android:maxLines="2"
        android:ellipsize="end"
        android:padding="5dp"/>

</LinearLayout>
</layout>
</file>

<file path="app/src/main/res/values/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
    <dimen name="exit_overlay_size">24dp</dimen>
    <dimen name="dialog_enter_device_id_width">280dp</dimen>
    <dimen name="activity_main_stacktrace_height">400dp</dimen>
    <dimen name="activity_main_stacktrace_text_size">6pt</dimen>
    <dimen name="activity_main_exit_button_size">24dp</dimen>
    <dimen name="app_list_item_size">100dp</dimen>
    <dimen name="status_bar_height">40dp</dimen>
    <dimen name="prevent_applications_list_width">8dp</dimen>
    <dimen name="info_icon_margin">40dp</dimen>
    <dimen name="block_window_button_width">150dp</dimen>
    <dimen name="button_text_size">12dp</dimen>
    <dimen name="button_text_size_small">12dp</dimen>
    <dimen name="device_info_width">300dp</dimen>
    <dimen name="device_info_column_width">150dp</dimen>
    <dimen name="title_text_size">16dp</dimen>
    <dimen name="app_icon_size">50dp</dimen>
    <dimen name="status_bar_side_width">60dp</dimen>
</resources>
</file>

<file path="app/src/main/res/values-vi/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Quản trị viên</string>
    <string name="install_error">Lỗi cài đặt</string>
    <string name="file_create_error">Lỗi tạo file</string>
    <string name="dialog_enter_device_id_error">ID này chưa được đăng ký tại %s. Lấy ID từ tab \"Thiết bị\" trong bảng điều khiển.</string>
    <string name="dialog_enter_device_id_qrcode">Mã QR</string>
    <string name="dialog_enter_device_id_variants">Biến thể</string>
    <string name="dialog_enter_device_id_save">Lưu</string>
    <string name="dialog_enter_device_id_exit">Thoát</string>
    <string name="dialog_enter_device_id_title">Nhập ID thiết bị tại %s</string>
    <string name="main_start_preparations">Chuẩn bị khởi động</string>
    <string name="main_downloading_configuration">Cập nhật file cấu hình</string>
    <string name="main_downloading_content">Cập nhật dữ liệu</string>
    <string name="main_update_applications">Cài đặt và cập nhật ứng dụng</string>
    <string name="dialog_root_message">Bạn cần quyền truy cập ROOT</string>
    <string name="main_application_start">Khởi động ứng dụng</string>
    <string name="main_app_installing">Đang cài đặt ứng dụng</string>
    <string name="main_app_downloading">Đang tải xuống ứng dụng</string>
    <string name="main_app_downloading_error">Không thể tải xuống gói cài đặt</string>
    <string name="main_app_removing">Gỡ cài đặt ứng dụng</string>
    <string name="main_file_downloading">Đang tải xuống file</string>
    <string name="main_file_downloading_error">Không thể tải xuống file</string>
    <string name="main_activity_repeat">Thử lại</string>
    <string name="main_activity_reset">Đặt lại</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Hủy</string>
    <string name="main_activity_details">Chi tiết</string>
    <string name="select_system_launcher">Chọn %s làm launcher mặc định và tích \'Luôn luôn\':</string>
    <string name="dialog_network_error_title">Lỗi kết nối đến %s. Vui lòng kiểm tra kết nối Internet và thử lại.</string>
    <string name="main_activity_update_config">Yêu cầu file cấu hình từ máy chủ</string>
    <string name="main_activity_applications_update">Cập nhật ứng dụng</string>
    <string name="dialog_overlay_settings_title">Vui lòng cho phép ứng dụng vẽ trên các cửa sổ khác.\n\nTùy chọn này giúp chặn các ứng dụng không mong muốn và cho phép mở khóa khẩn cấp chế độ kiosk.\n\nNhấn \"Tiếp tục\" để mở cài đặt. Tìm mục \"%s\", cấp quyền, sau đó nhấn \"Quay lại\".</string>
    <string name="dialog_manage_storage_title">Vui lòng cho phép ứng dụng quản lý bộ nhớ.\n\nTùy chọn này cho phép Headwind MDM quản lý file trên thiết bị của bạn.</string>
    <string name="dialog_history_settings_title">Vui lòng cho phép ứng dụng truy cập dữ liệu sử dụng.\n\nTùy chọn này cho phép kiểm soát ứng dụng và cài đặt.\n\nTùy chọn này có thể gây hao pin nhanh hơn. Để tiết kiệm pin, bỏ qua tùy chọn này (sử dụng dịch vụ trợ năng hoặc chế độ kiosk thay thế).\n\nNhấn \"Tiếp tục\" để mở cài đặt. Tìm mục \"%s\", cấp quyền, sau đó nhấn \"Quay lại\".</string>
    <string name="dialog_history_settings_continue">Tiếp tục</string>
    <string name="dialog_history_settings_skip">Bỏ qua</string>
    <string name="dialog_unknown_sources_title">Vui lòng cho phép cài đặt từ nguồn không xác định. Bảng cài đặt sẽ mở. Tìm \"Nguồn không xác định\", cho phép cài đặt và nhấn \"Quay lại\".</string>
    <string name="dialog_unknown_sources_continue">Tiếp tục</string>
    <string name="dialog_miui_permissions_title">MIUI yêu cầu thiết lập thủ công các quyền tùy chỉnh. Cửa sổ quyền ứng dụng sẽ mở. Nhấn \"Quyền khác\", cho phép \"Hiển thị cửa sổ bật lên khi chạy trong nền\" và nhấn \"Quay lại\".</string>
    <string name="dialog_miui_developer_title">MIUI yêu cầu thiết lập thủ công thiết bị của bạn. Trên màn hình thông tin, NHẤN 7 LẦN VÀO \"SỐ BẢN DỰNG\". Điều này sẽ kích hoạt cài đặt nhà phát triển.</string>
    <string name="dialog_miui_optimization_title">MIUI yêu cầu thiết lập thủ công thiết bị của bạn. Cửa sổ cài đặt nhà phát triển sẽ mở. Cuộn màn hình xuống và bỏ tích \"Tối ưu hóa MIUI\".</string>
    <string name="dialog_administrator_mode_message">Vui lòng cho phép ứng dụng hoạt động ở chế độ quản trị viên thiết bị. Bảng cài đặt sẽ mở. Chọn \"Quản trị viên thiết bị\", tìm mục \"%s\", kích hoạt quản trị viên, và nhấn \"Quay lại\".</string>
    <string name="dialog_administrator_mode_continue">Tiếp tục</string>
    <string name="dialog_administrator_mode_skip">Bỏ qua</string>
    <string name="accessibility_service_description">Giám sát ứng dụng hoạt động bởi ứng dụng MDM</string>
    <string name="dialog_accessibility_service_message">Vui lòng cho phép ứng dụng sử dụng dịch vụ trợ năng. Bảng cài đặt sẽ mở. Tìm mục \"%s\", cho phép sử dụng dịch vụ trợ năng, và nhấn \"Quay lại\".</string>
    <string name="dialog_accessibility_service_continue">Tiếp tục</string>
    <string name="dialog_accessibility_service_skip">Bỏ qua</string>
    <string name="access_to_app_denied">Gói không được phép:</string>
    <string name="access_to_app_denied_2">Vui lòng yêu cầu quản trị viên của bạn kích hoạt gói này trong cấu hình.\n\nNhấn \'Đóng\' hoặc nút Home để tiếp tục.</string>
    <string name="package_id_copied">ID gói đã được sao chép vào clipboard</string>
    <string name="dialog_app_not_allowed_close">Đóng</string>
    <string name="dialog_app_not_allowed_admin">Quản trị viên</string>
    <string name="device_id">ID thiết bị</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Số seri</string>
    <string name="phone_number">Số điện thoại</string>
    <string name="launcher_version">Phiên bản launcher</string>
    <string name="close">Đóng</string>
    <string name="admin_change_device_id">Thay đổi ID thiết bị</string>
    <string name="admin_change_server_url">Thay đổi URL máy chủ</string>
    <string name="admin_allow_settings">Mở cài đặt</string>
    <string name="settings_allowed">Bạn được phép thay đổi cài đặt trong 3 phút.</string>
    <string name="admin_clear_restrictions">Xóa hạn chế</string>
    <string name="permissive_mode_enabled">Bạn được phép chạy tất cả ứng dụng trong 3 phút.</string>
    <string name="admin_refresh">Cập nhật cấu hình</string>
    <string name="admin_exit">Thoát về launcher hệ thống</string>
    <string name="admin_reset_permissions">Kiểm tra quyền</string>
    <string name="admin_reset_network">Đặt lại chính sách mạng</string>
    <string name="admin_reset_network_hint">Chính sách mạng đã được xóa. Bây giờ bạn có thể bật mạng và tải lại cấu hình.</string>
    <string name="reboot">Khởi động lại thiết bị</string>
    <string name="reboot_failed">Không đủ quyền để khởi động lại thiết bị.</string>
    <string name="message_turn_on_gps">Màn hình cài đặt sẽ mở. Vui lòng bật định vị GPS trên màn hình này và nhấn Quay lại.</string>
    <string name="message_turn_off_gps">Màn hình cài đặt sẽ mở. Vui lòng TẮT định vị GPS trên màn hình này và nhấn Quay lại.</string>
    <string name="message_turn_on_mobile_data">Dữ liệu di động bị tắt! Vui lòng mở thanh trạng thái và bật dữ liệu di động.</string>
    <string name="message_turn_off_mobile_data">Dữ liệu di động đã bật. Vui lòng mở thanh trạng thái và TẮT dữ liệu di động.</string>
    <string name="message_set_password">Chất lượng mật khẩu của bạn không đủ tốt. Màn hình cài đặt sẽ mở. Vui lòng thay đổi mật khẩu và nhấn Quay lại.</string>
    <string name="switch_off_blockings">Đang tắt hạn chế...</string>
    <string name="kiosk_mode_requires_overlays">Chế độ kiosk bị tắt: không có quyền vẽ trên các cửa sổ khác. Vui lòng cho phép %s vẽ trên các cửa sổ khác.</string>
    <string name="enter_admin_password">Nhập mật khẩu quản trị viên</string>
    <string name="wrong_password">Mật khẩu sai</string>
    <string name="dialog_enter_password_login">Đăng nhập</string>
    <string name="dialog_enter_password_cancel">Hủy</string>
    <string name="internal_error">Ứng dụng gặp lỗi nội bộ. Vui lòng khởi động lại thiết bị và thử lại hành động.</string>
    <string name="empty_configuration">Cấu hình chưa được thiết lập, đang thử lấy từ máy chủ!</string>
    <string name="permissions_reset_hint">Đóng bảng quản trị để kiểm tra và yêu cầu quyền.</string>
    <string name="dialog_enter_server_error">Vui lòng nhập URL máy chủ hợp lệ.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Vui lòng nhập URL máy chủ</string>
    <string name="critical_server_failure">Thoát do lỗi máy chủ! Vui lòng sửa lỗi và khởi động lại %s, hoặc gỡ cài đặt hoàn toàn và cài đặt lại.</string>
    <string name="dialog_permission_title">Ứng dụng cần quyền để chạy. Vui lòng cấp các quyền được yêu cầu.</string>
    <string name="main_activity_exit">Thoát</string>
    <string name="browser_not_found">Không thể mở trang web vì không tìm thấy trình duyệt. Vui lòng thêm ứng dụng trình duyệt vào cấu hình thiết bị.</string>
    <string name="invalid_web_link">Không thể mở liên kết web vì nó không được định dạng đúng. Vui lòng liên hệ quản trị viên của bạn để biết chi tiết.</string>
    <string name="activity_not_found">Không thể thực hiện hành động %s vì không tìm thấy hoạt động.</string>
    <string name="location_service_text">Vị trí thiết bị được giám sát</string>
    <string name="qrcode_contents_error">Nội dung mã QR không hợp lệ. Vui lòng tạo mã QR cung cấp trong bảng điều khiển web %s.</string>
    <string name="device_locked">Thiết bị này (%s) đã bị khóa bởi quản trị viên.</string>
    <string name="fault_loop_detected">Ôi không, launcher gặp lỗi không thể khôi phục! Vui lòng liên hệ quản trị viên hệ thống của bạn.</string>
    <string name="mqtt_service_text">Thông báo đẩy đang hoạt động</string>
    <string name="background_location">%s yêu cầu quyền định vị nền. Nhấn \'Tiếp tục\' để mở quyền, nhấn \'Vị trí\' và cho phép xác định vị trí luôn.</string>
    <string name="location_disable">Tắt định vị</string>
    <string name="background_location_continue">Tiếp tục</string>
    <string name="initializing_mdm">Đang khởi tạo ứng dụng quản lý thiết bị di động...</string>
    <string name="dialog_server_error_title">Máy chủ MDM %s trả về phản hồi không hợp lệ. Vui lòng liên hệ quản trị viên của bạn.</string>
    <string name="mdm_choice_message">Thiết bị này sẽ được quản lý hoàn toàn bởi tổ chức của bạn. Dữ liệu của bạn sẽ không riêng tư và có thể bị xóa hoặc xem xét bởi quản trị viên IT bất cứ lúc nào.</string>
    <string name="work_profile_message">Thiết bị này sẽ nhận được hồ sơ công việc được quản lý thuộc về tổ chức của bạn. Hồ sơ công việc được tách biệt với hồ sơ riêng tư của bạn và bạn có thể chuyển đổi giữa các hồ sơ bất cứ lúc nào.</string>
    <string name="overlays_not_supported">Rất tiếc, lớp phủ không được hỗ trợ bởi thiết bị của bạn.</string>
    <string name="admin_not_supported">Thiết bị của bạn không có tùy chọn quản trị viên thiết bị. Nhấn Bỏ qua để tiếp tục.</string>
    <string name="manage_storage_not_supported">Thiết bị của bạn không có tùy chọn quản lý bộ nhớ ngoài.</string>
</resources>
</file>

<file path="fastlane/metadata/android/ca/short_description.txt">
Sistema de gestió de dispositius mòbils (MDM) per Android (agent - llançador)
</file>

<file path="fastlane/metadata/android/cs/short_description.txt">
Systém správy mobilních zařízení (MDM) pro Android (mobilní agent - launcher)
</file>

<file path="fastlane/metadata/android/de/short_description.txt">
Mobile-Device-Management-System (MDM) für Android (mobiler Agent – Launcher)
</file>

<file path="fastlane/metadata/android/en-US/full_description.txt">
A Powerful Open Source Platform to Manage your Enterprise Android Devices

* Quick and Easy to Install “Out of the Box”
* Compatible with Most Android Devices
* Manages Devices in Closed Private Networks
* Premium: All Must-Have MDM Features

Scaling of your business requires proper management. The MDM software is a smart manager of your enterprise tablets, smartphones, kiosks, and digital signage systems. It’s particularly useful to manage unattended devices, replacing hours of maintenance work by a few mouse clicks!

* Group-based policy management forces hundreds of devices to work in the same way, thus making business processes clearer and easier.

* Device status control makes it easy to find problems with enterprise devices and take actions to fix them in a timely manner.

* Remote support simplifies the IT manager’s work to resolve issues and correct faults.

Headwind MDM requires registration on a Headwind MDM server.  You can deploy your own (https://h-mdm.com/download/) or try the demo (https://srv.h-mdm.com). See the Headwind MDM documentation for more information.
</file>

<file path="fastlane/metadata/android/en-US/short_description.txt">
Mobile Device Management (MDM) System for Android (mobile agent - launcher)
</file>

<file path="fastlane/metadata/android/en-US/title.txt">
Headwind MDM Agent
</file>

<file path="fastlane/metadata/android/es/short_description.txt">
Gestión de dispositivos móviles (MDM) para Android (Mobile Agent Launcher)
</file>

<file path="fastlane/metadata/android/et/short_description.txt">
Mobiilseadmete haldusliides (MDM) Androidile (agent/käivitaja kliendi poolel)
</file>

<file path="fastlane/metadata/android/fr/short_description.txt">
Gestion d'appareils mobiles (MDM) pour Android (lanceur d'applications)
</file>

<file path="fastlane/metadata/android/ga/short_description.txt">
Córas Bainistíochta Gléas Soghluaiste (MDM) do Android (gníomhaire -Tosaitheoir)
</file>

<file path="fastlane/metadata/android/he/short_description.txt">
מערכת ניהול מכשירים ניידים (MDM) ל־Android (סוכן למכשיר הנייד - משגר)
</file>

<file path="fastlane/metadata/android/ja/short_description.txt">
Android向けのモバイルデバイスマネジメント（MDM）システム（モバイルエージェント - ランチャー）
</file>

<file path="fastlane/metadata/android/pl/short_description.txt">
Zarządzanie urządzeniami mobilnymi (MDM) dla Androida (agent mobilny — launcher)
</file>

<file path="fastlane/metadata/android/pt/short_description.txt">
Sistema de Mobile Device Management (MDM) para Android (agente móvel - lançador)
</file>

<file path="fastlane/metadata/android/pt-BR/short_description.txt">
Mobile Device Management (MDM) System for Android (mobile agent - launcher)
</file>

<file path="fastlane/metadata/android/pt-PT/short_description.txt">
Sistema de Mobile Device Management (MDM) para Android (agente móvel - lançador)
</file>

<file path="fastlane/metadata/android/ro/short_description.txt">
Sistem de gestionare a dispozitivelor mobile (MDM) pentru Android (lansator)
</file>

<file path="fastlane/metadata/android/ru/short_description.txt">
Система управления мобильными устройствами (MDM) для Android (лаунчер)
</file>

<file path="fastlane/metadata/android/sr/short_description.txt">
Систем за управљање мобилним уређајима (MDM) за Android (мобилни агент)
</file>

<file path="fastlane/metadata/android/sw/short_description.txt">
Córas Bainistíochta Gléas Soghluaiste (MDM) le haghaidh Android (gníomhaire soghluaiste - tosaitheoir)
</file>

<file path="fastlane/metadata/android/tr/short_description.txt">
Android için Mobil Aygıt Yönetimi Sistemi (mobil aracı - başlatıcı)
</file>

<file path="fastlane/metadata/android/uk/short_description.txt">
Система керування моб. пристроями (MDM) для Android (мобільний агент - лончер)
</file>

<file path="fastlane/metadata/android/zh-CN/short_description.txt">
安卓系统的移动设备管理（MDM）系统（移动代理 - 启动器）
</file>

<file path="lib/src/androidTest/java/com/hmdm/ExampleInstrumentedTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import static org.junit.Assert.assertEquals;

import android.content.Context;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getTargetContext();

        assertEquals("com.hmdm.test", appContext.getPackageName());
    }
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMPushHandler.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;

public abstract class MDMPushHandler {
    private BroadcastReceiver receiver;

    // This should be overridden
    public abstract void onMessageReceived(MDMPushMessage message);

    public void register(String messageType, Context context) {
        register(new String[] { messageType }, context);
    }

    public void register(String[] messageTypes, Context context) {
        if (messageTypes.length == 0) {
            return;
        }

        IntentFilter intentFilter = new IntentFilter();
        for (int n = 0; n < messageTypes.length; n++) {
            intentFilter.addAction(Const.INTENT_PUSH_NOTIFICATION_PREFIX + messageTypes[n]);
        }
        receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                try {
                    MDMPushMessage message = new MDMPushMessage(intent.getAction(), intent.getExtras());
                    onMessageReceived(message);
                } catch (MDMException e) {
                    e.printStackTrace();
                }
            }
        };

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.registerReceiver(receiver, intentFilter, Context.RECEIVER_EXPORTED);
        } else {
            context.registerReceiver(receiver, intentFilter);
        }
    }

    public void unregister(Context context) {
        if (receiver != null) {
            context.unregisterReceiver(receiver);
        }
    }
}
</file>

<file path="lib/src/main/AndroidManifest.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
    package="com.hmdm" />
</file>

<file path=".gitignore">
.idea
*.iml
.gradle
/local.properties
.DS_Store
/build
/captures
.externalNativeBuild
example/
app/release
</file>

<file path="etc-mdm.xml">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
app/
  src/
    androidTest/
      java/
        com/
          hmdm/
            launcher/
              ExampleInstrumentedTest.java
    main/
      aidl/
        com/
          hmdm/
            IMdmApi.aidl
      assets/
        isrg_root_x1.pem
      java/
        com/
          github/
            anrwatchdog/
              ANRError.java
              ANRWatchDog.java
          hmdm/
            launcher/
              databinding/
                ViewBindingUtils.java
              db/
                DatabaseHelper.java
                DownloadTable.java
                InfoHistoryTable.java
                LocationTable.java
                LogConfigTable.java
                LogTable.java
                RemoteFileTable.java
              helper/
                CertInstaller.java
                ConfigUpdater.java
                CryptoHelper.java
                Initializer.java
                MigrationHelper.java
                SettingsHelper.java
              json/
                Action.java
                Application.java
                ApplicationSetting.java
                DetailedInfo.java
                DetailedInfoConfig.java
                DetailedInfoConfigResponse.java
                DeviceCreateOptions.java
                DeviceEnrollOptions.java
                DeviceInfo.java
                Download.java
                PushMessage.java
                PushMessageJson.java
                PushResponse.java
                RemoteFile.java
                RemoteLogConfig.java
                RemoteLogConfigResponse.java
                RemoteLogItem.java
                ServerConfig.java
                ServerConfigResponse.java
                ServerResponse.java
              pro/
                service/
                  CheckForegroundAppAccessibilityService.java
                  CheckForegroundApplicationService.java
                worker/
                  DetailedInfoWorker.java
                ProUtils.java
              receiver/
                BootReceiver.java
                ShutdownReceiver.java
                SimChangedReceiver.java
              server/
                ServerService.java
                ServerServiceKeeper.java
                ServerUrl.java
                UnsafeOkHttpClient.java
              service/
                LocationService.java
                PluginApiService.java
                PushLongPollingService.java
                StatusControlService.java
              task/
                ConfirmDeviceResetTask.java
                ConfirmPasswordResetTask.java
                ConfirmRebootTask.java
                GetRemoteLogConfigTask.java
                GetServerConfigTask.java
                SendDeviceInfoTask.java
              ui/
                custom/
                  BatteryStateView.java
                  BlockingBar.java
                  StatusBarUpdater.java
                AdminActivity.java
                AdminModeRequestActivity.java
                AppShortcutManager.java
                BaseActivity.java
                BaseAppListAdapter.java
                BottomAppListAdapter.java
                ErrorDetailsActivity.java
                InitialSetupActivity.java
                MainActivity.java
                MainAppListAdapter.java
                MdmChoiceSetupActivity.java
              util/
                AppInfo.java
                ConnectionWaiter.java
                CrashLoopProtection.java
                CryptoUtils.java
                DeviceInfoProvider.java
                InstallUtils.java
                LegacyUtils.java
                PreferenceLogger.java
                PushNotificationMqttWrapper.java
                RemoteLogger.java
                SystemUtils.java
                Utils.java
                XapkUtils.java
              worker/
                PushNotificationProcessor.java
                PushNotificationWorker.java
                RemoteLogWorker.java
                ScheduledAppUpdateWorker.java
                SendDeviceInfoWorker.java
              AdminReceiver.java
              App.java
              Const.java
        org/
          eclipse/
            paho/
              android/
                service/
                  AlarmPingSender.java
                  DatabaseMessageStore.java
                  MessageStore.java
                  MqttAndroidClient.java
                  MqttAndroidConnectOptions.java
                  MqttConnection.java
                  MqttDeliveryTokenAndroid.java
                  MqttService.java
                  MqttServiceBinder.java
                  MqttServiceConstants.java
                  MqttTokenAndroid.java
                  MqttTraceHandler.java
                  ParcelableMqttMessage.java
                  PingDeathDetector.java
                  Status.java
                  WorkerPingSender.java
      res/
        drawable/
          ic_android_white_50dp.xml
          ic_arrow_back_white_24dp.xml
          ic_battery_1_red.xml
          ic_battery_2_black.xml
          ic_battery_2_white.xml
          ic_battery_3_black.xml
          ic_battery_3_white.xml
          ic_battery_4_black.xml
          ic_battery_4_white.xml
          ic_battery_5_black.xml
          ic_battery_5_white.xml
          ic_battery_6_black.xml
          ic_battery_6_white.xml
          ic_charger_black.xml
          ic_charger_white.xml
          ic_info_black_24dp.xml
          ic_info_opaque_24dp.xml
          ic_system_update_black_24dp.xml
          ic_system_update_opaque_24dp.xml
          ic_vpn_key_black_24dp.xml
          ic_vpn_key_opaque_24dp.xml
          ic_vpn_key_transparent_24dp.xml
        layout/
          activity_admin.xml
          activity_error_details.xml
          activity_initial_setup.xml
          activity_main.xml
          activity_mdm_choice.xml
          dialog_accessibility_service.xml
          dialog_administrator_mode.xml
          dialog_device_info.xml
          dialog_enter_device_id.xml
          dialog_enter_password.xml
          dialog_enter_server.xml
          dialog_file_downloading_failed.xml
          dialog_history_settings.xml
          dialog_manage_storage.xml
          dialog_miui_permissions.xml
          dialog_network_error.xml
          dialog_overlay_settings.xml
          dialog_permissions.xml
          dialog_system_settings.xml
          dialog_unknown_sources.xml
          item_app.xml
          layout_application_not_allowed.xml
        values/
          colors.xml
          dimens.xml
          strings.xml
          styles.xml
        values-ar/
          strings.xml
        values-cs/
          strings.xml
        values-de/
          strings.xml
        values-es/
          strings.xml
        values-fr/
          strings.xml
        values-it/
          strings.xml
        values-ja/
          strings.xml
        values-pl-rPL/
          strings.xml
        values-pt/
          strings.xml
        values-ru/
          strings.xml
        values-tr/
          strings.xml
        values-vi/
          strings.xml
        values-w400dp/
          dimens.xml
        values-w820dp/
          dimens.xml
        values-zh-rCN/
          strings.xml
        values-zh-rHK/
          strings.xml
        values-zh-rTW/
          strings.xml
        xml/
          accessibility_service_config.xml
          device_admin.xml
          network_security_config.xml
          provider_paths.xml
      AndroidManifest.xml
    test/
      java/
        com/
          hmdm/
            launcher/
              ExampleUnitTest.java
  .gitignore
  build.gradle
  proguard-rules.pro
fastlane/
  metadata/
    android/
      ca/
        short_description.txt
      cs/
        short_description.txt
      de/
        short_description.txt
      en-US/
        full_description.txt
        short_description.txt
        title.txt
      es/
        short_description.txt
      et/
        short_description.txt
      fr/
        short_description.txt
      ga/
        short_description.txt
      he/
        short_description.txt
      ja/
        short_description.txt
      pl/
        short_description.txt
      pt/
        short_description.txt
      pt-BR/
        short_description.txt
      pt-PT/
        short_description.txt
      ro/
        short_description.txt
      ru/
        short_description.txt
      sr/
        short_description.txt
      sw/
        short_description.txt
      tr/
        short_description.txt
      uk/
        short_description.txt
      zh-CN/
        short_description.txt
gradle/
  wrapper/
    gradle-wrapper.properties
lib/
  src/
    androidTest/
      java/
        com/
          hmdm/
            ExampleInstrumentedTest.java
    main/
      aidl/
        com/
          hmdm/
            IMdmApi.aidl
      java/
        com/
          hmdm/
            Const.java
            HeadwindMDM.java
            MDMError.java
            MDMException.java
            MDMPushHandler.java
            MDMPushMessage.java
            MDMService.java
      res/
        values/
          strings.xml
      AndroidManifest.xml
    test/
      java/
        com/
          hmdm/
            ExampleUnitTest.java
  .gitignore
  build.gradle
  proguard-rules.pro
.gitignore
build.gradle
gradle.properties
gradlew
gradlew.bat
LICENSE
lint.xml
NOTICE
README.md
settings.gradle
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/src/androidTest/java/com/hmdm/launcher/ExampleInstrumentedTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import android.content.Context;
import android.support.test.InstrumentationRegistry;
import android.support.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumentation test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getTargetContext();

//        assertEquals("com.hmdm.launcher", appContext.getPackageName());
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/databinding/ViewBindingUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.databinding;

import androidx.databinding.BindingAdapter;
import android.view.View;

public class ViewBindingUtils {

    @BindingAdapter( { "boolToVisible" } )
    public static void boolToVisible( View view, boolean boolToVisible ) {
        view.setVisibility( boolToVisible ? View.VISIBLE : View.GONE );
    }

    @BindingAdapter( { "boolToDisable" } )
    public static void boolToDisable( View view, boolean boolToDisable ) {
        view.setEnabled( !boolToDisable );
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LogConfigTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteLogConfig;
import com.hmdm.launcher.json.RemoteLogItem;

import java.util.List;

public class LogConfigTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE log_rules (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "packageId TEXT, " +
                    "level INTEGER, " +
                    "filter TEXT " +
                    ")";
    private static final String DELETE_ALL =
            "DELETE FROM log_rules";
    private static final String INSERT_RULE =
            "INSERT OR IGNORE INTO log_rules(packageId, level, filter) VALUES (?, ?, ?)";
    private static final String FIND_MATCHING =
            "SELECT * FROM log_rules WHERE packageId = ? AND level >= ? AND (filter IS NULL OR filter = '' OR ? LIKE ('%' || filter || '%')) LIMIT 1";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void replaceAll(SQLiteDatabase db, List<RemoteLogConfig> items) {
        db.beginTransaction();
        try {
            db.execSQL(DELETE_ALL);
            for (RemoteLogConfig item : items) {
                db.execSQL(INSERT_RULE, new String[]{
                        item.getPackageId(),
                        Integer.toString(item.getLogLevel()),
                        item.getFilter()
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static boolean match(SQLiteDatabase db, RemoteLogItem item) {
        Cursor cursor = db.rawQuery(FIND_MATCHING, new String[] {
                item.getPackageId(),
                Integer.toString(item.getLogLevel()),
                item.getMessage()
        });
        boolean ret = cursor.moveToFirst();
        cursor.close();
        return ret;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ApplicationSetting.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ApplicationSetting {

    private String packageId;
    private String name;
    private int type;
    private String value;
    private boolean readOnly;
    private long lastUpdate;

    public ApplicationSetting() {}

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public boolean isReadOnly() {
        return readOnly;
    }

    public void setReadOnly(boolean readOnly) {
        this.readOnly = readOnly;
    }

    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfoConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfoConfig {
    private Boolean sendData;
    private Integer intervalMins;

    public Boolean getSendData() {
        return sendData;
    }

    public void setSendData(Boolean sendData) {
        this.sendData = sendData;
    }

    public Integer getIntervalMins() {
        return intervalMins;
    }

    public void setIntervalMins(Integer intervalMins) {
        this.intervalMins = intervalMins;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfoConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfoConfigResponse extends ServerResponse {
    private DetailedInfoConfig data;

    public DetailedInfoConfigResponse() {}

    public DetailedInfoConfig getData() {
        return data;
    }

    public void setData( DetailedInfoConfig data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushMessageJson.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import org.json.JSONObject;

public class PushMessageJson extends PushMessage {
    private JSONObject payloadJSON;

    public PushMessageJson() {
    }

    public PushMessageJson(String messageType, JSONObject payloadJSON) {
        setMessageType(messageType);
        this.payloadJSON = payloadJSON;
    }

    @Override
    public JSONObject getPayloadJSON() {
        return payloadJSON;
    }

    public void setPayloadJSON(JSONObject payloadJSON) {
        this.payloadJSON = payloadJSON;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class PushResponse {
    private String status;
    private List<PushMessage> data;

    public PushResponse() {}

    public String getStatus() {
        return status;
    }

    public void setStatus( String status ) {
        this.status = status;
    }

    public List<PushMessage> getData() {
        return data;
    }

    public void setData( List<PushMessage> data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogConfig {
    private String packageId;
    private int logLevel;
    private String filter;

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getFilter() {
        return filter;
    }

    public void setFilter(String filter) {
        this.filter = filter;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogConfigResponse extends ServerResponse {

    private List<RemoteLogConfig> data;

    public RemoteLogConfigResponse() {}

    public List<RemoteLogConfig> getData() {
        return data;
    }

    public void setData( List<RemoteLogConfig> data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteLogItem.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteLogItem {
    @JsonIgnore
    private long _id;

    private long timestamp;
    private int logLevel;
    private String packageId;
    private String message;

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(long timestamp) {
        this.timestamp = timestamp;
    }

    public int getLogLevel() {
        return logLevel;
    }

    public void setLogLevel(int logLevel) {
        this.logLevel = logLevel;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerConfigResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerConfigResponse extends ServerResponse {
    private ServerConfig data;

    public ServerConfig getData() {
        return data;
    }

    public void setData( ServerConfig data ) {
        this.data = data;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerResponse.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerResponse {

    private String status;
    private String message;

    public ServerResponse() {}

    public String getStatus() {
        return status;
    }

    public void setStatus( String status ) {
        this.status = status;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage( String message ) {
        this.message = message;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/service/CheckForegroundApplicationService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

/**
 * In open-source version, the service checking foreground apps is just a stub;
 * this option is available in Pro-version only
 */
public class CheckForegroundApplicationService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        // Stub
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/worker/DetailedInfoWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.worker;

import android.content.Context;

/**
 * These functions are available in Pro-version only
 * In a free version, the class contains stubs
 */
public class DetailedInfoWorker {
    public static void schedule(Context context) {
        // stub
    }

    public static void requestConfigUpdate(Context context) {
        // stub
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/ShutdownReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

public class ShutdownReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        RemoteLogger.log(context, Const.LOG_INFO, "Shutting down the device");
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/SimChangedReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.RemoteLogger;

public class SimChangedReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(final Context context, final Intent intent) {
        // SIM card changed, log the new IMSI and number
        String phoneNumber = null;
        try {
            phoneNumber = DeviceInfoProvider.getPhoneNumber(context);
        } catch (Exception e) {
        }

        String simState = intent.getExtras().getString("ss");

        String message = null;
        if (simState.equals("LOADED")) {
            message = "SIM card loaded";
            if (phoneNumber != null && phoneNumber.length() > 0) {
                message += ". New phone number: " + phoneNumber;
            }
        } else if (simState.equals("ABSENT")) {
            message = "SIM card removed";
        }

        if (message != null) {
            RemoteLogger.log(context, Const.LOG_INFO, message);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmDeviceResetTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmDeviceResetTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmDeviceResetTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmDeviceReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmDeviceReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmRebootTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmRebootTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmRebootTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmReboot(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmReboot(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/GetRemoteLogConfigTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogConfigResponse;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.RemoteLogger;

import retrofit2.Response;

public class GetRemoteLogConfigTask extends AsyncTask< Void, Integer, Integer > {
    private Context context;
    private SettingsHelper settingsHelper;

    public GetRemoteLogConfigTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( Void... voids ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<RemoteLogConfigResponse> response = null;

        try {
            response = serverService.
                    getRemoteLogConfig(settingsHelper.getServerProject(), settingsHelper.getDeviceId()).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        getRemoteLogConfig(settingsHelper.getServerProject(), settingsHelper.getDeviceId()).execute();
            }

            if ( response.isSuccessful() ) {
                if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                    RemoteLogger.updateConfig(context, response.body().getData());

                    return Const.TASK_SUCCESS;
                } else {
                    return Const.TASK_ERROR;
                }
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }

        return Const.TASK_NETWORK_ERROR;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/SendDeviceInfoTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class SendDeviceInfoTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public SendDeviceInfoTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.sendDevice(settingsHelper.getServerProject(), info[ 0 ]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.sendDevice(settingsHelper.getServerProject(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/BlockingBar.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.LinearLayout;

import androidx.annotation.Nullable;

/**
 * This view is a transparent bar intended to block user interaction with swipeable system areas (status bar etc.)
 */
public class BlockingBar extends LinearLayout {

    public BlockingBar(Context context ) {
        super( context );
    }

    public BlockingBar(Context context, @Nullable AttributeSet attrs ) {
        super( context, attrs );
    }

    public BlockingBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr ) {
        super( context, attrs, defStyleAttr );
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        // Intercepted touch!
        return true;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/CryptoUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class CryptoUtils {
    public static String calculateChecksum(InputStream fileContent) {
        // Calculate checksum
        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("MD5");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
        try (InputStream is = new BufferedInputStream(fileContent);
             DigestInputStream dis = new DigestInputStream(is, md)) {
            /* Read decorated stream (dis) to EOF as normal... */
            int b;
            while ((b = dis.read()) != -1) {
                // digest will consume the content when read() called
            }
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        // to calculate message digest of the input string
        // returned as array of byte
        byte[] digest = md.digest();

        // Convert byte array into signum representation
        BigInteger no = new BigInteger(1, digest);

        // Convert message digest into hex value
        String hashtext = no.toString(16);

        // Add preceding 0s to make it 32 bit
        while (hashtext.length() < 32) {
            hashtext = "0" + hashtext;
        }

        return hashtext;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/LegacyUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.ComponentName;
import android.content.Context;

import com.hmdm.launcher.AdminReceiver;

/**
 * For compatibility with old builds
 * Legacy admin receiver is ru.headwind.kiosk.AdminReceiver, it is replaced in legacy build variants
 */
public class LegacyUtils {
    public static ComponentName getAdminComponentName(Context context) {
        return new ComponentName(context.getApplicationContext(), AdminReceiver.class);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/App.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import android.app.Application;

import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.Picasso;

public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        Picasso.Builder builder = new Picasso.Builder(this);
        builder.downloader(new OkHttp3Downloader(this,Integer.MAX_VALUE));
        Picasso built = builder.build();
        //built.setIndicatorsEnabled(true);
        //built.setLoggingEnabled(true);
        Picasso.setSingletonInstance(built);
    }

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MessageStore.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import java.util.Iterator;

/**
 * <p>
 * Mechanism for persisting messages until we know they have been received
 * </p>
 * <ul>
 * <li>A Service should store messages as they arrive via
 * {@link #storeArrived(String, String, MqttMessage)}.
 * <li>When a message has been passed to the consuming entity,
 * {@link #discardArrived(String, String)} should be called.
 * <li>To recover messages which have not been definitely passed to the
 * consumer, {@link MessageStore#getAllArrivedMessages(String)} is used.
 * <li>When a clean session is started {@link #clearArrivedMessages(String)} is
 * used.
 * </ul>
 */
interface MessageStore {

	/**
	 * External representation of a stored message
	 */
	interface StoredMessage {
		/**
		 * @return the identifier for the message within the store
		 */
		String getMessageId();

		/**
		 * @return the identifier of the client which stored this message
		 */
		String getClientHandle();

		/**
		 * @return the topic on which the message was received
		 */
		String getTopic();

		/**
		 * @return the identifier of the client which stored this message
		 */
		MqttMessage getMessage();
	}

	/**
	 * Store a message and return an identifier for it
	 * 
	 * @param clientHandle
	 *            identifier for the client
	 * @param message
	 *            message to be stored
	 * @return a unique identifier for it
	 */
	String storeArrived(String clientHandle, String Topic,
						MqttMessage message);

	/**
	 * Discard a message - called when we are certain that an arrived message
	 * has reached the application.
	 * 
	 * @param clientHandle
	 *            identifier for the client
	 * @param id
	 *            id of message to be discarded
	 */
	boolean discardArrived(String clientHandle, String id);

	/**
	 * Get all the stored messages, usually for a specific client
	 * 
	 * @param clientHandle
	 *            identifier for the client - if null, then messages for all
	 *            clients are returned
	 */
	Iterator<StoredMessage> getAllArrivedMessages(String clientHandle);

	/**
	 * Discard stored messages, usually for a specific client
	 * 
	 * @param clientHandle
	 *            identifier for the client - if null, then messages for all
	 *            clients are discarded
	 */
	void clearArrivedMessages(String clientHandle);

	void close();
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttAndroidConnectOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttConnectOptions;

public class MqttAndroidConnectOptions extends MqttConnectOptions {
    public static final int PING_ALARM = 0;
    public static final int PING_WORKER = 1;

    private int pingType;

    public int getPingType() {
        return pingType;
    }

    public void setPingType(int pingType) {
        this.pingType = pingType;
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttDeliveryTokenAndroid.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;

/**
 * <p>
 * Implementation of the IMqttDeliveryToken interface for use from within the
 * MqttAndroidClient implementation
 */
class MqttDeliveryTokenAndroid extends MqttTokenAndroid
		implements IMqttDeliveryToken {

	// The message which is being tracked by this token
	private MqttMessage message;

	MqttDeliveryTokenAndroid(MqttAndroidClient client,
			Object userContext, IMqttActionListener listener, MqttMessage message) {
		super(client, userContext, listener);
		this.message = message;
	}

	/**
	 * @see org.eclipse.paho.client.mqttv3.IMqttDeliveryToken#getMessage()
	 */
	@Override
	public MqttMessage getMessage() throws MqttException {
		return message;
	}

	void setMessage(MqttMessage message) {
		this.message = message;
	}

	void notifyDelivery(MqttMessage delivered) {
		message = delivered;
		super.notifyComplete();
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttServiceBinder.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.os.Binder;

/**
 * What the Service passes to the Activity on binding:-
 * <ul>
 * <li>a reference to the Service
 * <li>the activityToken provided when the Service was started
 * </ul>
 * 
 */
class MqttServiceBinder extends Binder {

	private MqttService mqttService;
	private String activityToken;

	MqttServiceBinder(MqttService mqttService) {
		this.mqttService = mqttService;
	}

	/**
	 * @return a reference to the Service
	 */
	public MqttService getService() {
		return mqttService;
	}

	void setActivityToken(String activityToken) {
		this.activityToken = activityToken;
	}

	/**
	 * @return the activityToken provided when the Service was started
	 */
	public String getActivityToken() {
		return activityToken;
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttServiceConstants.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Various strings used to identify operations or data in the Android MQTT
 * service, mainly used in Intents passed between Activities and the Service.
 */
interface MqttServiceConstants {

	/*
	 * Version information
	 */
	
	String VERSION = "v0";
	
  /*
   * Attributes of messages <p> Used for the column names in the database
   */
  String DUPLICATE = "duplicate";
  String RETAINED = "retained";
  String QOS = "qos";
  String PAYLOAD = "payload";
  String DESTINATION_NAME = "destinationName";
  String CLIENT_HANDLE = "clientHandle";
  String MESSAGE_ID = "messageId";

  /* Tags for actions passed between the Activity and the Service */
  String SEND_ACTION = "send";
  String UNSUBSCRIBE_ACTION = "unsubscribe";
  String SUBSCRIBE_ACTION = "subscribe";
  String DISCONNECT_ACTION = "disconnect";
  String CONNECT_ACTION = "connect";
  String CONNECT_EXTENDED_ACTION = "connectExtended";
  String MESSAGE_ARRIVED_ACTION = "messageArrived";
  String MESSAGE_DELIVERED_ACTION = "messageDelivered";
  String ON_CONNECTION_LOST_ACTION = "onConnectionLost";
  String TRACE_ACTION = "trace";

  /* Identifies an Intent which calls back to the Activity */
  String CALLBACK_TO_ACTIVITY = MqttService.TAG
                                             + ".callbackToActivity"+"."+VERSION;

  /* Identifiers for extra data on Intents broadcast to the Activity */
  String CALLBACK_ACTION = MqttService.TAG + ".callbackAction";
  String CALLBACK_STATUS = MqttService.TAG + ".callbackStatus";
  String CALLBACK_CLIENT_HANDLE = MqttService.TAG + "."
                                               + CLIENT_HANDLE;
  String CALLBACK_ERROR_MESSAGE = MqttService.TAG
                                               + ".errorMessage";
  String CALLBACK_EXCEPTION_STACK = MqttService.TAG
                                                 + ".exceptionStack";
  String CALLBACK_INVOCATION_CONTEXT = MqttService.TAG + "."
                                                    + "invocationContext";
  String CALLBACK_ACTIVITY_TOKEN = MqttService.TAG + "."
                                                + "activityToken";
  String CALLBACK_DESTINATION_NAME = MqttService.TAG + '.'
                                                  + DESTINATION_NAME;
  String CALLBACK_MESSAGE_ID = MqttService.TAG + '.'
                                            + MESSAGE_ID;
  String CALLBACK_RECONNECT = MqttService.TAG + ".reconnect";
  String CALLBACK_SERVER_URI = MqttService.TAG + ".serverURI";
  String CALLBACK_MESSAGE_PARCEL = MqttService.TAG + ".PARCEL";
  String CALLBACK_TRACE_SEVERITY = MqttService.TAG
                                                + ".traceSeverity";
  String CALLBACK_TRACE_TAG = MqttService.TAG + ".traceTag";
  String CALLBACK_TRACE_ID = MqttService.TAG + ".traceId";
  String CALLBACK_ERROR_NUMBER = MqttService.TAG
                                              + ".ERROR_NUMBER";

  String CALLBACK_EXCEPTION = MqttService.TAG + ".exception";
  
  //Intent prefix for Ping sender.
  String PING_SENDER = MqttService.TAG + ".pingSender.";
  
  //Constant for wakelock
  String PING_WAKELOCK = MqttService.TAG + ".client.";
  String WAKELOCK_NETWORK_INTENT = MqttService.TAG + "";

  //Trace severity levels  
  String TRACE_ERROR = "error";
  String TRACE_DEBUG = "debug";
  String TRACE_EXCEPTION = "exception";
  
  
  //exception code for non MqttExceptions
  int NON_MQTT_EXCEPTION = -1;

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttTokenAndroid.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;
import org.eclipse.paho.client.mqttv3.internal.wire.MqttWireMessage;

/**
 * <p>
 * Implementation of the IMqttToken interface for use from within the
 * MqttAndroidClient implementation
 */

class MqttTokenAndroid implements IMqttToken {

  private IMqttActionListener listener;

  private volatile boolean isComplete;

  private volatile MqttException lastException;

  private Object waitObject = new Object();

  private MqttAndroidClient client;

  private Object userContext;

  private String[] topics;

  private IMqttToken delegate; // specifically for getMessageId

  private MqttException pendingException;

  /**
   * Standard constructor
   * 
   * @param client used to pass MqttAndroidClient object
   * @param userContext used to pass context
   * @param listener optional listener that will be notified when the action completes. Use null if not required.
   */
  MqttTokenAndroid(MqttAndroidClient client,
      Object userContext, IMqttActionListener listener) {
    this(client, userContext, listener, null);
  }

  /**
   * Constructor for use with subscribe operations
   * 
   * @param client used to pass MqttAndroidClient object
   * @param userContext used to pass context
   * @param listener optional listener that will be notified when the action completes. Use null if not required.
   * @param topics topics to subscribe to, which can include wildcards.
   */
  MqttTokenAndroid(MqttAndroidClient client,
      Object userContext, IMqttActionListener listener, String[] topics) {
    this.client = client;
    this.userContext = userContext;
    this.listener = listener;
    this.topics = topics;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#waitForCompletion()
   */
  @Override
  public void waitForCompletion() throws MqttException, MqttSecurityException {
    synchronized (waitObject) {
      try {
        waitObject.wait();
      }
      catch (InterruptedException e) {
        // do nothing
      }
    }
    if (pendingException != null) {
      throw pendingException;
    }
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#waitForCompletion(long)
   */
  @Override
  public void waitForCompletion(long timeout) throws MqttException,
      MqttSecurityException {
    synchronized (waitObject) {
      try {
        waitObject.wait(timeout);
      }
      catch (InterruptedException e) {
        // do nothing
      }
      if (!isComplete) {
        throw new MqttException(MqttException.REASON_CODE_CLIENT_TIMEOUT);
      }
      if (pendingException != null) {
        throw pendingException;
      }
    }
  }

  /**
   * notify successful completion of the operation
   */
  void notifyComplete() {
    synchronized (waitObject) {
      isComplete = true;
      waitObject.notifyAll();
      if (listener != null) {
        listener.onSuccess(this);
      }
    }
  }

  /**
   * notify unsuccessful completion of the operation
   */
  void notifyFailure(Throwable exception) {
    synchronized (waitObject) {
      isComplete = true;
      if (exception instanceof MqttException) {
        pendingException = (MqttException) exception;
      }
      else {
        pendingException = new MqttException(exception);
      }
      waitObject.notifyAll();
      if (exception instanceof MqttException) {
        lastException = (MqttException) exception;
      }
      if (listener != null) {
        listener.onFailure(this, exception);
      }
    }

  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#isComplete()
   */
  @Override
  public boolean isComplete() {
    return isComplete;
  }

  void setComplete(boolean complete) {
    isComplete = complete;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getException()
   */
  @Override
  public MqttException getException() {
    return lastException;
  }

  void setException(MqttException exception) {
    lastException = exception;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getClient()
   */
  @Override
  public IMqttAsyncClient getClient() {
    return client;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#setActionCallback(IMqttActionListener)
   */
  @Override
  public void setActionCallback(IMqttActionListener listener) {
    this.listener = listener;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getActionCallback()
   */
  @Override
  public IMqttActionListener getActionCallback() {
    return listener;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getTopics()
   */
  @Override
  public String[] getTopics() {
    return topics;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#setUserContext(Object)
   */
  @Override
  public void setUserContext(Object userContext) {
    this.userContext = userContext;

  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getUserContext()
   */
  @Override
  public Object getUserContext() {
    return userContext;
  }

  void setDelegate(IMqttToken delegate) {
    this.delegate = delegate;
  }

  /**
   * @see org.eclipse.paho.client.mqttv3.IMqttToken#getMessageId()
   */
  @Override
  public int getMessageId() {
    return (delegate != null) ? delegate.getMessageId() : 0;
  }
  
  @Override
  public MqttWireMessage getResponse() {
    return delegate.getResponse();
  }
  
  @Override
  public boolean getSessionPresent() {
    return delegate.getSessionPresent();
  }
  
  @Override
  public int[] getGrantedQos() {
    return delegate.getGrantedQos();
  }
  
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttTraceHandler.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Interface for simple trace handling, pass the trace message to trace
 * callback.
 * 
 */

public interface MqttTraceHandler {

	/**
	 * Trace debugging information
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 */
	void traceDebug(String tag, String message);

	/**
	 * Trace error information
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 */
	void traceError(String tag, String message);

	/**
	 * trace exceptions
	 * 
	 * @param tag
	 *            identifier for the source of the trace
	 * @param message
	 *            the text to be traced
	 * @param e
	 *            the exception
	 */
	void traceException(String tag, String message,
						Exception e);

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/ParcelableMqttMessage.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import android.os.Parcel;
import android.os.Parcelable;

/**
 * <p>
 * A way to flow MqttMessages via Bundles/Intents
 * </p>
 * 
 * <p>
 * An application will probably use this only when receiving a message from a
 * Service in a Bundle - the necessary code will be something like this :-
 * </p>
 * <pre>
 * <code>
 * 	private void messageArrivedAction(Bundle data) {
 * 		ParcelableMqttMessage message = (ParcelableMqttMessage) data
 * 			.getParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL);
 *		<i>Use the normal {@link MqttMessage} methods on the the message object.</i>
 * 	}
 * 
 * </code>
 * </pre>
 *
 * <p>
 * It is unlikely that an application will directly use the methods which are
 * specific to this class.
 * </p>
 */

public class ParcelableMqttMessage extends MqttMessage implements Parcelable {

  String messageId = null;

  ParcelableMqttMessage(MqttMessage original) {
    super(original.getPayload());
    setQos(original.getQos());
    setRetained(original.isRetained());
    setDuplicate(original.isDuplicate());
  }

  ParcelableMqttMessage(Parcel parcel) {
    super(parcel.createByteArray());
    setQos(parcel.readInt());
    boolean[] flags = parcel.createBooleanArray();
    setRetained(flags[0]);
    setDuplicate(flags[1]);
    messageId = parcel.readString();
  }

  /**
   * @return the messageId
   */
  public String getMessageId() {
    return messageId;
  }

  /**
   * Describes the contents of this object
   */
  @Override
  public int describeContents() {
    return 0;
  }

  /**
   * Writes the contents of this object to a parcel
   * 
   * @param parcel
   *            The parcel to write the data to.
   * @param flags
   *            this parameter is ignored
   */
  @Override
  public void writeToParcel(Parcel parcel, int flags) {
    parcel.writeByteArray(getPayload());
    parcel.writeInt(getQos());
    parcel.writeBooleanArray(new boolean[]{isRetained(), isDuplicate()});
    parcel.writeString(messageId);
  }

	/**
	 * A creator which creates the message object from a parcel
	 */
	public static final Parcelable.Creator<ParcelableMqttMessage> CREATOR = new Parcelable.Creator<ParcelableMqttMessage>() {

		/**
		 * Creates a message from the parcel object
		 */
		@Override
		public ParcelableMqttMessage createFromParcel(Parcel parcel) {
			return new ParcelableMqttMessage(parcel);
		}

		/**
		 * creates an array of type {@link ParcelableMqttMessage}[]
		 * 
		 */
		@Override
		public ParcelableMqttMessage[] newArray(int size) {
			return new ParcelableMqttMessage[size];
		}
	};
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/Status.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

/**
 * Enumeration representing the success or failure of an operation
 */
enum Status {
	/**
	 * Indicates that the operation succeeded
	 */
	OK, 
	
	/**
	 * Indicates that the operation failed
	 */
	ERROR,
	
	/**
	 * Indicates that the operation's result may be returned asynchronously
	 */
	NO_RESULT
}
</file>

<file path="app/src/main/res/drawable/ic_android_white_50dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector android:height="50dp" android:viewportHeight="24.0"
    android:viewportWidth="24.0" android:width="50dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#ffffff" android:pathData="M6,18c0,0.55 0.45,1 1,1h1v3.5c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5L11,19h2v3.5c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5L16,19h1c0.55,0 1,-0.45 1,-1L18,8L6,8v10zM3.5,8C2.67,8 2,8.67 2,9.5v7c0,0.83 0.67,1.5 1.5,1.5S5,17.33 5,16.5v-7C5,8.67 4.33,8 3.5,8zM20.5,8c-0.83,0 -1.5,0.67 -1.5,1.5v7c0,0.83 0.67,1.5 1.5,1.5s1.5,-0.67 1.5,-1.5v-7c0,-0.83 -0.67,-1.5 -1.5,-1.5zM15.53,2.16l1.3,-1.3c0.2,-0.2 0.2,-0.51 0,-0.71 -0.2,-0.2 -0.51,-0.2 -0.71,0l-1.48,1.48C13.85,1.23 12.95,1 12,1c-0.96,0 -1.86,0.23 -2.66,0.63L7.85,0.15c-0.2,-0.2 -0.51,-0.2 -0.71,0 -0.2,0.2 -0.2,0.51 0,0.71l1.31,1.31C6.97,3.26 6,5.01 6,7h12c0,-1.99 -0.97,-3.75 -2.47,-4.84zM10,5L9,5L9,4h1v1zM15,5h-1L14,4h1v1z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_arrow_back_white_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#ffffff"
        android:pathData="M20,11H7.83l5.59,-5.59L12,4l-8,8 8,8 1.41,-1.41L7.83,13H20v-2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_info_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_info_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM13,17h-2v-6h2v6zM13,9h-2L11,7h2v2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_system_update_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M17,1.01L7,1c-1.1,0 -2,0.9 -2,2v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2L19,3c0,-1.1 -0.9,-1.99 -2,-1.99zM17,19L7,19L7,5h10v14zM16,13h-3L13,8h-2v5L8,13l4,4 4,-4z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_system_update_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M17,1.01L7,1c-1.1,0 -2,0.9 -2,2v18c0,1.1 0.9,2 2,2h10c1.1,0 2,-0.9 2,-2L19,3c0,-1.1 -0.9,-1.99 -2,-1.99zM17,19L7,19L7,5h10v14zM16,13h-3L13,8h-2v5L8,13l4,4 4,-4z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_black_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33333333"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_opaque_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#33ffffff"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_vpn_key_transparent_24dp.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">
    <path
        android:fillColor="#05ffffff"
        android:pathData="M12.65,10C11.83,7.67 9.61,6 7,6c-3.31,0 -6,2.69 -6,6s2.69,6 6,6c2.61,0 4.83,-1.67 5.65,-4H17v4h4v-4h2v-4H12.65zM7,14c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2z"/>
</vector>
</file>

<file path="app/src/main/res/layout/dialog_system_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <data>
        <variable name="message" type="String"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@{message}"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:id="@+id/continueButton"
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_unknown_sources.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_unknown_sources_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_unknown_sources_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueUnknownSources"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/values-w400dp/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <dimen name="dialog_enter_device_id_width">350dp</dimen>
    <dimen name="button_text_size">14dp</dimen>
    <dimen name="button_text_size_small">12dp</dimen>
</resources>
</file>

<file path="app/src/main/res/values-w820dp/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
<!-- Example customization of dimensions originally defined in res/values/dimens.xml
         (such as screen margins) for screens with more than 820dp of available width. This
         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
    <dimen name="activity_horizontal_margin">64dp</dimen>
</resources>
</file>

<file path="app/src/main/res/xml/accessibility_service_config.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="typeWindowStateChanged"
    android:accessibilityFlags="flagDefault"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:description="@string/accessibility_service_description"
    android:notificationTimeout="100"
    android:canRetrieveWindowContent="true"/>
</file>

<file path="app/src/main/res/xml/device_admin.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<device-admin xmlns:android="http://schemas.android.com/apk/res/android">
    <uses-policies>
        <wipe-data />
        <limit-password />
    </uses-policies>
</device-admin>
</file>

<file path="app/src/main/res/xml/provider_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<paths><external-path name="external_files" path="."/></paths>
</file>

<file path="app/src/test/java/com/hmdm/launcher/ExampleUnitTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="app/.gitignore">
/build
</file>

<file path="app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in C:\Android\sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}
-keep class !ru.headwind.kiosk.**{ *; }
-keep class ru.headwind.kiosk.sdk.UpdateError {*;}
</file>

<file path="lib/src/main/java/com/hmdm/MDMException.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

public class MDMException extends Exception {
    public MDMError mdmError;
    public String comment;
    public MDMException(int code) {
        super(MDMError.getMessage(code));
        mdmError = new MDMError(code);
    }
    public MDMException(int code, String comment) {
        super(MDMError.getMessage(code) + ": " + comment);
        mdmError = new MDMError(code);
        this.comment = comment;
    }
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMPushMessage.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.os.Bundle;

import org.json.JSONException;
import org.json.JSONObject;

public class MDMPushMessage {
    private String type;
    private JSONObject data;

    public static final String MessageConfigUpdated = "configUpdated";

    public MDMPushMessage(String action, Bundle bundle) throws MDMException {
        if (!action.startsWith(Const.INTENT_PUSH_NOTIFICATION_PREFIX)) {
            throw new MDMException(MDMError.ERROR_INVALID_PARAMETER);
        }
        type = action.substring(Const.INTENT_PUSH_NOTIFICATION_PREFIX.length());
        if (bundle != null) {
            String packedPayload = bundle.getString(Const.INTENT_PUSH_NOTIFICATION_EXTRA);
            if (packedPayload != null) {
                try {
                    data = new JSONObject(packedPayload);
                } catch (JSONException e) {
                    throw new MDMException(MDMError.ERROR_INVALID_PARAMETER);
                }
            }
        }
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public JSONObject getData() {
        return data;
    }

    public void setData(JSONObject data) {
        this.data = data;
    }
}
</file>

<file path="lib/src/main/res/values/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="app_name">PluginLibrary</string>
</resources>
</file>

<file path="lib/src/test/java/com/hmdm/ExampleUnitTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import org.junit.Test;

import static org.junit.Assert.*;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="lib/.gitignore">
/build
</file>

<file path="lib/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2018 Vsevolod Mayorov

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="NOTICE">
=========================================================================
==  NOTICE file corresponding to the section 4 d of                    ==
==  the Apache License, Version 2.0                                    ==
=========================================================================

Headwind MDM: Open Source Android Mobile Device Management Software

Project website: https://h-mdm.com

(c) 2019 Headwind Solutions LLC (http://www.h-sms.com)
</file>

<file path="app/src/main/assets/isrg_root_x1.pem">
-----BEGIN CERTIFICATE-----
MIIFazCCA1OgAwIBAgIRAIIQz7DSQONZRGPgu2OCiwAwDQYJKoZIhvcNAQELBQAw
TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh
cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwHhcNMTUwNjA0MTEwNDM4
WhcNMzUwNjA0MTEwNDM4WjBPMQswCQYDVQQGEwJVUzEpMCcGA1UEChMgSW50ZXJu
ZXQgU2VjdXJpdHkgUmVzZWFyY2ggR3JvdXAxFTATBgNVBAMTDElTUkcgUm9vdCBY
MTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK3oJHP0FDfzm54rVygc
h77ct984kIxuPOZXoHj3dcKi/vVqbvYATyjb3miGbESTtrFj/RQSa78f0uoxmyF+
0TM8ukj13Xnfs7j/EvEhmkvBioZxaUpmZmyPfjxwv60pIgbz5MDmgK7iS4+3mX6U
A5/TR5d8mUgjU+g4rk8Kb4Mu0UlXjIB0ttov0DiNewNwIRt18jA8+o+u3dpjq+sW
T8KOEUt+zwvo/7V3LvSye0rgTBIlDHCNAymg4VMk7BPZ7hm/ELNKjD+Jo2FR3qyH
B5T0Y3HsLuJvW5iB4YlcNHlsdu87kGJ55tukmi8mxdAQ4Q7e2RCOFvu396j3x+UC
B5iPNgiV5+I3lg02dZ77DnKxHZu8A/lJBdiB3QW0KtZB6awBdpUKD9jf1b0SHzUv
KBds0pjBqAlkd25HN7rOrFleaJ1/ctaJxQZBKT5ZPt0m9STJEadao0xAH0ahmbWn
OlFuhjuefXKnEgV4We0+UXgVCwOPjdAvBbI+e0ocS3MFEvzG6uBQE3xDk3SzynTn
jh8BCNAw1FtxNrQHusEwMFxIt4I7mKZ9YIqioymCzLq9gwQbooMDQaHWBfEbwrbw
qHyGO0aoSCqI3Haadr8faqU9GY/rOPNk3sgrDQoo//fb4hVC1CLQJ13hef4Y53CI
rU7m2Ys6xt0nUW7/vGT1M0NPAgMBAAGjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNV
HRMBAf8EBTADAQH/MB0GA1UdDgQWBBR5tFnme7bl5AFzgAiIyBpY9umbbjANBgkq
hkiG9w0BAQsFAAOCAgEAVR9YqbyyqFDQDLHYGmkgJykIrGF1XIpu+ILlaS/V9lZL
ubhzEFnTIZd+50xx+7LSYK05qAvqFyFWhfFQDlnrzuBZ6brJFe+GnY+EgPbk6ZGQ
3BebYhtF8GaV0nxvwuo77x/Py9auJ/GpsMiu/X1+mvoiBOv/2X/qkSsisRcOj/KK
NFtY2PwByVS5uCbMiogziUwthDyC3+6WVwW6LLv3xLfHTjuCvjHIInNzktHCgKQ5
ORAzI4JMPJ+GslWYHb4phowim57iaztXOoJwTdwJx4nLCgdNbOhdjsnvzqvHu7Ur
TkXWStAmzOVyyghqpZXjFaH3pO3JLF+l+/+sKAIuvtd7u+Nxe5AW0wdeRlN8NwdC
jNPElpzVmbUq4JUagEiuTDkHzsxHpFKVK7q4+63SM1N95R1NbdWhscdCb+ZAJzVc
oyi3B43njTOQ5yOf+1CceWxG1bQVs5ZufpsMljq4Ui0/1lvh+wjChP4kqKOJ2qxq
4RgqsahDYVvTH9w7jXbyLeiNdd8XM2w9U/t7y0Ff/9yi0GE44Za4rF2LN9d11TPA
mRGunUHBcnWEvgJBQl9nJEiU0Zsnvgc/ubhPgXRR4Xq37Z0j4r7g1SgEEzwxA57d
emyPxgcYxn/eR44/KJ4EBs+lVDR3veyJm+kXQ99b21/+jh5Xos1AnX5iItreGCc=
-----END CERTIFICATE-----
</file>

<file path="app/src/main/java/com/github/anrwatchdog/ANRError.java">
package com.github.anrwatchdog;

import android.os.Looper;

import java.io.Serializable;
import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;

/**
 * Error thrown by {@link com.github.anrwatchdog.ANRWatchDog} when an ANR is detected.
 * Contains the stack trace of the frozen UI thread.
 * <p>
 * It is important to notice that, in an ANRError, all the "Caused by" are not really the cause
 * of the exception. Each "Caused by" is the stack trace of a running thread. Note that the main
 * thread always comes first.
 */
public class ANRError extends Error {

    private static class $ implements Serializable {
        private final String _name;
        private final StackTraceElement[] _stackTrace;

        private class _Thread extends Throwable {
            private _Thread(_Thread other) {
                super(_name, other);
            }

            @Override
            public Throwable fillInStackTrace() {
                setStackTrace(_stackTrace);
                return this;
            }
        }

        private $(String name, StackTraceElement[] stackTrace) {
            _name = name;
            _stackTrace = stackTrace;
        }
    }

    private static final long serialVersionUID = 1L;

    /**
     * The minimum duration, in ms, for which the main thread has been blocked. May be more.
     */
    @SuppressWarnings("WeakerAccess")
    public final long duration;

    private ANRError($._Thread st, long duration) {
        super("Application Not Responding for at least " + duration + " ms.", st);
        this.duration = duration;
    }

    @Override
    public Throwable fillInStackTrace() {
        setStackTrace(new StackTraceElement[] {});
        return this;
    }

    static ANRError New(long duration, String prefix, boolean logThreadsWithoutStackTrace) {
        final Thread mainThread = Looper.getMainLooper().getThread();

        final Map<Thread, StackTraceElement[]> stackTraces = new TreeMap<Thread, StackTraceElement[]>(new Comparator<Thread>() {
            @Override
            public int compare(Thread lhs, Thread rhs) {
                if (lhs == rhs)
                    return 0;
                if (lhs == mainThread)
                    return 1;
                if (rhs == mainThread)
                    return -1;
                return rhs.getName().compareTo(lhs.getName());
            }
        });

        for (Map.Entry<Thread, StackTraceElement[]> entry : Thread.getAllStackTraces().entrySet())
            if (
                    entry.getKey() == mainThread
                ||  (
                        entry.getKey().getName().startsWith(prefix)
                    &&  (
                            logThreadsWithoutStackTrace
                        ||
                            entry.getValue().length > 0
                        )
                    )
                )
                stackTraces.put(entry.getKey(), entry.getValue());

        // Sometimes main is not returned in getAllStackTraces() - ensure that we list it
        if (!stackTraces.containsKey(mainThread)) {
            stackTraces.put(mainThread, mainThread.getStackTrace());
        }

        $._Thread tst = null;
        for (Map.Entry<Thread, StackTraceElement[]> entry : stackTraces.entrySet())
            tst = new $(getThreadTitle(entry.getKey()), entry.getValue()).new _Thread(tst);

        return new ANRError(tst, duration);
    }

    static ANRError NewMainOnly(long duration) {
        final Thread mainThread = Looper.getMainLooper().getThread();
        final StackTraceElement[] mainStackTrace = mainThread.getStackTrace();

        return new ANRError(new $(getThreadTitle(mainThread), mainStackTrace).new _Thread(null), duration);
    }

    private static String getThreadTitle(Thread thread) {
        return thread.getName() + " (state = " + thread.getState() + ")";
    }
}
</file>

<file path="app/src/main/java/com/github/anrwatchdog/ANRWatchDog.java">
package com.github.anrwatchdog;

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2016 Salomon BRYS
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import android.os.Debug;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

/**
 * A watchdog timer thread that detects when the UI thread has frozen.
 */
@SuppressWarnings("UnusedReturnValue")
public class ANRWatchDog extends Thread {

    public interface ANRListener {
        /**
         * Called when an ANR is detected.
         *
         * @param error The error describing the ANR.
         */
        void onAppNotResponding(ANRError error);
    }

    public interface ANRInterceptor {
        /**
         * Called when main thread has froze more time than defined by the timeout.
         *
         * @param duration The minimum time (in ms) the main thread has been frozen (may be more).
         * @return 0 or negative if the ANR should be reported immediately. A positive number of ms to postpone the reporting.
         */
        long intercept(long duration);
    }

    public interface InterruptionListener {
        void onInterrupted(InterruptedException exception);
    }

    private static final int DEFAULT_ANR_TIMEOUT = 5000;

    private static final ANRListener DEFAULT_ANR_LISTENER = new ANRListener() {
        @Override public void onAppNotResponding(ANRError error) {
            throw error;
        }
    };

    private static final ANRInterceptor DEFAULT_ANR_INTERCEPTOR = new ANRInterceptor() {
        @Override public long intercept(long duration) {
            return 0;
        }
    };

    private static final InterruptionListener DEFAULT_INTERRUPTION_LISTENER = new InterruptionListener() {
        @Override public void onInterrupted(InterruptedException exception) {
            Log.w("ANRWatchdog", "Interrupted: " + exception.getMessage());
        }
    };

    private ANRListener _anrListener = DEFAULT_ANR_LISTENER;
    private ANRInterceptor _anrInterceptor = DEFAULT_ANR_INTERCEPTOR;
    private InterruptionListener _interruptionListener = DEFAULT_INTERRUPTION_LISTENER;

    private final Handler _uiHandler = new Handler(Looper.getMainLooper());
    private final int _timeoutInterval;

    private String _namePrefix = "";
    private boolean _logThreadsWithoutStackTrace = false;
    private boolean _ignoreDebugger = true;

    private volatile long _tick = 0;
    private volatile boolean _reported = false;

    private final Runnable _ticker = new Runnable() {
        @Override public void run() {
            _tick = 0;
            _reported = false;
        }
    };

    /**
     * Constructs a watchdog that checks the ui thread every {@value #DEFAULT_ANR_TIMEOUT} milliseconds
     */
    public ANRWatchDog() {
        this(DEFAULT_ANR_TIMEOUT);
    }

    /**
     * Constructs a watchdog that checks the ui thread every given interval
     *
     * @param timeoutInterval The interval, in milliseconds, between to checks of the UI thread.
     *                        It is therefore the maximum time the UI may freeze before being reported as ANR.
     */
    public ANRWatchDog(int timeoutInterval) {
        super();
        _timeoutInterval = timeoutInterval;
    }

    /**
     * @return The interval the WatchDog
     */
    public int getTimeoutInterval() {
        return _timeoutInterval;
    }

    /**
     * Sets an interface for when an ANR is detected.
     * If not set, the default behavior is to throw an error and crash the application.
     *
     * @param listener The new listener or null
     * @return itself for chaining.
     */
    public ANRWatchDog setANRListener(ANRListener listener) {
        if (listener == null) {
            _anrListener = DEFAULT_ANR_LISTENER;
        } else {
            _anrListener = listener;
        }
        return this;
    }

    /**
     * Sets an interface to intercept ANRs before they are reported.
     * If set, you can define if, given the current duration of the detected ANR and external context, it is necessary to report the ANR.
     *
     * @param interceptor The new interceptor or null
     * @return itself for chaining.
     */
    public ANRWatchDog setANRInterceptor(ANRInterceptor interceptor) {
        if (interceptor == null) {
            _anrInterceptor = DEFAULT_ANR_INTERCEPTOR;
        } else {
            _anrInterceptor = interceptor;
        }
        return this;
    }

    /**
     * Sets an interface for when the watchdog thread is interrupted.
     * If not set, the default behavior is to just log the interruption message.
     *
     * @param listener The new listener or null.
     * @return itself for chaining.
     */
    public ANRWatchDog setInterruptionListener(InterruptionListener listener) {
        if (listener == null) {
            _interruptionListener = DEFAULT_INTERRUPTION_LISTENER;
        } else {
            _interruptionListener = listener;
        }
        return this;
    }

    /**
     * Set the prefix that a thread's name must have for the thread to be reported.
     * Note that the main thread is always reported.
     * Default "".
     *
     * @param prefix The thread name's prefix for a thread to be reported.
     * @return itself for chaining.
     */
    public ANRWatchDog setReportThreadNamePrefix(String prefix) {
        if (prefix == null) {
            prefix = "";
        }
        _namePrefix = prefix;
        return this;
    }

    /**
     * Set that only the main thread will be reported.
     *
     * @return itself for chaining.
     */
    public ANRWatchDog setReportMainThreadOnly() {
        _namePrefix = null;
        return this;
    }

    /**
     * Set that all threads will be reported (default behaviour).
     *
     * @return itself for chaining.
     */
    public ANRWatchDog setReportAllThreads() {
        _namePrefix = "";
        return this;
    }

    /**
     * Set that all running threads will be reported,
     * even those from which no stack trace could be extracted.
     * Default false.
     *
     * @param logThreadsWithoutStackTrace Whether or not all running threads should be reported
     * @return itself for chaining.
     */
    public ANRWatchDog setLogThreadsWithoutStackTrace(boolean logThreadsWithoutStackTrace) {
        _logThreadsWithoutStackTrace = logThreadsWithoutStackTrace;
        return this;
    }

    /**
     * Set whether to ignore the debugger when detecting ANRs.
     * When ignoring the debugger, ANRWatchdog will detect ANRs even if the debugger is connected.
     * By default, it does not, to avoid interpreting debugging pauses as ANRs.
     * Default false.
     *
     * @param ignoreDebugger Whether to ignore the debugger.
     * @return itself for chaining.
     */
    public ANRWatchDog setIgnoreDebugger(boolean ignoreDebugger) {
        _ignoreDebugger = ignoreDebugger;
        return this;
    }

    @SuppressWarnings("NonAtomicOperationOnVolatileField")
    @Override
    public void run() {
        setName("|ANR-WatchDog|");

        long interval = _timeoutInterval;
        while (!isInterrupted()) {
            boolean needPost = _tick == 0;
            _tick += interval;
            if (needPost) {
                _uiHandler.post(_ticker);
            }

            try {
                Thread.sleep(interval);
            } catch (InterruptedException e) {
                _interruptionListener.onInterrupted(e);
                return ;
            }

            // If the main thread has not handled _ticker, it is blocked. ANR.
            if (_tick != 0 && !_reported) {
                //noinspection ConstantConditions
                if (!_ignoreDebugger && (Debug.isDebuggerConnected() || Debug.waitingForDebugger())) {
                    Log.w("ANRWatchdog", "An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))");
                    _reported = true;
                    continue ;
                }

                interval = _anrInterceptor.intercept(_tick);
                if (interval > 0) {
                    continue;
                }

                final ANRError error;
                if (_namePrefix != null) {
                    error = ANRError.New(_tick, _namePrefix, _logThreadsWithoutStackTrace);
                } else {
                    error = ANRError.NewMainOnly(_tick);
                }
                _anrListener.onAppNotResponding(error);
                interval = _timeoutInterval;
                _reported = true;
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/DownloadTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.Download;

import java.util.LinkedList;
import java.util.List;

public class DownloadTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE downloads (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "url TEXT, " +
                    "path TEXT UNIQUE, " +
                    "attempts INTEGER, " +
                    "lastAttemptTime INTEGER, " +
                    "downloaded INTEGER, " +
                    "installed INTEGER " +
                    ")";
    private static final String INSERT_DOWNLOAD =
            "INSERT OR REPLACE INTO downloads(url, path, attempts, lastAttemptTime, downloaded, installed) VALUES (?, ?, ?, ?, ?, ?)";
    private static final String DELETE_DOWNLOAD =
            "DELETE FROM downloads WHERE _id=?";
    private static final String DELETE_DOWNLOAD_BY_PATH =
            "DELETE FROM downloads WHERE path=?";
    private static final String SELECT_ALL_DOWNLOADS =
            "SELECT * FROM downloads";
    private static final String SELECT_DOWNLOAD_BY_PATH =
            "SELECT * FROM downloads WHERE path=?";
    private static final String DELETE_ALL_DOWNLOADS =
            "DELETE FROM downloads";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, Download item) {
        try {
            db.execSQL(INSERT_DOWNLOAD, new String[]{
                    item.getUrl(),
                    item.getPath(),
                    Long.toString(item.getAttempts()),
                    Long.toString(item.getLastAttemptTime()),
                    item.isDownloaded() ? "1" : "0",
                    item.isInstalled() ? "1" : "0"
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteByPath(SQLiteDatabase db, String path) {
        try {
            db.execSQL(DELETE_DOWNLOAD_BY_PATH, new String[]{ path });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteAll(SQLiteDatabase db) {
        try {
            db.execSQL(DELETE_ALL_DOWNLOADS, new String[]{ });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @SuppressLint("Range")
    public static List<Download> selectAll(SQLiteDatabase db) {
        Cursor cursor = db.rawQuery(SELECT_ALL_DOWNLOADS, new String[] {});
        List<Download> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            Download item = new Download(cursor);
            result.add(item);

            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }

    @SuppressLint("Range")
    public static Download selectByPath(SQLiteDatabase db, String path) {
        Cursor cursor = db.rawQuery(SELECT_DOWNLOAD_BY_PATH, new String[] { path });

        Download item = null;
        if (cursor.moveToFirst()) {
            item = new Download(cursor);
        }
        cursor.close();

        return item;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/InfoHistoryTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.DetailedInfo;

import java.util.LinkedList;
import java.util.List;

public class InfoHistoryTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE info_history (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "deviceBatteryLevel INTEGER, " +
                    "deviceBatteryCharging TEXT, " +
                    "deviceWifi INTEGER, " +
                    "deviceGps INTEGER, " +
                    "deviceIp TEXT, " +
                    "deviceKeyguard INTEGER, " +
                    "deviceRingVolume INTEGER, " +
                    "deviceMobileData INTEGER, " +
                    "deviceBluetooth INTEGER, " +
                    "deviceUsbStorage INTEGER, " +
                    "wifiRssi INTEGER, " +
                    "wifiSsid TEXT, " +
                    "wifiSecurity TEXT, " +
                    "wifiState TEXT, " +
                    "wifiIp TEXT, " +
                    "wifiTx INTEGER, " +
                    "wifiRx INTEGER, " +
                    "gpsState TEXT, " +
                    "gpsProvider TEXT, " +
                    "gpsLat REAL, " +
                    "gpsLon REAL, " +
                    "gpsAlt REAL, " +
                    "gpsSpeed REAL, " +
                    "gpsCourse REAL, " +
                    "mobileRssi INTEGER, " +
                    "mobileCarrier TEXT, " +
                    "mobileNumber TEXT, " +
                    "mobileImsi TEXT, " +
                    "mobileData INTEGER, " +
                    "mobileIp TEXT, " +
                    "mobileState TEXT, " +
                    "mobileSimState TEXT, " +
                    "mobileTx INTEGER, " +
                    "mobileRx INTEGER, " +
                    "mobile2Rssi INTEGER, " +
                    "mobile2Carrier TEXT, " +
                    "mobile2Number TEXT, " +
                    "mobile2Imsi TEXT, " +
                    "mobile2Data INTEGER, " +
                    "mobile2Ip TEXT, " +
                    "mobile2State TEXT, " +
                    "mobile2SimState TEXT, " +
                    "mobile2Tx INTEGER, " +
                    "mobile2Rx INTEGER, " +
                    "deviceMemoryTotal INTEGER, " +
                    "deviceMemoryAvailable INTEGER " +
                    ")";
    private static final String ALTER_TABLE_ADD_MEMORY_TOTAL = "ALTER TABLE info_history ADD deviceMemoryTotal INT";
    private static final String ALTER_TABLE_ADD_MEMORY_AVAILABLE = "ALTER TABLE info_history ADD deviceMemoryAvailable INT";
    private static final String SELECT_LAST_INFO =
            "SELECT * FROM info_history ORDER BY ts LIMIT ?";
    private static final String INSERT_INFO =
            "INSERT OR IGNORE INTO info_history(ts, deviceBatteryLevel, deviceBatteryCharging, deviceWifi, " +
            "deviceGps, deviceIp, deviceKeyguard, deviceRingVolume, deviceMobileData, deviceBluetooth, deviceUsbStorage, " +
            "wifiRssi, wifiSsid, wifiSecurity, wifiState, wifiIp, wifiTx, wifiRx, " +
            "gpsState, gpsProvider, gpsLat, gpsLon, gpsAlt, gpsSpeed, gpsCourse, " +
            "mobileRssi, mobileCarrier, mobileNumber, mobileImsi, mobileData, mobileIp, mobileState, mobileSimState, mobileTx, mobileRx, " +
            "mobile2Rssi, mobile2Carrier, mobile2Number, mobile2Imsi, mobile2Data, mobile2Ip, mobile2State, mobile2SimState, mobile2Tx, mobile2Rx," +
            "deviceMemoryTotal, deviceMemoryAvailable" +
            ") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, " +
            "?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    private static final String DELETE_FROM_INFO =
            "DELETE FROM info_history WHERE _id=?";
    private static final String DELETE_OLD_ITEMS =
            "DELETE FROM info_history WHERE ts < ?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static String getAlterTableAddMemoryTotalSql() {
        return ALTER_TABLE_ADD_MEMORY_TOTAL;
    }

    public static String getAlterTableAddMemoryAvailableSql() {
        return ALTER_TABLE_ADD_MEMORY_AVAILABLE;
    }

    public static void insert(SQLiteDatabase db, DetailedInfo item) {
        try {
            DetailedInfo.Device device = item.getDevice();
            DetailedInfo.Wifi wifi = item.getWifi();
            DetailedInfo.Gps gps = item.getGps();
            DetailedInfo.Mobile mobile = item.getMobile();
            DetailedInfo.Mobile mobile2 = item.getMobile2();

            db.execSQL(INSERT_INFO, new String[]{
                    Long.toString(item.getTs()),

                    device != null && device.getBatteryLevel() != null ? device.getBatteryLevel().toString() : null,
                    device != null ? device.getBatteryCharging() : null,
                    device != null && device.getWifi() != null ? (device.getWifi() ? "1" : "0") : null,
                    device != null && device.getGps() != null ? (device.getGps() ? "1" : "0") : null,
                    device != null ? device.getIp() : null,
                    device != null && device.getKeyguard() != null ? (device.getKeyguard() ? "1" : "0") : null,
                    device != null && device.getRingVolume() != null ? device.getRingVolume().toString() : null,
                    device != null && device.getMobileData() != null ? (device.getMobileData() ? "1" : "0") : null,
                    device != null && device.getBluetooth() != null ? (device.getBluetooth() ? "1" : "0") : null,
                    device != null && device.getUsbStorage() != null ? (device.getUsbStorage() ? "1" : "0") : null,

                    wifi != null && wifi.getRssi() != null ? wifi.getRssi().toString() : null,
                    wifi != null ? wifi.getSsid() : null,
                    wifi != null ? wifi.getSecurity() : null,
                    wifi != null ? wifi.getState() : null,
                    wifi != null ? wifi.getIp() : null,
                    wifi != null && wifi.getTx() != null ? wifi.getTx().toString() : null,
                    wifi != null && wifi.getRx() != null ? wifi.getRx().toString() : null,

                    gps != null ? gps.getState() : null,
                    gps != null ? gps.getProvider() : null,
                    gps != null && gps.getLat() != null ? gps.getLat().toString() : null,
                    gps != null && gps.getLon() != null ? gps.getLon().toString() : null,
                    gps != null && gps.getAlt() != null ? gps.getAlt().toString() : null,
                    gps != null && gps.getSpeed() != null ? gps.getSpeed().toString() : null,
                    gps != null && gps.getCourse() != null ? gps.getCourse().toString() : null,

                    mobile != null && mobile.getRssi() != null ? mobile.getRssi().toString() : null,
                    mobile != null ? mobile.getCarrier() : null,
                    mobile != null ? mobile.getNumber() : null,
                    mobile != null ? mobile.getImsi() : null,
                    mobile != null && mobile.getData() != null ? (mobile.getData() ? "1" : "0") : null,
                    mobile != null ? mobile.getIp() : null,
                    mobile != null ? mobile.getState() : null,
                    mobile != null ? mobile.getSimState() : null,
                    mobile != null && mobile.getTx() != null ? mobile.getTx().toString() : null,
                    mobile != null && mobile.getRx() != null ? mobile.getRx().toString() : null,

                    mobile2 != null && mobile2.getRssi() != null ? mobile2.getRssi().toString() : null,
                    mobile2 != null ? mobile2.getCarrier() : null,
                    mobile2 != null ? mobile2.getNumber() : null,
                    mobile2 != null ? mobile2.getImsi() : null,
                    mobile2 != null && mobile2.getData() != null ? (mobile2.getData() ? "1" : "0") : null,
                    mobile2 != null ? mobile2.getIp() : null,
                    mobile2 != null ? mobile2.getState() : null,
                    mobile2 != null ? mobile2.getSimState() : null,
                    mobile2 != null && mobile2.getTx() != null ? mobile2.getTx().toString() : null,
                    mobile2 != null && mobile2.getRx() != null ? mobile2.getRx().toString() : null,

                    device != null && device.getMemoryTotal() != null ? device.getMemoryTotal().toString() : null,
                    device != null && device.getMemoryAvailable() != null ? device.getMemoryAvailable().toString() : null,
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_OLD_ITEMS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<DetailedInfo> items) {
        db.beginTransaction();
        try {
            for (DetailedInfo item : items) {
                db.execSQL(DELETE_FROM_INFO, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static List<DetailedInfo> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_INFO, new String[] {
                Integer.toString(limit)
        });
        List<DetailedInfo> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            DetailedInfo item = new DetailedInfo(cursor);
            result.add(item);
            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LogTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteLogItem;

import java.util.LinkedList;
import java.util.List;

public class LogTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE logs (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "level INTEGER, " +
                    "packageId TEXT, " +
                    "message TEXT" +
                    ")";
    private static final String SELECT_LAST_LOGS =
            "SELECT * FROM logs ORDER BY ts LIMIT ?";
    private static final String INSERT_LOG =
            "INSERT OR IGNORE INTO logs(ts, level, packageId, message) VALUES (?, ?, ?, ?)";
    private static final String DELETE_FROM_LOGS =
            "DELETE FROM logs WHERE _id=?";
    private static final String DELETE_OLD_LOGS =
            "DELETE FROM logs WHERE ts < ?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, RemoteLogItem item) {
        try {
            db.execSQL(INSERT_LOG, new String[]{
                    Long.toString(item.getTimestamp()),
                    Integer.toString(item.getLogLevel()),
                    item.getPackageId(),
                    item.getMessage()
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 7 * 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_FROM_LOGS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<RemoteLogItem> items) {
        db.beginTransaction();
        try {
            for (RemoteLogItem item : items) {
                db.execSQL(DELETE_FROM_LOGS, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    @SuppressLint("Range")
    public static List<RemoteLogItem> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_LOGS, new String[] {
            Integer.toString(limit)
        });
        List<RemoteLogItem> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            RemoteLogItem item = new RemoteLogItem();
            item.setId(cursor.getLong(cursor.getColumnIndex("_id")));
            item.setTimestamp(cursor.getLong(cursor.getColumnIndex("ts")));
            item.setLogLevel(cursor.getInt(cursor.getColumnIndex("level")));
            item.setPackageId(cursor.getString(cursor.getColumnIndex("packageId")));
            item.setMessage(cursor.getString(cursor.getColumnIndex("message")));
            result.add(item);

            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/RemoteFileTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import com.hmdm.launcher.json.RemoteFile;

public class RemoteFileTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE files (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "lastUpdate INTEGER, " +
                    "url TEXT, " +
                    "checksum TEXT, " +
                    "path TEXT UNIQUE, " +
                    "description TEXT " +
                    ")";
    private static final String INSERT_FILE =
            "INSERT OR REPLACE INTO files(lastUpdate, url, checksum, path, description) VALUES (?, ?, ?, ?, ?)";
    private static final String DELETE_FILE =
            "DELETE FROM files WHERE _id=?";
    private static final String DELETE_FILE_BY_PATH =
            "DELETE FROM files WHERE path=?";
    private static final String SELECT_FILE_BY_PATH =
            "SELECT * FROM files WHERE path=?";

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, RemoteFile item) {
        try {
            db.execSQL(INSERT_FILE, new String[]{
                    Long.toString(item.getLastUpdate()),
                    item.getUrl(),
                    item.getChecksum(),
                    item.getPath(),
                    item.getDescription()
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteByPath(SQLiteDatabase db, String path) {
        try {
            db.execSQL(DELETE_FILE_BY_PATH, new String[]{ path });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    @SuppressLint("Range")
    public static RemoteFile selectByPath(SQLiteDatabase db, String path) {
        Cursor cursor = db.rawQuery(SELECT_FILE_BY_PATH, new String[] { path });

        RemoteFile item = null;
        if (cursor.moveToFirst()) {
            item = new RemoteFile();
            item.setId(cursor.getLong(cursor.getColumnIndex("_id")));
            item.setLastUpdate(cursor.getLong(cursor.getColumnIndex("lastUpdate")));
            item.setUrl(cursor.getString(cursor.getColumnIndex("url")));
            item.setChecksum(cursor.getString(cursor.getColumnIndex("checksum")));
            item.setPath(cursor.getString(cursor.getColumnIndex("path")));
            item.setDescription(cursor.getString(cursor.getColumnIndex("description")));
        }
        cursor.close();

        return item;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/CryptoHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.helper;

import java.security.MessageDigest;

public class CryptoHelper {

    private final static String MD5 = "MD5";
    private final static String UTF8 = "UTF-8";

    private final static char[] hexArray = "0123456789abcdef".toCharArray();

    public static String getMD5String( String value ) {
        try {
            MessageDigest md = MessageDigest.getInstance( MD5 );
            md.update( value.getBytes( UTF8 ) );
            byte[] digest = md.digest();

            char[] hexChars = new char[ digest.length * 2 ];
            for ( int i = 0; i < digest.length; i++ ) {
                int v = digest[ i ] & 0xFF;
                hexChars[ i * 2 ] = hexArray[ v >>> 4 ];
                hexChars[ i * 2 + 1 ] = hexArray[ v & 0x0F ];
            }
            return new String( hexChars ).toUpperCase();
        } catch ( Exception e ) { throw new RuntimeException( e ); }
    }

    public static String getSHA1String( String value ) {
        try {
            MessageDigest md = MessageDigest.getInstance( "SHA-1" );
            md.update( value.getBytes( UTF8 ) );
            byte[] digest = md.digest();

            char[] hexChars = new char[ digest.length * 2 ];
            for ( int i = 0; i < digest.length; i++ ) {
                int v = digest[ i ] & 0xFF;
                hexChars[ i * 2 ] = hexArray[ v >>> 4 ];
                hexChars[ i * 2 + 1 ] = hexArray[ v & 0x0F ];
            }
            return new String( hexChars ).toUpperCase();
        } catch ( Exception e ) { throw new RuntimeException( e ); }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Action.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Action {
    private String action;
    private String categories;
    private String packageId;
    private String activity;
    private String schemes;
    private String hosts;
    private String mimeTypes;

    public Action() {}

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public String getCategories() {
        return categories;
    }

    public void setCategories(String categories) {
        this.categories = categories;
    }

    public String getPackageId() {
        return packageId;
    }

    public void setPackageId(String packageId) {
        this.packageId = packageId;
    }

    public String getActivity() {
        return activity;
    }

    public void setActivity(String activity) {
        this.activity = activity;
    }

    public String getSchemes() {
        return schemes;
    }

    public void setSchemes(String schemes) {
        this.schemes = schemes;
    }

    public String getHosts() {
        return hosts;
    }

    public void setHosts(String hosts) {
        this.hosts = hosts;
    }

    public String getMimeTypes() {
        return mimeTypes;
    }

    public void setMimeTypes(String mimeTypes) {
        this.mimeTypes = mimeTypes;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceCreateOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DeviceCreateOptions {
    private String customer;
    private String configuration;
    private List<String> groups;

    public DeviceCreateOptions() {}

    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }

    public String getConfiguration() {
        return configuration;
    }

    public void setConfiguration(String configuration) {
        this.configuration = configuration;
    }

    public List<String> getGroups() {
        return groups;
    }

    public void setGroups(List<String> groups) {
        this.groups = groups;
    }

    public void setGroups(String[] groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(Set<String> groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(String groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        String[] groupArray = groups.split(",");
        setGroups(groupArray);
    }

    public Set<String> getGroupSet() {
        if (groups == null) {
            return null;
        }
        Set<String> result = new HashSet<>();
        for (String group : groups) {
            result.add(group);
        }
        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceEnrollOptions.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DeviceEnrollOptions {
    private String customer;
    private String configuration;
    private List<String> groups;

    public DeviceEnrollOptions() {}

    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }

    public String getConfiguration() {
        return configuration;
    }

    public void setConfiguration(String configuration) {
        this.configuration = configuration;
    }

    public List<String> getGroups() {
        return groups;
    }

    public void setGroups(List<String> groups) {
        this.groups = groups;
    }

    public void setGroups(String[] groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(Set<String> groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        this.groups = new LinkedList<>();
        for (String group : groups) {
            this.groups.add(group);
        }
    }

    public void setGroups(String groups) {
        if (groups == null) {
            this.groups = null;
            return;
        }
        String[] groupArray = groups.split(",");
        setGroups(groupArray);
    }

    public Set<String> getGroupSet() {
        if (groups == null) {
            return null;
        }
        Set<String> result = new HashSet<>();
        for (String group : groups) {
            result.add(group);
        }
        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Download.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import android.annotation.SuppressLint;
import android.database.Cursor;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Download {
    @JsonIgnore
    private long _id;

    private String url;
    private String path;
    private long attempts;
    private long lastAttemptTime;
    private boolean downloaded;
    private boolean installed;

    public Download() {}

    public Download(Download download) {
        _id = download._id;
        url = download.url;
        path = download.path;
        attempts = download.attempts;
        lastAttemptTime = download.lastAttemptTime;
        downloaded = download.downloaded;
        installed = download.installed;
    }

    @SuppressLint("Range")
    public Download(Cursor cursor) {
        setId(cursor.getLong(cursor.getColumnIndex("_id")));
        setUrl(cursor.getString(cursor.getColumnIndex("url")));
        setPath(cursor.getString(cursor.getColumnIndex("path")));
        setAttempts(cursor.getLong(cursor.getColumnIndex("attempts")));
        setLastAttemptTime(cursor.getLong(cursor.getColumnIndex("lastAttemptTime")));
        setDownloaded(cursor.getInt(cursor.getColumnIndex("downloaded")) != 0);
        setInstalled(cursor.getInt(cursor.getColumnIndex("installed")) != 0);
    }

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public long getAttempts() {
        return attempts;
    }

    public void setAttempts(long attempts) {
        this.attempts = attempts;
    }

    public long getLastAttemptTime() {
        return lastAttemptTime;
    }

    public void setLastAttemptTime(long lastAttemptTime) {
        this.lastAttemptTime = lastAttemptTime;
    }

    public boolean isDownloaded() {
        return downloaded;
    }

    public void setDownloaded(boolean downloaded) {
        this.downloaded = downloaded;
    }

    public boolean isInstalled() {
        return installed;
    }

    public void setInstalled(boolean installed) {
        this.installed = installed;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/service/CheckForegroundAppAccessibilityService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro.service;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

/**
 * In open-source version, the service checking foreground apps is just a stub;
 * this option is available in Pro-version only
 */
public class CheckForegroundAppAccessibilityService extends Service {
    @Override
    public IBinder onBind(Intent intent) {
        // Stub
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerUrl.java">
package com.hmdm.launcher.server;

import java.net.MalformedURLException;
import java.net.URL;

public class ServerUrl {
    public String baseUrl;
    public String serverProject;

    public ServerUrl(String serverUrl) throws MalformedURLException {
        URL url;
         url = new URL(serverUrl);

        baseUrl = url.getProtocol() + "://" + url.getHost();
        if (url.getPort() != -1) {
            baseUrl += ":" + url.getPort();
        }
        serverProject = url.getPath();
        if (serverProject.endsWith("/")) {
            serverProject = serverProject.substring(0, serverProject.length() - 1);
        }
        if (serverProject.startsWith("/")) {
            serverProject = serverProject.substring(1);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/UnsafeOkHttpClient.java">
package com.hmdm.launcher.server;

import com.hmdm.launcher.Const;

import java.security.cert.CertificateException;
import java.util.concurrent.TimeUnit;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import okhttp3.OkHttpClient;

public class UnsafeOkHttpClient {
    public static OkHttpClient getUnsafeOkHttpClient() {
        try {
            // Create a trust manager that does not validate certificate chains
            final TrustManager[] trustAllCerts = new TrustManager[] {
                    new X509TrustManager() {
                        @Override
                        public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException {
                        }

                        @Override
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return new java.security.cert.X509Certificate[]{};
                        }
                    }
            };

            // Install the all-trusting trust manager
            final SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());

            // Create an ssl socket factory with our all-trusting manager
            final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();

            OkHttpClient.Builder builder = new OkHttpClient.Builder().
                    connectTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS ).
                    readTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS ).
                    writeTimeout( Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS );
            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager)trustAllCerts[0]);
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            });

            OkHttpClient okHttpClient = builder.build();
            return okHttpClient;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/ConfirmPasswordResetTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class ConfirmPasswordResetTask extends AsyncTask< DeviceInfo, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    public ConfirmPasswordResetTask(Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    @Override
    protected Integer doInBackground( DeviceInfo... info ) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response< ResponseBody > response = null;

        try {
            response = serverService.confirmPasswordReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.confirmPasswordReset(settingsHelper.getServerProject(), info[0].getDeviceId(), info[0]).execute();
            }
            if ( response.isSuccessful() ) {
                return Const.TASK_SUCCESS;
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Const.TASK_ERROR;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/BatteryStateView.java">
package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.Nullable;

import com.hmdm.launcher.R;

public class BatteryStateView extends LinearLayout {
    private Context context;
    private TextView percentView;
    private ImageView pluggedView;
    private ImageView batteryView;
    private boolean darkBackground = true;
    private int chargePercent = 100;
    private boolean plugged = false;

    private int[] lightImages = {
            R.drawable.ic_battery_1_red,
            R.drawable.ic_battery_2_white,
            R.drawable.ic_battery_3_white,
            R.drawable.ic_battery_4_white,
            R.drawable.ic_battery_5_white,
            R.drawable.ic_battery_6_white
    };

    private int[] darkImages = {
            R.drawable.ic_battery_1_red,
            R.drawable.ic_battery_2_black,
            R.drawable.ic_battery_3_black,
            R.drawable.ic_battery_4_black,
            R.drawable.ic_battery_5_black,
            R.drawable.ic_battery_6_black
    };

    public BatteryStateView(Context context) {
        super(context);
        init(context);
    }

    public BatteryStateView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public BatteryStateView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context);
    }

    private void init(Context context) {
        this.context = context;

        setOrientation(HORIZONTAL);
        setGravity(Gravity.RIGHT | Gravity.CENTER_VERTICAL);

        percentView = new TextView(context);
        pluggedView = new ImageView(context);
        batteryView = new ImageView(context);

        LayoutParams textParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
        LayoutParams imageParams = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);

        percentView.setLayoutParams(textParams);
        pluggedView.setLayoutParams(imageParams);
        batteryView.setLayoutParams(imageParams);

        addView(percentView);
        addView(pluggedView);
        addView(batteryView);

        pluggedView.setVisibility(View.GONE);
    }

    public void setDarkBackground(boolean darkBackground) {
        if (this.darkBackground != darkBackground) {
            this.darkBackground = darkBackground;
            updateControls();
        }
    }

    public void setChargePercent(int chargePercent) {
        if (this.chargePercent != chargePercent) {
            this.chargePercent = chargePercent;
            updateControls();
        }
    }

    public void setPlugged(boolean plugged) {
        if (this.plugged != plugged) {
            this.plugged = plugged;
            updateControls();
        }
    }

    private void updateControls() {
        percentView.setTextColor(context.getResources().getColor(darkBackground ? R.color.statusBarLight : R.color.statusBarDark));
        percentView.setText(chargePercent + "%");
        int imageIndex = chargePercent / 18;
        batteryView.setImageResource(darkBackground ? lightImages[imageIndex] : darkImages[imageIndex]);
        pluggedView.setImageResource(darkBackground ? R.drawable.ic_charger_white : R.drawable.ic_charger_black);
        if (plugged) {
            percentView.setVisibility(View.GONE);
            pluggedView.setVisibility(View.VISIBLE);
        } else {
            percentView.setVisibility(View.VISIBLE);
            pluggedView.setVisibility(View.GONE);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/custom/StatusBarUpdater.java">
package com.hmdm.launcher.ui.custom;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Handler;
import android.view.View;
import android.widget.TextView;

import com.hmdm.launcher.R;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

public class StatusBarUpdater {
    private Context context;
    private TextView clockView;
    private BatteryStateView batteryStateView;
    private final Handler handler = new Handler();
    private final SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm", Locale.getDefault());
    private boolean visible = false;

    private final Runnable updateRunnable = new Runnable() {
        @Override
        public void run() {
            if (visible) {
                updateStatusBar();
            }
            handler.postDelayed(this, 5000);
        }
    };

    private void updateStatusBar() {
        String currentTime = timeFormat.format(new Date());
        clockView.setText(currentTime);

        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);

        Intent batteryStatus = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                context.registerReceiver(null, ifilter, Context.RECEIVER_EXPORTED) :
                context.registerReceiver(null, ifilter);
        int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL) {
            int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            batteryStateView.setPlugged(chargePlug == BatteryManager.BATTERY_PLUGGED_USB ||
                chargePlug == BatteryManager.BATTERY_PLUGGED_AC);
        } else {
            batteryStateView.setPlugged(false);
        }

        int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
        int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        batteryStateView.setChargePercent(level * 100 / scale);
    }

    public void startUpdating(Context context, TextView clockView, BatteryStateView batteryStateView) {
        this.context = context;
        this.clockView = clockView;
        this.batteryStateView = batteryStateView;
        handler.post(updateRunnable);
    }

    public void stopUpdating() {
        handler.removeCallbacks(updateRunnable);
    }

    public void updateControlsState(boolean visible, boolean darkBackground) {
        this.visible = visible;
        if (clockView != null) {
            clockView.setVisibility(visible ? View.VISIBLE : View.GONE);
            clockView.setTextColor(context.getResources().getColor(darkBackground ? R.color.statusBarLight : R.color.statusBarDark));
        }
        if (batteryStateView != null) {
            batteryStateView.setVisibility(visible ? View.VISIBLE : View.GONE);
            batteryStateView.setDarkBackground(darkBackground);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/ConnectionWaiter.java">
package com.hmdm.launcher.util;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import com.hmdm.launcher.Const;

public class ConnectionWaiter {
    private static Handler handler = new Handler(Looper.getMainLooper());

    public static boolean waitForConnect(Context context, Runnable uiCallback) {
        for (int n = 0; n < 10; n++) {
            if (isNetworkAvailable(context)) {
                if (n > 0) {
                    try {
                        Thread.sleep(2000);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                Log.d(Const.LOG_TAG, "Network is available, resuming flow");
                handler.post(uiCallback);
                return true;
            }
            Log.d(Const.LOG_TAG, "Network is unavailable, waiting, attempts: " + (9 - n));
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        Log.d(Const.LOG_TAG, "Proceed without network!");
        handler.post(uiCallback);
        return false;
    }

    public static boolean isNetworkAvailable(Context context) {
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        if (cm == null) {
            return false;
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Network network = cm.getActiveNetwork();
            if (network == null) return false;

            NetworkCapabilities capabilities = cm.getNetworkCapabilities(network);
            return capabilities != null &&
                    (capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ||
                            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ||
                            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_ETHERNET));
        } else {
            android.net.NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
            return activeNetwork != null && activeNetwork.isConnected();
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/CrashLoopProtection.java">
package com.hmdm.launcher.util;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Log;

import com.hmdm.launcher.Const;

public class CrashLoopProtection {
    // Crash loop protection
    // We consider it to be an unrecoverable fault if Headwind MDM crashes 5 times or more within a minute
    private static final long LOOP_TIME_SPAN = 60000;
    private static final long LOOP_CRASHES = 3;
    private static final String FAULT_PREFERENCE_NAME = "com.hmdm.launcher.fault";
    private static final String LAST_FAULT_TIME_PREFERENCE = "last_fault_time";
    private static final String FAULT_COUNTER_PREFERENCE = "fault_counter";

    // Register crash
    public static void registerFault(Context context) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(FAULT_PREFERENCE_NAME, Context.MODE_PRIVATE);
        long faultTime = System.currentTimeMillis();
        long lastFaultTime = preferences.getLong(LAST_FAULT_TIME_PREFERENCE, 0);
        if (faultTime - lastFaultTime > LOOP_TIME_SPAN) {
            Log.i(Const.LOG_TAG, "Crash registered once");
            preferences.edit()
                    .putInt(FAULT_COUNTER_PREFERENCE, 1)
                    .putLong(LAST_FAULT_TIME_PREFERENCE, faultTime)
                    .commit();
            return;
        }
        int crashCounter = preferences.getInt(FAULT_COUNTER_PREFERENCE, 0);
        crashCounter++;

        Log.i(Const.LOG_TAG, "Crash registered " + crashCounter + " times within " + LOOP_TIME_SPAN + " ms");
        preferences.edit().putInt(FAULT_COUNTER_PREFERENCE, crashCounter).commit();
    }

    // Protection against looping
    // Returns false if loop is detected
    public static boolean isCrashLoopDetected(Context context) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(FAULT_PREFERENCE_NAME, Context.MODE_PRIVATE);
        long faultTime = System.currentTimeMillis();
        long lastFaultTime = preferences.getLong(LAST_FAULT_TIME_PREFERENCE, 0);
        if (lastFaultTime == 0) {
            return false;
        }
        if (faultTime - lastFaultTime > LOOP_TIME_SPAN) {
            Log.i(Const.LOG_TAG, "No recent crashes registered");
            preferences.edit()
                    .putInt(FAULT_COUNTER_PREFERENCE, 0)
                    .putLong(LAST_FAULT_TIME_PREFERENCE, 0)
                    .commit();
            return false;
        }
        int crashCounter = preferences.getInt(FAULT_COUNTER_PREFERENCE, 0);
        if (crashCounter > LOOP_CRASHES) {
            Log.i(Const.LOG_TAG, "Crash loop detected!");
            return true;
        }
        return false;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/PreferenceLogger.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.SharedPreferences;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.text.SimpleDateFormat;
import java.util.Date;

public class PreferenceLogger {

    private static boolean DEBUG = BuildConfig.DEVICE_ADMIN_DEBUG;

    private static SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    private static void _log(SharedPreferences preferences, String message) {
        Log.d(Const.LOG_TAG, message);
        if (DEBUG) {
            String logString = preferences.getString(Const.PREFERENCES_LOG_STRING, "");
            logString += sdf.format(new Date()) + " " + message;
            logString += "\n";
            preferences.edit().putString(Const.PREFERENCES_LOG_STRING, logString).commit();
        }
    }

    public synchronized static void log(SharedPreferences preferences, String message) {
        _log(preferences, message);
    }

    public synchronized static String getLogString(SharedPreferences preferences) {
        if (DEBUG) {
            return preferences.getString(Const.PREFERENCES_LOG_STRING, "");
        }
        return "";
    }

    public synchronized static void clearLogString(SharedPreferences preferences) {
        if (DEBUG) {
            preferences.edit().putString(Const.PREFERENCES_LOG_STRING, "").commit();
        }
    }

    public synchronized static void printStackTrace(SharedPreferences preferences, Exception e) {
        StringWriter errors = new StringWriter();
        e.printStackTrace(new PrintWriter(errors));
        _log(preferences, errors.toString());
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/RemoteLogger.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.LogConfigTable;
import com.hmdm.launcher.db.LogTable;
import com.hmdm.launcher.json.RemoteLogConfig;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.worker.RemoteLogWorker;

import java.util.List;

/**
 * Remote logging engine which uses SQLite for configuration
 * and storing unsent logs
 */
public class RemoteLogger {
    public static long lastLogRemoval = 0;

    public static void updateConfig(Context context, List<RemoteLogConfig> rules) {
        LogConfigTable.replaceAll(DatabaseHelper.instance(context).getWritableDatabase(), rules);
    }

    public static void log(Context context, int level, String message) {
        switch (level) {
            case Const.LOG_VERBOSE:
                Log.v(Const.LOG_TAG, message);
                break;
            case Const.LOG_DEBUG:
                Log.d(Const.LOG_TAG, message);
                break;
            case Const.LOG_INFO:
                Log.i(Const.LOG_TAG, message);
                break;
            case Const.LOG_WARN:
                Log.w(Const.LOG_TAG, message);
                break;
            case Const.LOG_ERROR:
                Log.e(Const.LOG_TAG, message);
                break;
        }

        RemoteLogItem item = new RemoteLogItem();
        item.setTimestamp(System.currentTimeMillis());
        item.setLogLevel(level);
        item.setPackageId(context.getPackageName());
        item.setMessage(message);
        postLog(context, item);
    }

    public static void postLog(Context context, RemoteLogItem item) {
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        SQLiteDatabase db = dbHelper.getReadableDatabase();
        if (LogConfigTable.match(db, item)) {
            db = dbHelper.getWritableDatabase();
            LogTable.insert(db, item);
            sendLogsToServer(context);
        }

        // Remove old logs once per hour
        long now = System.currentTimeMillis();
        if (now > lastLogRemoval + 3600000L) {
            db = dbHelper.getWritableDatabase();
            LogTable.deleteOldItems(db);
            lastLogRemoval = now;
        }
    }

    public static void resetState() {
        RemoteLogWorker.resetState();
    }

    public static void sendLogsToServer(Context context) {
        RemoteLogWorker.scheduleUpload(context);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/RemoteLogWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.LogTable;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;

import java.util.List;
import java.util.concurrent.TimeUnit;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class RemoteLogWorker extends Worker {

    // Amount of log messages sent to server at once
    public static final int MAX_UPLOADED_MESSAGES = 10;

    // Logs are sent once per minute to reduce the server load
    public static final int FIRE_PERIOD_MINS = 1;

    // If there's no Internet, retry in 15 minutes
    public static final int FIRE_PERIOD_RETRY_MINS = 15;

    private static final String WORK_TAG_REMOTE_LOG = "com.hmdm.launcher.WORK_TAG_REMOTE_LOG";

    private static boolean uploadScheduled = false;

    private Context context;
    private SettingsHelper settingsHelper;

    public static void resetState() {
        uploadScheduled = false;
    }

    public static void scheduleUpload(Context context) {
        scheduleUpload(context, 0);
    }

    public static void scheduleUpload(Context context, int delayMins) {
        Log.i(Const.LOG_TAG, "RemoteLogWorker scheduled");
        OneTimeWorkRequest.Builder builder = new OneTimeWorkRequest.Builder(RemoteLogWorker.class);
        builder.addTag(Const.WORK_TAG_COMMON);
        if (delayMins > 0) {
            builder.setInitialDelay(delayMins, TimeUnit.MINUTES);
        }
        OneTimeWorkRequest uploadWorkRequest = builder.build();
        if (!uploadScheduled) {
            uploadScheduled = true;
            WorkManager.getInstance(context).enqueueUniqueWork(WORK_TAG_REMOTE_LOG, ExistingWorkPolicy.REPLACE, uploadWorkRequest);
        }
    }

    public RemoteLogWorker(
            @NonNull Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        try {
            DatabaseHelper dbHelper = DatabaseHelper.instance(context);

            while (true) {
                List<RemoteLogItem> unsentItems = LogTable.select(dbHelper.getReadableDatabase(), MAX_UPLOADED_MESSAGES);
                Log.i(Const.LOG_TAG, "Remote logger: unsent items: " + unsentItems.size());
                if (unsentItems.size() == 0) {
                    uploadScheduled = false;
                    return Result.success();
                }
                if (!upload(unsentItems)) {
                    // There was an error: retry!
                    // XXX: we do not use Result.retry() here because new logs may come
                    Log.i(Const.LOG_TAG, "Failed to upload logs: retry in " + FIRE_PERIOD_RETRY_MINS + " mins");
                    uploadScheduled = false;
                    scheduleUpload(context, FIRE_PERIOD_RETRY_MINS);
                    return Result.failure();
                } else {
                    Log.i(Const.LOG_TAG, "Logs are uploaded");
                    // Mark items as sent and query next items
                    LogTable.delete(DatabaseHelper.instance(context).getWritableDatabase(), unsentItems);
                }
            }
        } catch (Exception e) {
            // Oops... WTF? We need to retry!
            e.printStackTrace();
            uploadScheduled = false;
            scheduleUpload(context, FIRE_PERIOD_MINS);
            return Result.failure();
        }
    }

    // Returns true on success and false on failure
    public boolean upload(List<RemoteLogItem> logItems) {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<ResponseBody> response = null;

        try {
            response = serverService.sendLogs(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), logItems).execute();
            return response.isSuccessful();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        sendLogs(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), logItems).execute();
                return response.isSuccessful();
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        return false;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/ScheduledAppUpdateWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.util.RemoteLogger;

import java.util.concurrent.TimeUnit;

public class ScheduledAppUpdateWorker extends Worker {

    // Minimal interval is 15 minutes as per docs
    public static final int FIRE_PERIOD_MINS = 15;

    private static final String WORK_TAG_SCHEDULED_UPDATES = "com.hmdm.launcher.WORK_TAG_SCHEDULED_UPDATES";

    public static void schedule(Context context) {
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (settingsHelper.getConfig() != null) {
            settingsHelper.setLastAppUpdateState(ConfigUpdater.checkAppUpdateTimeRestriction(settingsHelper.getConfig()));
        }
        Log.d(Const.LOG_TAG, "Scheduled app updates worker runs each " + FIRE_PERIOD_MINS + " mins");
        PeriodicWorkRequest queryRequest =
                new PeriodicWorkRequest.Builder(ScheduledAppUpdateWorker.class, FIRE_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_SCHEDULED_UPDATES,
                ExistingPeriodicWorkPolicy.REPLACE, queryRequest);
    }

    private Context context;
    private SettingsHelper settingsHelper;

    public ScheduledAppUpdateWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper.getConfig() == null) {
            Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: config=null");
            return Result.failure();
        }
        if (settingsHelper.getConfig().getAppUpdateFrom() == null || settingsHelper.getConfig().getAppUpdateTo() == null) {
            // No need to do anything
            Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: scheduled app update not set");
            return Result.success();
        }

        boolean lastAppUpdateState = settingsHelper.getLastAppUpdateState();
        boolean canUpdateAppsNow = ConfigUpdater.checkAppUpdateTimeRestriction(settingsHelper.getConfig());
        Log.d(Const.LOG_TAG, "ScheduledAppUpdateWorker: lastAppUpdateState=" + lastAppUpdateState + ", canUpdateAppsNow=" + canUpdateAppsNow);
        if (lastAppUpdateState == canUpdateAppsNow) {
            // App update state not changed
            return Result.success();
        }

        if (!lastAppUpdateState && canUpdateAppsNow) {
            // Need to update apps now
            RemoteLogger.log(context, Const.LOG_DEBUG, "Running scheduled app update");
            settingsHelper.setConfigUpdateTimestamp(System.currentTimeMillis());
            ConfigUpdater.forceConfigUpdate(context);
        }
        settingsHelper.setLastAppUpdateState(canUpdateAppsNow);
        return Result.success();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/SendDeviceInfoWorker.java">
package com.hmdm.launcher.worker;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.DeviceInfoProvider;

import java.util.concurrent.TimeUnit;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class SendDeviceInfoWorker extends Worker {

    private static final int SEND_DEVICE_INFO_PERIOD_MINS = 15;

    private static final String WORK_TAG_DEVICEINFO = "com.hmdm.launcher.WORK_TAG_DEVICEINFO";

    private Context context;
    private SettingsHelper settingsHelper;

    public SendDeviceInfoWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper == null || settingsHelper.getConfig() == null) {
            return Result.failure();
        }

        DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);

        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<ResponseBody> response = null;

        try {
            response = serverService.sendDevice(settingsHelper.getServerProject(), deviceInfo).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.sendDevice(settingsHelper.getServerProject(), deviceInfo).execute();
            }
            if ( response.isSuccessful() ) {
                SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
                return Result.success();
            }
        }
        catch ( Exception e ) { e.printStackTrace(); }

        return Result.failure();
    }

    public static void scheduleDeviceInfoSending(Context context) {
        PeriodicWorkRequest request =
                new PeriodicWorkRequest.Builder(SendDeviceInfoWorker.class, SEND_DEVICE_INFO_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(SEND_DEVICE_INFO_PERIOD_MINS, TimeUnit.MINUTES)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_DEVICEINFO, ExistingPeriodicWorkPolicy.REPLACE, request);
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/DatabaseMessageStore.java">
/*******************************************************************************
 * Copyright (c) 1999, 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 *   Contributors:
 *     James Sutton - Removing SQL Injection vunerability (bug 467378)
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

import org.eclipse.paho.client.mqttv3.MqttMessage;

import java.util.Iterator;

/**
 * Implementation of the {@link MessageStore} interface, using a SQLite database
 * 
 */
class DatabaseMessageStore implements MessageStore {

	// TAG used for indentify trace data etc.
	private static final String TAG = "DatabaseMessageStore";

	// One "private" database column name
	// The other database column names are defined in MqttServiceConstants
	private static final String MTIMESTAMP = "mtimestamp";

	// the name of the table in the database to which we will save messages
	private static final String ARRIVED_MESSAGE_TABLE_NAME = "MqttArrivedMessageTable";

	// the database
	private SQLiteDatabase db = null;

	// a SQLiteOpenHelper specific for this database
	private MQTTDatabaseHelper mqttDb = null;

	// a place to send trace data
	private MqttTraceHandler traceHandler = null;

	/**
	 * We need a SQLiteOpenHelper to handle database creation and updating
	 * 
	 */
	private static class MQTTDatabaseHelper extends SQLiteOpenHelper {
		// TAG used for indentify trace data etc.
		private static final String TAG = "MQTTDatabaseHelper";

		private static final String DATABASE_NAME = "mqttAndroidService.db";

		// database version, used to recognise when we need to upgrade
		// (delete and recreate)
		private static final int DATABASE_VERSION = 1;

		// a place to send trace data
		private MqttTraceHandler traceHandler = null;

		/**
		 * Constructor.
		 * 
		 * @param traceHandler
		 * @param context
		 */
		public MQTTDatabaseHelper(MqttTraceHandler traceHandler, Context context) {
			super(context, DATABASE_NAME, null, DATABASE_VERSION);
			this.traceHandler = traceHandler;
		}

		/**
		 * When the database is (re)created, create our table
		 * 
		 * @param database
		 */
		@Override
		public void onCreate(SQLiteDatabase database) {
			String createArrivedTableStatement = "CREATE TABLE "
					+ ARRIVED_MESSAGE_TABLE_NAME + "("
					+ MqttServiceConstants.MESSAGE_ID + " TEXT PRIMARY KEY, "
					+ MqttServiceConstants.CLIENT_HANDLE + " TEXT, "
					+ MqttServiceConstants.DESTINATION_NAME + " TEXT, "
					+ MqttServiceConstants.PAYLOAD + " BLOB, "
					+ MqttServiceConstants.QOS + " INTEGER, "
					+ MqttServiceConstants.RETAINED + " TEXT, "
					+ MqttServiceConstants.DUPLICATE + " TEXT, " + MTIMESTAMP
					+ " INTEGER" + ");";
			traceHandler.traceDebug(TAG, "onCreate {"
					+ createArrivedTableStatement + "}");
			try {
				database.execSQL(createArrivedTableStatement);
				traceHandler.traceDebug(TAG, "created the table");
			} catch (SQLException e) {
				traceHandler.traceException(TAG, "onCreate", e);
				throw e;
			}
		}

		/**
		 * To upgrade the database, drop and recreate our table
		 * 
		 * @param db
		 *            the database
		 * @param oldVersion
		 *            ignored
		 * @param newVersion
		 *            ignored
		 */

		@Override
		public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
			traceHandler.traceDebug(TAG, "onUpgrade");
			try {
				db.execSQL("DROP TABLE IF EXISTS " + ARRIVED_MESSAGE_TABLE_NAME);
			} catch (SQLException e) {
				traceHandler.traceException(TAG, "onUpgrade", e);
				throw e;
			}
			onCreate(db);
			traceHandler.traceDebug(TAG, "onUpgrade complete");
		}
	}

	/**
	 * Constructor - create a DatabaseMessageStore to store arrived MQTT message
	 * 
	 * @param service
	 *            our parent MqttService
	 * @param context
	 *            a context to use for android calls
	 */
	public DatabaseMessageStore(MqttService service, Context context) {
		this.traceHandler = service;

		// Open message database
		mqttDb = new MQTTDatabaseHelper(traceHandler, context);

		// Android documentation suggests that this perhaps
		// could/should be done in another thread, but as the
		// database is only one table, I doubt it matters...
		
		traceHandler.traceDebug(TAG, "DatabaseMessageStore<init> complete");
	}

	/**
	 * Store an MQTT message
	 * 
	 * @param clientHandle
	 *            identifier for the client storing the message
	 * @param topic
	 *            The topic on which the message was published
	 * @param message
	 *            the arrived MQTT message
	 * @return an identifier for the message, so that it can be removed when appropriate
	 */
	@Override
	public String storeArrived(String clientHandle, String topic,
			MqttMessage message) {
		
		db = mqttDb.getWritableDatabase();
		
		traceHandler.traceDebug(TAG, "storeArrived{" + clientHandle + "}, {"
				+ message.toString() + "}");

		byte[] payload = message.getPayload();
		int qos = message.getQos();
		boolean retained = message.isRetained();
		boolean duplicate = message.isDuplicate();

		ContentValues values = new ContentValues();
		String id = java.util.UUID.randomUUID().toString();
		values.put(MqttServiceConstants.MESSAGE_ID, id);
		values.put(MqttServiceConstants.CLIENT_HANDLE, clientHandle);
		values.put(MqttServiceConstants.DESTINATION_NAME, topic);
		values.put(MqttServiceConstants.PAYLOAD, payload);
		values.put(MqttServiceConstants.QOS, qos);
		values.put(MqttServiceConstants.RETAINED, retained);
		values.put(MqttServiceConstants.DUPLICATE, duplicate);
		values.put(MTIMESTAMP, System.currentTimeMillis());
		try {
			db.insertOrThrow(ARRIVED_MESSAGE_TABLE_NAME, null, values);
		} catch (SQLException e) {
			traceHandler.traceException(TAG, "onUpgrade", e);
			throw e;
		}
		int count = getArrivedRowCount(clientHandle);
		traceHandler
				.traceDebug(
						TAG,
						"storeArrived: inserted message with id of {"
								+ id
								+ "} - Number of messages in database for this clientHandle = "
								+ count);
		return id;
	}

	private int getArrivedRowCount(String clientHandle) {
        int count = 0;
        String[] projection = {
                MqttServiceConstants.MESSAGE_ID,
        };
  		String selection =  MqttServiceConstants.CLIENT_HANDLE + "=?";
        String[] selectionArgs = new String[1];
        selectionArgs[0] = clientHandle;
		Cursor c = db.query(
                ARRIVED_MESSAGE_TABLE_NAME, // Table Name
                projection, // The columns to return;
                selection, // Columns for WHERE Clause
                selectionArgs , // The values for the WHERE Cause
				null,  //Don't group the rows
                null,  // Don't filter by row groups
                null   // The sort order
        );

		if (c.moveToFirst()) {
			count = c.getInt(0);
		}
		c.close();
		return count;
	}

	/**
	 * Delete an MQTT message.
	 * 
	 * @param clientHandle
	 *            identifier for the client which stored the message
	 * @param id
	 *            the identifying string returned when the message was stored
	 * 
	 * @return true if the message was found and deleted
	 */
	@Override
	public boolean discardArrived(String clientHandle, String id) {
		
		db = mqttDb.getWritableDatabase();
		
		traceHandler.traceDebug(TAG, "discardArrived{" + clientHandle + "}, {"
				+ id + "}");
		int rows;
        String[] selectionArgs = new String[2];
        selectionArgs[0] = id;
        selectionArgs[1] = clientHandle;

		try {
			rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME,
					MqttServiceConstants.MESSAGE_ID + "=? AND "
							+ MqttServiceConstants.CLIENT_HANDLE + "=?",
                    selectionArgs);
		} catch (SQLException e) {
			traceHandler.traceException(TAG, "discardArrived", e);
			throw e;
		}
		if (rows != 1) {
			traceHandler.traceError(TAG,
					"discardArrived - Error deleting message {" + id
							+ "} from database: Rows affected = " + rows);
			return false;
		}
		int count = getArrivedRowCount(clientHandle);
		traceHandler
				.traceDebug(
						TAG,
						"discardArrived - Message deleted successfully. - messages in db for this clientHandle "
								+ count);
		return true;
	}

	/**
	 * Get an iterator over all messages stored (optionally for a specific client)
	 * 
	 * @param clientHandle
	 *            identifier for the client.<br>
	 *            If null, all messages are retrieved
	 * @return iterator of all the arrived MQTT messages
	 */
	@Override
	public Iterator<StoredMessage> getAllArrivedMessages(
			final String clientHandle) {
		return new Iterator<StoredMessage>() {
			private Cursor c;
			private boolean hasNext;
            private final String[] selectionArgs = {
                    clientHandle,
            };


			{
				db = mqttDb.getWritableDatabase();
				// anonymous initialiser to start a suitable query
				// and position at the first row, if one exists
				if (clientHandle == null) {
					c = db.query(ARRIVED_MESSAGE_TABLE_NAME,
                            null,
                            null,
                            null,
							null,
                            null,
                            "mtimestamp ASC");
				} else {
					c = db.query(ARRIVED_MESSAGE_TABLE_NAME,
                            null,
							MqttServiceConstants.CLIENT_HANDLE + "=?",
                            selectionArgs,
                            null,
                            null,
							"mtimestamp ASC");
				}
				hasNext = c.moveToFirst();
			}

			@Override
			public boolean hasNext() {
		        if (!hasNext){
		          	c.close();
				}
				return hasNext;
			}

			@Override
			@SuppressLint("Range")
			public StoredMessage next() {
				String messageId = c.getString(c
						.getColumnIndex(MqttServiceConstants.MESSAGE_ID));
				String clientHandle = c.getString(c
						.getColumnIndex(MqttServiceConstants.CLIENT_HANDLE));
				String topic = c.getString(c
						.getColumnIndex(MqttServiceConstants.DESTINATION_NAME));
				byte[] payload = c.getBlob(c
						.getColumnIndex(MqttServiceConstants.PAYLOAD));
				int qos = c.getInt(c.getColumnIndex(MqttServiceConstants.QOS));
				boolean retained = Boolean.parseBoolean(c.getString(c
						.getColumnIndex(MqttServiceConstants.RETAINED)));
				boolean dup = Boolean.parseBoolean(c.getString(c
						.getColumnIndex(MqttServiceConstants.DUPLICATE)));

				// build the result
				MqttMessageHack message = new MqttMessageHack(payload);
				message.setQos(qos);
				message.setRetained(retained);
				message.setDuplicate(dup);

				// move on
				hasNext = c.moveToNext();
				return new DbStoredData(messageId, clientHandle, topic, message);
			}

			@Override
			public void remove() {
				throw new UnsupportedOperationException();
			}

      /* (non-Javadoc)
       * @see java.lang.Object#finalize()
       */
      @Override
      protected void finalize() throws Throwable {
        c.close();
        super.finalize();
      }

    };
  }

	/**
	 * Delete all messages (optionally for a specific client)
	 * 
	 * @param clientHandle
	 *            identifier for the client.<br>
	 *            If null, all messages are deleted
	 */
	@Override
	public void clearArrivedMessages(String clientHandle) {
		
		db = mqttDb.getWritableDatabase();
        String[] selectionArgs = new String[1];
        selectionArgs[0] = clientHandle;
		
		int rows = 0;
		if (clientHandle == null) {
			traceHandler.traceDebug(TAG,
					"clearArrivedMessages: clearing the table");
			rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME, null, null);
		} else {
			traceHandler.traceDebug(TAG,
					"clearArrivedMessages: clearing the table of "
							+ clientHandle + " messages");
            rows = db.delete(ARRIVED_MESSAGE_TABLE_NAME,
                    MqttServiceConstants.CLIENT_HANDLE + "=?",
                    selectionArgs);

		}
		traceHandler.traceDebug(TAG, "clearArrivedMessages: rows affected = "
				+ rows);
	}

	private class DbStoredData implements StoredMessage {
		private String messageId;
		private String clientHandle;
		private String topic;
		private MqttMessage message;

		DbStoredData(String messageId, String clientHandle, String topic,
				MqttMessage message) {
			this.messageId = messageId;
			this.topic = topic;
			this.message = message;
		}

		@Override
		public String getMessageId() {
			return messageId;
		}

		@Override
		public String getClientHandle() {
			return clientHandle;
		}

		@Override
		public String getTopic() {
			return topic;
		}

		@Override
		public MqttMessage getMessage() {
			return message;
		}
	}

	/**
	 * A way to get at the "setDuplicate" method of MqttMessage
	 */
	private class MqttMessageHack extends MqttMessage {

		public MqttMessageHack(byte[] payload) {
			super(payload);
		}

		@Override
		protected void setDuplicate(boolean dup) {
			super.setDuplicate(dup);
		}
	}

	@Override
	public void close() {
		if (this.db!=null)
			this.db.close();
		
	}

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttConnection.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.app.Service;
import android.content.Context;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

import org.eclipse.paho.android.service.MessageStore.StoredMessage;
import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttAsyncClient;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.persist.MqttDefaultFilePersistence;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * <p>
 * MqttConnection holds a MqttAsyncClient {host,port,clientId} instance to perform 
 * MQTT operations to MQTT broker.
 * </p>
 * <p>
 * Most of the major API here is intended to implement the most general forms of
 * the methods in IMqttAsyncClient, with slight adjustments for the Android
 * environment<br>
 * These adjustments usually consist of adding two parameters to each method :-
 * <ul>
 * <li>invocationContext - a string passed from the application to identify the
 * context of the operation (mainly included for support of the javascript API
 * implementation)</li>
 * <li>activityToken - a string passed from the Activity to relate back to a
 * callback method or other context-specific data</li>
 * </ul>
 * </p>
 * <p>
 * Operations are very much asynchronous, so success and failure are notified by
 * packing the relevant data into Intent objects which are broadcast back to the
 * Activity via the MqttService.callbackToActivity() method.
 * </p>
 */
class MqttConnection implements MqttCallbackExtended {

	// Strings for Intents etc..
	private static final String TAG = "MqttConnection";
	// Error status messages
	private static final String NOT_CONNECTED = "not connected";

	// fields for the connection definition
	private String serverURI;
	public String getServerURI() {
		return serverURI;
	}

	public void setServerURI(String serverURI) {
		this.serverURI = serverURI;
	}

	public String getClientId() {
		return clientId;
	}

	public void setClientId(String clientId) {
		this.clientId = clientId;
	}

	private String clientId;
	private MqttClientPersistence persistence = null;
	private MqttConnectOptions connectOptions;

	public MqttConnectOptions getConnectOptions() {
		return connectOptions;
	}

	public void setConnectOptions(MqttConnectOptions connectOptions) {
		this.connectOptions = connectOptions;
	}

	// Client handle, used for callbacks...
	private String clientHandle;

	public String getClientHandle() {
		return clientHandle;
	}

	public void setClientHandle(String clientHandle) {
		this.clientHandle = clientHandle;
	}

	//store connect ActivityToken for reconnect
	private String reconnectActivityToken = null;

	// our client object - instantiated on connect
	private MqttAsyncClient myClient = null;

	private MqttPingSender pingSender = null;

	// our (parent) service object
	private MqttService service = null;

	private IMqttMessageListener defaultMessageListener = null;

	private volatile boolean disconnected = true;
	private boolean cleanSession = true;

	// Indicate this connection is connecting or not.
	// This variable uses to avoid reconnect multiple times.
	private volatile boolean isConnecting = false;

	// Saved sent messages and their corresponding Topics, activityTokens and
	// invocationContexts, so we can handle "deliveryComplete" callbacks
	// from the mqttClient
	private Map<IMqttDeliveryToken, String /* Topic */> savedTopics = new HashMap<>();
	private Map<IMqttDeliveryToken, MqttMessage> savedSentMessages = new HashMap<>();
	private Map<IMqttDeliveryToken, String> savedActivityTokens = new HashMap<>();
	private Map<IMqttDeliveryToken, String> savedInvocationContexts = new HashMap<>();

	private WakeLock wakelock = null;
	private String wakeLockTag = null;

	private DisconnectedBufferOptions bufferOpts = null;

	/**
	 * Constructor - create an MqttConnection to communicate with MQTT server
	 * 
	 * @param service
	 *            our "parent" service - we make callbacks to it
	 * @param serverURI
	 *            the URI of the MQTT server to which we will connect
	 * @param clientId
	 *            the name by which we will identify ourselves to the MQTT
	 *            server
	 * @param persistence
	 *            the persistence class to use to store in-flight message. If
	 *            null then the default persistence mechanism is used
	 * @param clientHandle
	 *            the "handle" by which the activity will identify us
	 */
	MqttConnection(MqttService service, String serverURI, String clientId,
			MqttClientPersistence persistence, String clientHandle, IMqttMessageListener defaultMessageListener) {
		this.serverURI = serverURI;
		this.service = service;
		this.clientId = clientId;
		this.persistence = persistence;
		this.clientHandle = clientHandle;
		this.defaultMessageListener = defaultMessageListener;

		StringBuilder stringBuilder = new StringBuilder(this.getClass().getCanonicalName());
		stringBuilder.append(" ");
		stringBuilder.append(clientId);
		stringBuilder.append(" ");
		stringBuilder.append("on host ");
		stringBuilder.append(serverURI);
		wakeLockTag = stringBuilder.toString();
	}

	// The major API implementation follows
	/**
	 * Connect to the server specified when we were instantiated
	 * 
	 * @param options
	 *            timeout, etc
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void connect(MqttConnectOptions options, String invocationContext,
			String activityToken) {
		
		connectOptions = options;
		reconnectActivityToken = activityToken;

		if (options != null) {
			cleanSession = options.isCleanSession();
		}

		if (connectOptions.isCleanSession()) { // if it's a clean session,
			// discard old data
			service.messageStore.clearArrivedMessages(clientHandle);
		}

		service.traceDebug(TAG, "Connecting {" + serverURI + "} as {" + clientId + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_ACTION);
		
				
		try {
			if (persistence == null) {
				// ask Android where we can put files
				File myDir = service.getExternalFilesDir(TAG);

				if (myDir == null) {
					// No external storage, use internal storage instead.
					myDir = service.getDir(TAG, Context.MODE_PRIVATE);
					
					if(myDir == null){
						//Shouldn't happen.
						resultBundle.putString(
								MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
								"Error! No external and internal storage available");
						resultBundle.putSerializable(
								MqttServiceConstants.CALLBACK_EXCEPTION, new MqttPersistenceException());
						service.callbackToActivity(clientHandle, Status.ERROR,
								resultBundle);
						return;
					}
				}

				// use that to setup MQTT client persistence storage
				persistence = new MqttDefaultFilePersistence(
						myDir.getAbsolutePath());
			}
			
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle) {

				@Override
				public void onSuccess(IMqttToken asyncActionToken) {
					doAfterConnectSuccess(resultBundle);
					service.traceDebug(TAG, "connect success!");
				}

				@Override
				public void onFailure(IMqttToken asyncActionToken,
						Throwable exception) {
					resultBundle.putString(
							MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
							exception.getLocalizedMessage());
					resultBundle.putSerializable(
							MqttServiceConstants.CALLBACK_EXCEPTION, exception);
					service.traceError(TAG,
							"connect fail, call connect to reconnect.reason:"
									+ exception.getMessage());

					doAfterConnectFail(resultBundle);

				}
			};
			
			if (myClient != null) {
				if (isConnecting ) {
					service.traceDebug(TAG,
							"myClient != null and the client is connecting. Connect return directly.");
					service.traceDebug(TAG,"Connect return:isConnecting:"+isConnecting+".disconnected:"+disconnected);
				}else if(!disconnected){
					service.traceDebug(TAG,"myClient != null and the client is connected and notify!");
					doAfterConnectSuccess(resultBundle);
				}
				else {					
					service.traceDebug(TAG, "myClient != null and the client is not connected");
					service.traceDebug(TAG,"Do Real connect!");
					setConnectingState(true);
					myClient.connect(connectOptions, invocationContext, listener);
				}
			}
			
			// if myClient is null, then create a new connection
			else {
			    pingSender = instantiatePingSender(service);
				myClient = new MqttAsyncClient(serverURI, clientId,
						persistence, pingSender);
				myClient.setCallback(this);

				service.traceDebug(TAG,"Do Real connect!");
				setConnectingState(true);
				myClient.connect(connectOptions, invocationContext, listener);
			}
		} catch (Exception e) {
			service.traceError(TAG, "Exception occurred attempting to connect: " + e.getMessage());
			setConnectingState(false);
			handleException(resultBundle, e);
		}
	}

	private MqttPingSender instantiatePingSender(MqttService service) {
	    if (connectOptions instanceof MqttAndroidConnectOptions) {
            MqttAndroidConnectOptions extendedOptions = (MqttAndroidConnectOptions) connectOptions;
            switch (extendedOptions.getPingType()) {
                case MqttAndroidConnectOptions.PING_WORKER:
                    return WorkerPingSender.getInstance(service);
            }
        }
	    // Default is Alarm sender
        return new AlarmPingSender(service);
    }

	private void doAfterConnectSuccess(final Bundle resultBundle) {
		//since the device's cpu can go to sleep, acquire a wakelock and drop it later.
		acquireWakeLock();
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		deliverBacklog();
		setConnectingState(false);
		disconnected = false;
		releaseWakeLock();
	}

	@Override
	public void connectComplete(boolean reconnect, String serverURI) {
		Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_EXTENDED_ACTION);
		resultBundle.putBoolean(MqttServiceConstants.CALLBACK_RECONNECT, reconnect);
		resultBundle.putString(MqttServiceConstants.CALLBACK_SERVER_URI, serverURI);
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
	}

	private void doAfterConnectFail(final Bundle resultBundle){
		//
		acquireWakeLock();
		disconnected = true;
		setConnectingState(false);
		service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		releaseWakeLock();
	}
	
	private void handleException(final Bundle resultBundle, Exception e) {
		resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
				e.getLocalizedMessage());

		resultBundle.putSerializable(MqttServiceConstants.CALLBACK_EXCEPTION, e);

		service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
	}

	/**
	 * Attempt to deliver any outstanding messages we've received but which the
	 * application hasn't acknowledged. If "cleanSession" was specified, we'll
	 * have already purged any such messages from our messageStore.
	 */
	private void deliverBacklog() {
		Iterator<StoredMessage> backlog = service.messageStore
				.getAllArrivedMessages(clientHandle);
		while (backlog.hasNext()) {
			StoredMessage msgArrived = backlog.next();
			Bundle resultBundle = messageToBundle(msgArrived.getMessageId(),
					msgArrived.getTopic(), msgArrived.getMessage());
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.MESSAGE_ARRIVED_ACTION);
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}
	}

	/**
	 * Create a bundle containing all relevant data pertaining to a message
	 * 
	 * @param messageId
	 *            the message's identifier in the messageStore, so that a
	 *            callback can be made to remove it once delivered
	 * @param topic
	 *            the topic on which the message was delivered
	 * @param message
	 *            the message itself
	 * @return the bundle
	 */
	private Bundle messageToBundle(String messageId, String topic,
			MqttMessage message) {
		Bundle result = new Bundle();
		result.putString(MqttServiceConstants.CALLBACK_MESSAGE_ID, messageId);
		result.putString(MqttServiceConstants.CALLBACK_DESTINATION_NAME, topic);
		result.putParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL,
				new ParcelableMqttMessage(message));
		return result;
	}
	
	/**
	 * Close connection from the server
	 * 
	 */
	void close() {
		service.traceDebug(TAG, "close()");
		try {
			if (myClient != null) {
				myClient.close();
			}
		} catch (MqttException e) {
			// Pass a new bundle, let handleException stores error messages.
			handleException(new Bundle(), e);
		}
	}

	/**
	 * Disconnect from the server
	 * 
	 * @param quiesceTimeout
	 *            in milliseconds
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 */
	void disconnect(long quiesceTimeout, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "disconnect()");
		disconnected = true;
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.DISCONNECT_ACTION);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.disconnect(quiesceTimeout, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.DISCONNECT_ACTION,
					NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		if (connectOptions != null && connectOptions.isCleanSession()) {
			// assume we'll clear the stored messages at this point
			service.messageStore.clearArrivedMessages(clientHandle);
		}

		releaseWakeLock();
	}

	/**
	 * Disconnect from the server
	 * 
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 */
	void disconnect(String invocationContext, String activityToken) {
		service.traceDebug(TAG, "disconnect()");
		disconnected = true;
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.DISCONNECT_ACTION);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.disconnect(invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.DISCONNECT_ACTION,
					NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		if (connectOptions != null && connectOptions.isCleanSession()) {
			// assume we'll clear the stored messages at this point
			service.messageStore.clearArrivedMessages(clientHandle);
		}
		releaseWakeLock();
	}

	/**
	 * @return true if we are connected to an MQTT server
	 */
	public boolean isConnected() {
		return myClient != null && myClient.isConnected();
	}

	/**
	 * Publish a message on a topic
	 * 
	 * @param topic
	 *            the topic on which to publish - represented as a string, not
	 *            an MqttTopic object
	 * @param payload
	 *            the content of the message to publish
	 * @param qos
	 *            the quality of service requested
	 * @param retained
	 *            whether the MQTT server should retain this message
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 * @return token for tracking the operation
	 */
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained, String invocationContext, String activityToken) {
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SEND_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		IMqttDeliveryToken sendToken = null;

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				MqttMessage message = new MqttMessage(payload);
				message.setQos(qos);
				message.setRetained(retained);
				sendToken = myClient.publish(topic, payload, qos, retained,
						invocationContext, listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.SEND_ACTION, NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}

		return sendToken;
	}

	/**
	 * Publish a message on a topic
	 * 
	 * @param topic
	 *            the topic on which to publish - represented as a string, not
	 *            an MqttTopic object
	 * @param message
	 *            the message to publish
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary string to be passed back to the activity
	 * @return token for tracking the operation
	 */
	public IMqttDeliveryToken publish(String topic, MqttMessage message,
			String invocationContext, String activityToken) {
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SEND_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		IMqttDeliveryToken sendToken = null;

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				sendToken = myClient.publish(topic, message, invocationContext,
						listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else if ((myClient !=null) && (this.bufferOpts != null) && (this.bufferOpts.isBufferEnabled())){
			// Client is not connected, but buffer is enabled, so sending message
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				sendToken = myClient.publish(topic, message, invocationContext,
						listener);
				storeSendDetails(topic, message, sendToken, invocationContext,
						activityToken);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		}  else {
			Log.i(TAG, "Client is not connected, so not sending message");
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError(MqttServiceConstants.SEND_ACTION, NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
		return sendToken;
	}

	/**
	 * Subscribe to a topic
	 * 
	 * @param topic
	 *            a possibly wildcarded topic name
	 * @param qos
	 *            requested quality of service for the topic
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void subscribe(final String topic, final int qos,
			String invocationContext, String activityToken) {
		service.traceDebug(TAG, "subscribe({" + topic + "}," + qos + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.subscribe(topic, qos, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Subscribe to one or more topics
	 * 
	 * @param topic
	 *            a list of possibly wildcarded topic names
	 * @param qos
	 *            requested quality of service for each topic
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	public void subscribe(final String[] topic, final int[] qos,
			String invocationContext, String activityToken) {
		service.traceDebug(TAG, "subscribe({" + Arrays.toString(topic) + "}," + Arrays.toString(qos) + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);

		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.subscribe(topic, qos, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	public void subscribe(String[] topicFilters, int[] qos, String invocationContext, String activityToken, IMqttMessageListener[] messageListeners) {
		service.traceDebug(TAG, "subscribe({" + Arrays.toString(topicFilters) + "}," + Arrays.toString(qos) + ",{"
				+ invocationContext + "}, {" + activityToken + "}");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.SUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN, activityToken);
		resultBundle.putString(MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, invocationContext);
		if((myClient != null) && (myClient.isConnected())){
			IMqttActionListener listener = new MqttConnectionListener(resultBundle);
			try {

				myClient.subscribe(topicFilters, qos,messageListeners);
			} catch (Exception e){
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE, NOT_CONNECTED);
			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

		/**
         * Unsubscribe from a topic
         *
         * @param topic
         *            a possibly wildcarded topic name
         * @param invocationContext
         *            arbitrary data to be passed back to the application
         * @param activityToken
         *            arbitrary identifier to be passed back to the Activity
         */
	void unsubscribe(final String topic, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "unsubscribe({" + topic + "},{"
				+ invocationContext + "}, {" + activityToken + "})");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.UNSUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.unsubscribe(topic, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);

			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Unsubscribe from one or more topics
	 * 
	 * @param topic
	 *            a list of possibly wildcarded topic names
	 * @param invocationContext
	 *            arbitrary data to be passed back to the application
	 * @param activityToken
	 *            arbitrary identifier to be passed back to the Activity
	 */
	void unsubscribe(final String[] topic, String invocationContext,
			String activityToken) {
		service.traceDebug(TAG, "unsubscribe({" + Arrays.toString(topic) + "},{"
				+ invocationContext + "}, {" + activityToken + "})");
		final Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.UNSUBSCRIBE_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				activityToken);
		resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
				invocationContext);
		if ((myClient != null) && (myClient.isConnected())) {
			IMqttActionListener listener = new MqttConnectionListener(
					resultBundle);
			try {
				myClient.unsubscribe(topic, invocationContext, listener);
			} catch (Exception e) {
				handleException(resultBundle, e);
			}
		} else {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					NOT_CONNECTED);

			service.traceError("subscribe", NOT_CONNECTED);
			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Get tokens for all outstanding deliveries for a client
	 * 
	 * @return an array (possibly empty) of tokens
	 */
	public IMqttDeliveryToken[] getPendingDeliveryTokens() {
		return myClient.getPendingDeliveryTokens();
	}

	// Implement MqttCallback
	/**
	 * Callback for connectionLost
	 * 
	 * @param why
	 *            the exeception causing the break in communications
	 */
	@Override
	public void connectionLost(Throwable why) {
		service.traceDebug(TAG, "connectionLost(" + why.getMessage() + ")");
		disconnected = true;
		try {
			if(!this.connectOptions.isAutomaticReconnect()) {
				myClient.disconnect(null, new IMqttActionListener() {

					@Override
					public void onSuccess(IMqttToken asyncActionToken) {
						// No action
					}

					@Override
					public void onFailure(IMqttToken asyncActionToken,
										  Throwable exception) {
						// No action
					}
				});
			} else {
				// Using the new Automatic reconnect functionality.
				// We can't force a disconnection, but we can speed one up
				pingSender.schedule(10000);

			}
		} catch (Exception e) {
			// ignore it - we've done our best
		}

		Bundle resultBundle = new Bundle();
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.ON_CONNECTION_LOST_ACTION);
		if (why != null) {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					why.getMessage());
			if (why instanceof MqttException) {
				resultBundle.putSerializable(
						MqttServiceConstants.CALLBACK_EXCEPTION, why);
			}
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_EXCEPTION_STACK,
					Log.getStackTraceString(why));
		}
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		// client has lost connection no need for wake lock
		releaseWakeLock();
	}

	/**
	 * Callback to indicate a message has been delivered (the exact meaning of
	 * "has been delivered" is dependent on the QOS value)
	 * 
	 * @param messageToken
	 *            the messge token provided when the message was originally sent
	 */
	@Override
	public void deliveryComplete(IMqttDeliveryToken messageToken) {

		service.traceDebug(TAG, "deliveryComplete(" + messageToken + ")");

		MqttMessage message = savedSentMessages.remove(messageToken);
		if (message != null) { // If I don't know about the message, it's
			// irrelevant
			String topic = savedTopics.remove(messageToken);
			String activityToken = savedActivityTokens.remove(messageToken);
			String invocationContext = savedInvocationContexts
					.remove(messageToken);

			Bundle resultBundle = messageToBundle(null, topic, message);
			if (activityToken != null) {
				resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
						MqttServiceConstants.SEND_ACTION);
				resultBundle.putString(
						MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
						activityToken);
				resultBundle.putString(
						MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT,
						invocationContext);
		
				service.callbackToActivity(clientHandle, Status.OK,
						resultBundle);
			}
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.MESSAGE_DELIVERED_ACTION);
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}

		// this notification will have kept the connection alive but send the previously sechudled ping anyway
	}

	/**
	 * Callback when a message is received
	 * 
	 * @param topic
	 *            the topic on which the message was received
	 * @param message
	 *            the message itself
	 */
	@Override
	public void messageArrived(String topic, MqttMessage message)
			throws Exception {

		service.traceDebug(TAG,
				"messageArrived(" + topic + ",{" + message.toString() + "})");

		if (defaultMessageListener != null) {
			defaultMessageListener.messageArrived(topic, message);
			return;
		}

		// Default action if no application-level listener is setup
		String messageId = service.messageStore.storeArrived(clientHandle,
				topic, message);
	
		Bundle resultBundle = messageToBundle(messageId, topic, message);
		resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.MESSAGE_ARRIVED_ACTION);
		resultBundle.putString(MqttServiceConstants.CALLBACK_MESSAGE_ID,
				messageId);
		service.callbackToActivity(clientHandle, Status.OK, resultBundle);
				
	}



	/**
	 * Store details of sent messages so we can handle "deliveryComplete"
	 * callbacks from the mqttClient
	 * 
	 * @param topic
	 * @param msg
	 * @param messageToken
	 * @param invocationContext
	 * @param activityToken
	 */
	private void storeSendDetails(final String topic, final MqttMessage msg,
			final IMqttDeliveryToken messageToken,
			final String invocationContext, final String activityToken) {
		savedTopics.put(messageToken, topic);
		savedSentMessages.put(messageToken, msg);
		savedActivityTokens.put(messageToken, activityToken);
		savedInvocationContexts.put(messageToken, invocationContext);
	}

	/**
	 * Acquires a partial wake lock for this client
	 */
	private void acquireWakeLock() {
		if (wakelock == null) {
			PowerManager pm = (PowerManager) service
					.getSystemService(Service.POWER_SERVICE);
			wakelock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
					wakeLockTag);
		}
		wakelock.acquire();

	}

	/**
	 * Releases the currently held wake lock for this client
	 */
	private void releaseWakeLock() {
		if(wakelock != null && wakelock.isHeld()){
			wakelock.release();
		}
	}



	/**
	 * General-purpose IMqttActionListener for the Client context
	 * <p>
	 * Simply handles the basic success/failure cases for operations which don't
	 * return results
	 * 
	 */
	private class MqttConnectionListener implements IMqttActionListener {

		private final Bundle resultBundle;

		private MqttConnectionListener(Bundle resultBundle) {
			this.resultBundle = resultBundle;
		}

		@Override
		public void onSuccess(IMqttToken asyncActionToken) {
			service.callbackToActivity(clientHandle, Status.OK, resultBundle);
		}

		@Override
		public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
			resultBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
					exception.getLocalizedMessage());

			resultBundle.putSerializable(
					MqttServiceConstants.CALLBACK_EXCEPTION, exception);

			service.callbackToActivity(clientHandle, Status.ERROR, resultBundle);
		}
	}

	/**
	 * Receive notification that we are offline<br>
	 * if cleanSession is true, we need to regard this as a disconnection
	 */
	void offline() {
		
		if (!disconnected && !cleanSession) {
			Exception e = new Exception("Android offline");
			connectionLost(e);
		}
	}
	
	/**
	* Reconnect<br>
	* Only appropriate if cleanSession is false and we were connected.
	* Declare as synchronized to avoid multiple calls to this method to send connect 
	* multiple times 
	*/
	synchronized void reconnect() {

		if (myClient == null) {
			service.traceError(TAG,"Reconnect myClient = null. Will not do reconnect");
			return;
		}

		if (isConnecting) {
			service.traceDebug(TAG, "The client is connecting. Reconnect return directly.");
			return ;
		}
		
		if(!service.isOnline()){
			service.traceDebug(TAG,
					"The network is not reachable. Will not do reconnect");
			return;
		}

		if(connectOptions.isAutomaticReconnect()){
			//The Automatic reconnect functionality is enabled here
			Log.i(TAG, "Requesting Automatic reconnect using New Java AC");
			final Bundle resultBundle = new Bundle();
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
					reconnectActivityToken);
			resultBundle.putString(
					MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, null);
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
					MqttServiceConstants.CONNECT_ACTION);
			try {
				myClient.disconnect();
			} catch (MqttException ex){
			}
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
			}
			try {
				myClient.reconnect();
			} catch (MqttException ex){
				if (ex.getReasonCode() != MqttException.REASON_CODE_CLIENT_CONNECTED) {
					Log.e(TAG, "Exception occurred attempting to reconnect: " + ex.getMessage());
					setConnectingState(false);
					handleException(resultBundle, ex);
				} else {
					// Do nothing, we are already connected
				}
			}
		} else if (disconnected && !cleanSession) {
			// use the activityToke the same with action connect
			service.traceDebug(TAG,"Do Real Reconnect!");
			final Bundle resultBundle = new Bundle();
			resultBundle.putString(
				MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN,
				reconnectActivityToken);
			resultBundle.putString(
				MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT, null);
			resultBundle.putString(MqttServiceConstants.CALLBACK_ACTION,
				MqttServiceConstants.CONNECT_ACTION);
			
			try {
				
				IMqttActionListener listener = new MqttConnectionListener(resultBundle) {
					@Override
					public void onSuccess(IMqttToken asyncActionToken) {
						// since the device's cpu can go to sleep, acquire a
						// wakelock and drop it later.
						service.traceDebug(TAG,"Reconnect Success!");
						service.traceDebug(TAG,"DeliverBacklog when reconnect.");
						doAfterConnectSuccess(resultBundle);
					}
					
					@Override
					public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
						resultBundle.putString(
								MqttServiceConstants.CALLBACK_ERROR_MESSAGE,
								exception.getLocalizedMessage());
						resultBundle.putSerializable(
								MqttServiceConstants.CALLBACK_EXCEPTION,
								exception);
						service.callbackToActivity(clientHandle, Status.ERROR,
								resultBundle);

						doAfterConnectFail(resultBundle);
						
					}
				};
				
				myClient.connect(connectOptions, null, listener);
				setConnectingState(true);
			} catch (MqttException e) {
				service.traceError(TAG, "Cannot reconnect to remote server." + e.getMessage());
				setConnectingState(false);
				handleException(resultBundle, e);
			} catch (Exception e){
				/*  TODO: Added Due to: https://github.com/eclipse/paho.mqtt.android/issues/101
				    For some reason in a small number of cases, myClient is null here and so
				    a NullPointer Exception is thrown. This is a workaround to pass the exception
				    up to the application. myClient should not be null so more investigation is
				    required.
				*/
				service.traceError(TAG, "Cannot reconnect to remote server." + e.getMessage());
				setConnectingState(false);
				MqttException newEx = new MqttException(MqttException.REASON_CODE_UNEXPECTED_ERROR, e.getCause());
				handleException(resultBundle, newEx);
			}
		}
	}
	
	/**
	 * 
	 * @param isConnecting
	 */
	private synchronized void setConnectingState(boolean isConnecting){
		this.isConnecting = isConnecting; 
	}

	/**
	 * Sets the DisconnectedBufferOptions for this client
	 * @param bufferOpts
	 */
	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
		this.bufferOpts = bufferOpts;
		myClient.setBufferOpts(bufferOpts);
	}

	public int getBufferedMessageCount(){
		return myClient.getBufferedMessageCount();
	}

	public MqttMessage getBufferedMessage(int bufferIndex){
		return myClient.getBufferedMessage(bufferIndex);
	}

	public void deleteBufferedMessage(int bufferIndex){
		myClient.deleteBufferedMessage(bufferIndex);
	}
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/WorkerPingSender.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.eclipse.paho.android.service;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.internal.ClientComms;

import java.util.concurrent.TimeUnit;

public class WorkerPingSender implements MqttPingSender {

    // Identifier for Intents, log messages, etc..
    private static final String TAG = "WorkerPingSender";

    private static final String WORKER_TAG_MQTT = "com.hmdm.launcher.WORK_TAG_MQTT";

    private ClientComms comms;
    private MqttService service;

    private static WorkerPingSender instance;

    private WorkerPingSender(MqttService service) {
        if (service == null) {
            throw new IllegalArgumentException(
                    "Neither service nor client can be null.");
        }
        this.service = service;
    }

    public static WorkerPingSender getInstance(MqttService service) {
        if (instance == null) {
            instance = new WorkerPingSender(service);
        }
        instance.service = service;
        return instance;
    }

    @Override
    public void init(ClientComms comms) {
        this.comms = comms;
    }

    @Override
    public void start() {
        schedule(comms.getKeepAlive());
    }

    @Override
    public void stop() {
        WorkManager.getInstance(service.getApplicationContext()).cancelUniqueWork(WORKER_TAG_MQTT);
        RemoteLogger.log(service, Const.LOG_DEBUG, "MQTT ping cancelled");
    }

    @Override
    public void schedule(long delayInMilliseconds) {
        // Minimal interval is 15 mins
        // If delay is less than 15 mins, just schedule it right now
        long sec = delayInMilliseconds / 1000l;
        RemoteLogger.log(service, Const.LOG_DEBUG, "MQTT ping scheduled: " + sec + " sec");
        OneTimeWorkRequest queryRequest =
                new OneTimeWorkRequest.Builder(WorkerPingSender.InternalWorker.class)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(sec, TimeUnit.SECONDS)
                        .build();
        WorkManager.getInstance(service.getApplicationContext()).enqueueUniqueWork(WORKER_TAG_MQTT, ExistingWorkPolicy.REPLACE, queryRequest);
    }

    public static class InternalWorker extends Worker {

        private Context context;

        public InternalWorker(
                @NonNull final Context context,
                @NonNull WorkerParameters params) {
            super(context, params);
            this.context = context;
        }

        @NonNull
        @Override
        public Result doWork() {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Sending MQTT Ping at:" + System.currentTimeMillis());
            PingDeathDetector.getInstance().registerPing();
            WorkerPingSender.instance.comms.checkForActivity(null);
            return null;
        }
    }
}
</file>

<file path="app/src/main/res/drawable/ic_battery_1_red.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aaff0000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,720L600,720L600,240L360,240L360,720Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_2_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,640L600,640L600,240L360,240L360,640Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_2_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,640L600,640L600,240L360,240L360,640Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_3_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,560L600,560L600,240L360,240L360,560Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_3_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,560L600,560L600,240L360,240L360,560Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_4_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,480L600,480L600,240L360,240L360,480Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_4_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,480L600,480L600,240L360,240L360,480Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_5_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
  <path
      android:fillColor="#aa000000"
      android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,320L600,320L600,240L360,240L360,320Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_5_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <group
      android:pivotX="480"
      android:pivotY="480"
      android:rotation="270">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M320,880Q303,880 291.5,868.5Q280,857 280,840L280,200Q280,183 291.5,171.5Q303,160 320,160L400,160L400,80L560,80L560,160L640,160Q657,160 668.5,171.5Q680,183 680,200L680,840Q680,857 668.5,868.5Q657,880 640,880L320,880ZM360,320L600,320L600,240L360,240L360,320Z"/>
  </group>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_6_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aa000000"
      android:pathData="M200,680Q183,680 171.5,668.5Q160,657 160,640L160,560L80,560L80,400L160,400L160,320Q160,303 171.5,291.5Q183,280 200,280L840,280Q857,280 868.5,291.5Q880,303 880,320L880,640Q880,657 868.5,668.5Q857,680 840,680L200,680Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_battery_6_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
    <path
        android:fillColor="#aaffffff"
        android:pathData="M200,680Q183,680 171.5,668.5Q160,657 160,640L160,560L80,560L80,400L160,400L160,320Q160,303 171.5,291.5Q183,280 200,280L840,280Q857,280 868.5,291.5Q880,303 880,320L880,640Q880,657 868.5,668.5Q857,680 840,680L200,680Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_charger_black.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aa000000"
      android:pathData="M452,800L652,410L512,410L512,160L312,550L452,550L452,800Z"/>
</vector>
</file>

<file path="app/src/main/res/drawable/ic_charger_white.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="960"
    android:viewportHeight="960">
  <path
      android:fillColor="#aaffffff"
      android:pathData="M452,800L652,410L512,410L512,160L312,550L452,550L452,800Z"/>
</vector>
</file>

<file path="app/src/main/res/layout/activity_initial_setup.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
        <variable name="loading" type="Boolean"/>
    </data>

    <RelativeLayout 
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.InitialSetupActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:orientation="vertical"
            android:layout_centerInParent="true"
            android:gravity="center">

            <ProgressBar
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                bind:boolToVisible="@{loading}"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{message}"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:textAppearance="?android:textAppearanceMedium"
                android:gravity="center"/>

        </LinearLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_accessibility_service.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_accessibility_service_message"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_administrator_mode_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="skipAccessibilityService"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="setAccessibilityService"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_administrator_mode.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_administrator_mode_message"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_administrator_mode_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="skipAdminMode"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_administrator_mode_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="setAdminMode"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_device_info.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="serverUrl" type="String"/>
        <variable name="deviceId" type="String"/>
        <variable name="imei" type="String"/>
        <variable name="serialNumber" type="String"/>
        <variable name="phone" type="String"/>
        <variable name="version" type="String"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:textStyle="bold"
            android:text="@{serverUrl}"/>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/device_id"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{deviceId}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/imei"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{imei}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/serial_number"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{serialNumber}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="8dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/phone_number"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{phone}"/>

        </LinearLayout>

        <LinearLayout
            android:layout_width="@dimen/device_info_width"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginBottom="16dp">

            <TextView
                android:layout_width="@dimen/device_info_column_width"
                android:layout_height="wrap_content"
                android:gravity="right"
                android:paddingRight="@dimen/activity_horizontal_margin"
                android:text="@string/launcher_version"/>

            <TextView
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:textStyle="bold"
                android:text="@{version}"/>

        </LinearLayout>

        <Button
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/close"
            android:onClick="closeDeviceInfoDialog"/>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_password.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
        <variable name="loading" type="Boolean"/>
    </data>

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/wrong_password"/>

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{!error}"
            android:text="@string/enter_admin_password"/>

        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/password"
            android:inputType="textPassword"
            bind:boolToDisable="@{loading}"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="@dimen/activity_vertical_margin"
                android:text="@string/dialog_enter_password_login"
                bind:boolToDisable="@{loading}"
                android:onClick="checkAdministratorPassword"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/dialog_enter_password_cancel"
                android:onClick="closeEnterPasswordDialog"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_file_downloading_failed.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:id="@+id/title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginRight="@dimen/activity_vertical_margin"
                android:text="@string/main_activity_repeat"
                android:onClick="repeatDownloadClicked"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/main_activity_cancel"
                android:onClick="confirmDownloadFailureClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_history_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_history_settings_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_history_settings_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="historyWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_history_settings_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueHistory"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_manage_storage.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_manage_storage_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_history_settings_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="storageWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_history_settings_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueStorage"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_miui_permissions.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/title"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_miui_permissions_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_unknown_sources_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueMiuiPermissions"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_overlay_settings.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/hint"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:text="@string/dialog_overlay_settings_title"
            android:layout_marginBottom="@dimen/activity_horizontal_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:orientation="horizontal">

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginRight="8dp"
                android:text="@string/dialog_accessibility_service_skip"
                android:textSize="@dimen/button_text_size"
                android:onClick="overlayWithoutPermission"/>

            <Button
                android:layout_width="0dp"
                android:layout_weight="1"
                android:layout_height="wrap_content"
                android:layout_marginLeft="8dp"
                android:text="@string/dialog_accessibility_service_continue"
                android:textSize="@dimen/button_text_size"
                android:onClick="continueOverlay"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_permissions.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/dialog_permission_title"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical|center_horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_repeat"
                android:onClick="permissionsRetryClicked"/>

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:layout_marginLeft="8dp"
                android:text="@string/main_activity_exit"
                android:onClick="permissionsExitClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/item_app.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:gravity="center_horizontal"
    tools:ignore="UseCompoundDrawables"
    android:id="@+id/root_linearLayout"
    android:layout_margin="5dp">

    <ImageView
        android:layout_width="@dimen/app_icon_size"
        android:layout_height="@dimen/app_icon_size"
        android:layout_marginTop="16dp"
        android:id="@+id/imageView"
        tools:ignore="ContentDescription" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/textView"
        android:gravity="center"
        android:maxLines="2"
        android:ellipsize="end"
        android:padding="5dp"/>

</LinearLayout>
</layout>
</file>

<file path="app/src/main/res/values/dimens.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">16dp</dimen>
    <dimen name="exit_overlay_size">24dp</dimen>
    <dimen name="dialog_enter_device_id_width">280dp</dimen>
    <dimen name="activity_main_stacktrace_height">400dp</dimen>
    <dimen name="activity_main_stacktrace_text_size">6pt</dimen>
    <dimen name="activity_main_exit_button_size">24dp</dimen>
    <dimen name="app_list_item_size">100dp</dimen>
    <dimen name="status_bar_height">40dp</dimen>
    <dimen name="prevent_applications_list_width">8dp</dimen>
    <dimen name="info_icon_margin">40dp</dimen>
    <dimen name="block_window_button_width">150dp</dimen>
    <dimen name="button_text_size">12dp</dimen>
    <dimen name="button_text_size_small">12dp</dimen>
    <dimen name="device_info_width">300dp</dimen>
    <dimen name="device_info_column_width">150dp</dimen>
    <dimen name="title_text_size">16dp</dimen>
    <dimen name="app_icon_size">50dp</dimen>
    <dimen name="status_bar_side_width">60dp</dimen>
</resources>
</file>

<file path="app/src/main/res/values-vi/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Quản trị viên</string>
    <string name="install_error">Lỗi cài đặt</string>
    <string name="file_create_error">Lỗi tạo file</string>
    <string name="dialog_enter_device_id_error">ID này chưa được đăng ký tại %s. Lấy ID từ tab \"Thiết bị\" trong bảng điều khiển.</string>
    <string name="dialog_enter_device_id_qrcode">Mã QR</string>
    <string name="dialog_enter_device_id_variants">Biến thể</string>
    <string name="dialog_enter_device_id_save">Lưu</string>
    <string name="dialog_enter_device_id_exit">Thoát</string>
    <string name="dialog_enter_device_id_title">Nhập ID thiết bị tại %s</string>
    <string name="main_start_preparations">Chuẩn bị khởi động</string>
    <string name="main_downloading_configuration">Cập nhật file cấu hình</string>
    <string name="main_downloading_content">Cập nhật dữ liệu</string>
    <string name="main_update_applications">Cài đặt và cập nhật ứng dụng</string>
    <string name="dialog_root_message">Bạn cần quyền truy cập ROOT</string>
    <string name="main_application_start">Khởi động ứng dụng</string>
    <string name="main_app_installing">Đang cài đặt ứng dụng</string>
    <string name="main_app_downloading">Đang tải xuống ứng dụng</string>
    <string name="main_app_downloading_error">Không thể tải xuống gói cài đặt</string>
    <string name="main_app_removing">Gỡ cài đặt ứng dụng</string>
    <string name="main_file_downloading">Đang tải xuống file</string>
    <string name="main_file_downloading_error">Không thể tải xuống file</string>
    <string name="main_activity_repeat">Thử lại</string>
    <string name="main_activity_reset">Đặt lại</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Hủy</string>
    <string name="main_activity_details">Chi tiết</string>
    <string name="select_system_launcher">Chọn %s làm launcher mặc định và tích \'Luôn luôn\':</string>
    <string name="dialog_network_error_title">Lỗi kết nối đến %s. Vui lòng kiểm tra kết nối Internet và thử lại.</string>
    <string name="main_activity_update_config">Yêu cầu file cấu hình từ máy chủ</string>
    <string name="main_activity_applications_update">Cập nhật ứng dụng</string>
    <string name="dialog_overlay_settings_title">Vui lòng cho phép ứng dụng vẽ trên các cửa sổ khác.\n\nTùy chọn này giúp chặn các ứng dụng không mong muốn và cho phép mở khóa khẩn cấp chế độ kiosk.\n\nNhấn \"Tiếp tục\" để mở cài đặt. Tìm mục \"%s\", cấp quyền, sau đó nhấn \"Quay lại\".</string>
    <string name="dialog_manage_storage_title">Vui lòng cho phép ứng dụng quản lý bộ nhớ.\n\nTùy chọn này cho phép Headwind MDM quản lý file trên thiết bị của bạn.</string>
    <string name="dialog_history_settings_title">Vui lòng cho phép ứng dụng truy cập dữ liệu sử dụng.\n\nTùy chọn này cho phép kiểm soát ứng dụng và cài đặt.\n\nTùy chọn này có thể gây hao pin nhanh hơn. Để tiết kiệm pin, bỏ qua tùy chọn này (sử dụng dịch vụ trợ năng hoặc chế độ kiosk thay thế).\n\nNhấn \"Tiếp tục\" để mở cài đặt. Tìm mục \"%s\", cấp quyền, sau đó nhấn \"Quay lại\".</string>
    <string name="dialog_history_settings_continue">Tiếp tục</string>
    <string name="dialog_history_settings_skip">Bỏ qua</string>
    <string name="dialog_unknown_sources_title">Vui lòng cho phép cài đặt từ nguồn không xác định. Bảng cài đặt sẽ mở. Tìm \"Nguồn không xác định\", cho phép cài đặt và nhấn \"Quay lại\".</string>
    <string name="dialog_unknown_sources_continue">Tiếp tục</string>
    <string name="dialog_miui_permissions_title">MIUI yêu cầu thiết lập thủ công các quyền tùy chỉnh. Cửa sổ quyền ứng dụng sẽ mở. Nhấn \"Quyền khác\", cho phép \"Hiển thị cửa sổ bật lên khi chạy trong nền\" và nhấn \"Quay lại\".</string>
    <string name="dialog_miui_developer_title">MIUI yêu cầu thiết lập thủ công thiết bị của bạn. Trên màn hình thông tin, NHẤN 7 LẦN VÀO \"SỐ BẢN DỰNG\". Điều này sẽ kích hoạt cài đặt nhà phát triển.</string>
    <string name="dialog_miui_optimization_title">MIUI yêu cầu thiết lập thủ công thiết bị của bạn. Cửa sổ cài đặt nhà phát triển sẽ mở. Cuộn màn hình xuống và bỏ tích \"Tối ưu hóa MIUI\".</string>
    <string name="dialog_administrator_mode_message">Vui lòng cho phép ứng dụng hoạt động ở chế độ quản trị viên thiết bị. Bảng cài đặt sẽ mở. Chọn \"Quản trị viên thiết bị\", tìm mục \"%s\", kích hoạt quản trị viên, và nhấn \"Quay lại\".</string>
    <string name="dialog_administrator_mode_continue">Tiếp tục</string>
    <string name="dialog_administrator_mode_skip">Bỏ qua</string>
    <string name="accessibility_service_description">Giám sát ứng dụng hoạt động bởi ứng dụng MDM</string>
    <string name="dialog_accessibility_service_message">Vui lòng cho phép ứng dụng sử dụng dịch vụ trợ năng. Bảng cài đặt sẽ mở. Tìm mục \"%s\", cho phép sử dụng dịch vụ trợ năng, và nhấn \"Quay lại\".</string>
    <string name="dialog_accessibility_service_continue">Tiếp tục</string>
    <string name="dialog_accessibility_service_skip">Bỏ qua</string>
    <string name="access_to_app_denied">Gói không được phép:</string>
    <string name="access_to_app_denied_2">Vui lòng yêu cầu quản trị viên của bạn kích hoạt gói này trong cấu hình.\n\nNhấn \'Đóng\' hoặc nút Home để tiếp tục.</string>
    <string name="package_id_copied">ID gói đã được sao chép vào clipboard</string>
    <string name="dialog_app_not_allowed_close">Đóng</string>
    <string name="dialog_app_not_allowed_admin">Quản trị viên</string>
    <string name="device_id">ID thiết bị</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Số seri</string>
    <string name="phone_number">Số điện thoại</string>
    <string name="launcher_version">Phiên bản launcher</string>
    <string name="close">Đóng</string>
    <string name="admin_change_device_id">Thay đổi ID thiết bị</string>
    <string name="admin_change_server_url">Thay đổi URL máy chủ</string>
    <string name="admin_allow_settings">Mở cài đặt</string>
    <string name="settings_allowed">Bạn được phép thay đổi cài đặt trong 3 phút.</string>
    <string name="admin_clear_restrictions">Xóa hạn chế</string>
    <string name="permissive_mode_enabled">Bạn được phép chạy tất cả ứng dụng trong 3 phút.</string>
    <string name="admin_refresh">Cập nhật cấu hình</string>
    <string name="admin_exit">Thoát về launcher hệ thống</string>
    <string name="admin_reset_permissions">Kiểm tra quyền</string>
    <string name="admin_reset_network">Đặt lại chính sách mạng</string>
    <string name="admin_reset_network_hint">Chính sách mạng đã được xóa. Bây giờ bạn có thể bật mạng và tải lại cấu hình.</string>
    <string name="reboot">Khởi động lại thiết bị</string>
    <string name="reboot_failed">Không đủ quyền để khởi động lại thiết bị.</string>
    <string name="message_turn_on_gps">Màn hình cài đặt sẽ mở. Vui lòng bật định vị GPS trên màn hình này và nhấn Quay lại.</string>
    <string name="message_turn_off_gps">Màn hình cài đặt sẽ mở. Vui lòng TẮT định vị GPS trên màn hình này và nhấn Quay lại.</string>
    <string name="message_turn_on_mobile_data">Dữ liệu di động bị tắt! Vui lòng mở thanh trạng thái và bật dữ liệu di động.</string>
    <string name="message_turn_off_mobile_data">Dữ liệu di động đã bật. Vui lòng mở thanh trạng thái và TẮT dữ liệu di động.</string>
    <string name="message_set_password">Chất lượng mật khẩu của bạn không đủ tốt. Màn hình cài đặt sẽ mở. Vui lòng thay đổi mật khẩu và nhấn Quay lại.</string>
    <string name="switch_off_blockings">Đang tắt hạn chế...</string>
    <string name="kiosk_mode_requires_overlays">Chế độ kiosk bị tắt: không có quyền vẽ trên các cửa sổ khác. Vui lòng cho phép %s vẽ trên các cửa sổ khác.</string>
    <string name="enter_admin_password">Nhập mật khẩu quản trị viên</string>
    <string name="wrong_password">Mật khẩu sai</string>
    <string name="dialog_enter_password_login">Đăng nhập</string>
    <string name="dialog_enter_password_cancel">Hủy</string>
    <string name="internal_error">Ứng dụng gặp lỗi nội bộ. Vui lòng khởi động lại thiết bị và thử lại hành động.</string>
    <string name="empty_configuration">Cấu hình chưa được thiết lập, đang thử lấy từ máy chủ!</string>
    <string name="permissions_reset_hint">Đóng bảng quản trị để kiểm tra và yêu cầu quyền.</string>
    <string name="dialog_enter_server_error">Vui lòng nhập URL máy chủ hợp lệ.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Vui lòng nhập URL máy chủ</string>
    <string name="critical_server_failure">Thoát do lỗi máy chủ! Vui lòng sửa lỗi và khởi động lại %s, hoặc gỡ cài đặt hoàn toàn và cài đặt lại.</string>
    <string name="dialog_permission_title">Ứng dụng cần quyền để chạy. Vui lòng cấp các quyền được yêu cầu.</string>
    <string name="main_activity_exit">Thoát</string>
    <string name="browser_not_found">Không thể mở trang web vì không tìm thấy trình duyệt. Vui lòng thêm ứng dụng trình duyệt vào cấu hình thiết bị.</string>
    <string name="invalid_web_link">Không thể mở liên kết web vì nó không được định dạng đúng. Vui lòng liên hệ quản trị viên của bạn để biết chi tiết.</string>
    <string name="activity_not_found">Không thể thực hiện hành động %s vì không tìm thấy hoạt động.</string>
    <string name="location_service_text">Vị trí thiết bị được giám sát</string>
    <string name="qrcode_contents_error">Nội dung mã QR không hợp lệ. Vui lòng tạo mã QR cung cấp trong bảng điều khiển web %s.</string>
    <string name="device_locked">Thiết bị này (%s) đã bị khóa bởi quản trị viên.</string>
    <string name="fault_loop_detected">Ôi không, launcher gặp lỗi không thể khôi phục! Vui lòng liên hệ quản trị viên hệ thống của bạn.</string>
    <string name="mqtt_service_text">Thông báo đẩy đang hoạt động</string>
    <string name="background_location">%s yêu cầu quyền định vị nền. Nhấn \'Tiếp tục\' để mở quyền, nhấn \'Vị trí\' và cho phép xác định vị trí luôn.</string>
    <string name="location_disable">Tắt định vị</string>
    <string name="background_location_continue">Tiếp tục</string>
    <string name="initializing_mdm">Đang khởi tạo ứng dụng quản lý thiết bị di động...</string>
    <string name="dialog_server_error_title">Máy chủ MDM %s trả về phản hồi không hợp lệ. Vui lòng liên hệ quản trị viên của bạn.</string>
    <string name="mdm_choice_message">Thiết bị này sẽ được quản lý hoàn toàn bởi tổ chức của bạn. Dữ liệu của bạn sẽ không riêng tư và có thể bị xóa hoặc xem xét bởi quản trị viên IT bất cứ lúc nào.</string>
    <string name="work_profile_message">Thiết bị này sẽ nhận được hồ sơ công việc được quản lý thuộc về tổ chức của bạn. Hồ sơ công việc được tách biệt với hồ sơ riêng tư của bạn và bạn có thể chuyển đổi giữa các hồ sơ bất cứ lúc nào.</string>
    <string name="overlays_not_supported">Rất tiếc, lớp phủ không được hỗ trợ bởi thiết bị của bạn.</string>
    <string name="admin_not_supported">Thiết bị của bạn không có tùy chọn quản trị viên thiết bị. Nhấn Bỏ qua để tiếp tục.</string>
    <string name="manage_storage_not_supported">Thiết bị của bạn không có tùy chọn quản lý bộ nhớ ngoài.</string>
</resources>
</file>

<file path="fastlane/metadata/android/ca/short_description.txt">
Sistema de gestió de dispositius mòbils (MDM) per Android (agent - llançador)
</file>

<file path="fastlane/metadata/android/cs/short_description.txt">
Systém správy mobilních zařízení (MDM) pro Android (mobilní agent - launcher)
</file>

<file path="fastlane/metadata/android/de/short_description.txt">
Mobile-Device-Management-System (MDM) für Android (mobiler Agent – Launcher)
</file>

<file path="fastlane/metadata/android/en-US/full_description.txt">
A Powerful Open Source Platform to Manage your Enterprise Android Devices

* Quick and Easy to Install “Out of the Box”
* Compatible with Most Android Devices
* Manages Devices in Closed Private Networks
* Premium: All Must-Have MDM Features

Scaling of your business requires proper management. The MDM software is a smart manager of your enterprise tablets, smartphones, kiosks, and digital signage systems. It’s particularly useful to manage unattended devices, replacing hours of maintenance work by a few mouse clicks!

* Group-based policy management forces hundreds of devices to work in the same way, thus making business processes clearer and easier.

* Device status control makes it easy to find problems with enterprise devices and take actions to fix them in a timely manner.

* Remote support simplifies the IT manager’s work to resolve issues and correct faults.

Headwind MDM requires registration on a Headwind MDM server.  You can deploy your own (https://h-mdm.com/download/) or try the demo (https://srv.h-mdm.com). See the Headwind MDM documentation for more information.
</file>

<file path="fastlane/metadata/android/en-US/short_description.txt">
Mobile Device Management (MDM) System for Android (mobile agent - launcher)
</file>

<file path="fastlane/metadata/android/en-US/title.txt">
Headwind MDM Agent
</file>

<file path="fastlane/metadata/android/es/short_description.txt">
Gestión de dispositivos móviles (MDM) para Android (Mobile Agent Launcher)
</file>

<file path="fastlane/metadata/android/et/short_description.txt">
Mobiilseadmete haldusliides (MDM) Androidile (agent/käivitaja kliendi poolel)
</file>

<file path="fastlane/metadata/android/fr/short_description.txt">
Gestion d'appareils mobiles (MDM) pour Android (lanceur d'applications)
</file>

<file path="fastlane/metadata/android/ga/short_description.txt">
Córas Bainistíochta Gléas Soghluaiste (MDM) do Android (gníomhaire -Tosaitheoir)
</file>

<file path="fastlane/metadata/android/he/short_description.txt">
מערכת ניהול מכשירים ניידים (MDM) ל־Android (סוכן למכשיר הנייד - משגר)
</file>

<file path="fastlane/metadata/android/ja/short_description.txt">
Android向けのモバイルデバイスマネジメント（MDM）システム（モバイルエージェント - ランチャー）
</file>

<file path="fastlane/metadata/android/pl/short_description.txt">
Zarządzanie urządzeniami mobilnymi (MDM) dla Androida (agent mobilny — launcher)
</file>

<file path="fastlane/metadata/android/pt/short_description.txt">
Sistema de Mobile Device Management (MDM) para Android (agente móvel - lançador)
</file>

<file path="fastlane/metadata/android/pt-BR/short_description.txt">
Mobile Device Management (MDM) System for Android (mobile agent - launcher)
</file>

<file path="fastlane/metadata/android/pt-PT/short_description.txt">
Sistema de Mobile Device Management (MDM) para Android (agente móvel - lançador)
</file>

<file path="fastlane/metadata/android/ro/short_description.txt">
Sistem de gestionare a dispozitivelor mobile (MDM) pentru Android (lansator)
</file>

<file path="fastlane/metadata/android/ru/short_description.txt">
Система управления мобильными устройствами (MDM) для Android (лаунчер)
</file>

<file path="fastlane/metadata/android/sr/short_description.txt">
Систем за управљање мобилним уређајима (MDM) за Android (мобилни агент)
</file>

<file path="fastlane/metadata/android/sw/short_description.txt">
Córas Bainistíochta Gléas Soghluaiste (MDM) le haghaidh Android (gníomhaire soghluaiste - tosaitheoir)
</file>

<file path="fastlane/metadata/android/tr/short_description.txt">
Android için Mobil Aygıt Yönetimi Sistemi (mobil aracı - başlatıcı)
</file>

<file path="fastlane/metadata/android/uk/short_description.txt">
Система керування моб. пристроями (MDM) для Android (мобільний агент - лончер)
</file>

<file path="fastlane/metadata/android/zh-CN/short_description.txt">
安卓系统的移动设备管理（MDM）系统（移动代理 - 启动器）
</file>

<file path="lib/src/androidTest/java/com/hmdm/ExampleInstrumentedTest.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import static org.junit.Assert.assertEquals;

import android.content.Context;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {
    @Test
    public void useAppContext() {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getTargetContext();

        assertEquals("com.hmdm.test", appContext.getPackageName());
    }
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMPushHandler.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;

public abstract class MDMPushHandler {
    private BroadcastReceiver receiver;

    // This should be overridden
    public abstract void onMessageReceived(MDMPushMessage message);

    public void register(String messageType, Context context) {
        register(new String[] { messageType }, context);
    }

    public void register(String[] messageTypes, Context context) {
        if (messageTypes.length == 0) {
            return;
        }

        IntentFilter intentFilter = new IntentFilter();
        for (int n = 0; n < messageTypes.length; n++) {
            intentFilter.addAction(Const.INTENT_PUSH_NOTIFICATION_PREFIX + messageTypes[n]);
        }
        receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                try {
                    MDMPushMessage message = new MDMPushMessage(intent.getAction(), intent.getExtras());
                    onMessageReceived(message);
                } catch (MDMException e) {
                    e.printStackTrace();
                }
            }
        };

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            context.registerReceiver(receiver, intentFilter, Context.RECEIVER_EXPORTED);
        } else {
            context.registerReceiver(receiver, intentFilter);
        }
    }

    public void unregister(Context context) {
        if (receiver != null) {
            context.unregisterReceiver(receiver);
        }
    }
}
</file>

<file path="lib/src/main/AndroidManifest.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<manifest xmlns:android="http://schemas.android.com/apk/res/android" 
    package="com.hmdm" />
</file>

<file path=".gitignore">
.idea
*.iml
.gradle
/local.properties
.DS_Store
/build
/captures
.externalNativeBuild
example/
app/release
</file>

<file path="gradle.properties">
#
# Headwind MDM: Open Source Android MDM Software
# https://h-mdm.com
#
# Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

android.useAndroidX=true
android.enableJetifier=true
android.nonTransitiveRClass=false
android.nonFinalResIds=false
android.enableR8.fullMode=false
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="lint.xml">
<?xml version="1.0" encoding="UTF-8"?>
<lint>
    <issue id="ExpiredTargetSdkVersion" severity="ignore" />
</lint>
</file>

<file path="settings.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include ':app', ':lib'
setBinding(new Binding([gradle: this]))
evaluate(new File(
        settingsDir.parentFile,
        'exs/.android/include_flutter.groovy'
))
</file>

<file path="app/src/main/aidl/com/hmdm/IMdmApi.aidl">
// IMdmApi.aidl
package com.hmdm;

// Declare any non-default types here with import statements

interface IMdmApi {
    /**
     * Get the MDM configuration (non-privileged, no sensitive info)
     */
    Bundle queryConfig();

    /**
     * Send a log message
     */
    void log(long timestamp, int level, String packageId, String message);

    /**
     * Get app preference
     */
    String queryAppPreference(String packageId, String attr);

    /**
     * Set app preference
     */
    boolean setAppPreference(String packageId, String attr, String value);

    /**
     * Send app preferences to server
     */
    void commitAppPreferences(String packageId);

    // Added in library version 1.1.3
    // All new methods should be added at the end of the AIDL file!!!

    /**
     * Get the API version supported by the launcher (1.1.3 = 113)
     */
    int getVersion();

    /**
     * Get the MDM configuration (privileged, including IMEI and serial number)
     */
    Bundle queryPrivilegedConfig(String apiKey);

    /**
     * Set a custom field to send it to the server
     */
    void setCustom(int number, String value);

    // Added in library version 1.1.5
    /**
     * Force the configuration update
     */
    void forceConfigUpdate();
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LocationTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import java.util.LinkedList;
import java.util.List;

public class LocationTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE locations (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "lat REAL, " +
                    "lon REAL " +
                    ")";
    private static final String SELECT_LAST_LOCATION =
            "SELECT * FROM locations ORDER BY ts LIMIT ?";
    private static final String INSERT_LOCATIONS =
            "INSERT OR IGNORE INTO locations(ts, lat, lon) " +
            "VALUES (?, ?, ?)";
    private static final String DELETE_FROM_LOCATION =
            "DELETE FROM locations WHERE _id=?";
    private static final String DELETE_OLD_ITEMS =
            "DELETE FROM locations WHERE ts < ?";

    public static class Location {
        private long _id;
        private long ts;
        private double lat;
        private double lon;

        public Location() {}

        public Location(android.location.Location location) {
            this.ts = location.getTime();
            this.lat = location.getLatitude();
            this.lon = location.getLongitude();
        }

        @SuppressLint("Range")
        public Location(Cursor cursor) {
            _id = cursor.getLong(cursor.getColumnIndex("_id"));
            ts = cursor.getLong(cursor.getColumnIndex("ts"));
            lat = cursor.getDouble(cursor.getColumnIndex("lat"));
            lon = cursor.getDouble(cursor.getColumnIndex("lon"));
        }

        public long getId() {
            return _id;
        }

        public void setId(int id) {
            this._id = id;
        }

        public long getTs() {
            return ts;
        }

        public void setTs(long ts) {
            this.ts = ts;
        }

        public double getLat() {
            return lat;
        }

        public void setLat(double lat) {
            this.lat = lat;
        }

        public double getLon() {
            return lon;
        }

        public void setLon(double lon) {
            this.lon = lon;
        }
    }

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, Location location) {
        try {
            db.execSQL(INSERT_LOCATIONS, new String[]{
                    Long.toString(location.getTs()),
                    Double.toString(location.getLat()),
                    Double.toString(location.getLon())
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_OLD_ITEMS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<Location> items) {
        db.beginTransaction();
        try {
            for (Location item : items) {
                db.execSQL(DELETE_FROM_LOCATION, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static List<Location> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_LOCATION, new String[] {
                Integer.toString(limit)
        });
        List<Location> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            Location item = new Location(cursor);
            result.add(item);
            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import android.annotation.SuppressLint;
import android.database.Cursor;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfo {

    @JsonIgnore
    private long _id;

    private long ts;
    private Device device;
    private Wifi wifi;
    private Gps gps;
    private Mobile mobile;
    private Mobile mobile2;

    public DetailedInfo() {
    }

    @SuppressLint("Range")
    public DetailedInfo(Cursor cursor) {
        _id = cursor.getLong(cursor.getColumnIndex("_id"));
        ts = cursor.getLong(cursor.getColumnIndex("ts"));

        device = new Device();
        device.setBatteryLevel(cursor.getInt(cursor.getColumnIndex("deviceBatteryLevel")));
        device.setBatteryCharging(cursor.getString(cursor.getColumnIndex("deviceBatteryCharging")));
        device.setWifi(cursor.getInt(cursor.getColumnIndex("deviceWifi")) != 0);
        device.setGps(cursor.getInt(cursor.getColumnIndex("deviceGps")) != 0);
        device.setIp(cursor.getString(cursor.getColumnIndex("deviceIp")));
        device.setKeyguard(cursor.getInt(cursor.getColumnIndex("deviceKeyguard")) != 0);
        device.setRingVolume(cursor.getInt(cursor.getColumnIndex("deviceRingVolume")));
        device.setMobileData(cursor.getInt(cursor.getColumnIndex("deviceMobileData")) != 0);
        device.setBluetooth(cursor.getInt(cursor.getColumnIndex("deviceBluetooth")) != 0);
        device.setUsbStorage(cursor.getInt(cursor.getColumnIndex("deviceUsbStorage")) != 0);
        device.setMemoryTotal(cursor.getInt(cursor.getColumnIndex("deviceMemoryTotal")));
        device.setMemoryAvailable(cursor.getInt(cursor.getColumnIndex("deviceMemoryAvailable")));

        wifi = new Wifi();
        wifi.setRssi(cursor.getInt(cursor.getColumnIndex("wifiRssi")));
        wifi.setSsid(cursor.getString(cursor.getColumnIndex("wifiSsid")));
        wifi.setSecurity(cursor.getString(cursor.getColumnIndex("wifiSecurity")));
        wifi.setState(cursor.getString(cursor.getColumnIndex("wifiState")));
        wifi.setIp(cursor.getString(cursor.getColumnIndex("wifiIp")));
        wifi.setTx(cursor.getLong(cursor.getColumnIndex("wifiTx")));
        wifi.setRx(cursor.getLong(cursor.getColumnIndex("wifiRx")));

        gps = new Gps();
        gps.setState(cursor.getString(cursor.getColumnIndex("gpsState")));
        gps.setLat(cursor.getDouble(cursor.getColumnIndex("gpsLat")));
        gps.setLon(cursor.getDouble(cursor.getColumnIndex("gpsLon")));
        gps.setAlt(cursor.getDouble(cursor.getColumnIndex("gpsAlt")));
        gps.setSpeed(cursor.getDouble(cursor.getColumnIndex("gpsSpeed")));
        gps.setCourse(cursor.getDouble(cursor.getColumnIndex("gpsCourse")));

        mobile = new Mobile();
        mobile.setRssi(cursor.getInt(cursor.getColumnIndex("mobileRssi")));
        mobile.setCarrier(cursor.getString(cursor.getColumnIndex("mobileCarrier")));
        mobile.setNumber(cursor.getString(cursor.getColumnIndex("mobileNumber")));
        mobile.setImsi(cursor.getString(cursor.getColumnIndex("mobileImsi")));
        mobile.setData(cursor.getInt(cursor.getColumnIndex("mobileData")) != 0);
        mobile.setIp(cursor.getString(cursor.getColumnIndex("mobileIp")));
        mobile.setState(cursor.getString(cursor.getColumnIndex("mobileState")));
        mobile.setSimState(cursor.getString(cursor.getColumnIndex("mobileSimState")));
        mobile.setTx(cursor.getLong(cursor.getColumnIndex("mobileTx")));
        mobile.setRx(cursor.getLong(cursor.getColumnIndex("mobileRx")));

        mobile2 = new Mobile();
        mobile2.setRssi(cursor.getInt(cursor.getColumnIndex("mobile2Rssi")));
        mobile2.setCarrier(cursor.getString(cursor.getColumnIndex("mobile2Carrier")));
        mobile2.setNumber(cursor.getString(cursor.getColumnIndex("mobile2Number")));
        mobile2.setImsi(cursor.getString(cursor.getColumnIndex("mobile2Imsi")));
        mobile2.setData(cursor.getInt(cursor.getColumnIndex("mobile2Data")) != 0);
        mobile2.setIp(cursor.getString(cursor.getColumnIndex("mobile2Ip")));
        mobile2.setState(cursor.getString(cursor.getColumnIndex("mobile2State")));
        mobile2.setSimState(cursor.getString(cursor.getColumnIndex("mobile2SimState")));
        mobile2.setTx(cursor.getLong(cursor.getColumnIndex("mobile2Tx")));
        mobile2.setRx(cursor.getLong(cursor.getColumnIndex("mobile2Rx")));
    }

    public long getId() {
        return _id;
    }

    public void setId(long _id) {
        this._id = _id;
    }

    public long getTs() {
        return ts;
    }

    public void setTs(long ts) {
        this.ts = ts;
    }

    public Device getDevice() {
        return device;
    }

    public void setDevice(Device device) {
        this.device = device;
    }

    public Wifi getWifi() {
        return wifi;
    }

    public void setWifi(Wifi wifi) {
        this.wifi = wifi;
    }

    public Gps getGps() {
        return gps;
    }

    public void setGps(Gps gps) {
        this.gps = gps;
    }

    public Mobile getMobile() {
        return mobile;
    }

    public void setMobile(Mobile mobile) {
        this.mobile = mobile;
    }

    public Mobile getMobile2() {
        return mobile2;
    }

    public void setMobile2(Mobile mobile2) {
        this.mobile2 = mobile2;
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Device {
        private Integer batteryLevel;
        private String batteryCharging;
        private Boolean wifi;
        private Boolean gps;
        private String ip;
        private Boolean keyguard;
        private Integer ringVolume;
        private Boolean mobileData;
        private Boolean bluetooth;
        private Boolean usbStorage;
        private Integer memoryTotal;
        private Integer memoryAvailable;

        public Integer getBatteryLevel() {
            return batteryLevel;
        }

        public void setBatteryLevel(Integer batteryLevel) {
            this.batteryLevel = batteryLevel;
        }

        public String getBatteryCharging() {
            return batteryCharging;
        }

        public void setBatteryCharging(String batteryCharging) {
            this.batteryCharging = batteryCharging;
        }

        public Boolean getWifi() {
            return wifi;
        }

        public void setWifi(Boolean wifi) {
            this.wifi = wifi;
        }

        public Boolean getGps() {
            return gps;
        }

        public void setGps(Boolean gps) {
            this.gps = gps;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public Boolean getKeyguard() {
            return keyguard;
        }

        public void setKeyguard(Boolean keyguard) {
            this.keyguard = keyguard;
        }

        public Integer getRingVolume() {
            return ringVolume;
        }

        public void setRingVolume(Integer ringVolume) {
            this.ringVolume = ringVolume;
        }

        public Boolean getMobileData() {
            return mobileData;
        }

        public void setMobileData(Boolean mobileData) {
            this.mobileData = mobileData;
        }

        public Boolean getBluetooth() {
            return bluetooth;
        }

        public void setBluetooth(Boolean bluetooth) {
            this.bluetooth = bluetooth;
        }

        public Boolean getUsbStorage() {
            return usbStorage;
        }

        public void setUsbStorage(Boolean usbStorage) {
            this.usbStorage = usbStorage;
        }

        public Integer getMemoryTotal() {
            return memoryTotal;
        }

        public void setMemoryTotal(Integer memoryTotal) {
            this.memoryTotal = memoryTotal;
        }

        public Integer getMemoryAvailable() {
            return memoryAvailable;
        }

        public void setMemoryAvailable(Integer memoryAvailable) {
            this.memoryAvailable = memoryAvailable;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Wifi {
        private Integer rssi;
        private String ssid;
        private String security;
        private String state;
        private String ip;
        private Long tx;
        private Long rx;

        public Integer getRssi() {
            return rssi;
        }

        public void setRssi(Integer rssi) {
            this.rssi = rssi;
        }

        public String getSsid() {
            return ssid;
        }

        public void setSsid(String ssid) {
            this.ssid = ssid;
        }

        public String getSecurity() {
            return security;
        }

        public void setSecurity(String security) {
            this.security = security;
        }

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public Long getTx() {
            return tx;
        }

        public void setTx(Long tx) {
            this.tx = tx;
        }

        public Long getRx() {
            return rx;
        }

        public void setRx(Long rx) {
            this.rx = rx;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Gps {
        private String state;
        private String provider;
        private Double lat;
        private Double lon;
        private Double alt;
        private Double speed;
        private Double course;

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getProvider() {
            return provider;
        }

        public void setProvider(String provider) {
            this.provider = provider;
        }

        public Double getLat() {
            return lat;
        }

        public void setLat(Double lat) {
            this.lat = lat;
        }

        public Double getLon() {
            return lon;
        }

        public void setLon(Double lon) {
            this.lon = lon;
        }

        public Double getAlt() {
            return alt;
        }

        public void setAlt(Double alt) {
            this.alt = alt;
        }

        public Double getSpeed() {
            return speed;
        }

        public void setSpeed(Double speed) {
            this.speed = speed;
        }

        public Double getCourse() {
            return course;
        }

        public void setCourse(Double course) {
            this.course = course;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Mobile {
        private Integer rssi;
        private String carrier;
        private String number;
        private String imsi;
        private Boolean data;
        private String ip;
        private String state;
        private String simState;
        private Long tx;
        private Long rx;

        public Integer getRssi() {
            return rssi;
        }

        public void setRssi(Integer rssi) {
            this.rssi = rssi;
        }

        public String getCarrier() {
            return carrier;
        }

        public void setCarrier(String carrier) {
            this.carrier = carrier;
        }

        public String getNumber() {
            return number;
        }

        public void setNumber(String number) {
            this.number = number;
        }

        public String getImsi() {
            return imsi;
        }

        public void setImsi(String imsi) {
            this.imsi = imsi;
        }

        public Boolean getData() {
            return data;
        }

        public void setData(Boolean data) {
            this.data = data;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getSimState() {
            return simState;
        }

        public void setSimState(String simState) {
            this.simState = simState;
        }

        public Long getTx() {
            return tx;
        }

        public void setTx(Long tx) {
            this.tx = tx;
        }

        public Long getRx() {
            return rx;
        }

        public void setRx(Long rx) {
            this.rx = rx;
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteFile.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteFile {
    @JsonIgnore
    private long _id;

    private String url;
    private String path;
    private long lastUpdate;
    private String checksum;
    private boolean remove;
    private String description;
    private boolean varContent;

    public RemoteFile() {}

    public RemoteFile(RemoteFile remoteFile) {
        _id = remoteFile._id;
        lastUpdate = remoteFile.lastUpdate;
        url = remoteFile.url;
        checksum = remoteFile.checksum;
        remove = remoteFile.remove;
        path = remoteFile.path;
        description = remoteFile.description;
        varContent = remoteFile.varContent;
    }

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getChecksum() {
        return checksum;
    }

    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }

    public boolean isRemove() {
        return remove;
    }

    public void setRemove(boolean remove) {
        this.remove = remove;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean isVarContent() {
        return varContent;
    }

    public void setVarContent(boolean varContent) {
        this.varContent = varContent;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/StatusControlService.java">
package com.hmdm.launcher.service;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiManager;
import android.os.IBinder;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.Utils;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class StatusControlService extends Service {

    private SettingsHelper settingsHelper;
    private ScheduledThreadPoolExecutor threadPoolExecutor = new ScheduledThreadPoolExecutor( 1 );
    private boolean controlDisabled = false;
    private Timer disableControlTimer;

    private final long ENABLE_CONTROL_DELAY = 60;

    private final long STATUS_CHECK_INTERVAL_MS = 10000;

    private static class PackageInfo {
        public String packageName;
        public String className;

        public PackageInfo(String packageName, String className) {
            this.packageName = packageName;
            this.className = className;
        }
    }

    private BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            switch ( intent.getAction() ) {
                case Const.ACTION_SERVICE_STOP:
                    stopSelf();
                    break;
                case Const.ACTION_STOP_CONTROL:
                    disableControl();
                    break;
            }
        }
    };

    @Override
    public void onDestroy() {
        LocalBroadcastManager.getInstance( this ).unregisterReceiver( receiver );

        threadPoolExecutor.shutdownNow();
        threadPoolExecutor = new ScheduledThreadPoolExecutor( 1 );

        Log.i(Const.LOG_TAG, "StatusControlService: service stopped");

        super.onDestroy();
    }

    @Override
    public int onStartCommand( Intent intent, int flags, int startId) {
        settingsHelper = SettingsHelper.getInstance(this);

        Log.i(Const.LOG_TAG, "StatusControlService: service started.");

        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);

        IntentFilter intentFilter = new IntentFilter(Const.ACTION_SERVICE_STOP);
        intentFilter.addAction(Const.ACTION_STOP_CONTROL);
        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, intentFilter);

        threadPoolExecutor.shutdownNow();

        threadPoolExecutor = new ScheduledThreadPoolExecutor(1);
        threadPoolExecutor.scheduleWithFixedDelay(() -> controlStatus(),
                STATUS_CHECK_INTERVAL_MS, STATUS_CHECK_INTERVAL_MS, TimeUnit.MILLISECONDS);

        return Service.START_STICKY;
    }


    private void disableControl() {
        Log.i(Const.LOG_TAG, "StatusControlService: request to disable control");

        if (disableControlTimer != null) {
            try {
                disableControlTimer.cancel();
            } catch (Exception e) {
            }
            disableControlTimer = null;
        }
        controlDisabled = true;
        disableControlTimer = new Timer();
        disableControlTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                controlDisabled = false;
                Log.i(Const.LOG_TAG, "StatusControlService: control enabled");
            }
        }, ENABLE_CONTROL_DELAY * 1000);
        Log.i(Const.LOG_TAG, "StatusControlService: control disabled for 60 sec");
    }

    private void controlStatus() {
        ServerConfig config = settingsHelper.getConfig();
        if (config == null || controlDisabled) {
            return;
        }

        if (config.getBluetooth() != null) {
            try {
                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                if (bluetoothAdapter != null) {
                    boolean enabled = bluetoothAdapter.isEnabled();
                    if (config.getBluetooth() && !enabled) {
                        bluetoothAdapter.enable();
                    } else if (!config.getBluetooth() && enabled) {
                        bluetoothAdapter.disable();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        // Note: SecurityException here on Mediatek
        // Looks like com.mediatek.permission.CTA_ENABLE_WIFI needs to be explicitly granted
        // or even available to system apps only
        // By now, let's just ignore this issue
        if (config.getWifi() != null) {
            try {
                WifiManager wifiManager = (WifiManager) this.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
                if (wifiManager != null) {
                    boolean enabled = wifiManager.isWifiEnabled();
                    if (config.getWifi() && !enabled) {
                        wifiManager.setWifiEnabled(true);
                    } else if (!config.getWifi() && enabled) {
                        wifiManager.setWifiEnabled(false);
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (config.getGps() != null) {
            LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
            if (lm != null) {
                boolean enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
                if (config.getGps() && !enabled) {
                    notifyStatusViolation(Const.GPS_ON_REQUIRED);
                    return;
                } else if (!config.getGps() && enabled) {
                    notifyStatusViolation(Const.GPS_OFF_REQUIRED);
                    return;
                }
            }
        }

        if (config.getMobileData() != null) {
            ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm != null) {
                try {
                    boolean enabled = Utils.isMobileDataEnabled(this);
                    if (config.getMobileData() && !enabled) {
                        notifyStatusViolation(Const.MOBILE_DATA_ON_REQUIRED);
                    } else if (!config.getMobileData() && enabled) {
                        notifyStatusViolation(Const.MOBILE_DATA_OFF_REQUIRED);
                    }
                } catch (Exception e) {
                    // Some problem access private API
                }
            }
        }
    }

    private void notifyStatusViolation(int cause) {
        Intent intent = new Intent(Const.ACTION_POLICY_VIOLATION);
        intent.putExtra(Const.POLICY_VIOLATION_CAUSE, cause);
        LocalBroadcastManager.getInstance(this).sendBroadcast(intent);
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AdminModeRequestActivity.java">
package com.hmdm.launcher.ui;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.hmdm.launcher.R;
import com.hmdm.launcher.util.LegacyUtils;

/**
 * There is a weird bug: MainActivity cannot open intent ACTION_ADD_DEVICE_ADMIN
 * because it is declared as "singleInstance" (???).
 * To work around this issue, I created a simple proxy activity which does the same
 */
public class AdminModeRequestActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(this);
        Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, adminComponentName);
        try {
            startActivityForResult(intent, 1);
        } catch (/*ActivityNotFound*/Exception e) {
            Toast.makeText(this, getString(R.string.admin_not_supported), Toast.LENGTH_LONG).show();
            finish();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        setResult(resultCode);
        finish();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BottomAppListAdapter.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.view.LayoutInflater;

public class BottomAppListAdapter extends BaseAppListAdapter {
    private LayoutInflater layoutInflater;

    public BottomAppListAdapter(Activity parentActivity, OnAppChooseListener appChooseListener, SwitchAdapterListener switchAdapterListener) {
        super(parentActivity, appChooseListener, switchAdapterListener);
        items = AppShortcutManager.getInstance().getInstalledApps(parentActivity, true);
        initShortcuts();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/ErrorDetailsActivity.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityErrorDetailsBinding;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class ErrorDetailsActivity extends AppCompatActivity {
    private ActivityErrorDetailsBinding binding;

    public static final String MESSAGE = "MESSAGE";
    public static final String RESET_ENABLED = "RESET_ENABLED";

    public static void display(Activity parent, String message, boolean resetEnabled) {
        Intent intent = new Intent(parent, ErrorDetailsActivity.class);
        intent.putExtra(MESSAGE, message);
        intent.putExtra(RESET_ENABLED, resetEnabled);
        parent.startActivity(intent);
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);
        binding = DataBindingUtil.setContentView(this, R.layout.activity_error_details);

        Intent intent = getIntent();
        boolean resetEnabled = intent.getBooleanExtra(RESET_ENABLED, false);
        binding.resetButton.setVisibility(resetEnabled ? View.VISIBLE : View.GONE);

        String message = intent.getStringExtra(MESSAGE);
        binding.editMessage.setText(message);
    }

    public void resetClicked(View view) {
        // Factory reset!!!
        if (!Utils.factoryReset(this)) {
            RemoteLogger.log(this, Const.LOG_WARN, "Device reset failed");
        }
        finish();
    }

    public void closeClicked(View view) {
        finish();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MainAppListAdapter.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.app.Activity;

/**
 * Created by Ivan Lozenko on 21.02.2017.
 */

public class MainAppListAdapter extends BaseAppListAdapter {

    public MainAppListAdapter(Activity parentActivity, OnAppChooseListener appChooseListener, SwitchAdapterListener switchAdapterListener) {
        super(parentActivity, appChooseListener, switchAdapterListener);
        items = AppShortcutManager.getInstance().getInstalledApps(parentActivity, false);
        initShortcuts();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/XapkUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.Context;
import android.content.pm.PackageInstaller;
import android.os.Build;
import android.util.Log;

import com.hmdm.launcher.Const;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class XapkUtils {
    public static List<File> extract(Context context, File xapk) {
        // Here we presume that xapk file name ends with .xapk
        try {
            String extractDir = xapk.getName().substring(0, xapk.getName().length() - 5);
            File extractDirFile = new File(context.getExternalFilesDir(null), extractDir);
            if (extractDirFile.isDirectory()) {
                FileUtils.deleteDirectory(extractDirFile);
            } else if (extractDirFile.exists()) {
                extractDirFile.delete();
            }
            extractDirFile.mkdirs();

            List<File> result = new LinkedList<File>();

            ZipFile zipFile = new ZipFile(xapk);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();

            while(entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                if (entry.getName().endsWith(".apk")) {
                    InputStream inputStream = zipFile.getInputStream(entry);
                    File resultFile = new File(extractDirFile, entry.getName());
                    FileOutputStream outputStream = new FileOutputStream(resultFile);
                    IOUtils.copy(inputStream, outputStream);
                    inputStream.close();
                    outputStream.close();
                    result.add(resultFile);
                }

            }
            zipFile.close();
            return result;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void install(Context context, List<File> files, String packageName, InstallUtils.InstallErrorHandler errorHandler) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        if (files == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Failed to unpack XAPK for " + packageName + " - ignoring installation");
            if (errorHandler != null) {
                errorHandler.onInstallError(null);
            }
            return;
        }
        long totalSize = 0;
        for (File file : files) {
            totalSize += file.length();
        }

        try {
            Log.i(Const.LOG_TAG, "Installing XAPK " + packageName);
            PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
            PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(
                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);
            if (packageName != null) {
                params.setAppPackageName(packageName);
            }
            params.setSize(totalSize);
            int sessionId = packageInstaller.createSession(params);

            for (File file : files) {
                addFileToSession(sessionId, file, packageInstaller);
            }

            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            session.commit(InstallUtils.createIntentSender(context, sessionId, packageName));
            session.close();
            Log.i(Const.LOG_TAG, "Installation session committed");

        } catch (Exception e) {
            if (errorHandler != null) {
                errorHandler.onInstallError(e.getMessage());
            }
        }
    }

    private static void addFileToSession(int sessionId, File file, PackageInstaller packageInstaller) throws IOException {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        FileInputStream in = new FileInputStream(file);
        // set params
        PackageInstaller.Session session = packageInstaller.openSession(sessionId);
        OutputStream out = session.openWrite(file.getName(), 0, file.length());
        byte[] buffer = new byte[65536];
        int c;
        while ((c = in.read(buffer)) != -1) {
            out.write(buffer, 0, c);
        }
        session.fsync(out);
        in.close();
        out.close();
        session.close();
    }

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttAndroidClient.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *   
 *   Ian Craggs - Per subscription message handlers bug 466579
 *   Ian Craggs - ack control (bug 472172)
 *   
 */
package org.eclipse.paho.android.service;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.util.SparseArray;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;

import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;
import org.eclipse.paho.client.mqttv3.MqttToken;

import java.io.IOException;
import java.io.InputStream;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;

/**
 * Enables an android application to communicate with an MQTT server using non-blocking methods.
 * <p>
 * Implementation of the MQTT asynchronous client interface {@link IMqttAsyncClient} , using the MQTT
 * android service to actually interface with MQTT server. It provides android applications a simple programming interface to all features of the MQTT version 3.1
 * specification including:
 * </p>
 * <ul>
 * <li>connect
 * <li>publish
 * <li>subscribe
 * <li>unsubscribe
 * <li>disconnect
 * </ul>
 */
public class MqttAndroidClient extends BroadcastReceiver implements
		IMqttAsyncClient {

	/**
	 * 
	 * The Acknowledgment mode for messages received from {@link MqttCallback#messageArrived(String, MqttMessage)}
	 *
	 */
	public enum Ack {
		/**
		 * As soon as the {@link MqttCallback#messageArrived(String, MqttMessage)} returns,
		 * the message has been acknowledged as received .
		 */
		AUTO_ACK,
		/**
		 * When {@link MqttCallback#messageArrived(String, MqttMessage)} returns, the message
		 * will not be acknowledged as received, the application will have to make an acknowledgment call
		 * to {@link MqttAndroidClient} using {@link MqttAndroidClient#acknowledgeMessage(String)}
		 */
		MANUAL_ACK
	}

	public static final String SERVICE_NAME = "org.eclipse.paho.android.service.MqttService";

	public static final String EXTRA_START_AT_BOOT = "START_AT_BOOT";
	public static final String EXTRA_DOMAIN = "DOMAIN";
	public static final String EXTRA_KEEPALIVE_TIME = "KEEPALIVE_TIME";
	public static final String EXTRA_PUSH_OPTIONS = "PUSH_OPTIONS";
	public static final String EXTRA_DEVICE_ID = "DEVICE_ID";

	private static final int BIND_SERVICE_FLAG = 0;

	private static final ExecutorService pool = Executors.newCachedThreadPool();

	/**
	 * ServiceConnection to process when we bind to our service
	 */
	private final class MyServiceConnection implements ServiceConnection {

		@Override
		public void onServiceConnected(ComponentName name, IBinder binder) {
			mqttService = ((MqttServiceBinder) binder).getService();
			bindedService = true;
			// now that we have the service available, we can actually
			// connect...
			doConnect();
		}

		@Override
		public void onServiceDisconnected(ComponentName name) {
			mqttService = null;
		}
	}

	// Listener for when the service is connected or disconnected
	private final MyServiceConnection serviceConnection = new MyServiceConnection();

	// The Android Service which will process our mqtt calls
	private MqttService mqttService;

	// An identifier for the underlying client connection, which we can pass to
	// the service
	private String clientHandle;

	private Context myContext;

	// We hold the various tokens in a collection and pass identifiers for them
	// to the service
	private final SparseArray<IMqttToken> tokenMap = new SparseArray<>();
	private int tokenNumber = 0;

	// Connection data
	private final String serverURI;
	private final String clientId;
	private MqttClientPersistence persistence = null;
	private MqttConnectOptions connectOptions;
	private IMqttToken connectToken;

	// The MqttCallback provided by the application
	private MqttCallback callback;
	private MqttTraceHandler traceCallback;

	// Default message listener (called if any messages are delivered before calling subscribe()
	private IMqttMessageListener defaultMessageListener;

	//The acknowledgment that a message has been processed by the application
	private final Ack messageAck;
	private boolean traceEnabled = false;
	
	private volatile boolean receiverRegistered = false;
	private volatile boolean bindedService = false;

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android
	 * 
	 * @param context 
	 *            object used to pass context to the callback. 
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 */
	public MqttAndroidClient(Context context, String serverURI,
			String clientId) {
		this(context, serverURI, clientId, null, Ack.AUTO_ACK);
	}

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param ctx
	 *            Application's context
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param ackType
	 *            how the application wishes to acknowledge a message has been
	 *            processed
	 */
	public MqttAndroidClient(Context ctx, String serverURI, String clientId, Ack ackType) {
		this(ctx, serverURI, clientId, null, ackType);
	}

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param ctx
	 *            Application's context
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param persistence
	 *            The object to use to store persisted data
	 */
	public MqttAndroidClient(Context ctx, String serverURI, String clientId, MqttClientPersistence persistence) {
		this(ctx, serverURI, clientId, persistence, Ack.AUTO_ACK);
	}

	/**
	 * Constructor- create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param context
	 *            used to pass context to the callback.
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param persistence
	 *            the persistence class to use to store in-flight message. If
	 *            null then the default persistence mechanism is used
	 * @param ackType
	 *            how the application wishes to acknowledge a message has been
	 *            processed.
	 */
	public MqttAndroidClient(Context context, String serverURI,
			String clientId, MqttClientPersistence persistence, Ack ackType) {
		myContext = context;
		this.serverURI = serverURI;
		this.clientId = clientId;
		this.persistence = persistence;
		messageAck = ackType;
	}

	 /**
	 * Determines if this client is currently connected to the server.
	 *
	 * @return <code>true</code> if connected, <code>false</code> otherwise.
	 */
	@Override
	public boolean isConnected() {

		return clientHandle != null && mqttService != null && mqttService.isConnected(clientHandle);
	}

	/**
	 * Returns the client ID used by this client.
	 * <p>
	 * All clients connected to the same server or server farm must have a
	 * unique ID.
	 * </p>
	 * 
	 * @return the client ID used by this client.
	 */
	@Override
	public String getClientId() {
		return clientId;
	}


	/**
	 * Sets the default message listener
	 * <p>
	 * Default message listener is called if messages are arrived
	 * before subscribe() is called
	 * </p>
	 * @param defaultMessageListener
	 *            default message listener or null if no listener required.
	 *
	 */
	public void setDefaultMessageListener(IMqttMessageListener defaultMessageListener) {
		this.defaultMessageListener = defaultMessageListener;
	}

	/**
	 * Returns the URI address of the server used by this client.
	 * <p>
	 * The format of the returned String is the same as that used on the
	 * constructor.
	 * </p>
	 * 
	 * @return the server's address, as a URI String.
	 */
	@Override
	public String getServerURI() {
		return serverURI;
	}

	/**
	 * Close the client. Releases all resource associated with the client. After
	 * the client has been closed it cannot be reused. For instance attempts to
	 * connect will fail.
	 *
	 */
	@Override
	public void close() {
		if(mqttService != null){
			if (clientHandle == null) {
				clientHandle = mqttService.getClient(serverURI, clientId, myContext.getApplicationInfo().packageName,persistence,defaultMessageListener);
			}
			mqttService.close(clientHandle);
		}
	}
	
	/**
	 * Connects to an MQTT server using the default options.
	 * <p>
	 * The default options are specified in {@link MqttConnectOptions} class.
	 * </p>
	 * 
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to the callback methods if a callback is
	 *         set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect() throws MqttException {
		return connect(null, null);
	}

	
	/**
	 * Connects to an MQTT server using the provided connect options.
	 * <p>
	 * The connection will be established using the options specified in the
	 * {@link MqttConnectOptions} parameter.
	 * </p>
	 * 
	 * @param options
	 *            a set of connection parameters that override the defaults.
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect(MqttConnectOptions options) throws MqttException {
		return connect(options, null, null);
	}

	/**
	 * Connects to an MQTT server using the default options.
	 * <p>
	 * The default options are specified in {@link MqttConnectOptions} class.
	 * </p>
	 * 
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the connect
	 *            completes. Use null if not required.
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect(Object userContext, IMqttActionListener callback)
			throws MqttException {
		return connect(new MqttConnectOptions(), userContext, callback);
	}

	/**
	 * Connects to an MQTT server using the specified options.
	 * <p>
	 * The server to connect to is specified on the constructor. It is
	 * recommended to call {@link #setCallback(MqttCallback)} prior to
	 * connecting in order that messages destined for the client can be accepted
	 * as soon as the client is connected.
	 * </p>
	 *
	 * <p>
	 * The method returns control before the connect completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 *
	 * 
	 * @param options
	 *            a set of connection parameters that override the defaults.
	 * @param userContext
	 *            optional object for used to pass context to the callback. Use
	 *            null if not required.
	 * @param callback
	 *            optional listener that will be notified when the connect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for any connected problems, including communication errors
	 */

	@Override
	public IMqttToken connect(MqttConnectOptions options, Object userContext,
			IMqttActionListener callback) throws MqttException {

		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);

		connectOptions = options;
		connectToken = token;

		/*
		 * The actual connection depends on the service, which we start and bind
		 * to here, but which we can't actually use until the serviceConnection
		 * onServiceConnected() method has run (asynchronously), so the
		 * connection itself takes place in the onServiceConnected() method
		 */
		if (mqttService == null) { // First time - must bind to the service
			Intent serviceStartIntent = new Intent();
			serviceStartIntent.setClassName(myContext, SERVICE_NAME);
			Object service = BuildConfig.MQTT_SERVICE_FOREGROUND && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
					myContext.startForegroundService(serviceStartIntent) :
					myContext.startService(serviceStartIntent);
			if (service == null) {
				IMqttActionListener listener = token.getActionCallback();
				if (listener != null) {
					listener.onFailure(token, new RuntimeException(
							"cannot start service " + SERVICE_NAME));
				}
			}

			// We bind with BIND_SERVICE_FLAG (0), leaving us the manage the lifecycle
			// until the last time it is stopped by a call to stopService()
			myContext.bindService(serviceStartIntent, serviceConnection,
					Context.BIND_AUTO_CREATE);

			if (!receiverRegistered) registerReceiver(this);
		}
		else {
			pool.execute(new Runnable() {

				@Override
				public void run() {
					doConnect();
					
					//Register receiver to show shoulder tap.
					if (!receiverRegistered) registerReceiver(MqttAndroidClient.this);
				}

			});
		}

		return token;
	}

	private void registerReceiver(BroadcastReceiver receiver) {
		IntentFilter filter = new IntentFilter();
				filter.addAction(MqttServiceConstants.CALLBACK_TO_ACTIVITY);
				LocalBroadcastManager.getInstance(myContext).registerReceiver(receiver, filter);
				receiverRegistered = true;
	}

	/**
	 * Actually do the mqtt connect operation
	 */
	private void doConnect() {
		if (clientHandle == null) {
			clientHandle = mqttService.getClient(serverURI, clientId,myContext.getApplicationInfo().packageName,
					persistence, defaultMessageListener);
		}
		mqttService.setTraceEnabled(traceEnabled);
		mqttService.setTraceCallbackId(clientHandle);
		
		String activityToken = storeToken(connectToken);
		try {
			mqttService.connect(clientHandle, connectOptions, null,
					activityToken);
		}
		catch (MqttException e) {
			IMqttActionListener listener = connectToken.getActionCallback();
			if (listener != null) {
				listener.onFailure(connectToken, e);
			}
		}
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of 30 seconds
	 * for work to quiesce before disconnecting. This method must not be called
	 * from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @return token used to track and wait for disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect() throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, null,
				null);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, null, activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of the
	 * specified quiesce time for work to complete before disconnecting. This
	 * method must not be called from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @param quiesceTimeout
	 *            the amount of time in milliseconds to allow for existing work
	 *            to finish before disconnecting. A value of zero or less means
	 *            the client will not quiesce.
	 * @return token used to track and wait for disconnect to complete. The
	 *         token will be passed to the callback methods if a callback is
	 *         set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect(long quiesceTimeout) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, null,
				null);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, quiesceTimeout, null,
				activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of 30 seconds
	 * for work to quiesce before disconnecting. This method must not be called
	 * from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the disconnect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect(Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, null, activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * The client will wait for {@link MqttCallback} methods to complete. It
	 * will then wait for up to the quiesce timeout to allow for work which has
	 * already been initiated to complete. For instance when a QoS 2 message has
	 * started flowing to the server but the QoS 2 flow has not completed.It
	 * prevents new messages being accepted and does not send any messages that
	 * have been accepted but not yet started delivery across the network to the
	 * server. When work has completed or after the quiesce timeout, the client
	 * will disconnect from the server. If the cleanSession flag was set to
	 * false and next time it is also set to false in the connection, the
	 * messages made in QoS 1 or 2 which were not previously delivered will be
	 * delivered this time.
	 * </p>
	 * <p>
	 * This method must not be called from inside {@link MqttCallback} methods.
	 * </p>
	 * <p>
	 * The method returns control before the disconnect completes. Completion
	 * can be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 * 
	 * @param quiesceTimeout
	 *            the amount of time in milliseconds to allow for existing work
	 *            to finish before disconnecting. A value of zero or less means
	 *            the client will not quiesce.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the disconnect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 */
	@Override
	public IMqttToken disconnect(long quiesceTimeout, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, quiesceTimeout, null,
				activityToken);
		return token;
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * A convenience method, which will create a new {@link MqttMessage} object
	 * with a byte array payload and the specified QoS, and then publish it.
	 * </p>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param payload
	 *            the byte array to use as the payload
	 * @param qos
	 *            the Quality of Service to deliver the message at. Valid values
	 *            are 0, 1 or 2.
	 * @param retained
	 *            whether or not this message should be retained by the server.
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance, too many messages are being processed.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained) throws MqttException, MqttPersistenceException {
		return publish(topic, payload, qos, retained, null, null);
	}

	/**
	 * Publishes a message to a topic on the server. Takes an
	 * {@link MqttMessage} message and delivers it to the server at the
	 * requested quality of service.
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param message
	 *            to deliver to the server
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance client not connected.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, MqttMessage message)
			throws MqttException, MqttPersistenceException {
		return publish(topic, message, null, null);
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * A convenience method, which will create a new {@link MqttMessage} object
	 * with a byte array payload, the specified QoS and retained, then publish it.
	 * </p>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param payload
	 *            the byte array to use as the payload
	 * @param qos
	 *            the Quality of Service to deliver the message at. Valid values
	 *            are 0, 1 or 2.
	 * @param retained
	 *            whether or not this message should be retained by the server.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when message delivery
	 *            has completed to the requested quality of service
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance client not connected.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained, Object userContext, IMqttActionListener callback)
			throws MqttException, MqttPersistenceException {

		MqttMessage message = new MqttMessage(payload);
		message.setQos(qos);
		message.setRetained(retained);
		MqttDeliveryTokenAndroid token = new MqttDeliveryTokenAndroid(
				this, userContext, callback, message);
		String activityToken = storeToken(token);
		IMqttDeliveryToken internalToken = mqttService.publish(clientHandle,
				topic, payload, qos, retained, null, activityToken);
		token.setDelegate(internalToken);
		return token;
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * Once this method has returned cleanly, the message has been accepted for
	 * publication by the client and will be delivered on a background thread.
	 * In the event the connection fails or the client stops, Messages will be
	 * delivered to the requested quality of service once the connection is
	 * re-established to the server on condition that:
     * </p>
	 * <ul>
	 * <li>The connection is re-established with the same clientID
	 * <li>The original connection was made with (@link
	 * MqttConnectOptions#setCleanSession(boolean)} set to false
	 * <li>The connection is re-established with (@link
	 * MqttConnectOptions#setCleanSession(boolean)} set to false
	 * <li>Depending when the failure occurs QoS 0 messages may not be
	 * delivered.
	 * </ul>
	 * 
	 * <p>
	 * When building an application, the design of the topic tree should take
	 * into account the following principles of topic name syntax and semantics:
	 * </p>
	 * 
	 * <ul>
	 * <li>A topic must be at least one character long.</li>
	 * <li>Topic names are case sensitive. For example, <em>ACCOUNTS</em> and
	 * <em>Accounts</em> are two different topics.</li>
	 * <li>Topic names can include the space character. For example,
	 * <em>Accounts
	 * 	payable</em> is a valid topic.</li>
	 * <li>A leading "/" creates a distinct topic. For example,
	 * <em>/finance</em> is different from <em>finance</em>. <em>/finance</em>
	 * matches "+/+" and "/+", but not "+".</li>
	 * <li>Do not include the null character (Unicode <em>\x0000</em>) in any topic.</li>
	 * </ul>
	 * 
	 * <p>
	 * The following principles apply to the construction and content of a topic
	 * tree:
	 * </p>
	 * 
	 * <ul>
	 * <li>The length is limited to 64k but within that there are no limits to
	 * the number of levels in a topic tree.</li>
	 * <li>There can be any number of root nodes; that is, there can be any
	 * number of topic trees.</li>
	 * </ul>
	 * <p>
	 * The method returns control before the publish completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Setting an {@link IMqttAsyncClient#setCallback(MqttCallback)} where
	 * the {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)} method will
	 * be called.</li>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param message
	 *            to deliver to the server
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when message delivery
	 *            has completed to the requested quality of service
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance, client not connected.
	 * @see MqttMessage
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, MqttMessage message,
			Object userContext, IMqttActionListener callback)
			throws MqttException, MqttPersistenceException {
		MqttDeliveryTokenAndroid token = new MqttDeliveryTokenAndroid(
				this, userContext, callback, message);
		String activityToken = storeToken(token);
		IMqttDeliveryToken internalToken = mqttService.publish(clientHandle,
				topic, message, null, activityToken);
		token.setDelegate(internalToken);
		return token;
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 * 
	 * @param topic
	 *            the topic to subscribe to, which can include wildcards.
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttSecurityException
	 *             for security related problems
	 * @throws MqttException
	 *             for non security related problems
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String topic, int qos) throws MqttException,
			MqttSecurityException {
		return subscribe(topic, qos, null, null);
	}

	/**
	 * Subscribe to multiple topics, each topic may include wildcards.
	 * 
	 * <p>
	 * Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.
	 * </p>
	 * 
	 * @param topic
	 *            one or more topics to subscribe to, which can include
	 *            wildcards
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @return token used to track and wait for the subscription to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttSecurityException
	 *             for security related problems
	 * @throws MqttException
	 *             for non security related problems
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String[] topic, int[] qos)
			throws MqttException, MqttSecurityException {
		return subscribe(topic, qos, null, null);
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 * 
	 * @param topic
	 *            the topic to subscribe to, which can include wildcards.
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when subscribe has
	 *            completed
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error when registering the subscription.
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String topic, int qos, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback, new String[]{topic});
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topic, qos, null, activityToken);
		return token;
	}

	/**
	 * Subscribes to multiple topics, each topic may include wildcards.
	 * <p>
	 * Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.
	 * </p>
	 * <p>
	 * The {@link #setCallback(MqttCallback)} method should be called before
	 * this method, otherwise any received messages will be discarded.
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true,
	 * when connecting to the server, the subscription remains in place until
	 * either:
     * </p>
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
     * </ul>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false,
	 * when connecting to the server, the subscription remains in place
	 * until either:
     * </p>
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The next time the client connects with cleanSession set to true
	 * </ul>
	 * <p>With cleanSession set to false the MQTT server will store messages
	 * on behalf of the client when the client is not connected. The next time
	 * the client connects with the <b>same client ID</b> the server will
	 * deliver the stored messages to the client.
     * </p>
	 * 
	 * <p>
	 * The "topic filter" string is used when subscription may contain special
	 * characters, which allows you to subscribe to multiple topics at once.
	 * <dl>
	 * <dt>Topic level separator</dt>
	 * <dd>The forward slash (/) is used to separate each level within a topic
	 * tree and provide a hierarchical structure to the topic space. The use of
	 * the topic level separator is significant when the two wildcard characters
	 * are encountered in topics specified by subscribers.</dd>
	 * 
	 * <dt>Multi-level wildcard</dt>
	 * <dd>
	 * <p>
	 * The number sign (#) is a wildcard character that matches any number of
	 * levels within a topic. For example, if you subscribe to <span><span
	 * class="filepath">finance/stock/ibm/#</span></span>, you receive messages
	 * on these topics:
     * </p>
     * <ul>
     *     <li><pre>finance/stock/ibm</pre></li>
     *     <li><pre>finance/stock/ibm/closingprice</pre></li>
     *     <li><pre>finance/stock/ibm/currentprice</pre></li>
     * </ul>
	 *
	 * <p>
	 * The multi-level wildcard can represent zero or more levels. Therefore,
	 * <em>finance/#</em> can also match the singular <em>finance</em>, where
	 * <em>#</em> represents zero levels. The topic level separator is
	 * meaningless in this context, because there are no levels to separate.
	 * </p>
	 * 
	 * <p>
	 * The <span>multi-level</span> wildcard can be specified only on its own or
	 * next to the topic level separator character. Therefore, <em>#</em> and
	 * <em>finance/#</em> are both valid, but <em>finance#</em> is not valid.
	 * <span>The multi-level wildcard must be the last character used within the
	 * topic tree. For example, <em>finance/#</em> is valid but
	 * <em>finance/#/closingprice</em> is not valid.</span>
	 * </p>
	 * </dd>
	 * 
	 * <dt>Single-level wildcard</dt>
	 * <dd>
	 * <p>
	 * The plus sign (+) is a wildcard character that matches only one topic
	 * level. For example, <em>finance/stock/+</em> matches
	 * <em>finance/stock/ibm</em> and <em>finance/stock/xyz</em>, but not
	 * <em>finance/stock/ibm/closingprice</em>. Also, because the single-level
	 * wildcard matches only a single level, <em>finance/+</em> does not match
	 * <em>finance</em>.
	 * </p>
	 * 
	 * <p>
	 * Use the single-level wildcard at any level in the topic tree, and in
	 * conjunction with the multilevel wildcard. Specify the single-level
	 * wildcard next to the topic level separator, except when it is specified
	 * on its own. Therefore, <em>+</em> and <em>finance/+</em> are both valid,
	 * but <em>finance+</em> is not valid. <span>The single-level wildcard can
	 * be used at the end of the topic tree or within the topic tree. For
	 * example, <em>finance/+</em> and <em>finance/+/ibm</em> are both
	 * valid.</span>
	 * </p>
	 * </dd>
	 * </dl>
	 * <p>
	 * The method returns control before the subscribe completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the supplied token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            one or more topics to subscribe to, which can include
	 *            wildcards
	 * @param qos
	 *            the maximum quality of service to subscribe each topic
	 *            at.Messages published at a lower quality of service will be
	 *            received at the published QoS. Messages published at a higher
	 *            quality of service will be received using the QoS specified on
	 *            the subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when subscribe has
	 *            completed
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error registering the subscription.
	 * @throws IllegalArgumentException
	 *             if the two supplied arrays are not the same size.
	 */
	@Override
	public IMqttToken subscribe(String[] topic, int[] qos, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback, topic);
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topic, qos, null, activityToken);
		return token;
	}
	
	/**
	 * Subscribe to a topic, which may include wildcards.
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param userContext optional object used to pass context to the callback. Use
	 * null if not required.
	 * @param callback optional listener that will be notified when subscribe
	 * has completed
	 * @param messageListener a callback to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String topicFilter, int qos, Object userContext, IMqttActionListener callback, IMqttMessageListener messageListener) throws MqttException {

		return subscribe(new String[] {topicFilter}, new int[] {qos}, userContext, callback, new IMqttMessageListener[] {messageListener});
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param messageListener a callback to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String topicFilter, int qos, IMqttMessageListener messageListener) throws MqttException {
		
		return subscribe(topicFilter, qos, null, null, messageListener);
	}

	
	/**
	 * Subscribe to multiple topics, each of which may include wildcards.
	 *
	 * <p>Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.</p>
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilters one or more topics to subscribe to, which can include wildcards
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param messageListeners an array of callbacks to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String[] topicFilters, int[] qos, IMqttMessageListener[] messageListeners) throws MqttException {
		
		return subscribe(topicFilters, qos, null, null, messageListeners);
	}


	/**
	 * Subscribe to multiple topics, each of which may include wildcards.
	 *
	 * <p>Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.</p>
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilters one or more topics to subscribe to, which can include wildcards
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param userContext optional object used to pass context to the callback. Use
	 * null if not required.
	 * @param callback optional listener that will be notified when subscribe
	 * has completed
	 * @param messageListeners an array of callbacks to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String[] topicFilters, int[] qos, Object userContext, IMqttActionListener callback, IMqttMessageListener[] messageListeners) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext, callback, topicFilters);
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topicFilters, qos, null, activityToken, messageListeners);

		return null;
	}


	/**
	 * Requests the server unsubscribe the client from a topic.
	 * 
	 * @param topic
	 *            the topic to unsubscribe from. It must match a topic specified
	 *            on an earlier subscribe.
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String topic) throws MqttException {
		return unsubscribe(topic, null, null);
	}

	/**
	 * Requests the server to unsubscribe the client from one or more topics.
	 * 
	 * @param topic
	 *            one or more topics to unsubscribe from. Each topic must match
	 *            one specified on an earlier subscription.
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String[] topic) throws MqttException {
		return unsubscribe(topic, null, null);
	}

	/**
	 * Requests the server to unsubscribe the client from a topics.
	 * 
	 * @param topic
	 *            the topic to unsubscribe from. It must match a topic specified
	 *            on an earlier subscribe.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when unsubscribe has
	 *            completed
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String topic, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.unsubscribe(clientHandle, topic, null, activityToken);
		return token;
	}

	/**
	 * Requests the server to unsubscribe the client from one or more topics.
	 * <p>
	 * Unsubcribing is the opposite of subscribing. When the server receives the
	 * unsubscribe request it looks to see if it can find a matching
	 * subscription for the client and then removes it. After this point the
	 * server will send no more messages to the client for this subscription.
	 * </p>
	 * <p>
	 * The topic(s) specified on the unsubscribe must match the topic(s)
	 * specified in the original subscribe request for the unsubscribe to
	 * succeed
	 * </p>
	 * <p>
	 * The method returns control before the unsubscribe completes. Completion
	 * can be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            one or more topics to unsubscribe from. Each topic must match
	 *            one specified on an earlier subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when unsubscribe has
	 *            completed
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 */
	@Override
	public IMqttToken unsubscribe(String[] topic, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.unsubscribe(clientHandle, topic, null, activityToken);
		return token;
	}

	/**
	 * Returns the delivery tokens for any outstanding publish operations.
	 * <p>
	 * If a client has been restarted and there are messages that were in the
	 * process of being delivered when the client stopped, this method returns a
	 * token for each in-flight message to enable the delivery to be tracked.
	 * Alternately the {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)}
	 * callback can be used to track the delivery of outstanding messages.
	 * </p>
	 * <p>
	 * If a client connects with cleanSession true then there will be no
	 * delivery tokens as the cleanSession option deletes all earlier state. For
	 * state to be remembered the client must connect with cleanSession set to
	 * false
	 * </P>
	 * 
	 * @return zero or more delivery tokens
	 */
	@Override
	public IMqttDeliveryToken[] getPendingDeliveryTokens() {
		return mqttService.getPendingDeliveryTokens(clientHandle);
	}

	/**
	 * Sets a callback listener to use for events that happen asynchronously.
	 * <p>
	 * There are a number of events that the listener will be notified about.
	 * These include:
     * </p>
	 * <ul>
	 * <li>A new message has arrived and is ready to be processed</li>
	 * <li>The connection to the server has been lost</li>
	 * <li>Delivery of a message to the server has completed</li>
	 * </ul>
	 * <p>
	 * Other events that track the progress of an individual operation such as
	 * connect and subscribe can be tracked using the {@link MqttToken} returned
	 * from each non-blocking method or using setting a
	 * {@link IMqttActionListener} on the non-blocking method.
	 * <p>
	 * 
	 * @param callback
	 *            which will be invoked for certain asynchronous events
	 * 
	 * @see MqttCallback
	 */
	@Override
	public void setCallback(MqttCallback callback) {
		this.callback = callback;

	}
	
	/**
	 * identify the callback to be invoked when making tracing calls back into
	 * the Activity
	 * 
	 * @param traceCallback handler
	 */
	public void setTraceCallback(MqttTraceHandler traceCallback) {
		this.traceCallback = traceCallback;
	 // mqttService.setTraceCallbackId(traceCallbackId);
	}

	/**
	 * turn tracing on and off
	 * 
	 * @param traceEnabled
	 *            set <code>true</code> to enable trace, otherwise, set
	 *            <code>false</code> to disable trace
	 * 
	 */
	public void setTraceEnabled(boolean traceEnabled) {
	this.traceEnabled = traceEnabled;
	if (mqttService !=null)
			mqttService.setTraceEnabled(traceEnabled);
	}
	
	/**
	 * <p>
	 * Process incoming Intent objects representing the results of operations
	 * and asynchronous activities such as message received
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This is only a public method because the Android
	 * APIs require such.<br>
	 * This method should not be explicitly invoked.
	 * </p>
	 */
	@Override
	public void onReceive(Context context, Intent intent) {
		Bundle data = intent.getExtras();

		String handleFromIntent = data
				.getString(MqttServiceConstants.CALLBACK_CLIENT_HANDLE);

		if ((handleFromIntent == null)
				|| (!handleFromIntent.equals(clientHandle))) {
			return;
		}

		String action = data.getString(MqttServiceConstants.CALLBACK_ACTION);

		if (MqttServiceConstants.CONNECT_ACTION.equals(action)) {
			connectAction(data);
		}
		else if (MqttServiceConstants.CONNECT_EXTENDED_ACTION.equals(action)){
			connectExtendedAction(data);
		}
		else if (MqttServiceConstants.MESSAGE_ARRIVED_ACTION.equals(action)) {
			messageArrivedAction(data);
		}
		else if (MqttServiceConstants.SUBSCRIBE_ACTION.equals(action)) {
			subscribeAction(data);
		}
		else if (MqttServiceConstants.UNSUBSCRIBE_ACTION.equals(action)) {
			unSubscribeAction(data);
		}
		else if (MqttServiceConstants.SEND_ACTION.equals(action)) {
			sendAction(data);
		}
		else if (MqttServiceConstants.MESSAGE_DELIVERED_ACTION.equals(action)) {
			messageDeliveredAction(data);
		}
		else if (MqttServiceConstants.ON_CONNECTION_LOST_ACTION
				.equals(action)) {
			connectionLostAction(data);
		}
		else if (MqttServiceConstants.DISCONNECT_ACTION.equals(action)) {
			disconnected(data);
		}
		else if (MqttServiceConstants.TRACE_ACTION.equals(action)) {
			traceAction(data);
		}else{
			mqttService.traceError(MqttService.TAG, "Callback action doesn't exist.");	
		}

	}

	/**
	 * Acknowledges a message received on the
	 * {@link MqttCallback#messageArrived(String, MqttMessage)}
	 * 
	 * @param messageId
	 *            the messageId received from the MqttMessage (To access this
	 *            field you need to cast {@link MqttMessage} to
	 *            {@link ParcelableMqttMessage})
	 * @return whether or not the message was successfully acknowledged
	 */
	public boolean acknowledgeMessage(String messageId) {
		if (messageAck == Ack.MANUAL_ACK) {
			Status status = mqttService.acknowledgeMessageArrival(clientHandle, messageId);
			return status == Status.OK;
		}
		return false;

	}
	
	public void messageArrivedComplete(int messageId, int qos) throws MqttException {
		throw new UnsupportedOperationException();	
	}
	
	public void setManualAcks(boolean manualAcks) {
		throw new UnsupportedOperationException();	
	}

	/**
	 * Process the results of a connection
	 * 
	 * @param data
	 */
	private void connectAction(Bundle data) {
		IMqttToken token = connectToken;
		removeMqttToken(data);
		
		simpleAction(token, data);
	}



	/**
	 * Process a notification that we have disconnected
	 * 
	 * @param data
	 */
	private void disconnected(Bundle data) {
		clientHandle = null; // avoid reuse!
		IMqttToken token = removeMqttToken(data);
		if (token != null) {
			((MqttTokenAndroid) token).notifyComplete();
		}
		if (callback != null) {
			callback.connectionLost(null);
		}
	}

	/**
	 * Process a Connection Lost notification
	 * 
	 * @param data
	 */
	private void connectionLostAction(Bundle data) {
		if (callback != null) {
			Exception reason = (Exception) data
					.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
			callback.connectionLost(reason);
		}
	}

	private void connectExtendedAction(Bundle data){
		// This is called differently from a normal connect

		if(callback instanceof MqttCallbackExtended){
			boolean reconnect = data.getBoolean(MqttServiceConstants.CALLBACK_RECONNECT, false);
			String serverURI = data.getString(MqttServiceConstants.CALLBACK_SERVER_URI);
			((MqttCallbackExtended) callback).connectComplete(reconnect, serverURI);
		}

	}

	/**
	 * Common processing for many notifications
	 * 
	 * @param token
	 *            the token associated with the action being undertake
	 * @param data
	 *            the result data
	 */
	private void simpleAction(IMqttToken token, Bundle data) {
		if (token != null) {
			Status status = (Status) data
					.getSerializable(MqttServiceConstants.CALLBACK_STATUS);
			if (status == Status.OK) {
				((MqttTokenAndroid) token).notifyComplete();
			}
			else {
				Exception exceptionThrown = (Exception) data.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
				((MqttTokenAndroid) token).notifyFailure(exceptionThrown);
			}
		} else {
			mqttService.traceError(MqttService.TAG, "simpleAction : token is null");	
		}
	}

	/**
	 * Process notification of a publish(send) operation
	 * 
	 * @param data
	 */
	private void sendAction(Bundle data) {
		IMqttToken token = getMqttToken(data); // get, don't remove - will
		// remove on delivery
		simpleAction(token, data);
	}

	/**
	 * Process notification of a subscribe operation
	 * 
	 * @param data
	 */
	private void subscribeAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		simpleAction(token, data);
	}

	/**
	 * Process notification of an unsubscribe operation
	 * 
	 * @param data
	 */
	private void unSubscribeAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		simpleAction(token, data);
	}

	/**
	 * Process notification of a published message having been delivered
	 * 
	 * @param data
	 */
	private void messageDeliveredAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		if (token != null) {
			if (callback != null) {
				Status status = (Status) data
						.getSerializable(MqttServiceConstants.CALLBACK_STATUS);
				if (status == Status.OK && token instanceof IMqttDeliveryToken) {
					callback.deliveryComplete((IMqttDeliveryToken) token);
				}
			}
		}
	}

	/**
	 * Process notification of a message's arrival
	 * 
	 * @param data
	 */
	private void messageArrivedAction(Bundle data) {
		if (callback != null) {
			String messageId = data
					.getString(MqttServiceConstants.CALLBACK_MESSAGE_ID);
			String destinationName = data
					.getString(MqttServiceConstants.CALLBACK_DESTINATION_NAME);

			ParcelableMqttMessage message = data
					.getParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL);
			try {
				if (messageAck == Ack.AUTO_ACK) {
					callback.messageArrived(destinationName, message);
					mqttService.acknowledgeMessageArrival(clientHandle, messageId);
				}
				else {
					message.messageId = messageId;
					callback.messageArrived(destinationName, message);
				}

				// let the service discard the saved message details
			}
			catch (Exception e) {
				// Swallow the exception
			}
		}
	}
	
	/**
	 * Process trace action - pass trace data back to the callback
	 * 
	 * @param data
	 */
	private void traceAction(Bundle data) {

		if (traceCallback != null) {
			String severity = data.getString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY);
			String message =  data.getString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE);
			String tag = data.getString(MqttServiceConstants.CALLBACK_TRACE_TAG);
			if (MqttServiceConstants.TRACE_DEBUG.equals(severity)) 
				traceCallback.traceDebug(tag, message);
			else if (MqttServiceConstants.TRACE_ERROR.equals(severity)) 
				traceCallback.traceError(tag, message);
			else
			{
				Exception e = (Exception) data.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
				traceCallback.traceException(tag, message, e);
			}
		}
	}
	
	/**
	 * @param token
	 *            identifying an operation
	 * @return an identifier for the token which can be passed to the Android
	 *         Service
	 */
	private synchronized String storeToken(IMqttToken token) {
		tokenMap.put(tokenNumber, token);
		return Integer.toString(tokenNumber++);
	}

	/**
	 * Get a token identified by a string, and remove it from our map
	 * 
	 * @param data
	 * @return the token
	 */
	private synchronized IMqttToken removeMqttToken(Bundle data) {
		
		String activityToken = data.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
		if (activityToken!=null){
			int tokenNumber = Integer.parseInt(activityToken);
			IMqttToken token = tokenMap.get(tokenNumber);
			tokenMap.delete(tokenNumber);
			return token;
		}
		return null;
	}

	/**
	 * Get a token identified by a string, and remove it from our map
	 * 
	 * @param data
	 * @return the token
	 */
	private synchronized IMqttToken getMqttToken(Bundle data) {
		String activityToken = data
				.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
		return tokenMap.get(Integer.parseInt(activityToken));
	}

	/**
	 * Sets the DisconnectedBufferOptions for this client
	 * @param bufferOpts the DisconnectedBufferOptions
	 */
	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
		mqttService.setBufferOpts(clientHandle, bufferOpts);
	}

	public int getBufferedMessageCount(){
		return mqttService.getBufferedMessageCount(clientHandle);
	}

	public MqttMessage getBufferedMessage(int bufferIndex){
		return mqttService.getBufferedMessage(clientHandle, bufferIndex);
	}

	public void deleteBufferedMessage(int bufferIndex){
		mqttService.deleteBufferedMessage(clientHandle, bufferIndex);
	}
	
	/**
	 * Get the SSLSocketFactory using SSL key store and password
	 * <p>
	 * A convenience method, which will help user to create a SSLSocketFactory
	 * object
	 * </p>
	 * 
	 * @param keyStore
	 *            the SSL key store which is generated by some SSL key tool,
	 *            such as keytool in Java JDK
	 * @param password
	 *            the password of the key store which is set when the key store
	 *            is generated
	 * @return SSLSocketFactory used to connect to the server with SSL
	 *         authentication
	 * @throws MqttSecurityException
	 *             if there was any error when getting the SSLSocketFactory
	 */
	public SSLSocketFactory getSSLSocketFactory (InputStream keyStore, String password) throws MqttSecurityException {
	 try{
		 SSLContext ctx = null;
		 SSLSocketFactory sslSockFactory=null;
		 KeyStore ts;
		 ts = KeyStore.getInstance("BKS");			
		 ts.load(keyStore, password.toCharArray());
		 TrustManagerFactory tmf = TrustManagerFactory.getInstance("X509");
		 tmf.init(ts);
		 TrustManager[] tm = tmf.getTrustManagers();
		 ctx = SSLContext.getInstance("TLSv1");
		 ctx.init(null, tm, null);
		 
		 sslSockFactory=ctx.getSocketFactory();
		 return sslSockFactory;
		 
		} catch (KeyStoreException | CertificateException | IOException | NoSuchAlgorithmException | KeyManagementException e) {
			throw new MqttSecurityException(e);
		}
	}

	@Override
	public void disconnectForcibly() throws MqttException {
		throw new UnsupportedOperationException();
	}
	
	@Override
	public void disconnectForcibly(long disconnectTimeout) throws MqttException {
		throw new UnsupportedOperationException();
	}
	
	@Override
	public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout)
			throws MqttException {
		throw new UnsupportedOperationException();	
	}
	
	/**
	 * Unregister receiver which receives intent from MqttService avoids
	 * IntentReceiver leaks.
	 */
	public void unregisterResources(){
		if(myContext != null && receiverRegistered){
			synchronized (MqttAndroidClient.this) {
				LocalBroadcastManager.getInstance(myContext).unregisterReceiver(this);
				receiverRegistered = false;
			}
			if(bindedService){
				try{
					myContext.unbindService(serviceConnection);
					bindedService = false;
				}catch(IllegalArgumentException e){
					//Ignore unbind issue.
				}
			}
		}
	}
	
	/**
	 * Register receiver to receiver intent from MqttService. Call this method
	 * when activity is hidden and become to show again.
	 * 
	 * @param context
	 *            - Current activity context.
	 */
	public void registerResources(Context context){
		if(context != null){
			this.myContext = context;
			if(!receiverRegistered){
				registerReceiver(this);
			}
		}
	}
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/PingDeathDetector.java">
package org.eclipse.paho.android.service;

import android.content.Context;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

public class PingDeathDetector {
    private static PingDeathDetector instance;

    private long lastPingTimestamp = 0;

    private PingDeathDetector() {
    }

    public static PingDeathDetector getInstance() {
        if (instance == null) {
            instance = new PingDeathDetector();
        }
        return instance;
    }

    public void registerPing() {
        lastPingTimestamp = System.currentTimeMillis();
    }

    public boolean detectPingDeath(Context context) {
        Log.d(Const.LOG_TAG, "checkPingDeath(): last connect " + lastPingTimestamp + ", current time " + System.currentTimeMillis());
        boolean pingDeath = lastPingTimestamp != 0 && lastPingTimestamp < System.currentTimeMillis() - 1800000;
        if (pingDeath) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "PingDeathDetector: lastPingTimestamp=" + lastPingTimestamp +
                    ", now=" + System.currentTimeMillis());
        }
        return pingDeath;
    }
}
</file>

<file path="app/src/main/res/layout/activity_admin.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout>

    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/activity_app_list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        tools:context="com.hmdm.launcher.ui.AdminActivity"
        android:gravity="center_horizontal">

        <androidx.appcompat.widget.Toolbar
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:title="@string/admin_title"
            app:navigationIcon="@drawable/ic_arrow_back_white_24dp"
            android:id="@+id/toolbar"/>

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                >

        <TextView
            android:id="@+id/deviceId"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:textSize="20dp"
            android:gravity="center_horizontal"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            />

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_allow_settings"
            android:onClick="allowSettings"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_clear_restrictions"
            android:onClick="clearRestrictions"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_change_device_id"
            android:onClick="changeDeviceId"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_change_server_url"
            android:onClick="changeServerUrl"/>

        <Button
            android:visibility="gone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_refresh"
            android:onClick="updateConfig"/>

        <Button
            android:id="@+id/systemLauncherButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_exit"
            android:onClick="exitToSystemLauncher"/>

        <Button
            android:id="@+id/resetPermissionsButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_reset_permissions"
            android:onClick="resetPermissions"/>

        <Button
            android:id="@+id/resetNetworkButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_reset_network"
            android:onClick="resetNetworkPolicy"/>

        <Button
            android:id="@+id/rebootButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="@dimen/activity_vertical_margin"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/reboot"
            android:onClick="reboot"/>

            </LinearLayout>
        </ScrollView>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/activity_error_details.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
    </data>

    <LinearLayout
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.ErrorDetailsActivity">

        <EditText
            android:id="@+id/editMessage"
            android:layout_width="match_parent"
            android:layout_height="0px"
            android:layout_weight="1"
            android:editable="false"
            android:inputType="none"
            android:textIsSelectable="true"
            android:layout_margin="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:gravity="center_vertical|center_horizontal"
                android:layout_margin="@dimen/activity_horizontal_margin"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/resetButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/main_activity_reset"
                    android:layout_margin="@dimen/activity_vertical_margin"
                    android:background="@color/wizardPrimary"
                    android:textColor="@color/white"
                    android:onClick="resetClicked"
                    android:paddingLeft="@dimen/activity_horizontal_margin"
                    android:paddingRight="@dimen/activity_horizontal_margin"
                    ></Button>

                <Button
                    android:id="@+id/closeButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/close"
                    android:layout_margin="@dimen/activity_vertical_margin"
                    android:background="@color/wizardPrimary"
                    android:textColor="@color/white"
                    android:onClick="closeClicked"
                    android:paddingLeft="@dimen/activity_horizontal_margin"
                    android:paddingRight="@dimen/activity_horizontal_margin"
                    ></Button>

            </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/layout_application_not_allowed.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimaryDark">

    <LinearLayout
        android:focusable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:padding="@dimen/activity_horizontal_margin"
        android:layout_centerInParent="true">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="@string/access_to_app_denied"
            android:id="@+id/message"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:layout_margin="@dimen/activity_vertical_margin"
            android:textSize="@dimen/title_text_size"
            android:textStyle="bold"
            android:textColor="@color/white"
            android:id="@+id/package_id"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="@string/access_to_app_denied_2"
            android:id="@+id/message2"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin">

            <Button
                android:layout_width="@dimen/block_window_button_width"
                android:layout_height="wrap_content"
                android:id="@+id/layout_application_not_allowed_continue"
                android:textSize="@dimen/button_text_size"
                android:text="@string/dialog_app_not_allowed_close"/>

            <Button
                android:layout_width="@dimen/block_window_button_width"
                android:layout_height="wrap_content"
                android:id="@+id/layout_application_not_allowed_admin"
                android:textSize="@dimen/button_text_size"
                android:text="@string/dialog_app_not_allowed_admin"
                android:layout_marginRight="@dimen/activity_horizontal_margin"/>

        </LinearLayout>

    </LinearLayout>

</RelativeLayout>
</file>

<file path="app/src/main/res/values/styles.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="SetupWizardTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="colorPrimary">@color/wizardPrimary</item>
        <item name="colorPrimaryDark">@color/wizardPrimaryDark</item>
        <item name="colorAccent">@color/wizardAccent</item>
    </style>

</resources>
</file>

<file path="app/src/main/res/values-it/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Amministratore</string>
    <string name="install_error">Errore durante l\'installazione</string>
    <string name="file_create_error">Errore durante la creazione del file</string>
    <string name="dialog_enter_device_id_error">Questo ID non è registrato su %s. Ottieni l\'ID dalla scheda \"Dispositivi\" del pannello di controllo.</string>
    <string name="dialog_enter_device_id_qrcode">Codice QR</string>
    <string name="dialog_enter_device_id_variants">Varianti</string>
    <string name="dialog_enter_device_id_save">Salva</string>
    <string name="dialog_enter_device_id_exit">Esci</string>
    <string name="dialog_enter_device_id_title">Inserisci l\'ID dispositivo in %s</string>
    <string name="main_start_preparations">Preparazione all\'avvio</string>
    <string name="main_downloading_configuration">Aggiornamento del file di configurazione</string>
    <string name="main_downloading_content">Aggiornamento dei dati</string>
    <string name="main_update_applications">Installazione e aggiornamento delle applicazioni</string>
    <string name="dialog_root_message">Hai bisogno di accesso ROOT</string>
    <string name="main_application_start">Avvio applicazione</string>
    <string name="main_app_installing">Installazione applicazione</string>
    <string name="main_app_downloading">Download applicazione</string>
    <string name="main_app_downloading_error">Impossibile scaricare il pacchetto</string>
    <string name="main_app_removing">Disinstallazione applicazione</string>
    <string name="main_file_downloading">Download file</string>
    <string name="main_file_downloading_error">Impossibile scaricare il file</string>
    <string name="main_activity_repeat">Riprova</string>
    <string name="main_activity_reset">Reimposta</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Annulla</string> <string name="main_activity_details">Dettagli</string>
    <string name="select_system_launcher">Seleziona %s come launcher predefinito e seleziona \'Sempre\':</string>
    <string name="dialog_network_error_title">Errore di connessione a %s. Controlla la connessione Internet e riprova.</string>
    <string name="main_activity_update_config">Richiesta file di configurazione dal server</string>
    <string name="main_activity_applications_update">Aggiornamento applicazioni</string>
    <string name="dialog_overlay_settings_title">Consenti all\'app di sovrapporre altre finestre.\n\nQuesta opzione aiuta a bloccare le app indesiderate e consente lo sblocco di emergenza della modalità chiosco.\n\nTocca \"Continua\" per aprire le impostazioni. Trova la voce \"%s\", concedi l\'autorizzazione, quindi tocca \"Indietro\".</string>
    <string name="dialog_manage_storage_title">Consenti all\'app di gestire l\'archiviazione.\n\nQuesta opzione consente a Headwind MDM di gestire i file sul tuo dispositivo.</string>
    <string name="dialog_history_settings_title">Consenti all\'app di accedere ai dati di utilizzo.\n\nQuesta opzione consente il controllo di app e impostazioni.\n\nQuesta opzione potrebbe causare un consumo più rapido della batteria. Per risparmiare batteria, salta questa opzione (usa invece i servizi di accessibilità o la modalità chiosco).\n\nTocca \"Continua\" per aprire le impostazioni. Trova la voce \"%s\", concedi l\'autorizzazione, quindi tocca \"Indietro\".</string>
    <string name="dialog_history_settings_continue">Continua</string>
    <string name="dialog_history_settings_skip">Salta</string>
    <string name="dialog_unknown_sources_title">Consenti l\'installazione da fonti sconosciute. Ora si aprirà un foglio delle impostazioni. Trova \"Origini sconosciute\", consenti l\'installazione e fai clic su \"Indietro\".</string>
    <string name="dialog_unknown_sources_continue">Continua</string>
    <string name="dialog_miui_permissions_title">MIUI richiede la configurazione manuale delle autorizzazioni personalizzate. Ora si aprirà la finestra delle autorizzazioni app. Tocca \"Altre autorizzazioni\", consenti \"Visualizza finestre pop-up durante l\'esecuzione in background\" e fai clic su \"Indietro\".</string>
    <string name="dialog_miui_developer_title">MIUI richiede la configurazione manuale del tuo dispositivo. Nella schermata informativa, TOCCA 7 VOLTE SU \"NUMERO BUILD\". Ciò abiliterà le impostazioni sviluppatore.</string>
    <string name="dialog_miui_optimization_title">MIUI richiede la configurazione manuale del tuo dispositivo. Ora si aprirà la finestra delle impostazioni sviluppatore. Scorri la schermata verso il basso e deseleziona \"Ottimizzazione MIUI\".</string>
    <string name="dialog_administrator_mode_message">Consenti all\'app di funzionare in modalità amministratore dispositivo. Si aprirà ora un foglio Impostazioni. Seleziona \"Amministratori dispositivo\", trova la voce \"%s\", attiva l\'amministratore e tocca \"Indietro\".</string>
    <string name="dialog_administrator_mode_continue">Continua</string>
    <string name="dialog_administrator_mode_skip">Salta</string>
    <string name="accessibility_service_description">Monitoraggio app attivo tramite l\'applicazione MDM</string>
    <string name="dialog_accessibility_service_message">Consenti all\'app di utilizzare i servizi di accessibilità. Si aprirà ora un foglio Impostazioni. Trova la voce \"%s\", consenti di utilizzare i servizi di accessibilità e tocca \"Indietro\".</string>
    <string name="dialog_accessibility_service_continue">Continua</string>
    <string name="dialog_accessibility_service_skip">Salta</string>
    <string name="access_to_app_denied">Il pacchetto non è consentito:</string>
    <string name="access_to_app_denied_2">Chiedi all\'amministratore di abilitare questo pacchetto nella configurazione.\n\nFai clic sul pulsante \'Chiudi\' o Home per procedere.</string>
    <string name="package_id_copied">L\'ID del pacchetto viene copiato negli appunti</string>
    <string name="dialog_app_not_allowed_close">Chiudi</string>
    <string name="dialog_app_not_allowed_admin">Amministratore</string>
    <string name="device_id">ID dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numero di serie</string>
    <string name="phone_number">Numero di telefono</string>
    <string name="launcher_version">Versione del launcher</string>
    <string name="close">Chiudi</string>
    <string name="admin_change_device_id">Cambia ID dispositivo</string>
    <string name="admin_change_server_url">Cambia URL server</string>
    <string name="admin_allow_settings">Apri impostazioni</string>
    <string name="settings_allowed">Puoi modificare le impostazioni per 3 minuti.</string>
    <string name="admin_clear_restrictions">Cancella restrizioni</string>
    <string name="permissive_mode_enabled">Puoi eseguire tutte le app per 3 minuti.</string>
    <string name="admin_refresh">Aggiorna configurazione</string>
    <string name="admin_exit">Esci al launcher di sistema</string>
    <string name="admin_reset_permissions">Controlla autorizzazioni</string>
    <string name="admin_reset_network">Reimposta policy di rete</string>
    <string name="admin_reset_network_hint">Le policy di rete sono state cancellate. Ora puoi abilitare la rete e ricaricare la configurazione.</string>
    <string name="reboot">Riavvia il dispositivo</string>
    <string name="reboot_failed">Diritti insufficienti per riavviare il dispositivo.</string>
    <string name="message_turn_on_gps">Si aprirà la schermata delle impostazioni. Attiva la posizione GPS in questa schermata e fai clic su Indietro.</string>
    <string name="message_turn_off_gps">Si aprirà la schermata delle impostazioni. DISATTIVARE la posizione GPS in questa schermata e fai clic su Indietro.</string>
    <string name="message_turn_on_mobile_data">I dati mobili sono disabilitati! Apri la barra di stato e attiva i dati mobili.</string>
    <string name="message_turn_off_mobile_data">I dati mobili sono abilitati. Apri la barra di stato e DISATTIVARE i dati mobili.</string>
    <string name="message_set_password">La qualità della tua password non è sufficientemente buona. Si aprirà la schermata delle impostazioni. Cambia la password e fai clic su Indietro.</string>
    <string name="switch_off_blockings">Disattivazione delle restrizioni...</string>
    <string name="kiosk_mode_requires_overlays">Modalità chiosco disabilitata: nessuna autorizzazione a disegnare su altre finestre. Consenti a %s di disegnare su altre finestre.</string>
    <string name="enter_admin_password">Inserisci la password amministratore</string>
    <string name="wrong_password">Password errata</string>
    <string name="dialog_enter_password_login">Accedi</string>
    <string name="dialog_enter_password_cancel">Annulla</string>
    <string name="internal_error">L\'app ha riscontrato un errore interno. Riavvia il dispositivo e riprova l\'azione.</string>
    <string name="empty_configuration">La configurazione non è impostata, riprova a ottenere dal server!</string>
    <string name="permissions_reset_hint">Chiudi il pannello di amministrazione per controllare e richiedere le autorizzazioni.</string>
    <string name="dialog_enter_server_error">Inserisci un URL del server valido.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Inserisci l\'URL del server</string>
    <string name="critical_server_failure">Esci a causa di un errore del server! Risolvi il problema e riavvia %s, oppure rimuovilo completamente e reinstallalo.</string>
    <string name="dialog_permission_title">L\'app richiede le autorizzazioni per essere eseguita. Concedi le autorizzazioni richieste.</string>
    <string name="main_activity_exit">Esci</string>
    <string name="browser_not_found">Impossibile aprire la pagina Web perché il browser non è stato trovato. Aggiungi un\'app browser alla configurazione del dispositivo.</string>
    <string name="invalid_web_link">Impossibile aprire il collegamento Web perché non è ben formato. Contatta l\'amministratore per i dettagli.</string>

    <string name="activity_not_found">Impossibile eseguire l\'azione %s perché l\'attività non è stata trovata.</string>

    <string name="location_service_text">La posizione del dispositivo è monitorata</string>

    <string name="qrcode_contents_error">Contenuto del codice QR non valido. Genera il codice QR di provisioning nel pannello Web %s.</string>

    <string name="device_locked">Questo dispositivo (%s) è stato bloccato dall\'amministratore.</string>

    <string name="fault_loop_detected">Oops, il launcher ha riscontrato un errore irreversibile! Contatta l\'amministratore di sistema.</string>

    <string name="mqtt_service_text">Le notifiche push sono attive</string>

    <string name="background_location">%s richiede l\'autorizzazione per la posizione in background. Fai clic su \'Continua\' per aprire le autorizzazioni, fai clic su \'Posizione\' e consenti di determinare sempre la posizione.</string>
    <string name="location_disable">Disabilita posizione</string>
    <string name="background_location_continue">Continua</string>
    <string name="initializing_mdm">Inizializzazione dell\'applicazione di gestione dei dispositivi mobili...</string>
    <string name="dialog_server_error_title">Il server MDM %s ha restituito una risposta non valida. Contatta l\'amministratore.</string>
    <string name="mdm_choice_message">Questo dispositivo sarà completamente gestito dalla tua organizzazione. I tuoi dati non saranno privati e potranno essere cancellati o esaminati dal tuo amministratore IT in qualsiasi momento.</string>
    <string name="work_profile_message">Questo dispositivo otterrà un profilo di lavoro gestito appartenente alla tua organizzazione. Il profilo di lavoro è separato dal tuo profilo privato e puoi passare da un profilo all\'altro in qualsiasi momento.</string>
    <string name="overlays_not_supported">Purtroppo le sovrapposizioni non sono supportate dal tuo dispositivo.</string>
    <string name="admin_not_supported">Il tuo dispositivo non ha un\'opzione di amministratore dispositivo. Fai clic su Salta per continuare.</string>
    <string name="manage_storage_not_supported">Il tuo dispositivo non ha alcuna opzione per gestire la memoria esterna.</string>
</resources>
</file>

<file path="app/src/main/res/values-tr/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Yönetici</string>
	<string name="install_error">Yükleme hatası</string>
	<string name="file_create_error">Dosya oluşturma hatası</string>
	<string name="dialog_enter_device_id_error">Bu kimlik %s adresinde kayıtlı değil. Kontrol panelinin \"Cihazlar\" sekmesinden kimliği alın.</string>
	<string name="dialog_enter_device_id_qrcode">QR kodu</string>
	<string name="dialog_enter_device_id_variants">Varyantlar</string>
	<string name="dialog_enter_device_id_save">Kaydet</string>
	<string name="dialog_enter_device_id_exit">Çıkış</string>
	<string name="dialog_enter_device_id_title">%s adresindeki cihaz kimliğini girin</string>
	<string name="main_start_preparations">Başlatmaya hazırlanıyor</string>
	<string name="main_downloading_configuration">Yapılandırma dosyası güncelleniyor</string>
	<string name="main_downloading_content">Veriler güncelleniyor</string>
	<string name="main_update_applications">Uygulamalar yükleniyor ve güncelleniyor</string>
	<string name="dialog_root_message">ROOT erişimine ihtiyacınız var</string>
	<string name="main_application_start">Uygulama başlatılıyor</string>
	<string name="main_app_installing">Uygulama yükleniyor</string>
	<string name="main_app_downloading">Uygulama indiriliyor</string>
	<string name="main_app_downloading_error">Paket indirilemedi</string>
	<string name="main_app_removing">Uygulama kaldırılıyor</string>
	<string name="main_file_downloading">Dosya indiriliyor</string>
	<string name="main_file_downloading_error">Dosya indirilemedi</string>
	<string name="main_activity_repeat">Tekrar dene</string>
	<string name="main_activity_reset">Sıfırla</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">İptal</string>
	<string name="main_activity_details">Ayrıntılar</string>
	<string name="select_system_launcher">Varsayılan başlatıcı olarak %s\'yi seçin ve \'Her Zaman\'ı işaretleyin:</string>
	<string name="dialog_network_error_title">%s\'ye bağlanırken hata oluştu. Lütfen İnternet bağlantısını kontrol edin ve tekrar deneyin.</string>
	<string name="main_activity_update_config">Sunucudan yapılandırma dosyası isteniyor</string>
	<string name="main_activity_applications_update">Uygulamalar güncelleniyor</string>
	<string name="dialog_overlay_settings_title">Lütfen uygulamanın diğer pencerelerin üzerine çizim yapmasına izin verin.\n\nBu seçenek istenmeyen uygulamaların engellenmesine yardımcı olur ve kiosk modunun acil olarak kilidini açmayı sağlar.\n\nAyarları açmak için \"Devam\" öğesine dokunun. \"%s\" öğesini bulun, izni verin ve ardından \"Geri\" öğesine dokunun.</string>
	<string name="dialog_manage_storage_title">Lütfen uygulamanın depolama alanını yönetmesine izin verin.\n\nBu seçenek Headwind MDM\'nin cihazınızdaki dosyaları yönetmesine olanak tanır.</string>
	<string name="dialog_history_settings_title">Lütfen uygulamanın kullanım verilerine erişmesine izin verin.\n\nBu seçenek uygulamaların ve ayarların kontrolünü sağlar.\n\nBu seçenek pilin daha hızlı bitmesine neden olabilir. Pil tasarrufu için bu seçeneği atlayın (bunun yerine erişilebilirlik hizmetlerini veya kiosk modunu kullanın).\n\nAyarları açmak için \"Devam\" öğesine dokunun. \"%s\" öğesini bulun, izni verin ve ardından \"Geri\" öğesine dokunun.</string>
	<string name="dialog_history_settings_continue">Devam</string>
	<string name="dialog_history_settings_skip">Atla</string>
	<string name="dialog_unknown_sources_title">Lütfen bilinmeyen kaynaklardan yüklemeye izin verin. Şimdi bir ayarlar sayfası açılacak. \"Bilinmeyen kaynaklar\" öğesini bulun, yüklemeye izin verin ve \"Geri\" öğesine tıklayın.</string>
	<string name="dialog_unknown_sources_continue">Devam</string>
	<string name="dialog_miui_permissions_title">MIUI, özel izinlerin manuel olarak ayarlanmasını gerektirir. Uygulama izinleri penceresi şimdi açılacak. \"Diğer izinler\"e dokunun, \"Arka planda çalışırken açılır pencereleri görüntüle\"ye izin verin ve \"Geri\"ye tıklayın.</string>
	<string name="dialog_miui_developer_title">MIUI cihazınızın manuel kurulumunu gerektirir. Bilgi ekranında, \"DERLEME NUMARASI\"NA 7 KEZ DOKUNUN. Bu, geliştirici ayarlarını etkinleştirecektir.</string>
	<string name="dialog_miui_optimization_title">MIUI cihazınızın manuel kurulumunu gerektirir. Geliştirici ayarları penceresi şimdi açılacaktır. Ekranı aşağı kaydırın ve \"MIUI optimizasyonu\"nun işaretini kaldırın.</string>
	<string name="dialog_administrator_mode_message">Lütfen uygulamanın cihaz yöneticisi modunda çalışmasına izin verin. Şimdi bir Ayarlar sayfası açılacaktır. \"Cihaz yöneticileri\"ni seçin, \"%s\" öğesini bulun, yöneticiyi etkinleştirin ve \"Geri\"ye dokunun.</string>
	<string name="dialog_administrator_mode_continue">Devam</string>
	<string name="dialog_administrator_mode_skip">Atla</string>
	<string name="accessibility_service_description">MDM uygulaması tarafından etkin uygulama izleme</string>
	<string name="dialog_accessibility_service_message">Lütfen uygulamanın erişilebilirlik hizmetlerini kullanmasına izin verin. Şimdi bir Ayarlar sayfası açılacaktır. \"%s\" öğesini bulun, erişilebilirlik hizmetlerini kullanmaya izin verin ve \"Geri\" öğesine dokunun.</string>
	<string name="dialog_accessibility_service_continue">Devam</string>
	<string name="dialog_accessibility_service_skip">Atla</string>
	<string name="access_to_app_denied">Pakete izin verilmiyor:</string>
	<string name="access_to_app_denied_2">Lütfen yöneticinizden yapılandırmada bu paketi etkinleştirmesini isteyin.\n\nDevam etmek için \'Kapat\' veya Ana Sayfa düğmesine tıklayın.</string>
	<string name="package_id_copied">Paket kimliği panoya kopyalandı</string>
	<string name="dialog_app_not_allowed_close">Kapat</string>
	<string name="dialog_app_not_allowed_admin">Yönetici</string>
	<string name="device_id">Cihaz Kimlik</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">Seri numarası</string>
	<string name="phone_number">Telefon numarası</string>
	<string name="launcher_version">Başlatıcı sürümü</string>
	<string name="close">Kapat</string>
	<string name="admin_change_device_id">Cihaz kimliğini değiştir</string>
	<string name="admin_change_server_url">Sunucu URL\'sini değiştir</string>
	<string name="admin_allow_settings">Ayarları aç</string>
	<string name="settings_allowed">Ayarları 3 dakika boyunca değiştirmenize izin verilir.</string>
	<string name="admin_clear_restrictions">Kısıtlamaları temizle</string>
	<string name="permissive_mode_enabled">Tüm uygulamaları 3 dakika boyunca çalıştırmanıza izin verilir.</string>
	<string name="admin_refresh">Yapılandırmayı güncelle</string>
	<string name="admin_exit">Sistem başlatıcısından çık</string>
	<string name="admin_reset_permissions">İzinleri kontrol et</string>
	<string name="admin_reset_network">Ağ politikasını sıfırla</string>
	<string name="admin_reset_network_hint">Ağ politikaları temizlendi. Artık ağı etkinleştirebilir ve yapılandırmayı yeniden yükleyebilirsiniz.</string>
	<string name="reboot">Cihazı yeniden başlat</string>
	<string name="reboot_failed">Cihazı yeniden başlatmak için yeterli hak yok.</string>
	<string name="message_turn_on_gps">Ayarlar ekranı açılacaktır. Lütfen bu ekranda GPS konumunu açın ve Geri\'ye tıklayın.</string>
	<string name="message_turn_off_gps">Ayarlar ekranı açılacaktır. Lütfen bu ekranda GPS konumunu KAPATIN ve Geri\'ye tıklayın.</string>
	<string name="message_turn_on_mobile_data">Mobil veri devre dışı! Lütfen durum çubuğunu açın ve mobil veriyi açın.</string>
	<string name="message_turn_off_mobile_data">Mobil veri etkin. Lütfen durum çubuğunu açın ve mobil veriyi KAPATIN.</string>
	<string name="message_set_password">Şifrenizin kalitesi yeterince iyi değil. Ayarlar ekranı açılacaktır. Lütfen şifreyi değiştirin ve Geri\'ye tıklayın.</string>
	<string name="switch_off_blockings">Kısıtlamalar kapatılıyor...</string>
	<string name="kiosk_mode_requires_overlays">Kiosk modu devre dışı bırakıldı: diğer pencerelerin üzerine çizim yapma izni yok. Lütfen %s\'nin diğer pencerelerin üzerine çizim yapmasına izin verin.</string>
	<string name="enter_admin_password">Yönetici şifresini girin</string>
	<string name="wrong_password">Yanlış şifre</string>
	<string name="dialog_enter_password_login">Giriş yap</string>
	<string name="dialog_enter_password_cancel">İptal</string>
	<string name="internal_error">Uygulama dahili bir hatayla karşılaştı. Lütfen cihazı yeniden başlatın ve işlemi tekrar deneyin.</string>
	<string name="empty_configuration">Yapılandırma ayarlanmadı, sunucudan almaya tekrar çalışılıyor!</string>
	<string name="permissions_reset_hint">İzinleri kontrol etmek ve talep etmek için yönetici panelini kapatın.</string>
	<string name="dialog_enter_server_error">Lütfen geçerli bir sunucu URL\'si girin.</string>
	<string name="dialog_enter_server_ok">Tamam</string>
	<string name="dialog_enter_server_title">Lütfen sunucu URL\'sini girin</string>
	<string name="critical_server_failure">Sunucu hatası nedeniyle çıkın! Lütfen sorunu düzeltin ve %s uygulamasını yeniden başlatın veya tamamen kaldırıp yeniden yükleyin.</string>
	<string name="dialog_permission_title">Uygulamanın çalışması için izinlere ihtiyaç var. Lütfen istenen izinleri verin.</string>
	<string name="main_activity_exit">Çıkış</string>
	<string name="browser_not_found">Tarayıcı bulunamadığından web sayfası açılamıyor. Lütfen cihaz yapılandırmasına bir tarayıcı uygulaması ekleyin.</string>
	<string name="invalid_web_link">Web bağlantısı düzgün biçimlendirilmediği için açılamıyor. Lütfen ayrıntılar için yöneticinizle iletişime geçin.</string>
	<string name="activity_not_found">Etkinlik bulunamadığından %s eylemi gerçekleştirilemiyor.</string>
	<string name="location_service_text">Cihaz konumu izleniyor</string>
	<string name="qrcode_contents_error">Geçersiz QR kodu içerikleri. Lütfen %s web panelinde sağlama QR kodunu oluşturun.</string>
	<string name="device_locked">Bu cihaz (%s) yönetici tarafından kilitlendi.</string>
	<string name="fault_loop_detected">Oops, başlatıcıda kurtarılamaz bir hata oluştu! Lütfen sistem yöneticinizle iletişime geçin.</string>
	<string name="mqtt_service_text">Anında bildirimler etkin</string>
	<string name="background_location">%s, arka plan konum iznini gerektirir. İzinleri açmak için \'Devam\'a tıklayın, \'Konum\'a tıklayın ve konumun her zaman belirlenmesine izin verin.</string>
	<string name="location_disable">Konumu devre dışı bırak</string>
	<string name="background_location_continue">Devam</string>
	<string name="initializing_mdm">Mobil cihaz yönetim uygulaması başlatılıyor...</string>
	<string name="dialog_server_error_title">MDM sunucusu %s geçersiz bir yanıt döndürdü. Lütfen yöneticinizle iletişime geçin.</string>
	<string name="mdm_choice_message">Bu cihaz kuruluşunuz tarafından tamamen yönetilecektir. Verileriniz özel olmayacak ve istediğiniz zaman BT yöneticiniz tarafından silinebilir veya incelenebilir.</string>
	<string name="work_profile_message">Bu cihaz kuruluşunuza ait yönetilen bir çalışma profili alacaktır. Çalışma profili özel profilinizden ayrılmıştır ve istediğiniz zaman profiller arasında geçiş yapabilirsiniz.</string>
	<string name="overlays_not_supported">Ne yazık ki cihazınız kaplamaları desteklemiyor.</string>
	<string name="admin_not_supported">Cihazınızda cihaz yöneticisi seçeneği yok. Devam etmek için Atla\'ya tıklayın.</string>
	<string name="manage_storage_not_supported">Cihazınızda harici depolamayı yönetme seçeneği bulunmuyor.</string>
</resources>
</file>

<file path="app/src/main/res/xml/network_security_config.xml">
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system"/>
            <certificates src="user"/>
        </trust-anchors>
    </base-config>
</network-security-config>
</file>

<file path="lib/src/main/aidl/com/hmdm/IMdmApi.aidl">
// IMdmApi.aidl
package com.hmdm;

// Declare any non-default types here with import statements

interface IMdmApi {
    /**
     * Get the MDM configuration (non-privileged, no sensitive info)
     */
    Bundle queryConfig();

    /**
     * Send a log message
     */
    void log(long timestamp, int level, String packageId, String message);

    /**
     * Get app preference
     */
    String queryAppPreference(String packageId, String attr);

    /**
     * Set app preference
     */
    boolean setAppPreference(String packageId, String attr, String value);

    /**
     * Send app preferences to server
     */
    void commitAppPreferences(String packageId);

    // Added in library version 1.1.3
    // All new methods should be added at the end of the AIDL file!!!

    /**
     * Get the API version supported by the launcher (1.1.3 = 113)
     */
    int getVersion();

    /**
     * Get the MDM configuration (privileged, including IMEI and serial number)
     */
    Bundle queryPrivilegedConfig(String apiKey);

    /**
     * Set a custom field to send it to the server
     */
    void setCustom(int number, String value);

    // Added in library version 1.1.5
    /**
     * Force the configuration update
     */
    void forceConfigUpdate();
}
</file>

<file path="lib/src/main/java/com/hmdm/Const.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

class Const {
    static final String SERVICE_ACTION = "com.hmdm.action.Connect";
    static final String PACKAGE = "com.hmdm.launcher";
    static final String LEGACY_PACKAGE = "ru.headwind.kiosk";
    static final String ADMIN_RECEIVER_CLASS = "com.hmdm.launcher.AdminReceiver";

    public static final String INTENT_PUSH_NOTIFICATION_PREFIX = "com.hmdm.push.";
    public static final String INTENT_PUSH_NOTIFICATION_EXTRA = "com.hmdm.PUSH_DATA";

    public static final String LOG_TAG ="HeadwindMDMAPI";

    public static final String NOTIFICATION_CONFIG_UPDATED = "com.hmdm.push.configUpdated";

    public static final int HMDM_RECONNECT_DELAY_FIRST = 5000;
    public static final int HMDM_RECONNECT_DELAY_NEXT = 60000;
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMError.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

public class MDMError {
    public int code;
    public MDMError() {
        code = 0;
    }
    public MDMError(int code) {
        this.code = code;
    }

    public static String getMessage(int code) {
        switch (code) {
            case NO_ERROR:
                return "";
            case ERROR_NO_MDM:
                return "Headwind MDM not installed";
            case ERROR_INTERNAL:
                return "Internal Headwind MDM error";
            case ERROR_GENERAL:
                return "General error";
            case ERROR_DISCONNECTED:
                return "MDM service not connected";
            case ERROR_INVALID_PARAMETER:
                return "Invalid parameter";
            case ERROR_VERSION:
                return "Please update Headwind MDM launcher";
            case ERROR_KEY_NOT_MATCH:
                return "API key is not correct";
            case ERROR_NOT_CONFIGURED:
                return "Mobile agent is not configured";
            default:
                return "Unknown error";
        }
    }

    public String getMessage() {
        return getMessage(code);
    }

    public static final int NO_ERROR = 0;
    public static final int ERROR_NO_MDM = 1;           // Headwind MDM not installed
    public static final int ERROR_INTERNAL = 2;         // Launcher internal error
    public static final int ERROR_GENERAL = 3;          // Library error
    public static final int ERROR_DISCONNECTED = 4;     // Service disconnected
    public static final int ERROR_INVALID_PARAMETER = 5;
    public static final int ERROR_VERSION = 6;          // Launcher needs to update
    public static final int ERROR_KEY_NOT_MATCH = 7;    // API key does not match
    public static final int ERROR_NOT_CONFIGURED = 8;  // Headwind MDM is not configured
}
</file>

<file path="build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
        maven {
            url 'https://maven.google.com/'
            name 'Google'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
        google()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="README.md">
# Headwind MDM: free and open-source MDM launcher

A Powerful Open Source Platform to Manage your Enterprise Android Devices

[<img src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png"
     alt="Get it on F-Droid"
     height="80">](https://f-droid.org/packages/com.hmdm.launcher/)

## Starting work

Open the project directory in Android Studio (use default settings).

## Debugging on the device

1. Connect the device by USB
2. Click "Run 'App'" icon in Android Studio
3. After successful run, add device owner rights to the app (optional).

    Run in the console
   
    `adb shell`

    Run the command in the adb console
   
    `dpm set-device-owner com.hmdm.launcher/.AdminReceiver`

## Building the APK

Build the APK after you successfully build the app.

1. Setup the keys for signing the app
2. Select Build - Generate signed Bundle / APK
3. Select the place you'd like to save APK

## Building the library

1. Select the 'lib' item in the project tree
2. Select Build - Make Module 'lib'
3. Find the library in the 'lib/build/outputs/aar' directory

## Building the project in the command line

1. Install the Gradle plugin v5.1.1 (Linux only)
2. Install Android Studio or download the standalone Android SDK
3. Create the file local.properties and store the SDK location in this file:

sdk.dir=/path/to/sdk

4. Run the command

gradlew build

5. Find the resulting APK in the app/build/outputs/apk/release/ directory.
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/CertInstaller.java">
package com.hmdm.launcher.helper;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.Build;
import android.util.Log;

import androidx.annotation.RequiresApi;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.util.LegacyUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

import java.io.IOException;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;

public class CertInstaller {
    static class CertEntry {
        public String path;
        public String cert;
        public CertEntry() {}
        public CertEntry(String path, String cert) {
            this.path = path;
            this.cert = cert;
        }
    }

    public static List<CertEntry> getCertificatesFromAssets(Context context) {
        String[] names = context.getResources().getStringArray(R.array.certificates);
        if (names == null) {
            return null;
        }
        List<CertEntry> result = new LinkedList<>();
        for (String name : names) {
            try {
                String cert = Utils.loadStreamAsString(new InputStreamReader(context.getAssets().open(name)));
                if (cert != null) {
                    result.add(new CertEntry(name, cert));
                } else {
                    Log.e(Const.LOG_TAG, "Failed to read certificate " + name);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public static List<CertEntry> getCertificatesFromFiles(Context context, String paths) {
        String[] names = paths.split("[;:,]");
        if (names == null) {
            return null;
        }
        List<CertEntry> result = new LinkedList<>();
        for (String name : names) {
            String adjustedName = name;
            if (!adjustedName.startsWith("/storage/emulated/0/")) {
                if (!adjustedName.startsWith("/")) {
                    adjustedName = "/" + adjustedName;
                }
                adjustedName = "/storage/emulated/0" + adjustedName;
            }
            try {
                String cert = Utils.loadFileAsString(adjustedName);
                if (cert != null) {
                    result.add(new CertEntry(adjustedName, cert));
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to read certificate " + adjustedName);
                }
            } catch (IOException e) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to read certificate " + adjustedName + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
        return result;
    }

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static boolean installCertificate(Context context, String cert, String path, boolean remoteLog) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            boolean res = dpm.installCaCert(adminComponentName, cert.getBytes());
            if (remoteLog) {
                if (res) {
                    RemoteLogger.log(context, Const.LOG_INFO, "Certificate installed: " + path);
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to install certificate " + path);
                }
            } else {
                if (res) {
                    Log.d(Const.LOG_TAG, "Certificate installed: " + path);
                } else {
                    Log.w(Const.LOG_TAG, "Failed to install certificate: " + path);
                }
            }
            return res;
        } catch (Exception e) {
            if (remoteLog) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to install certificate " + path + ": " + e.getMessage());
            } else {
                Log.w(Const.LOG_TAG, "Failed to install certificate " + path + ": " + e.getMessage());
            }
            e.printStackTrace();
            return false;
        }
    }

    public static void installCertificatesFromAssets(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        List<CertEntry> certs = getCertificatesFromAssets(context);
        if (certs == null || certs.size() == 0) {
            return;
        }
        for (CertEntry cert : certs) {
            // Do not log installation of certificates from assets
            // because the remote logger is not yet initialized
            installCertificate(context, cert.cert, cert.path, false);
        }
    }

    public static void installCertificatesFromFiles(Context context, String paths) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        List<CertEntry> certs = getCertificatesFromFiles(context, paths);
        if (certs == null || certs.size() == 0) {
            return;
        }
        for (CertEntry cert : certs) {
            installCertificate(context, cert.cert, cert.path, true);
        }
    }

    public static List<String> getInstalledCerts() {
        try {
            List<String> result = new LinkedList<>();
            KeyStore ks = KeyStore.getInstance("AndroidCAStore");

            if (ks != null) {
                ks.load(null, null);
                Enumeration<String> aliases = ks.aliases();

                while (aliases.hasMoreElements()) {
                    String alias = aliases.nextElement();
                    java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);
                    result.add(cert.getIssuerDN().getName());
                }

                return result;
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (java.security.cert.CertificateException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/MigrationHelper.java">
package com.hmdm.launcher.helper;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.ServerConfigResponse;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.server.ServerUrl;

import java.net.MalformedURLException;

import retrofit2.Response;

public class MigrationHelper {

    public interface CompletionHandler {
        public void onSuccess();
        public void onError(String cause);
    }

    private ServerUrl serverUrl;

    public MigrationHelper(String url) throws MalformedURLException {
        serverUrl = new ServerUrl(url);
    }

    public String getBaseUrl() {
        return serverUrl.baseUrl;
    }

    public String getServerProject() {
        return serverUrl.serverProject;
    }

    public boolean needMigrating(Context context) {
        return !serverUrl.baseUrl.equalsIgnoreCase(SettingsHelper.getInstance(context).getBaseUrl()) ||
               !serverUrl.serverProject.equalsIgnoreCase(SettingsHelper.getInstance(context).getServerProject());
    }

    // Before migration, test that URL is working well
    public void tryNewServer(final Context context, final CompletionHandler completionHandler) {
        new AsyncTask<Void, Void, String>() {
            @Override
            protected String doInBackground(Void... voids) {
                final ServerService newServer;
                try {
                    newServer = ServerServiceKeeper.createServerService(serverUrl.baseUrl);
                } catch (Exception e) {
                    return e.getMessage();
                }

                Response<ServerConfigResponse> response = null;
                SettingsHelper settingsHelper = SettingsHelper.getInstance(context);

                String deviceId = settingsHelper.getDeviceId();
                String signature = "";
                try {
                    signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + deviceId);
                } catch (Exception e) {
                }

                try {
                    response = newServer.getServerConfig(serverUrl.serverProject, deviceId, signature, Build.CPU_ABI).execute();
                } catch (Exception e) {
                    e.printStackTrace();
                }

                if (response == null) {
                    return "Network error";
                }

                if (!response.isSuccessful()) {
                    return "Bad server response: " + response.message();
                }

                if (!Const.STATUS_OK.equals(response.body().getStatus())) {
                    return "Bad server status: " + response.body().getStatus();
                }

                if (response.body().getData() == null) {
                    return "Failed to parse server response";
                }

                // We get something JSON-like, let's conclude the request has been successful!
                return null;
            }

            @Override
            protected void onPostExecute(String error) {
                if (error == null) {
                    completionHandler.onSuccess();
                } else {
                    completionHandler.onError(error);
                }
            }
        }.execute();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AppShortcutManager.java">
package com.hmdm.launcher.ui;

import android.content.Context;
import android.content.pm.ApplicationInfo;

import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.util.AppInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AppShortcutManager {

    private static AppShortcutManager instance;

    public static AppShortcutManager getInstance() {
        if (instance == null) {
            instance = new AppShortcutManager();
        }
        return instance;
    }

    public int getInstalledAppCount(Context context, boolean bottom) {
        Map<String, Application> requiredPackages = new HashMap();
        Map<String, Application> requiredLinks = new HashMap();
        getConfiguredApps(context, bottom, requiredPackages, requiredLinks);
        List<ApplicationInfo> packs = context.getPackageManager().getInstalledApplications(0);
        if (packs == null) {
            return requiredLinks.size();
        }
        // Calculate applications
        int packageCount = 0;
        for(int i = 0; i < packs.size(); i++) {
            ApplicationInfo p = packs.get(i);
            if (context.getPackageManager().getLaunchIntentForPackage(p.packageName) != null &&
                    requiredPackages.containsKey(p.packageName)) {
                packageCount++;
            }
        }
        return requiredLinks.size() + packageCount;
    }

    public List<AppInfo> getInstalledApps(Context context, boolean bottom) {
        Map<String, Application> requiredPackages = new HashMap();
        Map<String, Application> requiredLinks = new HashMap();
        getConfiguredApps(context, bottom, requiredPackages, requiredLinks);

        List<AppInfo> appInfos = new ArrayList<>();
        List<ApplicationInfo> packs = context.getPackageManager().getInstalledApplications(0);
        if (packs == null) {
            return new ArrayList<AppInfo>();
        }
        // First we display app icons
        for(int i = 0; i < packs.size(); i++) {
            ApplicationInfo p = packs.get(i);
            if ( context.getPackageManager().getLaunchIntentForPackage(p.packageName) != null &&
                    requiredPackages.containsKey( p.packageName ) ) {
                Application app = requiredPackages.get(p.packageName);
                AppInfo newInfo = new AppInfo();
                newInfo.type = AppInfo.TYPE_APP;
                newInfo.keyCode = app.getKeyCode();
                newInfo.name = app.getIconText() != null ? app.getIconText() : p.loadLabel(context.getPackageManager()).toString();
                newInfo.packageName = p.packageName;
                newInfo.iconUrl = app.getIcon();
                newInfo.screenOrder = app.getScreenOrder();
                newInfo.longTap = app.isLongTap() ? 1 : 0;
                appInfos.add(newInfo);
            }
        }

        // Then we display weblinks
        for (Map.Entry<String, Application> entry : requiredLinks.entrySet()) {
            AppInfo newInfo = new AppInfo();
            newInfo.type = entry.getValue().getType().equals(Application.TYPE_INTENT) ? AppInfo.TYPE_INTENT : AppInfo.TYPE_WEB;
            newInfo.keyCode = entry.getValue().getKeyCode();
            newInfo.name = entry.getValue().getIconText();
            newInfo.url = entry.getValue().getUrl();
            newInfo.iconUrl = entry.getValue().getIcon();
            newInfo.screenOrder = entry.getValue().getScreenOrder();
            newInfo.useKiosk = entry.getValue().isUseKiosk() ? 1 : 0;
            newInfo.intent = entry.getValue().getIntent();
            appInfos.add(newInfo);
        }

        // Apply manually set order
        Collections.sort(appInfos, new AppInfosComparator());

        return appInfos;
    }

    private void getConfiguredApps(Context context, boolean bottom, Map<String, Application> requiredPackages, Map<String, Application> requiredLinks) {
        SettingsHelper config = SettingsHelper.getInstance( context );
        if ( config.getConfig() != null ) {
            List< Application > applications = SettingsHelper.getInstance( context ).getConfig().getApplications();
            for ( Application application : applications ) {
                if (application.isShowIcon() && !application.isRemove() && (bottom == application.isBottom())) {
                    if (application.getType() == null || application.getType().equals(Application.TYPE_APP)) {
                        requiredPackages.put(application.getPkg(), application);
                    } else if (application.getType().equals(Application.TYPE_WEB)) {
                        requiredLinks.put(application.getUrl(), application);
                    } else if (application.getType().equals(Application.TYPE_INTENT)) {
                        requiredLinks.put(application.getIntent(), application);
                    }
                }
            }
        }
    }

    public class AppInfosComparator implements Comparator<AppInfo> {
        @Override
        public int compare(AppInfo o1, AppInfo o2) {
            if (o1.screenOrder == null) {
                if (o2.screenOrder == null) {
                    return 0;
                }
                return 1;
            }
            if (o2.screenOrder == null) {
                return -1;
            }
            return Integer.compare(o1.screenOrder, o2.screenOrder);
        }
    }

}
</file>

<file path="app/src/main/res/layout/activity_mdm_choice.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
    </data>

    <RelativeLayout 
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.InitialSetupActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:gravity="center"
            android:orientation="vertical"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingBottom="@dimen/activity_vertical_margin">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:gravity="center"
                android:text="@string/mdm_choice_message"
                android:textAppearance="?android:textAppearanceMedium" />

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/dialog_administrator_mode_continue"
                android:layout_marginTop="@dimen/activity_vertical_margin"
                android:background="@color/wizardPrimary"
                android:textColor="@color/white"
                android:onClick="continueSetup"
                android:paddingLeft="@dimen/activity_horizontal_margin"
                android:paddingRight="@dimen/activity_horizontal_margin"
                ></Button>

        </LinearLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_device_id.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
    </data>

    <LinearLayout
          android:focusable="true"
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/deviceIdError"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/dialog_enter_device_id_error"/>

        <TextView
            android:id="@+id/deviceIdErrorDetails"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:textColor="@color/colorAccent"
            bind:boolToVisible="@{error}"
            android:text="@string/main_activity_details"
            android:onClick="showErrorDetails"/>

        <TextView
            android:id="@+id/deviceIdPrompt"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:gravity="center_horizontal"
            android:layout_height="wrap_content"
            bind:boolToVisible="@{!error}"
            android:text="@string/dialog_enter_device_id_title"/>

        <AutoCompleteTextView
            android:focusable="true"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/device_id"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_horizontal"
            >
            <Button
                android:id="@+id/showDeviceIdQrCode"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_qrcode"
                android:onClick="showDeviceIdQrCode"/>
            <Button
                android:id="@+id/showDeviceIdVariants"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_variants"
                android:onClick="showDeviceIdVariants"/>
            <Button
                android:id="@+id/saveDeviceId"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_save"
                android:onClick="saveDeviceId"/>
            <Button
                android:id="@+id/exitDeviceId"
                bind:boolToVisible="@{error}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_exit"
                android:onClick="exitDeviceId"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_server.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
        <variable name="server" type="String"/>
    </data>

    <LinearLayout
          android:focusable="true"
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/dialog_enter_server_error"/>

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{!error}"
            android:text="@string/dialog_enter_server_title"/>

        <EditText
            android:focusable="true"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/server_url"
            android:hint="@string/dialog_enter_server_hint"
            android:text="@{server}"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_horizontal"
        >

        <Button
            android:id="@+id/showDeviceIdQrCode"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:textSize="@dimen/button_text_size_small"
            android:text="@string/dialog_enter_device_id_qrcode"
            android:onClick="showDeviceIdQrCode"/>

            <Button
                android:id="@+id/saveServerUrl"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/dialog_enter_server_ok"
                android:onClick="saveServerUrl"/>
    </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_network_error.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/title"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/dialog_network_error_title"/>

        <TextView
            android:id="@+id/details"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/main_activity_details"
            android:textColor="@color/colorAccent"
            android:layout_marginBottom="@dimen/activity_vertical_margin"
            android:onClick="networkErrorDetailsClicked"
            />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical|center_horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:id="@+id/repeatButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_repeat"
                android:onClick="networkErrorRepeatClicked"/>

            <Button
                android:id="@+id/resetButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_reset"
                android:onClick="networkErrorResetClicked"/>

            <Button
                android:id="@+id/wifiButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_wifi"
                android:onClick="networkErrorWifiClicked"/>

            <Button
                android:id="@+id/cancelButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_cancel"
                android:onClick="networkErrorCancelClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <color name="colorPrimary">#607D8B</color>
    <color name="colorPrimaryDark">#000000</color>
    <color name="colorAccent">#87d3e1</color>
    <color name="white">#ffffff</color>
    <color name="defaultBackground">#303030</color>

    <color name="wizardPrimaryDark">#ff254FAE</color>
    <color name="wizardPrimary">#ff3367d6</color>
    <color name="wizardAccent">#ff3367d6</color>

    <color name="statusBarLight">#aaffffff</color>
    <color name="statusBarDark">#aa000000</color>
</resources>
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
#Thu Sep 18 17:23:18 AST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="lib/src/main/java/com/hmdm/MDMService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

public class MDMService {
    // MDM configuration attributes
    public static final String KEY_SERVER_HOST = "SERVER_HOST";
    public static final String KEY_SECONDARY_SERVER_HOST = "SECONDARY_SERVER_HOST";
    public static final String KEY_SERVER_PATH = "SERVER_PATH";
    public static final String KEY_DEVICE_ID = "DEVICE_ID";
    public static final String KEY_CUSTOM_1 = "CUSTOM_1";
    public static final String KEY_CUSTOM_2 = "CUSTOM_2";
    public static final String KEY_CUSTOM_3 = "CUSTOM_3";
    public static final String KEY_IMEI = "IMEI";
    public static final String KEY_SERIAL = "SERIAL";
    public static final String KEY_IS_MANAGED = "IS_MANAGED";
    public static final String KEY_IS_KIOSK = "IS_KIOSK";
    public static final String KEY_ERROR = "ERROR";

    public static final int INITIAL_VERSION = 112;

    private Context context;
    private IMdmApi mdmApi;
    private RemoteServiceConnection serviceConnection;

    private static MDMService instance;

    public interface ResultHandler {
        void onMDMConnected();
        void onMDMDisconnected();
    }

    public static MDMService getInstance() {
        if (instance == null) {
            instance = new MDMService();
        }
        return instance;
    }

    /**
     * Connect to the MDM service
     * @param handler
     * @return true on success and false if no Headwind MDM installed
     */
    public boolean connect(Context context, ResultHandler handler) {
        this.context = context;
        serviceConnection = new RemoteServiceConnection(handler);

        // First we try up-to-date package
        Intent i = new Intent(Const.SERVICE_ACTION);
        i.setPackage(Const.PACKAGE);
        boolean ret = context.bindService(i, serviceConnection, Context.BIND_AUTO_CREATE);
        if (!ret) {
            android.util.Log.i("MDMService", "Failed to bind service: intent " + i.getAction() + ", package " + i.getPackage());
            // Try legacy package
            i.setPackage(Const.LEGACY_PACKAGE);
            ret = context.bindService(i, serviceConnection, Context.BIND_AUTO_CREATE);
        }
        if (!ret) {
            android.util.Log.i("MDMService", "Failed to bind legacy service: intent " + i.getAction() + ", package " + i.getPackage());
        }

        return ret;
    }

    class RemoteServiceConnection implements ServiceConnection {

        ResultHandler handler;

        public RemoteServiceConnection(ResultHandler handler) {
            super();
            this.handler = handler;
        }

        public void onServiceConnected(ComponentName name, IBinder boundService) {
            mdmApi = IMdmApi.Stub.asInterface((IBinder) boundService);
            if (handler != null) {
                handler.onMDMConnected();
            }
        }

        public void onServiceDisconnected(ComponentName name) {
            mdmApi = null;
            if (handler != null) {
                handler.onMDMDisconnected();
            }
        }
    }

    /**
     * Get version
     */
    public int getVersion() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            return mdmApi.getVersion();
        } catch (RemoteException e) {
            // No getVersion() method prior to 1.1.3, so return 0 by default
            return 0;
        }
    }

    /**
     * Request the configuration update by the app
     * This method forces the application update even if the background update is scheduled
     * Reason: this method may be called manually from a kiosk app
     */
    public void forceConfigUpdate() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            mdmApi.forceConfigUpdate();
        } catch (RemoteException e) {
            // No forceConfigUpdate() method prior to 1.1.5
        }
    }

    /**
     * Query configuration
     */
    public Bundle queryConfig() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            return mdmApi.queryConfig();
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Query configuration (including privileged fields)
     */
    public Bundle queryConfig(String apiKey) throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        if (getVersion() <= INITIAL_VERSION) {
            throw new MDMException(MDMError.ERROR_VERSION);
        }

        try {
            Bundle config = mdmApi.queryPrivilegedConfig(apiKey);
            String error = config.getString(KEY_ERROR);
            if (error != null) {
                if (error.equals("KEY_NOT_MATCH")) {
                    throw new MDMException(MDMError.ERROR_KEY_NOT_MATCH);
                } else {
                    throw new MDMException(MDMError.ERROR_INTERNAL);
                }
            }
            return config;
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Set a custom field to send its value to the server
     */
    public void setCustom(int number, String value) throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        if (getVersion() <= INITIAL_VERSION) {
            throw new MDMException(MDMError.ERROR_VERSION);
        }

        try {
            mdmApi.setCustom(number, value);
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Usage:
     * Log.v (etc)
     */
    public static class Log {
        public static final int ERROR = 1;
        public static final int WARN = 2;
        public static final int INFO = 3;
        public static final int DEBUG = 4;
        public static final int VERBOSE = 5;

        public static void log(int level, String tag, String message) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Remote logger not initialized!");
                return;
            }
            try {
                String finalMessage = tag != null ? tag + " " + message : message;
                instance.mdmApi.log(System.currentTimeMillis(), level, instance.context.getPackageName(), finalMessage);
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to send a log to Headwind MDM!");
                e.printStackTrace();
            }
        }

        public static void v(String tag, String message) {
            android.util.Log.v(tag, message);
            log(VERBOSE, tag, message);
        }

        public static void d(String tag, String message) {
            android.util.Log.d(tag, message);
            log(DEBUG, tag, message);
        }

        public static void i(String tag, String message) {
            android.util.Log.i(tag, message);
            log(INFO, tag, message);
        }

        public static void w(String tag, String message) {
            android.util.Log.w(tag, message);
            log(WARN, tag, message);
        }

        public static void e(String tag, String message) {
            android.util.Log.e(tag, message);
            log(ERROR, tag, message);
        }
    }

    public static class Preferences {

        public static String get(String attr, String defValue) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
                return defValue;
            }
            try {
                String result = instance.mdmApi.queryAppPreference(instance.context.getPackageName(), attr);
                if (result == null) {
                    return defValue;
                }
                return result;
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to get Headwind MDM app preference " + attr);
                e.printStackTrace();
            }
            return defValue;
        }

        public static boolean set(String attr, String value) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
            }
            try {
                return instance.mdmApi.setAppPreference(instance.context.getPackageName(), attr, value);
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to set Headwind MDM app preference " + attr + "=" + value);
                e.printStackTrace();
            }
            return false;
        }

        public static void apply() {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
                return;
            }
            try {
                instance.mdmApi.commitAppPreferences(instance.context.getPackageName());
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to apply Headwind MDM app preferences!");
                e.printStackTrace();
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/DatabaseHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DatabaseHelper extends SQLiteOpenHelper {
    // Next version should be 10 and versions must be increased by 10
    // to enable custom database changes
    private static final int DATABASE_VERSION = 10;
    private static final String DATABASE_NAME = "hmdm.launcher.sqlite";

    private static DatabaseHelper sInstance;

    private DatabaseHelper( Context context ) {
        super( context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    public static synchronized DatabaseHelper instance(Context context) {
        if (sInstance == null) {
            sInstance = new DatabaseHelper(context.getApplicationContext());
        }
        return sInstance;
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.beginTransaction();
        try {
            db.execSQL(LogTable.getCreateTableSql());
            db.execSQL(LogConfigTable.getCreateTableSql());
            db.execSQL(InfoHistoryTable.getCreateTableSql());
            db.execSQL(RemoteFileTable.getCreateTableSql());
            db.execSQL(LocationTable.getCreateTableSql());
            db.execSQL(DownloadTable.getCreateTableSql());
            db.setTransactionSuccessful();
        }
        catch ( Exception e ) {
            e.printStackTrace();
        }
        finally {
            db.endTransaction();
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.beginTransaction();
        try {
            if (oldVersion < 2 && newVersion >= 2) {
                db.execSQL(InfoHistoryTable.getCreateTableSql());
            }
            if (oldVersion < 3 && newVersion >= 3) {
                db.execSQL(RemoteFileTable.getCreateTableSql());
            }
            if (oldVersion < 4 && newVersion >= 4) {
                db.execSQL(InfoHistoryTable.getAlterTableAddMemoryTotalSql());
                db.execSQL(InfoHistoryTable.getAlterTableAddMemoryAvailableSql());
            }
            if (oldVersion < 5 && newVersion >= 5) {
                db.execSQL(LocationTable.getCreateTableSql());
            }
            if (oldVersion < 10 && newVersion >= 10) {
                db.execSQL(DownloadTable.getCreateTableSql());
            }
            db.setTransactionSuccessful();
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        finally {
            db.endTransaction();
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.LinkedList;
import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
@JsonInclude(JsonInclude.Include.NON_NULL)
public class DeviceInfo {

    private String model;
    private List<Integer> permissions = new LinkedList();
    private List<Application> applications = new LinkedList();
    private List<RemoteFile> files = new LinkedList();
    private String deviceId;
    private String phone;
    private String imei;
    private boolean mdmMode;
    private boolean kioskMode;
    private int batteryLevel;
    private String batteryCharging;
    private String androidVersion;
    private Boolean factoryReset;
    private Location location;
    private String launcherType;
    private String launcherPackage;
    private boolean defaultLauncher;
    private String iccid;
    private String imsi;
    private String phone2;
    private String imei2;
    private String iccid2;
    private String imsi2;
    private String cpu;
    private String serial;

    // These fields are reserved for custom builds of Headwind MDM
    private String custom1;
    private String custom2;
    private String custom3;

    public static class Location {
        private long ts;
        private double lat;
        private double lon;

        public long getTs() {
            return ts;
        }

        public void setTs(long ts) {
            this.ts = ts;
        }

        public double getLat() {
            return lat;
        }

        public void setLat(double lat) {
            this.lat = lat;
        }

        public double getLon() {
            return lon;
        }

        public void setLon(double lon) {
            this.lon = lon;
        }
    }

    public DeviceInfo() {}

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public List<Integer> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<Integer> permissions) {
        this.permissions = permissions;
    }

    public List<Application> getApplications() {
        return applications;
    }

    public void setApplications(List<Application> applications) {
        this.applications = applications;
    }

    public List<RemoteFile> getFiles() {
        return files;
    }

    public void setFiles(List<RemoteFile> files) {
        this.files = files;
    }

    public String getDeviceId() {
        return deviceId;
    }

    public void setDeviceId( String deviceId ) {
        this.deviceId = deviceId;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getImei() {
        return imei;
    }

    public void setImei(String imei) {
        this.imei = imei;
    }

    public boolean isMdmMode() {
        return mdmMode;
    }

    public void setMdmMode(boolean mdmMode) {
        this.mdmMode = mdmMode;
    }

    public boolean isKioskMode() {
        return kioskMode;
    }

    public void setKioskMode(boolean kioskMode) {
        this.kioskMode = kioskMode;
    }

    public int getBatteryLevel() {
        return batteryLevel;
    }

    public void setBatteryLevel(int batteryLevel) {
        this.batteryLevel = batteryLevel;
    }

    public String isBatteryCharging() {
        return batteryCharging;
    }

    public void setBatteryCharging(String batteryCharging) {
        this.batteryCharging = batteryCharging;
    }

    public String getAndroidVersion() {
        return androidVersion;
    }

    public void setAndroidVersion(String androidVersion) {
        this.androidVersion = androidVersion;
    }

    public Boolean getFactoryReset() {
        return factoryReset;
    }

    public void setFactoryReset(Boolean factoryReset) {
        this.factoryReset = factoryReset;
    }

    public Location getLocation() {
        return location;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    public String getLauncherType() {
        return launcherType;
    }

    public void setLauncherType(String launcherType) {
        this.launcherType = launcherType;
    }

    public String getLauncherPackage() {
        return launcherPackage;
    }

    public void setLauncherPackage(String launcherPackage) {
        this.launcherPackage = launcherPackage;
    }

    public boolean isDefaultLauncher() {
        return defaultLauncher;
    }

    public void setDefaultLauncher(boolean defaultLauncher) {
        this.defaultLauncher = defaultLauncher;
    }

    public String getIccid() {
        return iccid;
    }

    public void setIccid(String iccid) {
        this.iccid = iccid;
    }

    public String getImsi() {
        return imsi;
    }

    public void setImsi(String imsi) {
        this.imsi = imsi;
    }

    public String getPhone2() {
        return phone2;
    }

    public void setPhone2(String phone2) {
        this.phone2 = phone2;
    }

    public String getImei2() {
        return imei2;
    }

    public void setImei2(String imei2) {
        this.imei2 = imei2;
    }

    public String getIccid2() {
        return iccid2;
    }

    public void setIccid2(String iccid2) {
        this.iccid2 = iccid2;
    }

    public String getImsi2() {
        return imsi2;
    }

    public void setImsi2(String imsi2) {
        this.imsi2 = imsi2;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    public String getCustom1() {
        return custom1;
    }

    public void setCustom1(String custom1) {
        this.custom1 = custom1;
    }

    public String getCustom2() {
        return custom2;
    }

    public void setCustom2(String custom2) {
        this.custom2 = custom2;
    }

    public String getCustom3() {
        return custom3;
    }

    public void setCustom3(String custom3) {
        this.custom3 = custom3;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerServiceKeeper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.server;

import android.content.Context;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;

import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import retrofit2.converter.jackson.JacksonConverterFactory;

public class ServerServiceKeeper {

    private static ServerService serverServiceInstance;
    private static ServerService secondaryServerServiceInstance;

    // This is called after changing the server URL
    public static void resetServices() {
        serverServiceInstance = null;
        secondaryServerServiceInstance = null;
    }

    public static ServerService getServerServiceInstance(Context context) {
        if ( serverServiceInstance == null ) {
            try {
                serverServiceInstance = createServerService(SettingsHelper.getInstance(context).getBaseUrl());
            } catch (Exception e) {
                // "Invalid URL" exception. We must not be here but in the case we are here,
                // avoid crash loop by replacing the URL to the default one
                serverServiceInstance = createServerService(BuildConfig.BASE_URL);
            }
        }

        return serverServiceInstance;
    }

    public static ServerService getSecondaryServerServiceInstance(Context context) {
        if ( secondaryServerServiceInstance == null ) {
            try {
                secondaryServerServiceInstance = createServerService(SettingsHelper.getInstance(context).getSecondaryBaseUrl());
            } catch (Exception e) {
                // Here we can go if the secondary base URL is invalid
                // In this case, just return a copy of the primary instance
                secondaryServerServiceInstance = getServerServiceInstance(context);
            }
        }

        return secondaryServerServiceInstance;
    }

    // Made public for downloading from third party servers
    public static ServerService createServerService(String baseUrl) {
        return createBuilder(baseUrl, Const.CONNECTION_TIMEOUT).build().create(ServerService.class);
    }

    // For long polling, read timeout should be adjustable
    public static ServerService createServerService(String baseUrl, long readTimeout) {
        return createBuilder(baseUrl, readTimeout).build().create(ServerService.class);
    }

    private static Retrofit.Builder createBuilder(String baseUrl, long readTimeout) {
        Retrofit.Builder builder = new Retrofit.Builder();

        if (BuildConfig.TRUST_ANY_CERTIFICATE) {
            builder.client(UnsafeOkHttpClient.getUnsafeOkHttpClient());
        } else {
            OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder().
                    connectTimeout(Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS).
                    readTimeout(readTimeout, TimeUnit.MILLISECONDS).
                    writeTimeout(Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);
            builder.client(clientBuilder.build());
        }

        builder.baseUrl( baseUrl )
                .addConverterFactory( JacksonConverterFactory.create( new ObjectMapper()) );

        return builder;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/PushLongPollingService.java">
package com.hmdm.launcher.service;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.IBinder;
import android.util.Log;

import androidx.core.app.NotificationCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.PushNotificationProcessor;

import org.eclipse.paho.android.service.MqttService;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;

import retrofit2.Response;

public class PushLongPollingService extends Service {

    private boolean enabled = true;
    private boolean threadActive = false;
    private Thread pollingThread;
    // If we get an exception, we have to delay, otherwise there would be a looping
    private final long DELAY_AFTER_EXCEPTION_MS = 60000;
    // Delay between polling requests to avoid looping if the server would respond instantly
    private final long DELAY_AFTER_REQUEST_MS = 5000;
    public static String CHANNEL_ID = MqttService.class.getName();
    // A flag preventing multiple notifications for the foreground service
    boolean started = false;
    // Notification ID for the foreground service
    private static final int NOTIFICATION_ID = 113;
    private ServerService serverService;
    private ServerService secondaryServerService;

    private final BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            if (intent != null && intent.getAction() != null &&
                    intent.getAction().equals(Const.ACTION_SERVICE_STOP)) {
                enabled = false;
                stopSelf();
            }
        }
    };

    @Override
    public void onDestroy() {
        LocalBroadcastManager.getInstance( this ).unregisterReceiver(receiver);
        Log.i(Const.LOG_TAG, "PushLongPollingService: service stopped");
        started = false;
        super.onDestroy();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
        enabled = true;

        if (BuildConfig.MQTT_SERVICE_FOREGROUND && !started) {
            startAsForeground();
            started = true;
        }

        Log.i(Const.LOG_TAG, "PushLongPolling: service started. ");

        IntentFilter intentFilter = new IntentFilter(Const.ACTION_SERVICE_STOP);
        LocalBroadcastManager.getInstance( this ).registerReceiver( receiver, intentFilter );

        if (!threadActive) {
            pollingThread = new Thread(pollingRunnable);
            pollingThread.start();
        }

        return Service.START_STICKY;
    }

    private Runnable pollingRunnable = () -> {
        Context context = PushLongPollingService.this;
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (serverService == null) {
            serverService = ServerServiceKeeper.createServerService(settingsHelper.getBaseUrl(), Const.LONG_POLLING_READ_TIMEOUT);
        }
        if (secondaryServerService == null) {
            secondaryServerService = ServerServiceKeeper.createServerService(settingsHelper.getSecondaryBaseUrl(), Const.LONG_POLLING_READ_TIMEOUT);
        }

        // Calculate request signature
        String encodedDeviceId = settingsHelper.getDeviceId();
        try {
            encodedDeviceId = URLEncoder.encode(encodedDeviceId, "utf8");
        } catch (UnsupportedEncodingException e) {
        }
        String path = settingsHelper.getServerProject() + "/rest/notification/polling/" + encodedDeviceId;
        String signature = null;
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + path);
        } catch (Exception e) {
        }

        threadActive = true;
        while (enabled) {
            Response<PushResponse> response = null;

            RemoteLogger.log(context, Const.LOG_VERBOSE, "Push long polling inquiry");
            try {
                // This is the long operation
                response = serverService.
                        queryPushLongPolling(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
            } catch (Exception e) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications from "
                        + settingsHelper.getBaseUrl() + " : " + e.getMessage());
                e.printStackTrace();
            }

            try {
                if (response == null) {
                    response = secondaryServerService.
                            queryPushLongPolling(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
                }

                if ( response.isSuccessful() ) {
                    if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                        Map<String, PushMessage> filteredMessages = new HashMap<String, PushMessage>();
                        for (PushMessage message : response.body().getData()) {
                            // Filter out multiple configuration update requests
                            if (!message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED) ||
                                    !filteredMessages.containsKey(PushMessage.TYPE_CONFIG_UPDATED)) {
                                filteredMessages.put(message.getMessageType(), message);
                            }
                        }
                        for (Map.Entry<String, PushMessage> entry : filteredMessages.entrySet()) {
                            PushNotificationProcessor.process(entry.getValue(), context);
                        }
                    }
                } else if (response.code() >= 400 && response.code() < 500) {
                    // Response code 500 is fine (Timeout), so here we log only 4xx requests (403 Forbidden in particular)
                    RemoteLogger.log(context, Const.LOG_WARN, "Wrong response while querying push notifications from "
                            + settingsHelper.getSecondaryBaseUrl() + " : HTTP status " + response.code());
                    try {
                        // On exception, we need to wait to avoid looping
                        Thread.sleep(DELAY_AFTER_EXCEPTION_MS);
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                }
                // Avoid looping by adding some pause
                Thread.sleep(DELAY_AFTER_REQUEST_MS);

            } catch ( Exception e ) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications from "
                        + settingsHelper.getSecondaryBaseUrl() + " : " + e.getMessage());
                e.printStackTrace();
                try {
                    // On exception, we need to wait to avoid looping
                    Thread.sleep(DELAY_AFTER_EXCEPTION_MS);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        }
        threadActive = false;
    };


    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText(getString(R.string.mqtt_service_text))
                .setSmallIcon(R.drawable.ic_mqtt_service).build();

        Utils.startStableForegroundService(this, NOTIFICATION_ID, notification);
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/AdminReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;
import static android.content.Context.MODE_PRIVATE;

import android.app.admin.DeviceAdminReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.PersistableBundle;

import androidx.annotation.RequiresApi;

import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.util.PreferenceLogger;

/**
 * Created by Ivan Lozenko on 21.02.2017.
 */

public class AdminReceiver extends DeviceAdminReceiver {

    @Override
    public void onEnabled(Context context, Intent intent) {
        // We come here after both successful provisioning and manual activation of the device owner
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        PreferenceLogger.log(preferences, "Administrator enabled");
        preferences.edit().putInt(Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_ON).commit();
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        PreferenceLogger.log(preferences, "Profile provisioning complete");

        if ( Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP ) {
            // This function is never called on Android versions less than 5 (in fact, less than 7)
            return;
        }

        PersistableBundle bundle = intent.getParcelableExtra(EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        updateSettings(context, bundle);
    }

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static void updateSettings(Context context, PersistableBundle bundle) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        try {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());
            String deviceId = null;
            PreferenceLogger.log(preferences, "Bundle != null: " + (bundle != null));
            if (bundle != null) {
                deviceId = bundle.getString(Const.QR_DEVICE_ID_ATTR, null);
                if (deviceId == null) {
                    // Also let's try legacy attribute
                    deviceId = bundle.getString(Const.QR_LEGACY_DEVICE_ID_ATTR, null);
                }
                if (deviceId == null) {
                    String deviceIdUse = bundle.getString(Const.QR_DEVICE_ID_USE_ATTR, null);
                    if (deviceIdUse != null) {
                        PreferenceLogger.log(preferences, "deviceIdUse: " + deviceIdUse);
                        // Save for further automatic choice of the device ID
                        settingsHelper.setDeviceIdUse(deviceIdUse);
                    }
                }
            }
            if (deviceId != null) {
                // Device ID is delivered in the QR code!
                // Added: "android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE": {"com.hmdm.DEVICE_ID": "(device id)"}
                PreferenceLogger.log(preferences, "DeviceID: " + deviceId);
                settingsHelper.setDeviceId(deviceId);
            }

            String baseUrl = null;
            String secondaryBaseUrl = null;
            String serverProject = null;
            DeviceEnrollOptions createOptions = new DeviceEnrollOptions();
            if (bundle != null) {
                baseUrl = bundle.getString(Const.QR_BASE_URL_ATTR, null);
                secondaryBaseUrl = bundle.getString(Const.QR_SECONDARY_BASE_URL_ATTR, null);
                serverProject = bundle.getString(Const.QR_SERVER_PROJECT_ATTR, null);
                createOptions.setCustomer(bundle.getString(Const.QR_CUSTOMER_ATTR, null));
                createOptions.setConfiguration(bundle.getString(Const.QR_CONFIG_ATTR, null));
                createOptions.setGroups(bundle.getString(Const.QR_GROUP_ATTR, null));
                if (baseUrl != null) {
                    PreferenceLogger.log(preferences, "BaseURL: " + baseUrl);
                    settingsHelper.setBaseUrl(baseUrl);
                    // If we don't set the secondary base URL, it will point to app.h-mdm.com by default which is wrong
                    if (secondaryBaseUrl == null) {
                        secondaryBaseUrl = baseUrl;
                    }
                }
                if (secondaryBaseUrl != null) {
                    PreferenceLogger.log(preferences, "SecondaryBaseURL: " + secondaryBaseUrl);
                    settingsHelper.setSecondaryBaseUrl(secondaryBaseUrl);
                }
                if (serverProject != null) {
                    PreferenceLogger.log(preferences, "ServerPath: " + serverProject);
                    settingsHelper.setServerProject(serverProject);
                }
                if (createOptions.getCustomer() != null) {
                    PreferenceLogger.log(preferences, "Customer: " + createOptions.getCustomer());
                    settingsHelper.setEnrollOptionCustomer(createOptions.getCustomer());
                }
                if (createOptions.getConfiguration() != null) {
                    PreferenceLogger.log(preferences, "Configuration: " + createOptions.getConfiguration());
                    settingsHelper.setEnrollOptionConfigName(createOptions.getConfiguration());
                }
                if (createOptions.getGroups() != null) {
                    PreferenceLogger.log(preferences, "Groups: " + bundle.getString(Const.QR_GROUP_ATTR));
                    settingsHelper.setEnrollOptionGroup(createOptions.getGroupSet());
                }
                settingsHelper.setQrProvisioning(true);
            }
        } catch (Exception e) {
            // Ignored
            e.printStackTrace();
            PreferenceLogger.printStackTrace(preferences, e);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/Initializer.java">
package com.hmdm.launcher.helper;

import static android.content.Context.MODE_PRIVATE;

import android.bluetooth.BluetoothAdapter;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.pro.service.CheckForegroundAppAccessibilityService;
import com.hmdm.launcher.pro.service.CheckForegroundApplicationService;
import com.hmdm.launcher.pro.worker.DetailedInfoWorker;
import com.hmdm.launcher.service.PushLongPollingService;
import com.hmdm.launcher.service.StatusControlService;
import com.hmdm.launcher.task.SendDeviceInfoTask;
import com.hmdm.launcher.util.ConnectionWaiter;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.PushNotificationWorker;
import com.hmdm.launcher.worker.ScheduledAppUpdateWorker;
import com.hmdm.launcher.worker.SendDeviceInfoWorker;

import org.eclipse.paho.android.service.MqttAndroidClient;

import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Shared initialization code which should run either by MainActivity (in foreground mode)
// or by InitialSetupActivity (in background mode)
public class Initializer {
    private static ExecutorService executor = Executors.newSingleThreadExecutor();
    private static Handler uiHandler = new Handler(Looper.getMainLooper());

    public static void init(Context context, Runnable completion) {
        // Background work
        executor.execute(() -> {
            // Crashlytics is not included in the open-source version
            ProUtils.initCrashlytics(context);

            if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                InstallUtils.initUnsafeTrustManager();
            }

            Utils.lockSafeBoot(context);
            Utils.initPasswordReset(context);

            RemoteLogger.log(context, Const.LOG_INFO, "MDM Launcher " + BuildConfig.VERSION_NAME + "-" + Utils.getLauncherVariant() + " started");

            InstallUtils.clearTempFiles(context);

            // Install the certificates (repeat the action from InitialSetupActivity because
            // the customer may wish to install new certificates without re-enrolling the device
            CertInstaller.installCertificatesFromAssets(context);

            ConnectionWaiter.waitForConnect(context, () -> {
                DetailedInfoWorker.schedule(context);
                if (BuildConfig.ENABLE_PUSH) {
                    PushNotificationWorker.schedule(context);
                }
                ScheduledAppUpdateWorker.schedule(context);

                // Run completion in the UI thread
                uiHandler.post(completion);
            });
        });
    }

    public static void startServicesAndLoadConfig(Context context) {
        // Start Push service
        String pushOptions = null;
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            pushOptions = settingsHelper.getConfig().getPushOptions();
            Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
            if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
                keepaliveTime = newKeepaliveTime;
            }
        }
        if (BuildConfig.MQTT_SERVICE_FOREGROUND && BuildConfig.ENABLE_PUSH && pushOptions != null) {
            if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
                try {
                    URL url = new URL(settingsHelper.getBaseUrl());
                    // Broadcast receivers are not allowed to bind to services
                    // Therefore we start a service, and it binds to itself using
                    // PushNotificationMqttWrapper.getInstance().connect()
                    Intent serviceStartIntent = new Intent();
                    serviceStartIntent.setClassName(context, MqttAndroidClient.SERVICE_NAME);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_START_AT_BOOT, true);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_DOMAIN, url.getHost());
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_KEEPALIVE_TIME, keepaliveTime);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_PUSH_OPTIONS, pushOptions);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_DEVICE_ID, settingsHelper.getDeviceId());
                    Object service = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                            context.startForegroundService(serviceStartIntent) :
                            context.startService(serviceStartIntent);
                    Log.i(Const.LOG_TAG, "Starting Push service from BootReceiver");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_POLLING)) {
                try {
                    Intent serviceStartIntent = new Intent(context, PushLongPollingService.class);
                    serviceStartIntent.putExtra(Const.EXTRA_ENABLED, true);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceStartIntent);
                    } else {
                        context.startService(serviceStartIntent);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        // Start required services here instead of MainActivity (because it's not running)
        // Notice: some devices do not allow starting background services from boot receiver
        // java.lang.IllegalStateException
        // Not allowed to start service Intent { cmp=com.hmdm.launcher/.service.StatusControlService }: app is in background
        // Let's just ignore these exceptions for now
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        // Foreground apps checks are not available in a free version: services are the stubs
        if (preferences.getInt(Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            try {
                context.startService(new Intent(context, CheckForegroundApplicationService.class));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        if (BuildConfig.USE_ACCESSIBILITY &&
            preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            try {
                context.startService(new Intent(context, CheckForegroundAppAccessibilityService.class));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        try {
            context.startService(new Intent(context, StatusControlService.class));
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Send pending logs to server
        RemoteLogger.sendLogsToServer(context);

        final ConfigUpdater.UINotifier uiNotifier = new ConfigUpdater.UINotifier() {
            @Override
            public void onConfigUpdateStart() {
            }

            @Override
            public void onConfigUpdateServerError(String errorText) {
            }

            @Override
            public void onConfigUpdateNetworkError(String errorText) {
            }

            @Override
            public void onConfigLoaded() {
            }

            @Override
            public void onPoliciesUpdated() {
            }

            @Override
            public void onFileDownloading(RemoteFile remoteFile) {
            }

            @Override
            public void onDownloadProgress(int progress, long total, long current) {
            }

            @Override
            public void onFileDownloadError(RemoteFile remoteFile) {
            }

            @Override
            public void onFileInstallError(RemoteFile remoteFile) {
            }

            @Override
            public void onAppUpdateStart() {
            }

            @Override
            public void onAppRemoving(Application application) {
            }

            @Override
            public void onAppDownloading(Application application) {
            }

            @Override
            public void onAppInstalling(Application application) {
            }

            @Override
            public void onAppDownloadError(Application application) {
            }

            @Override
            public void onAppInstallError(String packageName) {
            }

            @Override
            public void onAppInstallComplete(String packageName) {
            }

            @Override
            public void onConfigUpdateComplete() {
                // In background mode, we need to send the information to the server once update is complete
                SendDeviceInfoTask sendDeviceInfoTask = new SendDeviceInfoTask(context);
                DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
                sendDeviceInfoTask.execute(deviceInfo);
                SendDeviceInfoWorker.scheduleDeviceInfoSending(context);
            }

            @Override
            public void onAllAppInstallComplete() {
            }
        };
        ConfigUpdater.forceConfigUpdate(context, uiNotifier, false);
    }

    // Used by InitialSetupActivity
    public static void applyEarlyNonInteractivePolicies(Context context, ServerConfig config) {
        if (config.getSystemUpdateType() != null &&
                config.getSystemUpdateType() != ServerConfig.SYSTEM_UPDATE_DEFAULT &&
                Utils.isDeviceOwner(context)) {
            Utils.setSystemUpdatePolicy(context, config.getSystemUpdateType(), config.getSystemUpdateFrom(), config.getSystemUpdateTo());
        }

        if (config.getBluetooth() != null) {
            try {
                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                if (bluetoothAdapter != null) {
                    boolean enabled = bluetoothAdapter.isEnabled();
                    if (config.getBluetooth() && !enabled) {
                        bluetoothAdapter.enable();
                    } else if (!config.getBluetooth() && enabled) {
                        bluetoothAdapter.disable();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (config.getTimeZone() != null) {
            Utils.setTimeZone(config.getTimeZone(), context);
        }

        if (config.getUsbStorage() != null) {
            Utils.lockUsbStorage(config.getUsbStorage(), context);
        }

        // Null value is processed here, it means unlock brightness
        Utils.setBrightnessPolicy(config.getAutoBrightness(), config.getBrightness(), context);

        if (config.getManageTimeout() != null) {
            Utils.setScreenTimeoutPolicy(config.getManageTimeout(), config.getTimeout(), context);
        }

        if (config.getManageVolume() != null && config.getManageVolume() && config.getVolume() != null) {
            Utils.lockVolume(false, context);
            if (!Utils.setVolume(config.getVolume(), context)) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to set the device volume");
            }
        }

        if (config.getLockVolume() != null) {
            Utils.lockVolume(config.getLockVolume(), context);
        }

        Utils.disableScreenshots(config.isDisableScreenshots(), context);
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MdmChoiceSetupActivity.java">
package com.hmdm.launcher.ui;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_MODE;

import android.app.Dialog;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.provider.Settings;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.widget.ArrayAdapter;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.AdminReceiver;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityMdmChoiceBinding;
import com.hmdm.launcher.databinding.DialogEnterDeviceIdBinding;
import com.hmdm.launcher.helper.SettingsHelper;

import java.util.ArrayList;
import java.util.List;

public class MdmChoiceSetupActivity extends AppCompatActivity {
    private ActivityMdmChoiceBinding binding;

    protected Dialog enterDeviceIdDialog;
    protected DialogEnterDeviceIdBinding enterDeviceIdDialogBinding;

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);

        Log.d(Const.LOG_TAG, "Launching the provisioning mode choice activity");

        binding = DataBindingUtil.setContentView(this, R.layout.activity_mdm_choice);

        Intent intent = getIntent();
        PersistableBundle bundle = intent.getParcelableExtra(DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            if (bundle != null && bundle.getString(Const.QR_OPEN_WIFI_ATTR) != null) {
                try {
                    startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                } catch (Exception e) {
                    e.printStackTrace();
                    Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
                }
            }
            AdminReceiver.updateSettings(this, bundle);
        }

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        if (settingsHelper.getDeviceId() == null || settingsHelper.getDeviceId().length() == 0) {
            Log.d(Const.LOG_TAG, "Device ID is empty");
            String deviceIdUse = settingsHelper.getDeviceIdUse();
            String deviceId;
            Log.d(Const.LOG_TAG, "Device ID choice: " + deviceIdUse);
            if (BuildConfig.DEVICE_ID_CHOICE.equals("imei") || "imei".equals(deviceIdUse)) {
                // These extras could not be set so we should retry setting these values in InitialSetupActivity!
                deviceId = intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_IMEI);
            } else if (BuildConfig.DEVICE_ID_CHOICE.equals("serial") || "serial".equals(deviceIdUse)) {
                deviceId = intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_SERIAL_NUMBER);
            } else {
                displayEnterDeviceIdDialog(intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_IMEI),
                        intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_SERIAL_NUMBER));
                return;
            }
            settingsHelper.setDeviceId(deviceId);
        }
    }

    @Override
    public void onBackPressed() {
        setResult(RESULT_CANCELED);
        super.onBackPressed();
    }

    public void continueSetup(View view) {
        final Intent intent = new Intent();
        intent.putExtra(EXTRA_PROVISIONING_MODE, DevicePolicyManager.PROVISIONING_MODE_FULLY_MANAGED_DEVICE);
        setResult(RESULT_OK, intent);
        finish();
    }

    protected void displayEnterDeviceIdDialog(String imei, String serial) {
        enterDeviceIdDialog = new Dialog(this);
        enterDeviceIdDialogBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_device_id,
                null,
                false);
        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        String serverUrl = settingsHelper.getBaseUrl();
        String serverPath = settingsHelper.getServerProject();
        if (serverPath.length() > 0) {
            serverUrl += "/" + serverPath;
        }
        enterDeviceIdDialogBinding.deviceIdPrompt.setText(getString(R.string.dialog_enter_device_id_title, serverUrl));
        enterDeviceIdDialogBinding.deviceIdError.setText(getString(R.string.dialog_enter_device_id_error, serverUrl));
        enterDeviceIdDialogBinding.setError(false);
        enterDeviceIdDialog.setCancelable(false);
        enterDeviceIdDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        // Suggest variants to choose the device ID: IMEI or serial
        List<String> variantsList = new ArrayList<>();
        if (imei != null) {
            variantsList.add(imei);
        }
        if (serial != null && !serial.equals(Build.UNKNOWN)) {
            variantsList.add(serial);
        }
        if (variantsList.size() > 0) {
            String[] variantsArray = variantsList.toArray(new String[variantsList.size()]);
            enterDeviceIdDialogBinding.deviceId.setThreshold(0);
            enterDeviceIdDialogBinding.deviceId.setAdapter(new ArrayAdapter<String>(this,
                    android.R.layout.select_dialog_item, variantsArray));
        } else {
            enterDeviceIdDialogBinding.showDeviceIdVariants.setVisibility(View.GONE);
        }

        enterDeviceIdDialogBinding.showDeviceIdQrCode.setVisibility(View.GONE);

        enterDeviceIdDialog.setContentView( enterDeviceIdDialogBinding.getRoot() );
        enterDeviceIdDialog.show();
    }

    public void saveDeviceId( View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString().trim();
        if ("".equals(deviceId)) {
            return;
        } else {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
            settingsHelper.setDeviceId( deviceId );
            if (enterDeviceIdDialog != null) {
                enterDeviceIdDialog.dismiss();
            }
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/AppInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.os.Parcel;
import android.os.Parcelable;

public class AppInfo implements Parcelable {
    public static final int TYPE_APP = 0;
    public static final int TYPE_WEB = 1;
    public static final int TYPE_INTENT = 2;

    public int type;
    public Integer keyCode;
    public CharSequence name;
    public String packageName;
    public String url;
    public String iconUrl;
    public Integer screenOrder;
    public int useKiosk;
    public int longTap;
    public String intent;

    public AppInfo(){}

    protected AppInfo(Parcel in) {
        type = in.readInt();
        keyCode = (Integer)in.readSerializable();
        name = in.readString();
        packageName = in.readString();
        url = in.readString();
        iconUrl = in.readString();
        screenOrder = (Integer)in.readSerializable();
        useKiosk = in.readInt();
        longTap = in.readInt();
        intent = in.readString();
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(type);
        dest.writeSerializable(keyCode);
        dest.writeString(name != null ? name.toString() : null);
        dest.writeString(packageName);
        dest.writeString(url);
        dest.writeString(iconUrl);
        dest.writeSerializable(screenOrder);
        dest.writeInt(useKiosk);
        dest.writeInt(longTap);
        dest.writeString(intent);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public static final Creator<AppInfo> CREATOR = new Creator<AppInfo>() {
        @Override
        public AppInfo createFromParcel(Parcel in) {
            return new AppInfo(in);
        }

        @Override
        public AppInfo[] newArray(int size) {
            return new AppInfo[size];
        }
    };
}
</file>

<file path="app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
        <variable name="downloading" type="Boolean"/>
        <variable name="showContent" type="Boolean"/>
        <variable name="fileLength" type="Long"/>
        <variable name="downloadedLength" type="Long"/>
    </data>
    
    <RelativeLayout 
        android:id="@+id/activity_main"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.MainActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:orientation="vertical"
            android:layout_centerInParent="true"
            android:gravity="center">

            <ProgressBar
                android:id="@+id/loading"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{message}"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:gravity="center"/>

            <ProgressBar
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:id="@+id/progress"
                android:max="100"
                style="?android:attr/progressBarStyleHorizontal"
                bind:boolToVisible="@{downloading}"/>

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="10dp"
                bind:boolToVisible="@{downloading}">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@{String.valueOf(downloadedLength)}"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="/"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@{String.valueOf(fileLength)}"/>

            </LinearLayout>

        </LinearLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            bind:boolToVisible="@{showContent}"
            android:id="@+id/activity_main_content_wrapper">

            <ImageView
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                android:id="@+id/activity_main_background"/>


            <LinearLayout
                android:id="@+id/status_header"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">
                <TextView
                    android:id="@+id/clock"
                    android:layout_width="@dimen/status_bar_side_width"
                    android:layout_height="wrap_content"
                    android:layout_marginLeft="5dp"
                    android:textSize="@dimen/title_text_size"
                    />
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:id="@+id/activity_main_title"
                    android:gravity="center"
                    android:textSize="@dimen/title_text_size"
                    />
                <com.hmdm.launcher.ui.custom.BatteryStateView
                    android:id="@+id/battery_state"
                    android:layout_width="@dimen/status_bar_side_width"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="5dp"/>
                <Button
                    android:id="@+id/openFlutterButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Flutter" />
            </LinearLayout>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/activity_main_content"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_above="@+id/activity_bottom_layout"
                android:layout_below="@+id/status_header" />

            <RelativeLayout
                android:id="@+id/activity_bottom_layout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                >

                <androidx.recyclerview.widget.RecyclerView
                    android:layout_centerHorizontal="true"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:id="@+id/activity_bottom_line"/>

            </RelativeLayout>

        </RelativeLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/PluginApiService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.service;

import android.app.Service;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.util.Log;

import androidx.annotation.Nullable;

import com.hmdm.IMdmApi;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class PluginApiService extends Service {
    // Data keys
    public static final String KEY_SERVER_HOST = "SERVER_HOST";
    public static final String KEY_SECONDARY_SERVER_HOST = "SECONDARY_SERVER_HOST";
    public static final String KEY_SERVER_PATH = "SERVER_PATH";
    public static final String KEY_DEVICE_ID = "DEVICE_ID";
    public static final String KEY_CUSTOM_1 = "CUSTOM_1";
    public static final String KEY_CUSTOM_2 = "CUSTOM_2";
    public static final String KEY_CUSTOM_3 = "CUSTOM_3";
    public static final String KEY_IMEI = "IMEI";
    public static final String KEY_SERIAL = "SERIAL";
    public static final String KEY_IS_MANAGED = "IS_MANAGED";
    public static final String KEY_IS_KIOSK = "IS_KIOSK";
    public static final String KEY_ERROR = "ERROR";

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    private final IMdmApi.Stub mBinder = new IMdmApi.Stub() {

        @Override
        public int getVersion() {
            // 1.1.7
            return 117;
        }

        @Override
        public Bundle queryConfig() {
            return queryPrivilegedConfig(null);
        }

        @Override
        public Bundle queryPrivilegedConfig(String apiKey) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return null;
            } else {
                Bundle bundle = new Bundle();
                bundle.putString(KEY_SERVER_HOST, settingsHelper.getBaseUrl());
                bundle.putString(KEY_SECONDARY_SERVER_HOST, settingsHelper.getSecondaryBaseUrl());
                bundle.putString(KEY_SERVER_PATH, settingsHelper.getServerProject());
                bundle.putString(KEY_DEVICE_ID, settingsHelper.getDeviceId());
                bundle.putBoolean(KEY_IS_MANAGED, Utils.isDeviceOwner(PluginApiService.this));
                bundle.putBoolean(KEY_IS_KIOSK, ProUtils.isKioskModeRunning(PluginApiService.this));
                if (settingsHelper.getConfig().getCustom1() != null) {
                    bundle.putString(KEY_CUSTOM_1, settingsHelper.getConfig().getCustom1());
                }
                if (settingsHelper.getConfig().getCustom2() != null) {
                    bundle.putString(KEY_CUSTOM_2, settingsHelper.getConfig().getCustom2());
                }
                if (settingsHelper.getConfig().getCustom3() != null) {
                    bundle.putString(KEY_CUSTOM_3, settingsHelper.getConfig().getCustom3());
                }
                if (apiKey != null) {
                    if (apiKey.equals(BuildConfig.LIBRARY_API_KEY)) {
                        // IMEI and serial are set only to authorized requests
                        bundle.putString(KEY_IMEI, DeviceInfoProvider.getImei(PluginApiService.this));
                        bundle.putString(KEY_SERIAL, DeviceInfoProvider.getSerialNumber());
                    } else {
                        bundle.putString(KEY_ERROR, "KEY_NOT_MATCH");
                    }
                }

                return bundle;
            }
        }

        @Override
        public void log(long timestamp, int level, String packageId, String message) {
            Log.i(Const.LOG_TAG, "Got a log item from " + packageId);
            RemoteLogItem item = new RemoteLogItem();
            item.setTimestamp(timestamp);
            item.setLogLevel(level);
            item.setPackageId(packageId);
            item.setMessage(message);
            RemoteLogger.postLog(PluginApiService.this, item);
        }

        @Override
        public String queryAppPreference(String packageId, String attr) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return null;
            }
            return settingsHelper.getAppPreference(packageId, attr);
        }

        @Override
        public boolean setAppPreference(String packageId, String attr, String value) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return false;
            }
            return settingsHelper.setAppPreference(packageId, attr, value);
        }

        @Override
        public void commitAppPreferences(String packageId) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return;
            }
            settingsHelper.commitAppPreferences(packageId);
        }

        @Override
        public void setCustom(int number, String value) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return;
            }
            switch (number) {
                case 1:
                    settingsHelper.getConfig().setCustom1(value);
                    settingsHelper.setUserCustom1(value);
                    break;
                case 2:
                    settingsHelper.getConfig().setCustom2(value);
                    settingsHelper.setUserCustom2(value);
                    break;
                case 3:
                    settingsHelper.getConfig().setCustom3(value);
                    settingsHelper.setUserCustom3(value);
                    break;
            }
        }

        @Override
        public void forceConfigUpdate() {
            // userInteraction is set to true so the applications are also updated unrelated from the app update schedule
            ConfigUpdater.forceConfigUpdate(PluginApiService.this, null, true);
        }
    };
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/PushNotificationWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;

import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import retrofit2.Response;

public class PushNotificationWorker extends Worker {

    // Minimal interval is 15 minutes as per docs
    public static final int FIRE_PERIOD_MINS = 15;

    // Interval to update configuration to avoid losing device due to push failure
    public static final long CONFIG_UPDATE_INTERVAL = 3600000l;

    private static final String WORK_TAG_PERIODIC = "com.hmdm.launcher.WORK_TAG_PUSH_PERIODIC";

    public static void schedule(Context context) {
        RemoteLogger.log(context, Const.LOG_DEBUG, "Push notifications enqueued: " + FIRE_PERIOD_MINS + " mins");
        PeriodicWorkRequest queryRequest =
                new PeriodicWorkRequest.Builder(PushNotificationWorker.class, FIRE_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_PERIODIC, ExistingPeriodicWorkPolicy.REPLACE, queryRequest);
    }

    private Context context;
    private SettingsHelper settingsHelper;

    public PushNotificationWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper == null || settingsHelper.getConfig() == null) {
            return Result.failure();
        }

        String pushOptions = settingsHelper.getConfig().getPushOptions();

        if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER) ||
                pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
            // Note: MQTT client is automatically reconnected if connection is broken during launcher running,
            // and re-initializing it may cause looped errors
            // In particular, MQTT client is reconnected after turning Wi-Fi off and back on.
            // Re-connection of MQTT client at Headwind MDM startup is implemented in MainActivity
            // So by now, just request configuration update some times per day to avoid "device lost" issues
            return doMqttWork();
        } else {
            // PUSH_OPTIONS_POLLING by default
            //return doPollingWork();
            // Long polling is done in a related service
            // This is just a reserve task to prevent devices from being lost just in case
            return doLongPollingWork();
        }
    }

    // Query server for incoming messages each 15 minutes
    private Result doPollingWork() {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<PushResponse> response = null;

        // Calculate request signature
        String encodedDeviceId = settingsHelper.getDeviceId();
        try {
            encodedDeviceId = URLEncoder.encode(encodedDeviceId, "utf8");
        } catch (UnsupportedEncodingException e) {
        }
        String path = settingsHelper.getServerProject() + "/rest/notifications/device/" + encodedDeviceId;
        String signature = null;
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + path);
        } catch (Exception e) {
        }

        RemoteLogger.log(context, Const.LOG_DEBUG, "Querying push notifications");
        try {
            response = serverService.
                    queryPushNotifications(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications: " + e.getMessage());
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        queryPushNotifications(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
            }

            if ( response.isSuccessful() ) {
                if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                    Map<String, PushMessage> filteredMessages = new HashMap<String, PushMessage>();
                    for (PushMessage message : response.body().getData()) {
                        // Filter out multiple configuration update requests
                        if (!message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED) ||
                                !filteredMessages.containsKey(PushMessage.TYPE_CONFIG_UPDATED)) {
                            filteredMessages.put(message.getMessageType(), message);
                        }
                    }
                    for (Map.Entry<String, PushMessage> entry : filteredMessages.entrySet()) {
                        PushNotificationProcessor.process(entry.getValue(), context);
                    }
                    return Result.success();
                } else {
                    return Result.failure();
                }
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }

        return Result.failure();
    }

    // Periodic configuration update requests
    private Result doLongPollingWork() {
        return forceConfigUpdateWork();
    }

    // Periodic configuration update requests
    private Result doMqttWork() {

        if (PushNotificationMqttWrapper.getInstance().checkPingDeath(context)) {
            RemoteLogger.log(context, Const.LOG_INFO, "MQTT ping death detected, reconnecting!");
            mqttReconnect();
        }

        return forceConfigUpdateWork();
    }

    private Result forceConfigUpdateWork() {
        long lastConfigUpdateTimestamp = settingsHelper.getConfigUpdateTimestamp();
        long now = System.currentTimeMillis();
        if (lastConfigUpdateTimestamp == 0) {
            settingsHelper.setConfigUpdateTimestamp(now);
            return Result.success();
        }
        if (lastConfigUpdateTimestamp + CONFIG_UPDATE_INTERVAL > now) {
            return Result.success();
        }
        RemoteLogger.log(context, Const.LOG_DEBUG, "Forcing configuration update");
        settingsHelper.setConfigUpdateTimestamp(now);
        ConfigUpdater.forceConfigUpdate(context);
        return Result.success();
    }

    // We assume we're running in the background!
    // https://stackoverflow.com/questions/57552955/is-possible-backgroundworker-dowork-in-main-thread
    private void mqttReconnect() {
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        String pushOptions = settingsHelper.getConfig().getPushOptions();
        Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
        if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
            keepaliveTime = newKeepaliveTime;
        }
        try {
            PushNotificationMqttWrapper.getInstance().disconnect(context);
            Thread.sleep(5000);
            URL url = new URL(settingsHelper.getBaseUrl());
            PushNotificationMqttWrapper.getInstance().connect(context, url.getHost(), BuildConfig.MQTT_PORT,
                    pushOptions, keepaliveTime, settingsHelper.getDeviceId(), null, null);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Reconnection failure: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/AlarmPingSender.java">
/*******************************************************************************
 * Copyright (c) 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.internal.ClientComms;

/**
 * Default ping sender implementation on Android. It is based on AlarmManager.
 *
 * <p>This class implements the {@link MqttPingSender} pinger interface
 * allowing applications to send ping packet to server every keep alive interval.
 * </p>
 *
 * @see MqttPingSender
 */
class AlarmPingSender implements MqttPingSender {
	// Identifier for Intents, log messages, etc..
	private static final String TAG = "MqttAlarmPingSender";

	// TODO: Add log.
	private ClientComms comms;
	private MqttService service;
	private BroadcastReceiver alarmReceiver;
	private AlarmPingSender that;
	private PendingIntent pendingIntent;
	private volatile boolean hasStarted = false;

	public AlarmPingSender(MqttService service) {
		if (service == null) {
			throw new IllegalArgumentException(
					"Neither service nor client can be null.");
		}
		this.service = service;
		that = this;
	}

	@Override
	public void init(ClientComms comms) {
		this.comms = comms;
		this.alarmReceiver = new AlarmReceiver();
	}

	@Override
	public void start() {
		String action = MqttServiceConstants.PING_SENDER
				+ comms.getClient().getClientId();
		Log.d(TAG, "Register alarmreceiver to MqttService"+ action);
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
			service.registerReceiver(alarmReceiver, new IntentFilter(action), Context.RECEIVER_EXPORTED);
		} else {
			service.registerReceiver(alarmReceiver, new IntentFilter(action));
		}

		pendingIntent = PendingIntent.getBroadcast(service, 0, new Intent(
				action), PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

		schedule(comms.getKeepAlive());
		hasStarted = true;
	}

	@Override
	public void stop() {

		Log.d(TAG, "Unregister alarmreceiver to MqttService"+comms.getClient().getClientId());
		if(hasStarted){
			if(pendingIntent != null){
				// Cancel Alarm.
				AlarmManager alarmManager = (AlarmManager) service.getSystemService(Service.ALARM_SERVICE);
				alarmManager.cancel(pendingIntent);
			}

			hasStarted = false;
			try{
				service.unregisterReceiver(alarmReceiver);
			}catch(IllegalArgumentException e){
				//Ignore unregister errors.			
			}
		}
	}

	@Override
	public void schedule(long delayInMilliseconds) {
			long nextAlarmInMilliseconds = System.currentTimeMillis()
				+ delayInMilliseconds;
		Log.d(TAG, "Schedule next alarm at " + nextAlarmInMilliseconds);
		AlarmManager alarmManager = (AlarmManager) service
				.getSystemService(Service.ALARM_SERVICE);

        if(Build.VERSION.SDK_INT >= 23){
			// In SDK 23 and above, dosing will prevent setExact, setExactAndAllowWhileIdle will force
			// the device to run this task whilst dosing.
			Log.d(TAG, "Alarm schedule using setExactAndAllowWhileIdle, next: " + delayInMilliseconds);
			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S || alarmManager.canScheduleExactAlarms()) {
				alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
						pendingIntent);
			} else {
				Log.w(TAG, "Failed to alarm schedule: no permission!");
			}
		} else if (Build.VERSION.SDK_INT >= 19) {
			Log.d(TAG, "Alarm schedule using setExact, delay: " + delayInMilliseconds);
			alarmManager.setExact(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
					pendingIntent);
		} else {
			alarmManager.set(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
					pendingIntent);
		}
	}

	/*
	 * This class sends PingReq packet to MQTT broker
	 */
	class AlarmReceiver extends BroadcastReceiver {
		private WakeLock wakelock;
		private final String wakeLockTag = MqttServiceConstants.PING_WAKELOCK
				+ that.comms.getClient().getClientId();

		@Override
        @SuppressLint("Wakelock")
		public void onReceive(final Context context, Intent intent) {
			// According to the docs, "Alarm Manager holds a CPU wake lock as
			// long as the alarm receiver's onReceive() method is executing.
			// This guarantees that the phone will not sleep until you have
			// finished handling the broadcast.", but this class still get
			// a wake lock to wait for ping finished.

			Log.d(TAG, "Sending Ping at:" + System.currentTimeMillis());

			PowerManager pm = (PowerManager) service
					.getSystemService(Service.POWER_SERVICE);
			wakelock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, wakeLockTag);
			wakelock.acquire();

			RemoteLogger.log(context, Const.LOG_VERBOSE, "Sending MQTT Ping at:" + System.currentTimeMillis());
			PingDeathDetector.getInstance().registerPing();

			// Assign new callback to token to execute code after PingResq
			// arrives. Get another wakelock even receiver already has one,
			// release it until ping response returns.
			IMqttToken token = comms.checkForActivity(new IMqttActionListener() {

				@Override
				public void onSuccess(IMqttToken asyncActionToken) {
					RemoteLogger.log(context, Const.LOG_VERBOSE, "Ping success");
					Log.d(TAG, "Success. Release lock(" + wakeLockTag + "):"
							+ System.currentTimeMillis());
					//Release wakelock when it is done.
					wakelock.release();
				}

				@Override
				public void onFailure(IMqttToken asyncActionToken,
									  Throwable exception) {
					RemoteLogger.log(context, Const.LOG_INFO, "MQTT ping failure");
					Log.d(TAG, "Failure. Release lock(" + wakeLockTag + "):"
							+ System.currentTimeMillis());
					//Release wakelock when it is done.
					wakelock.release();
				}
			});


			if (token == null && wakelock.isHeld()) {
				RemoteLogger.log(context, Const.LOG_VERBOSE, "WakeLock released");
				wakelock.release();
			}
		}
	}
}
</file>

<file path="app/src/main/res/values-cs/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrátor</string>
    <string name="install_error">Chyba instalace</string>
    <string name="file_create_error">Chyba při vytváření souboru</string>
    <string name="dialog_enter_device_id_error">ID není registrováno na %s. Získejte ID ze záložky \"Zařízení\" admin panelu.</string>
    <string name="dialog_enter_device_id_qrcode">QR kód</string>
    <string name="dialog_enter_device_id_variants">Varianty</string>
    <string name="dialog_enter_device_id_save">Uložit</string>
    <string name="dialog_enter_device_id_exit">Ukončit</string>
    <string name="dialog_enter_device_id_title">Vložte ID zařízení na %s</string>
    <string name="main_start_preparations">Příprava spuštění</string>
    <string name="main_downloading_configuration">Aktualizace konfiguračního souboru</string>
    <string name="main_downloading_content">Aktualizace dat</string>
    <string name="main_update_applications">Instalace a aktualizace aplikací</string>
    <string name="dialog_root_message">Potřebujete ROOT přístup</string>
    <string name="main_application_start">Aplikace se zapíná</string>
    <string name="main_app_installing">Aplikace se instaluje</string>
    <string name="main_app_downloading">Aplikace se stahuje</string>
    <string name="main_app_downloading_error">Aplikace se nepodařila stáhnout</string>
    <string name="main_app_removing">Aplikace se odebírá</string>
    <string name="main_file_downloading">Soubor se stahuje</string>
    <string name="main_file_downloading_error">Soubor se nepodařilo stáhnout</string>
    <string name="main_activity_repeat">Zkusit znovu</string>
    <string name="main_activity_reset">Reset</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Ukončit</string>
    <string name="main_activity_details">Podrobnosti</string>
    <string name="select_system_launcher">Vyberte %s jako hlavní launcher a klepněte na \'Vždy\':</string>
    <string name="dialog_network_error_title">Chyba připojení k %s. Zkontrolujte připojení k internetu a zkuste znovu.</string>
    <string name="main_activity_update_config">Získávám konfigurační soubor ze serveru</string>
    <string name="main_activity_applications_update">Aktualizace aplikací</string>
    <string name="dialog_overlay_settings_title">Prosím povolte aplikaci vykreslování přes ostatní okna.\n\nToto nastavení pomáhá lépe blokovat nežádoucí aplikace a umožní nouzové odemykání kiosku.\n\nVyberte \"Pokračovat\" pro otevření nastavení. Vyberte položku \"%s\" a povolte oprávnění, poté se vraťte.</string>
    <string name="dialog_manage_storage_title">Povolte aplikaci spravovat úložiště.\n\nTato možnost umožňuje Headwind MDM spravovat soubory ve vašem zařízení.</string>
    <string name="dialog_history_settings_title">Prosím povolte aplikaci přístup k diagnostickým datům.\n\nToto nastavení pomáhá k ovládání nastavení a aplikací.\n\nToto nastavení může způsobit rychlejší vybití baterie. Pokud chcete šetřit baterii, toto nastavení přeskočte (použijte kiosk nebo nastavení přístupnosti).\n\nVyberte \"Pokračovat\" pro otevření nastavení. Vyberte položku \"%s\" a povolte oprávnění, poté se vraťte.</string>
    <string name="dialog_history_settings_continue">Pokračovat</string>
    <string name="dialog_history_settings_skip">Přeskočit</string>
    <string name="dialog_unknown_sources_title">Prosím povolte instalaci z neznámých zdrojů. Bude otevřeno nastavení. Vyberte \"Neznámé zdroje\" a povolte instalaci, poté se vraťte.</string>
    <string name="dialog_unknown_sources_continue">Pokračovat</string>
    <string name="dialog_miui_permissions_title">MIUI vyžaduje ruční nastavení vlastních oprávnění. Oprávnění aplikace se nyní otevřou. Vyberte \"Ostatní oprávnění\" a povolte \"Zobrazovat vyskakovací okna při běhu v pozadí\", poté se vraťte.</string>
    <string name="dialog_miui_developer_title">MIUI vyžaduje ruční nastavení vašeho zařízení. Na stavové obrazovce 7x poklepejte na \"Číslo sestavení\". Toto povolí možnosti vývojáře.</string>
    <string name="dialog_miui_optimization_title">MIUI vyžaduje ruční nastavení vašeho zařízení. Nastavení vývojáře se nyní otevře. Najděte položku \"MIUI optimization\" a vypněte ji.</string>
    <string name="dialog_administrator_mode_message">Prosím povolte aplikaci možnost běhu jako administrátor zařízení. Bude otevřeno nastavení. Vyberte \"Administrátoři zařízeni\" a aktivujte administrátora pro \"%s\", poté se vraťte.</string>
    <string name="dialog_administrator_mode_continue">Pokračovat</string>
    <string name="dialog_administrator_mode_skip">Přeskočit</string>
    <string name="accessibility_service_description">Aktivní monitorování aplikací přes MDM</string>
    <string name="dialog_accessibility_service_message">Prosím povolte aplikaci oprávnění ke službám přístupnosti. Bude otevřeno nastavení. Najděte \"%s\" a povolte přístup, poté se vraťte.</string>
    <string name="dialog_accessibility_service_continue">Pokračovat</string>
    <string name="dialog_accessibility_service_skip">Přeskočit</string>
    <string name="access_to_app_denied">Balíček není povolen:</string>
    <string name="access_to_app_denied_2">Požádejte svého administrátora, aby tento balíček povolil v konfiguraci.\n\nPokračujte kliknutím na tlačítko \'Zavřít\' nebo Domů.</string>
    <string name="package_id_copied">ID balíčku se zkopíruje do schránky</string>
    <string name="dialog_app_not_allowed_close">Zavřít</string>
    <string name="dialog_app_not_allowed_admin">Administrátor</string>
    <string name="device_id">ID zařízení</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Sériové číslo</string>
    <string name="phone_number">Telefonní číslo</string>
    <string name="launcher_version">Verze launcheru</string>
    <string name="close">Zavřít</string>
    <string name="admin_change_device_id">Změnit ID zařízení</string>
    <string name="admin_change_server_url">Změnit adresu serveru</string>
    <string name="admin_allow_settings">Otevřít nastavení</string>
    <string name="settings_allowed">Máte povoleno 3 minuty měnit nastavení.</string>
    <string name="admin_clear_restrictions">Smazat omezení</string>
    <string name="permissive_mode_enabled">Máte povoleno 3 minuty spouštět všechny aplikace.</string>
    <string name="admin_refresh">Aktualizovat konfiguraci</string>
    <string name="admin_exit">Odejít do systémového launcheru</string>
    <string name="admin_reset_permissions">Zkontrolovat oprávnění</string>
    <string name="admin_reset_network">Resetovat nastavení sítě</string>
    <string name="admin_reset_network_hint">Nastavení sítě bylo resetováno. Nyní můžete znovu připojit síť a aktualizovat konfiguraci</string>
    <string name="reboot">Restartovat zařízení</string>
    <string name="reboot_failed">Nedostatečná oprávnění pro restartování zařízení.</string>
    <string name="message_turn_on_gps">Nyní se otevře nastavení. Prosím zapněte lokalizaci přes GPS.</string>
    <string name="message_turn_off_gps">Nyní se otevře nastavení. Prosím vypněte lokalizaci přes GPS.</string>
    <string name="message_turn_on_mobile_data">Mobilní data jsou vypnuta. Zapněte je prosím ve stavové liště</string>
    <string name="message_turn_off_mobile_data">Mobilní data jsou zapnuta. Vypněte je prosím ve stavové liště.</string>
    <string name="message_set_password">Vaše heslo nesplňuje požadavky. Nyní se otevře nastavení. Prosím změnte si heslo.</string>
    <string name="switch_off_blockings">Vypínám omezení...</string>
    <string name="kiosk_mode_requires_overlays">Režim kiosk vypnut: chybí oprávnění pro vykreslování přes aplikace. Prosím povolte oprávnění pro %s.</string>
    <string name="enter_admin_password">Zadejte administrátorské heslo</string>
    <string name="wrong_password">Špatné heslo</string>
    <string name="dialog_enter_password_login">Přihlásit se</string>
    <string name="dialog_enter_password_cancel">Zavřít</string>
    <string name="internal_error">Aplikace zaznamenala vnitřní chybu. Prosím restartujte zařízení a zkuste znovu.</string>
    <string name="empty_configuration">Prázdná konfigurace! Pokouším se stáhnout konfiguraci ze serveru.</string>
    <string name="permissions_reset_hint">Zavřete panel administrátora pro kontrolu a nastavení oprávnění.</string>
    <string name="dialog_enter_server_error">Prosím zadejte platnou URL serveru.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Prosím zadejte adres URL serveru</string>
    <string name="critical_server_failure">Ukončeno - Chyba serveru! Prosím opravta chybu a restartujte %s, nebo kompletně reinstalujte.</string>
    <string name="dialog_permission_title">Tato aplikace vyžaduje oprávnění k jejímu běhu. Prosím aktivujte je.</string>
    <string name="main_activity_exit">Ukončit</string>
    <string name="browser_not_found">Webová stránka nelze otevřít, protože nebyl nalezen prohlížeč. Prosím přidejte aplikaci prohlížeče do konfigurace zařízení.</string>
    <string name="invalid_web_link">Webový odkaz nelze otevřít, protože má špatný formát. Prosím kontaktujte vašeho administrátora.</string>
    <string name="activity_not_found">Nelze provést akci %s, protože aktivita nebyla nalezena.</string>
    <string name="location_service_text">Poloha zařízení je sledována</string>
    <string name="qrcode_contents_error">Neplatný obsah QR kódu. Prosím vygenerujte QR kód znovu ve webové administraci %s.</string>
    <string name="device_locked">Toto zařízení (%s) bylo zamknuto administrátorem.</string>
    <string name="fault_loop_detected">Launcher se dostal do neobnovitelného stavu! Prosím kontaktujte vašeho administrátora.</string>
    <string name="mqtt_service_text">Push notifikace jsou zapnuté</string>
    <string name="background_location">%s vyžaduje oprávnění sledování polohy na pozadí. Vyberte \'Pokračovat\' pro otevření nastavení. Vyberte \'Poloha\' a možnost sledování polohy kdykoliv.</string>
    <string name="location_disable">Zakázat polohu</string>
    <string name="background_location_continue">Pokračovat</string>
    <string name="initializing_mdm">Připravuji aplikaci pro správu zařízení...</string>
    <string name="dialog_server_error_title">MDM server %s vrátil neplatnou odpověď. Prosím kontaktujte administrátora.</string>
    <string name="mdm_choice_message">Toto zažízení bude plně řízeno vaší organizací. Vaše data nejsou soukromá a mohou být kdykoliv smazána, nebo zobrazena vaším administrátotem.</string>
    <string name="work_profile_message">Na tomto zařízení se vytvoří pracovní profil, který patří vaší organizaci. Pracovní profil je oddělen od vašeho soukromého a lze mezi nimi kdykoliv přepínat.</string>
    <string name="overlays_not_supported">Překreslování obrazovku bohužel není podporováno na vašem zařízení.</string>
    <string name="admin_not_supported">Vaše zařízení nemá možnost vytvoření administrátora zařízení. Vyberte přeskočit pro pokračování.</string>
    <string name="manage_storage_not_supported">Vaše zařízení nemá možnost spravovat externí úložiště.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/ProUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.view.View;

import com.hmdm.launcher.R;
import com.hmdm.launcher.json.ServerConfig;

import java.util.Calendar;

/**
 * These functions are available in Pro-version only
 * In a free version, the class contains stubs
 */
public class ProUtils {

    public static boolean isPro() {
        return false;
    }

    public static boolean kioskModeRequired(Context context) {
        return false;
    }

    public static void initCrashlytics(Context context) {
        // Stub
    }

    public static void sendExceptionToCrashlytics(Throwable e) {
        // Stub
    }

    // Start the service checking if the foreground app is allowed to the user (by usage statistics)
    public static boolean checkAccessibilityService(Context context) {
        // Stub
        return true;
    }

    // Pro-version
    public static boolean checkUsageStatistics(Context context) {
        // Stub
        return true;
    }

    // Add a transparent view on top of the status bar which prevents user interaction with the status bar
    public static View preventStatusBarExpansion(Activity activity) {
        // Stub
        return null;
    }

    // Add a transparent view on top of a swipeable area at the right (opens app list on Samsung tablets)
    public static View preventApplicationsList(Activity activity) {
        // Stub
        return null;
    }

    public static View createKioskUnlockButton(Activity activity) {
        // Stub
        return null;
    }

    public static boolean isKioskAppInstalled(Context context) {
        // Stub
        return false;
    }

    public static boolean isKioskModeRunning(Context context) {
        // Stub
        return false;
    }

    public static Intent getKioskAppIntent(String kioskApp, Activity activity) {
        // Stub
        return null;
    }

    // Start COSU kiosk mode
    public static boolean startCosuKioskMode(String kioskApp, Activity activity, boolean enableSettings) {
        // Stub
        return false;
    }

    // Set/update kiosk mode options (lock tack features)
    public static void updateKioskOptions(Activity activity) {
        // Stub
    }

    // Update app list in the kiosk mode
    public static void updateKioskAllowedApps(String kioskApp, Activity activity, boolean enableSettings) {
        // Stub
    }

    public static void unlockKiosk(Activity activity) {
        // Stub
    }

    public static void processConfig(Context context, ServerConfig config) {
        // Stub
    }

    public static void processLocation(Context context, Location location, String provider) {
        // Stub    
    }

    public static String getAppName(Context context) {
        return context.getString(R.string.app_name);
    }

    public static String getCopyright(Context context) {
        return "(c) " + Calendar.getInstance().get(Calendar.YEAR) + " " + context.getString(R.string.vendor);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/LocationService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.service;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.location.GnssStatus;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.RemoteLogger;

public class LocationService extends Service {
    private LocationManager locationManager;

    private static final int NOTIFICATION_ID = 112;
    public static String CHANNEL_ID = LocationService.class.getName();

    public static final String ACTION_UPDATE_GPS = "gps";
    public static final String ACTION_UPDATE_NETWORK = "network";
    public static final String ACTION_STOP = "stop";

    boolean updateViaGps = false;
    boolean started = false;

    private static final int LOCATION_UPDATE_INTERVAL = 60000;

    // Use different location listeners for GPS and Network
    // Not sure what happens if we share the same listener for both providers
    private LocationListener gpsLocationListener = new LocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            // Do nothing here: we use getLastKnownLocation() to determine the location!
            //Toast.makeText(LocationService.this, "Location updated from GPS", Toast.LENGTH_SHORT).show();
            RemoteLogger.log(LocationService.this, Const.LOG_VERBOSE, "GPS location update: lat="
                    + location.getLatitude() + ", lon=" + location.getLongitude());
            ProUtils.processLocation(LocationService.this, location, LocationManager.GPS_PROVIDER);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        @Override
        public void onProviderEnabled(String provider) {
        }

        @Override
        public void onProviderDisabled(String provider) {
        }
    };
    private LocationListener networkLocationListener = new LocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            // Do nothing here: we use getLastKnownLocation() to determine the location!
            //Toast.makeText(LocationService.this, "Location updated from Network", Toast.LENGTH_SHORT).show();
            RemoteLogger.log(LocationService.this, Const.LOG_VERBOSE, "Network location update: lat="
                    + location.getLatitude() + ", lon=" + location.getLongitude());
            ProUtils.processLocation(LocationService.this, location, LocationManager.NETWORK_PROVIDER);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        @Override
        public void onProviderEnabled(String provider) {
        }

        @Override
        public void onProviderDisabled(String provider) {
        }
    };

    private Handler handler = new Handler();
    private GnssStatus.Callback gnssStatusCallback = null;

    @Override
    public void onCreate() {
        super.onCreate();
        locationManager = (LocationManager)this.getSystemService(LOCATION_SERVICE);

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            gnssStatusCallback = new GnssStatus.Callback() {
                @Override
                public void onSatelliteStatusChanged(@NonNull GnssStatus status) {
                    super.onSatelliteStatusChanged(status);
                    try {
                        Log.d(Const.LOG_TAG, "Satellite status changed, count: " + status.getSatelliteCount());
                        SettingsHelper.getInstance(LocationService.this.getApplicationContext()).setSatelliteCount(status.getSatelliteCount());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            };
        }
    }

    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText( getString( R.string.location_service_text ) )
                .setSmallIcon( R.drawable.ic_location_service ).build();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            startForeground(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
        } else {
            startForeground(NOTIFICATION_ID, notification);
        }
    }

    private boolean requestLocationUpdates() {
        if (updateViaGps && (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) !=
                PackageManager.PERMISSION_GRANTED || !locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER))) {
            updateViaGps = false;
        }
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) !=
                PackageManager.PERMISSION_GRANTED) {
            // No permission, so give up!
            return false;
        }

        boolean gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
        boolean networkEnabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
        boolean passiveEnabled = locationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER);
        RemoteLogger.log(this, Const.LOG_VERBOSE,
                "Request location updates. gps=" + gpsEnabled + ", network=" + networkEnabled + ", passive=" + passiveEnabled);

        locationManager.removeUpdates(networkLocationListener);
        locationManager.removeUpdates(gpsLocationListener);
        try {
            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, LOCATION_UPDATE_INTERVAL, 0, networkLocationListener);
            if (updateViaGps) {
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, LOCATION_UPDATE_INTERVAL, 0, gpsLocationListener);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    locationManager.registerGnssStatusCallback(gnssStatusCallback, handler);
                }
            }
        } catch (Exception e) {
            // Provider may not exist, so process it friendly
            e.printStackTrace();
            return false;
        }

        return true;
    }


    @Override
    public void onDestroy() {
        locationManager.removeUpdates(networkLocationListener);
        locationManager.removeUpdates(gpsLocationListener);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            locationManager.unregisterGnssStatusCallback(gnssStatusCallback);
        }
        started = false;

        super.onDestroy();
    }


    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent inputIntent, int flags, int startId) {
        boolean legacyGpsFlag = updateViaGps;
        if (inputIntent != null && inputIntent.getAction() != null) {
            if (inputIntent.getAction().equals(ACTION_STOP)) {
                // Stop service
                started = false;
                stopForeground(true);
                stopSelf();
                return Service.START_NOT_STICKY;
            } else if (inputIntent.getAction().equals(ACTION_UPDATE_GPS)) {
                updateViaGps = true;
            } else {
                updateViaGps = false;
            }
        } else {
            updateViaGps = false;
        }
        if (!started || legacyGpsFlag != updateViaGps) {
            if (!requestLocationUpdates()) {
                // No permissions!
                started = false;
                stopForeground(true);
                stopSelf();
                return Service.START_NOT_STICKY;
            }
        }
        if (!started) {
            startAsForeground();
            started = true;
        }
        return START_STICKY;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AdminActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.os.UserManager;
import android.util.Log;
import android.view.View;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityAdminBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.LegacyUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class AdminActivity extends BaseActivity {

    private static final String KEY_APP_INFO = "info";
    private SettingsHelper settingsHelper;

    @Nullable
    public static AppInfo getAppInfo(Intent intent){
        if (intent == null){
            return null;
        }
        return intent.getParcelableExtra(KEY_APP_INFO);
    }

    ActivityAdminBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_admin);
        binding.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
        binding.toolbar.setTitle(ProUtils.getAppName(this));
        binding.toolbar.setSubtitle(ProUtils.getCopyright(this));

        // If QR code doesn't contain "android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED":true
        // the system launcher is turned off, so it's not possible to exit and we must hide the exit button
        // Currently the QR code contains this parameter, so the button is always visible
        //binding.systemLauncherButton.setVisibility(Utils.isDeviceOwner(this) ? View.GONE : View.VISIBLE);

        if ( Build.VERSION.SDK_INT <= Build.VERSION_CODES.M ) {
            binding.rebootButton.setVisibility(View.GONE);
        }

        settingsHelper = SettingsHelper.getInstance( this );
        binding.deviceId.setText(settingsHelper.getDeviceId());
        binding.deviceId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                createAndShowInfoDialog();
            }
        });
    }

    @Override
    protected void onPause() {
        super.onPause();

        if (progressDialog != null) {
            progressDialog.dismiss();
            progressDialog = null;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        if (progressDialog != null) {
            progressDialog.dismiss();
            progressDialog = null;
        }
    }

    public void changeDeviceId(View view) {
        dismissDialog(enterDeviceIdDialog);
        createAndShowEnterDeviceIdDialog(false, settingsHelper.getDeviceId());
    }

    public void changeServerUrl(View view) {
        dismissDialog(enterServerDialog);
        createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
    }

    public void allowSettings(View view) {
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_ENABLE_SETTINGS ) );
        Toast.makeText(this, R.string.settings_allowed, Toast.LENGTH_LONG).show();
        startActivity(new Intent(android.provider.Settings.ACTION_SETTINGS));
        //finish();
    }

    public void clearRestrictions(View view) {
        String restrictions =
                UserManager.DISALLOW_SAFE_BOOT + "," +
                UserManager.DISALLOW_USB_FILE_TRANSFER + "," +
                UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA + "," +
                UserManager.DISALLOW_CONFIG_BRIGHTNESS + "," +
                UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT + "," +
                UserManager.DISALLOW_ADJUST_VOLUME;
        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            restrictions = "," + settingsHelper.getConfig().getRestrictions();
        }
        Utils.unlockUserRestrictions(this, restrictions);
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_PERMISSIVE_MODE ) );
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_STOP_CONTROL ) );
        Toast.makeText(this, R.string.permissive_mode_enabled, Toast.LENGTH_LONG).show();
        //finish();
    }
    @Override
    protected void updateSettingsFromQr(String qrcode) {
        super.updateSettingsFromQr(qrcode);
        dismissDialog(enterServerDialog);
        dismissDialog(enterDeviceIdDialog);
        binding.deviceId.setText(settingsHelper.getDeviceId());
    }

    public void saveServerUrl(View view ) {
        if (saveServerUrlBase()) {
            ServerServiceKeeper.resetServices();
            String pushOptions = null;
            if (settingsHelper != null && settingsHelper.getConfig() != null) {
                pushOptions = settingsHelper.getConfig().getPushOptions();
            }
            if (BuildConfig.ENABLE_PUSH && pushOptions != null && (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM))) {
                PushNotificationMqttWrapper.getInstance().disconnect(this);
            }
            updateConfig(view);
        }
    }

    public void saveDeviceId(View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString();
        if ( "".equals( deviceId ) ) {
            return;
        } else {
            settingsHelper.setDeviceId( deviceId );
            enterDeviceIdDialogBinding.setError( false );

            dismissDialog(enterDeviceIdDialog);

            Log.i(Const.LOG_TAG, "saveDeviceId(): calling updateConfig()");
            updateConfig(view);
        }
    }

    public void updateConfig( View view ) {
        LocalBroadcastManager.getInstance( this ).
                sendBroadcast( new Intent( Const.ACTION_UPDATE_CONFIGURATION ) );
        finish();
    }

    public void resetPermissions(View view) {
        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        SharedPreferences preferences = getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        SharedPreferences.Editor editor = preferences.edit();
        editor.remove(Const.PREFERENCES_UNKNOWN_SOURCES);
        editor.remove(Const.PREFERENCES_ADMINISTRATOR);
        editor.remove(Const.PREFERENCES_ACCESSIBILITY_SERVICE);
        editor.remove(Const.PREFERENCES_OVERLAY);
        editor.remove(Const.PREFERENCES_USAGE_STATISTICS);
        editor.remove(Const.PREFERENCES_DEVICE_OWNER);
        editor.remove(Const.PREFERENCES_MIUI_PERMISSIONS);
        editor.remove(Const.PREFERENCES_MIUI_OPTIMIZATION);
        editor.remove(Const.PREFERENCES_DEVICE_OWNER);
        editor.commit();
        RemoteLogger.log(this, Const.LOG_INFO, "Reset saved permissions state, will be refreshed at next start");
        Toast.makeText(this, R.string.permissions_reset_hint, Toast.LENGTH_LONG).show();
    }


    public void resetNetworkPolicy(View view) {
        ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            config.setWifi(null);
            config.setMobileData(null);
            settingsHelper.updateConfig(config);
        }
        RemoteLogger.log(this, Const.LOG_INFO, "Network policies are cleared");
        Toast.makeText(this, R.string.admin_reset_network_hint, Toast.LENGTH_LONG).show();
    }

    public void reboot(View view) {
        if ( Build.VERSION.SDK_INT > Build.VERSION_CODES.M ) {
            ComponentName deviceAdmin = LegacyUtils.getAdminComponentName(this);
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
            try {
                devicePolicyManager.reboot(deviceAdmin);
            } catch (Exception e) {
                Toast.makeText(this, R.string.reboot_failed, Toast.LENGTH_LONG).show();
            }
        }
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttService.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *   James Sutton - isOnline Null Pointer (bug 473775)
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;

import androidx.core.app.NotificationCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.Utils;

import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * <p>
 * The android service which interfaces with an MQTT client implementation
 * </p>
 * <p>
 * The main API of MqttService is intended to pretty much mirror the
 * IMqttAsyncClient with appropriate adjustments for the Android environment.<br>
 * These adjustments usually consist of adding two parameters to each method :-
 * </p>
 * <ul>
 * <li>invocationContext - a string passed from the application to identify the
 * context of the operation (mainly included for support of the javascript API
 * implementation)</li>
 * <li>activityToken - a string passed from the Activity to relate back to a
 * callback method or other context-specific data</li>
 * </ul>
 * <p>
 * To support multiple client connections, the bulk of the MQTT work is
 * delegated to MqttConnection objects. These are identified by "client
 * handle" strings, which is how the Activity, and the higher-level APIs refer
 * to them.
 * </p>
 * <p>
 * Activities using this service are expected to start it and bind to it using
 * the BIND_AUTO_CREATE flag. The life cycle of this service is based on this
 * approach.
 * </p>
 * <p>
 * Operations are highly asynchronous - in most cases results are returned to
 * the Activity by broadcasting one (or occasionally more) appropriate Intents,
 * which the Activity is expected to register a listener for.<br>
 * The Intents have an Action of
 * {@link MqttServiceConstants#CALLBACK_TO_ACTIVITY
 * MqttServiceConstants.CALLBACK_TO_ACTIVITY} which allows the Activity to
 * register a listener with an appropriate IntentFilter.<br>
 * Further data is provided by "Extra Data" in the Intent, as follows :-
 * </p>
 * <table border="1" summary="">
 * <tr>
 * <th align="left">Name</th>
 * <th align="left">Data Type</th>
 * <th align="left">Value</th>
 * <th align="left">Operations used for</th>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_CLIENT_HANDLE
 * MqttServiceConstants.CALLBACK_CLIENT_HANDLE}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The clientHandle identifying the client which
 * initiated this operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">{@link MqttServiceConstants#CALLBACK_STATUS
 * MqttServiceConstants.CALLBACK_STATUS}</td>
 * <td align="left" valign="top">Serializable</td>
 * <td align="left" valign="top">An {@link Status} value indicating success or
 * otherwise of the operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ACTIVITY_TOKEN
 * MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">the activityToken passed into the operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_INVOCATION_CONTEXT
 * MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">the invocationContext passed into the operation
 * </td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">{@link MqttServiceConstants#CALLBACK_ACTION
 * MqttServiceConstants.CALLBACK_ACTION}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">one of
 * <table summary="">
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#SEND_ACTION
 * MqttServiceConstants.SEND_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#UNSUBSCRIBE_ACTION
 * MqttServiceConstants.UNSUBSCRIBE_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#SUBSCRIBE_ACTION
 * MqttServiceConstants.SUBSCRIBE_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#DISCONNECT_ACTION
 * MqttServiceConstants.DISCONNECT_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#CONNECT_ACTION
 * MqttServiceConstants.CONNECT_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#MESSAGE_ARRIVED_ACTION
 * MqttServiceConstants.MESSAGE_ARRIVED_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#MESSAGE_DELIVERED_ACTION
 * MqttServiceConstants.MESSAGE_DELIVERED_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#ON_CONNECTION_LOST_ACTION
 * MqttServiceConstants.ON_CONNECTION_LOST_ACTION}</td>
 * </tr>
 * </table>
 * </td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ERROR_MESSAGE
 * MqttServiceConstants.CALLBACK_ERROR_MESSAGE}
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">A suitable error message (taken from the
 * relevant exception where possible)</td>
 * <td align="left" valign="top">All failing operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ERROR_NUMBER
 * MqttServiceConstants.CALLBACK_ERROR_NUMBER}
 * <td align="left" valign="top">int</td>
 * <td align="left" valign="top">A suitable error code (taken from the relevant
 * exception where possible)</td>
 * <td align="left" valign="top">All failing operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_EXCEPTION_STACK
 * MqttServiceConstants.CALLBACK_EXCEPTION_STACK}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The stacktrace of the failing call</td>
 * <td align="left" valign="top">The Connection Lost event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_MESSAGE_ID
 * MqttServiceConstants.CALLBACK_MESSAGE_ID}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The identifier for the message in the message
 * store, used by the Activity to acknowledge the arrival of the message, so
 * that the service may remove it from the store</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_DESTINATION_NAME
 * MqttServiceConstants.CALLBACK_DESTINATION_NAME}
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The topic on which the message was received</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_MESSAGE_PARCEL
 * MqttServiceConstants.CALLBACK_MESSAGE_PARCEL}</td>
 * <td align="left" valign="top">Parcelable</td>
 * <td align="left" valign="top">The new message encapsulated in Android
 * Parcelable format as a {@link ParcelableMqttMessage}</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * </table>
 */
@SuppressLint("Registered")
public class MqttService extends Service implements MqttTraceHandler {

	// Identifier for Intents, log messages, etc..
	static final String TAG = "MqttService";

	// callback id for making trace callbacks to the Activity
	// needs to be set by the activity as appropriate
	private String traceCallbackId;
	// state of tracing
	private boolean traceEnabled = false;

	// somewhere to persist received messages until we're sure
	// that they've reached the application
	MessageStore messageStore;

	// An intent receiver to deal with changes in network connectivity
	private NetworkConnectionIntentReceiver networkConnectionMonitor;

	// A flag preventing multiple notifications for the foreground service
    boolean started = false;

    // Notification ID for the foreground service
    private static final int NOTIFICATION_ID = 113;

    // Channel ID for the foreground service
    public static String CHANNEL_ID = MqttService.class.getName();

    //a receiver to recognise when the user changes the "background data" preference
  // and a flag to track that preference
  // Only really relevant below android version ICE_CREAM_SANDWICH - see
  // android docs
  private BackgroundDataPreferenceReceiver backgroundDataPreferenceMonitor;
  private volatile boolean backgroundDataEnabled = true;

  // a way to pass ourself back to the activity
  private MqttServiceBinder mqttServiceBinder;

	// mapping from client handle strings to actual client connections.
	private Map<String/* clientHandle */, MqttConnection/* client */> connections = new ConcurrentHashMap<>();

  public MqttService() {
    super();
  }

  /**
   * pass data back to the Activity, by building a suitable Intent object and
   * broadcasting it
   *
   * @param clientHandle
   *            source of the data
   * @param status
   *            OK or Error
   * @param dataBundle
   *            the data to be passed
   */
  void callbackToActivity(String clientHandle, Status status,
      Bundle dataBundle) {
    // Don't call traceDebug, as it will try to callbackToActivity leading
    // to recursion.
    Intent callbackIntent = new Intent(
        MqttServiceConstants.CALLBACK_TO_ACTIVITY);
    if (clientHandle != null) {
      callbackIntent.putExtra(
          MqttServiceConstants.CALLBACK_CLIENT_HANDLE, clientHandle);
    }
    callbackIntent.putExtra(MqttServiceConstants.CALLBACK_STATUS, status);
    if (dataBundle != null) {
      callbackIntent.putExtras(dataBundle);
    }
    LocalBroadcastManager.getInstance(this).sendBroadcast(callbackIntent);
  }

  // The major API implementation follows :-

  /**
   * Get an MqttConnection object to represent a connection to a server
   *
   * @param serverURI specifies the protocol, host name and port to be used to connect to an MQTT server
   * @param clientId specifies the name by which this connection should be identified to the server
   * @param contextId specifies the app conext info to make a difference between apps
   * @param persistence specifies the persistence layer to be used with this client
   * @param defaultMessageListener speficies the default message listener called if messages arrived before subscription
   * @return a string to be used by the Activity as a "handle" for this
   *         MqttConnection
   */
  public String getClient(String serverURI, String clientId, String contextId, MqttClientPersistence persistence,
                          IMqttMessageListener defaultMessageListener) {
    String clientHandle = serverURI + ":" + clientId+":"+contextId;
    if (!connections.containsKey(clientHandle)) {
      MqttConnection client = new MqttConnection(this, serverURI,
          clientId, persistence, clientHandle, defaultMessageListener);
      connections.put(clientHandle, client);
    }
    return clientHandle;
  }

  /**
   * Connect to the MQTT server specified by a particular client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param connectOptions
   *            the MQTT connection options to be used
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttSecurityException thrown if there is a security exception
   * @throws MqttException thrown for all other MqttExceptions
   */
  public void connect(String clientHandle, MqttConnectOptions connectOptions,
      String invocationContext, String activityToken)
      throws MqttSecurityException, MqttException {
	  	MqttConnection client = getConnection(clientHandle);
	  	client.connect(connectOptions, null, activityToken);

  }

  /**
   * Request all clients to reconnect if appropriate
   */
  void reconnect() {
	traceDebug(TAG, "Reconnect to server, client size=" + connections.size());
	for (MqttConnection client : connections.values()) {
			traceDebug("Reconnect Client:",
					client.getClientId() + '/' + client.getServerURI());
		if(this.isOnline() && !client.isConnected()){
			client.reconnect();
		}
	}
  }

  /**
   * Close connection from a particular client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   */
  public void close(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    client.close();
  }

  /**
   * Disconnect from the server
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void disconnect(String clientHandle, String invocationContext,
      String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.disconnect(invocationContext, activityToken);
    connections.remove(clientHandle);


    // the activity has finished using us, so we can stop the service
    // the activities are bound with BIND_AUTO_CREATE, so the service will
    // remain around until the last activity disconnects
    stopSelf();
  }

  /**
   * Disconnect from the server
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param quiesceTimeout
   *            in milliseconds
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void disconnect(String clientHandle, long quiesceTimeout,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.disconnect(quiesceTimeout, invocationContext, activityToken);
    connections.remove(clientHandle);

    // the activity has finished using us, so we can stop the service
    // the activities are bound with BIND_AUTO_CREATE, so the service will
    // remain around until the last activity disconnects
    stopSelf();
  }

  /**
   * Get the status of a specific client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @return true if the specified client is connected to an MQTT server
   */
  public boolean isConnected(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    return client.isConnected();
  }

  /**
   * Publish a message to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            the topic to which to publish
   * @param payload
   *            the content of the message to publish
   * @param qos
   *            the quality of service requested
   * @param retained
   *            whether the MQTT server should retain this message
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttPersistenceException when a problem occurs storing the message
   * @throws MqttException if there was an error publishing the message
   * @return token for tracking the operation
   */
  public IMqttDeliveryToken publish(String clientHandle, String topic,
      byte[] payload, int qos, boolean retained,
      String invocationContext, String activityToken)
      throws MqttPersistenceException, MqttException {
    MqttConnection client = getConnection(clientHandle);
    return client.publish(topic, payload, qos, retained, invocationContext,
        activityToken);
  }

  /**
   * Publish a message to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            the topic to which to publish
   * @param message
   *            the message to publish
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttPersistenceException when a problem occurs storing the message
   * @throws MqttException if there was an error publishing the message
   * @return token for tracking the operation
   */
  public IMqttDeliveryToken publish(String clientHandle, String topic,
      MqttMessage message, String invocationContext, String activityToken)
      throws MqttPersistenceException, MqttException {
    MqttConnection client = getConnection(clientHandle);
    return client.publish(topic, message, invocationContext, activityToken);
  }

  /**
   * Subscribe to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            a possibly wildcarded topic name
   * @param qos
   *            requested quality of service for the topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void subscribe(String clientHandle, String topic, int qos,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topic, qos, invocationContext, activityToken);
  }

  /**
   * Subscribe to one or more topics
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            a list of possibly wildcarded topic names
   * @param qos
   *            requested quality of service for each topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void subscribe(String clientHandle, String[] topic, int[] qos,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topic, qos, invocationContext, activityToken);
  }

  /**
   * Subscribe using topic filters
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topicFilters
   *            a list of possibly wildcarded topicfilters
   * @param qos
   *            requested quality of service for each topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @param messageListeners a callback to handle incoming messages
   */
  public void subscribe(String clientHandle, String[] topicFilters, int[] qos, String invocationContext, String activityToken, IMqttMessageListener[] messageListeners){
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topicFilters, qos, invocationContext, activityToken, messageListeners);
  }

  /**
   * Unsubscribe from a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @param topic
   *            a possibly wildcarded topic name
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void unsubscribe(String clientHandle, final String topic,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.unsubscribe(topic, invocationContext, activityToken);
  }

  /**
   * Unsubscribe from one or more topics
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @param topic
   *            a list of possibly wildcarded topic names
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void unsubscribe(String clientHandle, final String[] topic,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.unsubscribe(topic, invocationContext, activityToken);
  }

  /**
   * Get tokens for all outstanding deliveries for a client
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @return an array (possibly empty) of tokens
   */
  public IMqttDeliveryToken[] getPendingDeliveryTokens(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    return client.getPendingDeliveryTokens();
  }

  /**
   * Get the MqttConnection identified by this client handle
   *
   * @param clientHandle identifies the MqttConnection
   * @return the MqttConnection identified by this handle
   */
  private MqttConnection getConnection(String clientHandle) {
    MqttConnection client = connections.get(clientHandle);
    if (client == null) {
      throw new IllegalArgumentException("Invalid ClientHandle");
    }
    return client;
  }

  /**
   * Called by the Activity when a message has been passed back to the
   * application
   *
   * @param clientHandle identifier for the client which received the message
   * @param id identifier for the MQTT message
   * @return {@link Status}
   */
  public Status acknowledgeMessageArrival(String clientHandle, String id) {
    if (messageStore.discardArrived(clientHandle, id)) {
      return Status.OK;
    }
    else {
      return Status.ERROR;
    }
  }

  // Extend Service

  /**
   * @see android.app.Service#onCreate()
   */
  @Override
  public void onCreate() {
    super.onCreate();

    // create a binder that will let the Activity UI send
    // commands to the Service
    mqttServiceBinder = new MqttServiceBinder(this);

    // create somewhere to buffer received messages until
    // we know that they have been passed to the application
    messageStore = new DatabaseMessageStore(this, this);
	}



	/**
	 * @see android.app.Service#onDestroy()
	 */
	@Override
	public void onDestroy() {
		// disconnect immediately
		for (MqttConnection client : connections.values()) {
			client.disconnect(null, null);
		}

    // clear down
    if (mqttServiceBinder != null) {
      mqttServiceBinder = null;
    }

		unregisterBroadcastReceivers();

		if (this.messageStore !=null )
			this.messageStore.close();

		super.onDestroy();
	}

  /**
   * @see android.app.Service#onBind(Intent)
   */
  @Override
  public IBinder onBind(Intent intent) {
    // What we pass back to the Activity on binding -
    // a reference to ourself, and the activityToken
    // we were given when started
    String activityToken = intent
        .getStringExtra(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
    mqttServiceBinder.setActivityToken(activityToken);
    return mqttServiceBinder;
  }

  /**
   * @see android.app.Service#onStartCommand(Intent,int,int)
   */
  @Override
  public int onStartCommand(final Intent intent, int flags, final int startId) {
    // run till explicitly stopped, restart when
    // process restarted
	registerBroadcastReceivers();

	if (BuildConfig.MQTT_SERVICE_FOREGROUND && !started) {
        startAsForeground();
        started = true;
    }

      SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
      if (intent != null && intent.getBooleanExtra(MqttAndroidClient.EXTRA_START_AT_BOOT, false)) {
          try {
              String domain = intent.getStringExtra(MqttAndroidClient.EXTRA_DOMAIN);
              String pushType = intent.getStringExtra(MqttAndroidClient.EXTRA_PUSH_OPTIONS);
              int keepaliveTime = intent.getIntExtra(MqttAndroidClient.EXTRA_KEEPALIVE_TIME, Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC);
              String deviceId = intent.getStringExtra(MqttAndroidClient.EXTRA_DEVICE_ID);

              PushNotificationMqttWrapper.getInstance().connect(this,
                      domain, BuildConfig.MQTT_PORT, pushType, keepaliveTime, deviceId,
                      null,null);
          } catch (Exception e) {
              e.printStackTrace();
          }
      }

    return START_STICKY;
  }

    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText(getString(R.string.mqtt_service_text))
                .setSmallIcon(R.drawable.ic_mqtt_service).build();

        Utils.startStableForegroundService(this, NOTIFICATION_ID, notification);
    }


    /**
   * Identify the callbackId to be passed when making tracing calls back into
   * the Activity
   *
   * @param traceCallbackId identifier to the callback into the Activity
   */
  public void setTraceCallbackId(String traceCallbackId) {
    this.traceCallbackId = traceCallbackId;
  }

  /**
   * Turn tracing on and off
   *
   * @param traceEnabled set <code>true</code> to turn on tracing, <code>false</code> to turn off tracing
   */
  public void setTraceEnabled(boolean traceEnabled) {
    this.traceEnabled = traceEnabled;
  }

  /**
   * Check whether trace is on or off.
   *
   * @return the state of trace
   */
  public boolean isTraceEnabled(){
	  return this.traceEnabled;
  }

  /**
   * Trace debugging information
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   */
  @Override
  public void traceDebug(String tag, String message) {
    traceCallback(MqttServiceConstants.TRACE_DEBUG, tag, message);
  }

  /**
   * Trace error information
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   */
  @Override
  public void traceError(String tag, String message) {
    traceCallback(MqttServiceConstants.TRACE_ERROR, tag, message);
  }

  private void traceCallback(String severity, String tag, String message) {
    if ((traceCallbackId != null) && (traceEnabled)) {
      Bundle dataBundle = new Bundle();
      dataBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.TRACE_ACTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY, severity);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_TAG, tag);
      //dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_ID, traceCallbackId);
      dataBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE, message);
      callbackToActivity(traceCallbackId, Status.ERROR, dataBundle);
    }
  }

  /**
   * trace exceptions
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   * @param e
   *            the exception
   */
  @Override
  public void traceException(String tag, String message, Exception e) {
    if (traceCallbackId != null) {
      Bundle dataBundle = new Bundle();
      dataBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.TRACE_ACTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY, MqttServiceConstants.TRACE_EXCEPTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,  message);
      dataBundle.putSerializable(MqttServiceConstants.CALLBACK_EXCEPTION, e); //TODO: Check
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_TAG, tag);
      //dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_ID, traceCallbackId);
      callbackToActivity(traceCallbackId, Status.ERROR, dataBundle);
    }
  }

  @SuppressWarnings("deprecation")
  private void registerBroadcastReceivers() {
		if (networkConnectionMonitor == null) {
			networkConnectionMonitor = new NetworkConnectionIntentReceiver();
			registerReceiver(networkConnectionMonitor, new IntentFilter(
					ConnectivityManager.CONNECTIVITY_ACTION));
		}

		if (Build.VERSION.SDK_INT < 14 /**Build.VERSION_CODES.ICE_CREAM_SANDWICH**/) {
			// Support the old system for background data preferences
			ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
			backgroundDataEnabled = cm.getBackgroundDataSetting();
			if (backgroundDataPreferenceMonitor == null) {
				backgroundDataPreferenceMonitor = new BackgroundDataPreferenceReceiver();
				registerReceiver(
						backgroundDataPreferenceMonitor,
						new IntentFilter(
								ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED));
			}
		}
  }

  private void unregisterBroadcastReceivers(){
  	if(networkConnectionMonitor != null){
  		unregisterReceiver(networkConnectionMonitor);
  		networkConnectionMonitor = null;
  	}

  	if (Build.VERSION.SDK_INT < 14 /**Build.VERSION_CODES.ICE_CREAM_SANDWICH**/) {
  		if(backgroundDataPreferenceMonitor != null){
  			unregisterReceiver(backgroundDataPreferenceMonitor);
  		}
		}
  }

  /*
   * Called in response to a change in network connection - after losing a
   * connection to the server, this allows us to wait until we have a usable
   * data connection again
   */
  private class NetworkConnectionIntentReceiver extends BroadcastReceiver {

		@Override
        @SuppressLint("Wakelock")
		public void onReceive(Context context, Intent intent) {
			traceDebug(TAG, "Internal network status receive.");
			// we protect against the phone switching off
			// by requesting a wake lock - we request the minimum possible wake
			// lock - just enough to keep the CPU running until we've finished
			PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
			WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "org.eclipse.paho:mqtt");
			wl.acquire();
			traceDebug(TAG,"Reconnect for Network recovery.");
			if (isOnline()) {
				traceDebug(TAG,"Online,reconnect.");
				// we have an internet connection - have another try at
				// connecting
				reconnect();
			} else {
				notifyClientsOffline();
			}

			wl.release();
		}
  }

	/**
	 * @return whether the android service can be regarded as online
	 */
	public boolean isOnline() {
		ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
		NetworkInfo networkInfo = cm.getActiveNetworkInfo();
      //noinspection RedundantIfStatement
      if (networkInfo != null
              && networkInfo.isAvailable()
              && networkInfo.isConnected()
              && backgroundDataEnabled) {
			return true;
		}

		return false;
	}

	/**
	 * Notify clients we're offline
	 */
    private void notifyClientsOffline() {
		for (MqttConnection connection : connections.values()) {
			connection.offline();
		}
	}

	/**
	 * Detect changes of the Allow Background Data setting - only used below
	 * ICE_CREAM_SANDWICH
	 */
	private class BackgroundDataPreferenceReceiver extends BroadcastReceiver {

		@SuppressWarnings("deprecation")
		@Override
		public void onReceive(Context context, Intent intent) {
			ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
			traceDebug(TAG,"Reconnect since BroadcastReceiver.");
			if (cm.getBackgroundDataSetting()) {
				if (!backgroundDataEnabled) {
					backgroundDataEnabled = true;
					// we have the Internet connection - have another try at
					// connecting
					reconnect();
				}
			} else {
				backgroundDataEnabled = false;
				notifyClientsOffline();
			}
		}
	}

  /**
   * Sets the DisconnectedBufferOptions for this client
   * @param clientHandle identifier for the client
   * @param bufferOpts the DisconnectedBufferOptions for this client
   */
  public void setBufferOpts(String clientHandle, DisconnectedBufferOptions bufferOpts) {
    MqttConnection client = getConnection(clientHandle);
    client.setBufferOpts(bufferOpts);
  }

  public int getBufferedMessageCount(String clientHandle){
    MqttConnection client = getConnection(clientHandle);
    return client.getBufferedMessageCount();
  }

  public MqttMessage getBufferedMessage(String clientHandle, int bufferIndex){
    MqttConnection client = getConnection(clientHandle);
    return client.getBufferedMessage(bufferIndex);
  }

  public void deleteBufferedMessage(String clientHandle, int bufferIndex){
    MqttConnection client = getConnection(clientHandle);
    client.deleteBufferedMessage(bufferIndex);
  }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Application.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Application {

    public static final String TYPE_APP = "app";
    public static final String TYPE_WEB = "web";
    public static final String TYPE_INTENT = "intent";

    private String type;
    private String name;
    private String pkg;
    private String version;
    private Integer code;
    private String url;
    private boolean useKiosk;
    private boolean showIcon;
    private boolean remove;
    private boolean runAfterInstall;
    private boolean runAtBoot;
    private boolean skipVersion;
    private String iconText;
    private String icon;
    private Integer screenOrder;
    private Integer keyCode;
    private boolean bottom;
    private boolean longTap;
    private String intent;

    public Application() {}

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPkg() {
        return pkg;
    }

    public void setPkg(String pkg) {
        this.pkg = pkg;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public boolean isUseKiosk() {
        return useKiosk;
    }

    public void setUseKiosk(boolean useKiosk) {
        this.useKiosk = useKiosk;
    }

    public boolean isShowIcon() {
        return showIcon;
    }

    public void setShowIcon(boolean showIcon) {
        this.showIcon = showIcon;
    }

    public boolean isRemove() {
        return remove;
    }

    public void setRemove(boolean remove) {
        this.remove = remove;
    }

    public boolean isRunAfterInstall() {
        return runAfterInstall;
    }

    public void setRunAfterInstall(boolean runAfterInstall) {
        this.runAfterInstall = runAfterInstall;
    }

    public boolean isRunAtBoot() {
        return runAtBoot;
    }

    public void setRunAtBoot(boolean runAtBoot) {
        this.runAtBoot = runAtBoot;
    }

    public boolean isSkipVersion() {
        return skipVersion;
    }

    public void setSkipVersion(boolean skipVersion) {
        this.skipVersion = skipVersion;
    }

    public String getIconText() {
        return iconText;
    }

    public void setIconText(String iconText) {
        this.iconText = iconText;
    }

    public String getIcon() {
        return icon;
    }

    public void setIcon(String icon) {
        this.icon = icon;
    }

    public Integer getScreenOrder() {
        return screenOrder;
    }

    public void setScreenOrder(Integer screenOrder) {
        this.screenOrder = screenOrder;
    }

    public Integer getKeyCode() {
        return keyCode;
    }

    public void setKeyCode(Integer keyCode) {
        this.keyCode = keyCode;
    }

    public boolean isBottom() {
        return bottom;
    }

    public void setBottom(boolean bottom) {
        this.bottom = bottom;
    }

    public boolean isLongTap() {
        return longTap;
    }

    public void setLongTap(boolean longTap) {
        this.longTap = longTap;
    }

    public String getIntent() {
        return intent;
    }

    public void setIntent(String intent) {
        this.intent = intent;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/PushNotificationMqttWrapper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.work.Data;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.json.PushMessageJson;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.worker.PushNotificationProcessor;

import org.eclipse.paho.android.service.MqttAndroidClient;
import org.eclipse.paho.android.service.MqttAndroidConnectOptions;
import org.eclipse.paho.android.service.PingDeathDetector;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.json.JSONObject;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class PushNotificationMqttWrapper {
    private static PushNotificationMqttWrapper instance;

    private MqttAndroidClient client;
    private Handler handler = new Handler(Looper.getMainLooper());
    private Handler connectHangupMonitorHandler = new Handler(Looper.getMainLooper());
    private BroadcastReceiver debugReceiver;
    private Context context;
    private boolean needProcessConnectExtended;

    private static final String WORKER_TAG_MQTT_RECONNECT = "com.hmdm.launcher.WORK_TAG_MQTT_RECONNECT";
    private static final int MQTT_RECONNECT_INTERVAL_SEC = 900;

    // If more than 20 connections per minute, we are stopping:
    // this is a sign that two devices with the same ID are registered
    private List<Long> connectionLoopProtectionArray = new LinkedList<>();
    private static final int CONNECTION_LOOP_PROTECTION_TIME_MS = 60000;
    private static final int CONNECTION_LOOP_CRITICAL_COUNT = 15;

    private PushNotificationMqttWrapper() {
    }

    public static PushNotificationMqttWrapper getInstance() {
        if (instance == null) {
            instance = new PushNotificationMqttWrapper();
        }
        return instance;
    }

    public void connect(final Context context, String host, int port, String pushType, int keepaliveTime,
                        final String deviceId, final Runnable onSuccess, final Runnable onFailure) {
        this.context = context;
        cancelReconnectionAfterFailure(context);
        if (client != null && client.isConnected()) {
            if (onSuccess != null) {
                handler.post(onSuccess);
            }
            return;
        }
        MqttAndroidConnectOptions connectOptions = new MqttAndroidConnectOptions();
        connectOptions.setAutomaticReconnect(true);
        connectOptions.setKeepAliveInterval(keepaliveTime);
        connectOptions.setCleanSession(false);
        if (pushType.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)) {
            connectOptions.setPingType(MqttAndroidConnectOptions.PING_WORKER);
            // For worker, keepalive time cannot be less than 15 minutes
            connectOptions.setKeepAliveInterval(Const.DEFAULT_PUSH_WORKER_KEEPALIVE_TIME_SEC);
        } else {
            connectOptions.setPingType(MqttAndroidConnectOptions.PING_ALARM);
            connectOptions.setKeepAliveInterval(keepaliveTime);
        }
        connectOptions.setUserName("hmdm");
        connectOptions.setPassword(CryptoHelper.getSHA1String("hmdm" + BuildConfig.REQUEST_SIGNATURE).toCharArray());
        String serverUri = "tcp://" + host + ":" + port;

        if (client != null) {
            // Here we go after reconnection.
            // Previous client is disconnected and in "Failure" state, but it listens for broadcasts
            // We need to clean it up before registering a new client
            client.unregisterResources();
        }

        client = new MqttAndroidClient(context, serverUri, deviceId);
        client.setTraceEnabled(true);
        client.setDefaultMessageListener(mqttMessageListener);
        setupDebugging(context);

        // We need to re-subscribe after reconnection. This is required because server may be not persistent
        // so after the server restart all subscription info is lost
        client.setCallback(new MqttCallbackExtended() {

            @Override
            public void connectionLost(Throwable cause) {
            }

            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
            }

            @Override
            public void connectComplete(boolean reconnect, String serverURI) {
                if (reconnect || needProcessConnectExtended) {
                    RemoteLogger.log(context, Const.LOG_VERBOSE, "Reconnect complete");
                    if (checkConnectionLoop()) {
                        subscribe(context, deviceId, null, null);
                    } else {
                        RemoteLogger.log(context, Const.LOG_ERROR, "Reconnection loop detected! You have multiple devices with ID=" + deviceId + "! MQTT service stopped.");
                        disconnect(context);
                    }
                }
            }
        });

        try {
            needProcessConnectExtended = false;

            // If connection hangs up, consider it as failure and continue the flow
            connectHangupMonitorHandler.postDelayed(() -> {
                RemoteLogger.log(context, Const.LOG_WARN, "MQTT connection timeout, disconnecting");
                try {
                    client.disconnect();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                scheduleReconnectionAfterFailure(context, host, port, pushType, keepaliveTime, deviceId);
                if (onFailure != null) {
                    handler.post(onFailure);
                }
            }, 30000);

            client.connect(connectOptions, null, new IMqttActionListener() {
                @Override
                public void onSuccess(IMqttToken asyncActionToken) {
                    // We believe that if connect is successful, subscribe() won't hang up
                    connectHangupMonitorHandler.removeCallbacksAndMessages(null);
                    subscribe(context, deviceId, onSuccess, onFailure);
                }

                @Override
                public void onFailure(IMqttToken asyncActionToken, Throwable e) {
                    e.printStackTrace();
                    connectHangupMonitorHandler.removeCallbacksAndMessages(null);
                    RemoteLogger.log(context, Const.LOG_WARN, "MQTT connection failure");
                    scheduleReconnectionAfterFailure(context, host, port, pushType, keepaliveTime, deviceId);
                    // We fail here but Mqtt client tries to reconnect and we need to subscribe
                    // after connection succeeds. This is done in the extended callback client.
                    // The flag needProcessConnectExtended prevents duplicate subscribe after
                    // successful connection
                    needProcessConnectExtended = true;
                    if (onFailure != null) {
                        handler.post(onFailure);
                    }
                }
            });


        } catch (MqttException e) {
            e.printStackTrace();
            if (onFailure != null) {
                handler.post(onFailure);
            }
        }
    }

    private boolean checkConnectionLoop() {
        Long now = System.currentTimeMillis();
        // Remove old items
        for (int n = 0; n < connectionLoopProtectionArray.size(); n++) {
            if (connectionLoopProtectionArray.get(n) < now - CONNECTION_LOOP_PROTECTION_TIME_MS) {
                connectionLoopProtectionArray.remove(n);
                n--;
            }
        }
        connectionLoopProtectionArray.add(now);
        return connectionLoopProtectionArray.size() <= CONNECTION_LOOP_CRITICAL_COUNT;
    }

    private IMqttMessageListener mqttMessageListener = new IMqttMessageListener() {
        @Override
        public void messageArrived(String topic, final MqttMessage message) throws Exception {
            handler.post(new Runnable() {
                @Override
                public void run() {
                    try {
                        JSONObject obj = new JSONObject(new String(message.getPayload()));
                        String messageType = obj.getString("messageType");
                        PushMessageJson msg = new PushMessageJson(messageType, obj.optJSONObject("payload"));
                        PushNotificationProcessor.process(msg, context);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });

        }
    };

    private void subscribe(final Context context, final String deviceId, final Runnable onSuccess, final Runnable onFailure) {
        try {
            // Topic is deviceId
            client.subscribe(deviceId, 2, mqttMessageListener);
            if (onSuccess != null) {
                RemoteLogger.log(context, Const.LOG_DEBUG, "MQTT connection established");
                handler.post(onSuccess);
            }
        } catch (Exception e) {
            e.printStackTrace();
            RemoteLogger.log(context, Const.LOG_DEBUG, "Exception while subscribing: " + e.getMessage());
            if (onFailure != null) {
                handler.post(onFailure);
            }
        }
    }

    private void setupDebugging(Context context) {
        if (debugReceiver == null) {
            debugReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String errorMessage = intent.getStringExtra("MqttService.errorMessage");
                    if (errorMessage != null) {
                        Log.d(Const.LOG_TAG, intent.getStringExtra("MqttService.traceTag") + " " + errorMessage);
                    }
                }
            };
            LocalBroadcastManager.getInstance(context).registerReceiver(debugReceiver, new IntentFilter("MqttService.callbackToActivity.v0"));
        }
    }

    public void disconnect(Context context) {
        try {
            cancelReconnectionAfterFailure(context);
            RemoteLogger.log(context, Const.LOG_DEBUG, "MQTT client disconnected by user request");
            client.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
        client = null;
        LocalBroadcastManager.getInstance(context).unregisterReceiver(debugReceiver);
        debugReceiver = null;
    }

    private void cancelReconnectionAfterFailure(Context context) {
        WorkManager.getInstance(context.getApplicationContext()).cancelUniqueWork(WORKER_TAG_MQTT_RECONNECT);
    }

    private void scheduleReconnectionAfterFailure(Context context, String host, int port,
                                                  String pushType, int keepaliveTime, final String deviceId) {
        RemoteLogger.log(context, Const.LOG_INFO, "Scheduling MQTT reconnection in " + MQTT_RECONNECT_INTERVAL_SEC + " sec");
        Data data = new Data.Builder()
                .putString("host", host)
                .putInt("port", port)
                .putString("pushType", pushType)
                .putInt("keepalive", keepaliveTime)
                .putString("deviceId", deviceId)
                .build();
        OneTimeWorkRequest queryRequest =
                new OneTimeWorkRequest.Builder(PushNotificationMqttWrapper.ReconnectAfterFailureWorker.class)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(MQTT_RECONNECT_INTERVAL_SEC, TimeUnit.SECONDS)
                        .setInputData(data)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniqueWork(WORKER_TAG_MQTT_RECONNECT,
                ExistingWorkPolicy.REPLACE, queryRequest);
    }

    public static class ReconnectAfterFailureWorker extends Worker {

        private Context context;

        public ReconnectAfterFailureWorker(
                @NonNull final Context context,
                @NonNull WorkerParameters params) {
            super(context, params);
            this.context = context;
        }

        @NonNull
        @Override
        public Result doWork() {
            Data data = getInputData();
            PushNotificationMqttWrapper.getInstance().connect(context, data.getString("host"),
                    data.getInt("port", 0), data.getString("pushType"),
                    data.getInt("keepalive", Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC),
                    data.getString("deviceId"), null, null);
            return Result.success();
        }
    }

    public boolean checkPingDeath(Context context) {
        // If not connected, ping is not working so we return false
        return client != null && client.isConnected() && PingDeathDetector.getInstance().detectPingDeath(context);
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/SystemUtils.java">
package com.hmdm.launcher.util;

import android.annotation.TargetApi;
import android.app.AppOpsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.provider.Settings;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Method;

/**
 * These utils are used only in the 'system' flavor
 * when Headwind MDM is installed as a system app and
 * signed by OS keys
 */
public class SystemUtils {

    /**
     * This command requires system privileges: MANAGE_DEVICE_ADMINS, MANAGE_PROFILE_AND_DEVICE_OWNERS
     * The MANAGE_PROFILE_AND_DEVICE_OWNERS is only provided to system apps!
     *
     * Also, there's the following restriction in the DevicePolicyManagerService.java:
     * The device owner can only be set before the setup phase of the primary user has completed,
     * except for adb command if no accounts or additional users are present on the device.
     *
     * So it looks like Headwind MDM can never declare itself as a device owner,
     * except when it is running from inside a setup wizard (or declares itself as a setup wizard!)
     * To become a setup wizard, Headwind MDM should be preinstalled in the system, and
     * handle the following intent: android.intent.action.DEVICE_INITIALIZATION_WIZARD
     *
     * @param context
     * @return
     */
    public static boolean becomeDeviceOwnerByCommand(Context context) {
        String command = "dpm set-device-owner " + context.getPackageName() + "/.AdminReceiver";
        String result = executeShellCommand(command, false);
        RemoteLogger.log(context, Const.LOG_INFO, "DPM command output: " + result);
        return result.startsWith("Active admin component set");
    }

    public static String executeShellCommand(String command, boolean useShell) {
        StringBuffer output = new StringBuffer();

        Process p;
        try {
            if (useShell) {
                String[] cmdArray = {"sh", "-c", command};
                p = Runtime.getRuntime().exec(cmdArray);
            } else {
                p = Runtime.getRuntime().exec(command);
            }
            p.waitFor();
            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

            String line = "";
            while ((line = reader.readLine()) != null) {
                output.append(line + "\n");
            }

            if (output.toString().trim().equalsIgnoreCase("")) {
                // No output, try to read an error!
                BufferedReader errorReader = new BufferedReader(new InputStreamReader(p.getErrorStream()));
                while ((line = errorReader.readLine()) != null) {
                    output.append(line + "\n");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        String response = output.toString();
        return response;
    }

    public static boolean autoSetDeviceId(Context context) {
        String deviceIdUse = SettingsHelper.getInstance(context).getDeviceIdUse();
        String deviceId = null;
        Log.d(Const.LOG_TAG, "Device ID choice: " + deviceIdUse);
        if (BuildConfig.DEVICE_ID_CHOICE.equals("imei") || "imei".equals(deviceIdUse)) {
            deviceId = DeviceInfoProvider.getImei(context);
        } else if (BuildConfig.DEVICE_ID_CHOICE.equals("serial") || "serial".equals(deviceIdUse)) {
            deviceId = DeviceInfoProvider.getSerialNumber();
            if (deviceId.equals(Build.UNKNOWN)) {
                deviceId = null;
            }
        } else if (BuildConfig.DEVICE_ID_CHOICE.equals("mac")) {
            deviceId = DeviceInfoProvider.getMacAddress();
        }

        if (deviceId == null || deviceId.length() == 0) {
            return false;
        }

        return SettingsHelper.getInstance(context.getApplicationContext()).setDeviceId(deviceId);
    }

    public static boolean becomeDeviceOwnerByXmlFile(Context context) {
        ComponentName cn = LegacyUtils.getAdminComponentName(context);

        final String deviceOwnerFileName = "/data/system/device_owner_2.xml";
        final String deviceOwnerFileContent = "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n" +
                "<root>\n" +
                "<device-owner package=\"" + cn.getPackageName() + "\" name=\"\" " +
                "component=\"" + cn.getPackageName() + "/" + cn.getClassName() + "\" userRestrictionsMigrated=\"true\" canAccessDeviceIds=\"true\" />\n" +
                "<device-owner-context userId=\"0\" />\n" +
                "</root>";

        final String devicePoliciesFileName = "/data/system/device_policies.xml";
        final String devicePoliciesFileContent = "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n" +
                "<policies setup-complete=\"true\" provisioning-state=\"3\">\n" +
                "<admin name=\"" + cn.getPackageName() + "/" + cn.getClassName() + "\">\n" +
                "<policies flags=\"17\" />\n" +
                "<strong-auth-unlock-timeout value=\"0\" />\n" +
                "<user-restrictions no_add_managed_profile=\"true\" />\n" +
                "<default-enabled-user-restrictions>\n" +
                "<restriction value=\"no_add_managed_profile\" />\n" +
                "</default-enabled-user-restrictions>\n" +
                "<cross-profile-calendar-packages />\n" +
                "</admin>\n" +
                "<password-validity value=\"true\" />\n" +
                "<lock-task-features value=\"16\" />\n" +
                "</policies>";

        if (!Utils.writeStringToFile(deviceOwnerFileName, deviceOwnerFileContent, false)) {
            Log.e(Const.LOG_TAG, "Could not create device owner file " + deviceOwnerFileName);
            return false;
        }

        // Now when we succeeded to create the device owner file, let's update device policies file
        if (!Utils.writeStringToFile(devicePoliciesFileName, devicePoliciesFileContent, true)) {
            Log.e(Const.LOG_TAG, "Could not update device policies file " + devicePoliciesFileName);
            return false;
        }
        return true;
    }

    // https://stackoverflow.com/questions/10061154/how-to-programmatically-enable-disable-accessibility-service-in-android
    public static void autoSetAccessibilityPermission(Context context, String packageName, String className) {
        Settings.Secure.putString(context.getContentResolver(),
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, packageName + "/" + className);
        Settings.Secure.putString(context.getContentResolver(),
                Settings.Secure.ACCESSIBILITY_ENABLED, "1");
    }

    static final int OP_WRITE_SETTINGS = 23;
    static final int OP_SYSTEM_ALERT_WINDOW = 24;
    static final int OP_GET_USAGE_STATS = 43;
    static final int OP_MANAGE_EXTERNAL_STORAGE = 92;

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetOverlayPermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_SYSTEM_ALERT_WINDOW, "Overlay");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetUsageStatsPermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_GET_USAGE_STATS, "Usage history");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetStoragePermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_MANAGE_EXTERNAL_STORAGE, "Manage storage");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetPermission(Context context, String packageName, int permission, String permText) {
        PackageManager packageManager = context.getPackageManager();
        int uid = 0;
        try {
            ApplicationInfo applicationInfo = packageManager.getApplicationInfo(packageName, 0);
            uid = applicationInfo.uid;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return false;
        }

        AppOpsManager appOpsManager = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);

        // src/com/android/settings/applications/DrawOverlayDetails.java
        // See method: void setCanDrawOverlay(boolean newState)
        try {
            Class clazz = AppOpsManager.class;
            Method method = clazz.getDeclaredMethod("setMode", int.class, int.class, String.class, int.class);
            method.invoke(appOpsManager, permission, uid, packageName, AppOpsManager.MODE_ALLOWED);
            Log.d(Const.LOG_TAG, permText + " permission granted to " + packageName);
            return true;
        } catch (Exception e) {
            Log.e(Const.LOG_TAG, Log.getStackTraceString(e));
            return false;
        }
    }
}
</file>

<file path="app/src/main/res/values-ja/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">管理者</string>
    <string name="install_error">インストールエラー</string>
    <string name="file_create_error">ファイル作成エラー</string>
    <string name="dialog_enter_device_id_error">このIDは %s に登録されていません。コントロールパネルの\"端末\" タブからIDを取得して下さい。</string>
    <string name="dialog_enter_device_id_qrcode">QRコード</string>
    <string name="dialog_enter_device_id_variants">バリアント</string>
    <string name="dialog_enter_device_id_save">保存</string>
    <string name="dialog_enter_device_id_exit">終了</string>
    <string name="dialog_enter_device_id_title">%s にデバイスIDを入力してください</string>
    <string name="main_start_preparations">起動中</string>
    <string name="main_downloading_configuration">設定ファイルを更新中</string>
    <string name="main_downloading_content">データ更新中</string>
    <string name="main_update_applications">アプリケーションのインストールと更新</string>
    <string name="dialog_root_message">ROOT権限が必要です</string>
    <string name="main_application_start">アプリケーションを開始</string>
    <string name="main_app_installing">アプリケーションをインストール</string>
    <string name="main_app_downloading">アプリケーションをダウンロードしています</string>
    <string name="main_app_downloading_error">パッケージのダウンロードに失敗しました</string>
    <string name="main_app_removing">アプリケーションをアンインストールしています</string>
    <string name="main_file_downloading">ファイルをダウンロードしています</string>
    <string name="main_file_downloading_error">ファイルのダウンロードに失敗しました</string>
    <string name="main_activity_repeat">再試行</string>
    <string name="main_activity_reset">リセット</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">キャンセル</string>
    <string name="main_activity_details">詳細</string>
    <string name="select_system_launcher">%s をデフォルトのランチャーとして選択し、\'常に\' にチェックを入れます:</string>
    <string name="dialog_network_error_title">%s への接続エラー。インターネット接続を確認して、再試行してください。</string>
    <string name="main_activity_update_config">サーバーから設定ファイルをリクエストしています</string>
    <string name="main_activity_applications_update">アプリケーションの更新</string>
    <string name="dialog_overlay_settings_title">アプリが他のウィンドウの上に描画できるようにしてください。\n\nこのオプションは、不要なアプリをより効果的にブロックし、キオスクモードの緊急ロック解除を可能にします。\n\n\"続行\" をタップして設定を開きますシート。 \"%s\" アイテムを見つけて許可を与え、\"戻る\" をタップしてください。</string>
    <string name="dialog_manage_storage_title">アプリにストレージの管理を許可してください。\n\nこのオプションにより、Headwind MDM はデバイス上のファイルを管理できるようになります。</string>
    <string name="dialog_history_settings_title">アプリが使用状況データにアクセスできるようにしてください。\n\nこのオプションにより、アプリと設定の制御が可能になります。\n\nこのオプションにより、バッテリーの消耗が早くなる可能性があります。バッテリーを節約するには、このオプションをスキップしてください (代わりにアクセシビリティサービスまたはキオスクモードを使用してください)。\n\n \"続行\" をタップして設定シートを開きます。 \"%s\" アイテムを見つけて権限を与え、\"戻る\" をタップしてください。</string>
    <string name="dialog_history_settings_continue">続ける</string>
    <string name="dialog_history_settings_skip">スキップ</string>
    <string name="dialog_unknown_sources_title">提供元不明のインストールを許可してください。設定シートが開きます。 \"不明なソース\" を見つけて、インストールを許可し、\"戻る\" をクリックします。</string>
    <string name="dialog_unknown_sources_continue">続ける</string>
    <string name="dialog_miui_permissions_title">MIUIではカスタム権限を手動で設定する必要があります。アプリの権限ウィンドウが開きます。 \"その他の権限\" をタップし、\"バックグラウンドでの実行中にポップアップウィンドウを表示する\" を許可して、\"戻る\" をクリックします。</string>
    <string name="dialog_miui_developer_title">MIUIでは、デバイスを手動でセットアップする必要があります。情報画面で、「ビルド番号」を 7 回タップします。これにより、開発者設定が有効になります。</string>
    <string name="dialog_miui_optimization_title">MIUIでは、デバイスを手動でセットアップする必要があります。開発者設定ウィンドウが開きます。画面を下にスクロールし、\"MIUI最適化\" のチェックを外します。</string>
    <string name="dialog_administrator_mode_message">アプリがデバイス管理者モードで動作することを許可してください。設定シートが開きます。 \"デバイス管理者\" を選択し、\"%s\" アイテムを見つけ、管理者を有効にして、\"戻る\" をタップします。</string>
    <string name="dialog_administrator_mode_continue">続ける</string>
    <string name="dialog_administrator_mode_skip">スキップ</string>
    <string name="accessibility_service_description">MDMアプリケーションによるアクティブなアプリの監視</string>
    <string name="dialog_accessibility_service_message">アプリがアクセシビリティサービスを使用できるようにしてください。設定シートが開きます。 \"%s\" アイテムを見つけて、ユーザー補助サービスの使用を許可し、\"戻る\" をタップしてください。</string>
    <string name="dialog_accessibility_service_continue">続ける</string>
    <string name="dialog_accessibility_service_skip">スキップ</string>
    <string name="access_to_app_denied">パッケージは許可されていません:</string>
    <string name="access_to_app_denied_2">構成でこのパッケージを有効にするよう管理者に依頼してください。\n\n「閉じる」または「ホーム」ボタンをクリックして続行してください。</string>
    <string name="package_id_copied">パッケージIDがクリップボードにコピーされます</string>
    <string name="dialog_app_not_allowed_close">閉じる</string>
    <string name="dialog_app_not_allowed_admin">管理者</string>
    <string name="device_id">デバイスID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">シリアル番号</string>
    <string name="phone_number">電話番号</string>
    <string name="launcher_version">ランチャーのバージョン</string>
    <string name="close">閉じる</string>
    <string name="admin_change_device_id">デバイスIDを変更</string>
    <string name="admin_change_server_url">サーバーのURLを変更</string>
    <string name="admin_allow_settings">設定を開く</string>
    <string name="settings_allowed">3 分以内で設定を変更できます。</string>
    <string name="admin_clear_restrictions">制限を解除</string>
    <string name="permissive_mode_enabled">すべてのアプリを 3 分以内で実行できます。</string>
    <string name="admin_refresh">設定を更新</string>
    <string name="admin_exit">システムランチャーに戻る</string>
    <string name="admin_reset_permissions">権限を確認</string>
    <string name="admin_reset_network">ネットワークポリシーをリセット</string>
    <string name="admin_reset_network_hint">ネットワークポリシーがクリアされました。これで、ネットワークを有効にして構成をリロードできます。</string>
    <string name="reboot">デバイスを再起動</string>
    <string name="reboot_failed">デバイスを再起動するための権限がありません.</string>
    <string name="message_turn_on_gps">設定画面が開きます。この画面でGPS位置情報をオンにして、[戻る] をクリックしてください。</string>
    <string name="message_turn_off_gps">設定画面が開きます。この画面でGPS位置情報をオフにして、[戻る] をクリックしてください。</string>
    <string name="message_turn_on_mobile_data">モバイルデータが無効になっています!ステータスバーを開いてモバイルデータをオンにしてください。</string>
    <string name="message_turn_off_mobile_data">モバイルデータが有効になっています。ステータスバーを開いてモバイルデータをオフにしてください。</string>
    <string name="message_set_password">パスワードの強度が十分ではありません。設定画面よりパスワードを変更し [戻る] をクリックしてください。</string>
    <string name="switch_off_blockings">制限をオフにしています...</string>
    <string name="kiosk_mode_requires_overlays">キオスクモードが無効です: 他のウィンドウの上に描画する権限がありません。 %s が他のウィンドウの上に描画できるようにしてください。</string>
    <string name="enter_admin_password">管理者パスワードを入力してください</string>
    <string name="wrong_password">パスワードが違います</string>
    <string name="dialog_enter_password_login">ログイン</string>
    <string name="dialog_enter_password_cancel">キャンセル</string>
    <string name="internal_error">アプリで内部エラーが発生しました。デバイスを再起動の上、再試行してください。</string>
    <string name="empty_configuration">設定がありません。サーバーからの取得を再試行しています!</string>
    <string name="permissions_reset_hint">管理パネルを閉じ、権限を確認してください。</string>
    <string name="dialog_enter_server_error">有効なサーバーURLを入力してください。</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">サーバーのURLを入力してください</string>
    <string name="critical_server_failure">サーバー障害のため終了します。障害修復後に %s を再起動するか、完全に削除して再インストールしてください。</string>
    <string name="dialog_permission_title">アプリを実行するには権限が必要です。必要な権限を付与してください。</string>
    <string name="main_activity_exit">終了</string>
    <string name="browser_not_found">ブラウザを見つけられないため、ウェブページを開くことができません。デバイス構成にブラウザーアプリを追加してください。</string>
    <string name="invalid_web_link">リンクの形式が正しくないため、開くことができません。詳細は、管理者にお問い合わせください。</string>
    <string name="activity_not_found">アクティビティが見つからないため、アクション %s を実行できません。</string>
    <string name="location_service_text">デバイスの位置情報は監視されています</string>
    <string name="qrcode_contents_error">QRコードの内容が無効です。 %s WebパネルでプロビジョニングQRコードを生成してください。</string>
    <string name="device_locked">このデバイス (%s) は管理者によってロックされています.</string>
    <string name="fault_loop_detected">ランチャーに回復不能なエラーが発生しました。システム管理者に連絡してください。</string>
    <string name="mqtt_service_text">プッシュ通知が有効です</string>
    <string name="background_location">%s にはバックグラウンドでの位置情報の許可が必要です。 \'続行\' をクリックしてアクセス許可を開き、 \'Location\' をクリックして位置情報を許可してください。</string>
    <string name="location_disable">位置情報を無効にする</string>
    <string name="background_location_continue">続ける</string>
    <string name="initializing_mdm">モバイルデバイス管理アプリケーションを初期化しています...</string>
    <string name="dialog_server_error_title">MDMサーバー %s が無効な応答を返しました。管理者に連絡してください。</string>
    <string name="mdm_choice_message">このデバイスは組織によって完全に管理されます。データは秘匿されず、管理者がいつでも消去または確認することができます。</string>
    <string name="work_profile_message">このデバイスは、組織に属する管理対象の仕事用プロファイルを取得します。 仕事用プロファイルはプライベート プロファイルから分離されており、いつでもプロファイルを切り替えることができます。</string>
    <string name="overlays_not_supported">お使いのデバイスではオーバーレイがサポートされていません.</string>
    <string name="admin_not_supported">お使いのデバイスにはデバイス管理者オプションがありません。続けるには [スキップ] をクリックして下さい。</string>
    <string name="manage_storage_not_supported">デバイスには外部ストレージを管理するオプションがありません。</string>
</resources>
</file>

<file path="app/src/main/res/values-pl-rPL/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrator</string>
    <string name="install_error">Błąd instalacji</string>
    <string name="file_create_error">Błąd podczas tworzenia pliku</string>
    <string name="dialog_enter_device_id_error">Wprowadzony ID nie został zarejestrowany na %s. Wprowadź poprawny ID widoczny w zakładce \"Devices\".</string>
    <string name="dialog_enter_device_id_qrcode">Kod QR</string>
    <string name="dialog_enter_device_id_variants">Warianty</string>
    <string name="dialog_enter_device_id_save">Zapisz</string>
    <string name="dialog_enter_device_id_exit">Wyjdź</string>
    <string name="dialog_enter_device_id_title">Wprowadź ID urządzenia z %s</string>
    <string name="main_start_preparations">Przygotowywanie do uruchomienia</string>
    <string name="main_downloading_configuration">Aktualizacja pliku konfiguracyjnego</string>
    <string name="main_downloading_content">Aktualizacja danych</string>
    <string name="main_update_applications">Instalowanie i aktualizowanie aplikacji</string>
    <string name="dialog_root_message">Potrzebujesz uprawnień ROOT</string>
    <string name="main_application_start">Uruchamianie aplikacji</string>
    <string name="main_app_installing">Instalowanie aplikacji</string>
    <string name="main_app_downloading">Pobieranie aplikacji</string>
    <string name="main_app_downloading_error">Niepowodzenie pobierania paczki</string>
    <string name="main_app_removing">Odinstalowywanie aplikacji</string>
    <string name="main_file_downloading">Pobieranie pliku</string>
    <string name="main_file_downloading_error">Niepowodzenie pobierania pliku</string>
    <string name="main_activity_repeat">Ponów</string>
    <string name="main_activity_reset">Resetuj</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Anuluj</string>
    <string name="main_activity_details">Szczegóły</string>
    <string name="select_system_launcher">Wybierz %s jako domyślny launcher i zaznacz \"Zawsze\":</string>
    <string name="dialog_network_error_title">Błąd połączenia z serwerem %s. Sprawdź połączenie sieciowe i spróbuj ponownie.</string>
    <string name="main_activity_update_config">Żądanie pliku konfiguracyjnego z serwera</string>
    <string name="main_activity_applications_update">Aktualizowanie aplikacji</string>
    <string name="dialog_overlay_settings_title">Zezwól tej aplikacji na wyświetlanie nad innymi aplikacjami.\n\nTo ustawienie pomaga lepiej blokować niechciane aplikacje i włącza awaryjną deaktywację trybu kiosk.\n\nNaciśnij \"Kontynuuj\", aby otworzyć ekran ustawień. Znajdź element \"%s\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_manage_storage_title">Zezwól aplikacji na zarządzanie pamięcią masową.\n\nTa opcja umożliwia Headwind MDM zarządzanie plikami na Twoim urządzeniu.</string>
    <string name="dialog_history_settings_title">Zezwol tej aplikacji na dostęp do danych o zużyciu.\n\nTo ustawienie włącza kontrolę aplikacji i ustawień.\n\nMoże powodować zwiększone zużycie baterii. Aby ją oszczędzać, pomiń to ustawienie i użyj ułatwień dostępu lub trybu kiosk.\n\nNaciśnij \"Kontynuuj\", aby otworzyć ekran ustawień. Znajdź element \"%s\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_history_settings_continue">Kontynuuj</string>
    <string name="dialog_history_settings_skip">Pomiń</string>
    <string name="dialog_unknown_sources_title">Zezwól na instalację aplikacji z nieznanych źródeł. Otworzy się ekran ustawień. Znajdź \"Nieznane źródła\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_unknown_sources_continue">Kontynuuj</string>
    <string name="dialog_miui_permissions_title">MIUI wymaga ręcznej konfiguracji uprawnień. Otworzy się ekran uprawnień aplikacji. Kliknij \"Inne uprawnienia\", zezwól \"Wyświetlaj ekrany pop-up podczas działania w tle\" i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_miui_developer_title">MIUI wymaga ręcznej konfiguracji twojego urządzenia. Na ekranie informacji o urządzeniu, KLIKNIJ 7 RAZY \"WERSJA KOMPILACJI\". Uaktywni to opcje programistyczne.</string>
    <string name="dialog_miui_optimization_title">MIUI wymaga ręcznej konfiguracji twojego urządzenia. Otworzy się ekran opcji programisty. Znajdź opcję \"Optymalizacje MIUI\" i ją odznacz.</string>
    <string name="dialog_administrator_mode_message">Zezwól tej aplikacji na działanie w trybie administratora urządzenia. Otworzy się ekran ustawień, wybierz \"Administratorzy urządzenia\", znajdź element \"%s\", aktywuj administratora i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_administrator_mode_continue">Kontynuuj</string>
    <string name="dialog_administrator_mode_skip">Pomiń</string>
    <string name="accessibility_service_description">Aktywne monitorowanie aplikacji przez aplikację MDM</string>
    <string name="dialog_accessibility_service_message">Zezwól aplikacji na korzystanie z usług ułatwień dostępu. Otworzy się teraz ekran ustawień. Znajdź element \"%s\", zezwól na korzystanie z usług ułatwień dostępu i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_accessibility_service_continue">Kontynuuj</string>
    <string name="dialog_accessibility_service_skip">Pomiń</string>
    <string name="access_to_app_denied">Pakiet nie jest dozwolony:</string>
    <string name="access_to_app_denied_2">Poproś administratora o włączenie tego pakietu w konfiguracji.\n\nKliknij przycisk \'Zamknij\' lub przycisk Strona główna, aby kontynuować.</string>
    <string name="package_id_copied">Identyfikator pakietu zostanie skopiowany do schowka</string>
    <string name="dialog_app_not_allowed_close">Zamknij</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">ID urządzenia</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numer seryjny</string>
    <string name="phone_number">Numer telefonu</string>
    <string name="launcher_version">Wersja launchera</string>
    <string name="close">Zamknij</string>
    <string name="admin_change_device_id">Zmień ID urządzenia</string>
    <string name="admin_change_server_url">Zmień URL serwera</string>
    <string name="admin_allow_settings">Otwórz ustawienia</string>
    <string name="settings_allowed">Możesz modyfikować ustawienia przez 3 minuty.</string>
    <string name="admin_clear_restrictions">Wyłącz ograniczenia</string>
    <string name="permissive_mode_enabled">Możesz uruchamiać wszystkie aplikacje przez 3 minuty.</string>
    <string name="admin_refresh">Aktualizuj konfigurację</string>
    <string name="admin_exit">Wyjdź do systemowego launchera</string>
    <string name="admin_reset_permissions">Sprawdź uprawnienia</string>
    <string name="admin_reset_network">Resetuj polityki sieciowe</string>
    <string name="admin_reset_network_hint">Polityki sieciowe zostały zresetowane. Możesz włączyć sieć i przeładować konfigurację.</string>
    <string name="reboot">Uruchom ponownie urządzenie</string>
    <string name="reboot_failed">Niewystarczające uprawnienia do ponownego uruchomienia urządzenia.</string>
    <string name="message_turn_on_gps">Otworzy się ekran ustawień. Włącz lokalizację i naciśnij przycisk \"Wstecz\".</string>
    <string name="message_turn_off_gps">Otworzy się ekran ustawień. WYŁĄCZ lokalizację i naciśnij przycisk \"Wstecz\".</string>
    <string name="message_turn_on_mobile_data">Dane komórkowe są wyłączone. Otwórz pasek statusu i włącz dane komórkowe.</string>
    <string name="message_turn_off_mobile_data">Dane komórkowe są wyłączone. Otwórz pasek statusu i WYŁĄCZ dane komórkowe.</string>
    <string name="message_set_password">Wprowadzone hasło nie spełnia wymagań. Otworzy się ekran ustawień. Zmień hasło i naciśnij \"Wstecz\".</string>
    <string name="switch_off_blockings">Wyłączanie ograniczeń…</string>
    <string name="kiosk_mode_requires_overlays">Tryb kiosku wyłączony: brak uprawnień do wyświetlania nad innymi aplikacjami. Zezwól %s na wyświetlanie nad innymi aplikacjami.</string>
    <string name="enter_admin_password">Wprowadź hasło administratora</string>
    <string name="wrong_password">Wprowadzono nieprawidłowe hasło</string>
    <string name="dialog_enter_password_login">Zaloguj</string>
    <string name="dialog_enter_password_cancel">Anuluj</string>
    <string name="internal_error">Aplikacja napotkała błąd wewnętrzny. Uruchom ponownie urządzenie i spróbuj ponownie wykonać tą operację.</string>
    <string name="empty_configuration">Konfiguracja nie jest ustawiona, ponawianie próby pobrania jej z serwera!</string>
    <string name="permissions_reset_hint">Zamknij panel administracyjny, aby sprawdzić i poprosić o uprawnienia.</string>
    <string name="dialog_enter_server_error">Wprowadź poprawny adres serwera.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Wprowadź adres serwera</string>
    <string name="critical_server_failure">Napotkano na błąd serwera. Napraw problem i uruchom ponownie %s lub zainstaluj go na nowo.</string>
    <string name="dialog_permission_title">Aplikacja wymaga uprawnień do działania. Proszę udzielić żądanych uprawnień.</string>
    <string name="main_activity_exit">Wyjdź</string>
    <string name="browser_not_found">Nie można otworzyć strony internetowej, ponieważ nie znaleziono przeglądarki. Dodaj aplikację przeglądarki do konfiguracji urządzenia.</string>
    <string name="invalid_web_link">Nie można otworzyć wskazanego linku, ponieważ jest nieprawidłowy. Aby uzyskać szczegółowe informacje, skontaktuj się z administratorem.</string>
    <string name="activity_not_found">Nie można wykonać akcji %s, ponieważ nie znaleziono działania.</string>
    <string name="location_service_text">Lokalizacja tego urządzenia jest monitorowana</string>
    <string name="qrcode_contents_error">Kod QR ma nieprawidłową zawartość. Wygeneruj kod QR w panelu administratora na %s.</string>
    <string name="device_locked">To urządzenie (%s) zostało zablokowane przez administratora.</string>
    <string name="fault_loop_detected">Launcher napotkał na nienaprawialną usterkę! Skontaktuj się z administratorem systemu.</string>
    <string name="mqtt_service_text">Powiadomienia push są aktywne</string>
    <string name="background_location">%s wymaga pozwolenia na dostęp do lokalizacji w tle. Kliknij \"Kontynuuj\", aby otworzyć ekran uprawnień, kliknij \"Lokalizacja\" i zawsze zezwalaj na określenie lokalizacji.</string>
    <string name="location_disable">Wyłącz lokalizację</string>
    <string name="background_location_continue">Kontynuuj</string>
    <string name="initializing_mdm">Inicjowanie aplikacji do zarządzania urządzeniem…</string>
    <string name="dialog_server_error_title">Serwer MDM %s zwrócił nieprawidłową odpowiedź. Skontaktuj się z administratorem.</string>
    <string name="mdm_choice_message">To urządzenie będzie w pełni zarządzane przez Twoją organizację. Twoje dane nie będą prywatne i w każdej chwili mogą zostać usunięte lub przejrzane przez administratora IT.</string>
    <string name="work_profile_message">To urządzenie otrzyma zarządzany profil służbowy należący do Twojej organizacji. Profil do pracy jest oddzielony od profilu prywatnego i możesz przełączać się między profilami w dowolnym momencie.</string>
    <string name="overlays_not_supported">Niestety twoje urządzenie nie obsługuje nakładek.</string>
    <string name="admin_not_supported">Twoje urządzenie nie wspiera administracji urządzeniem. Kliknij \"Pomiń\", aby kontynuować.</string>
    <string name="manage_storage_not_supported">Twoje urządzenie nie ma możliwości zarządzania pamięcią zewnętrzną.</string>
</resources>
</file>

<file path="lib/src/main/java/com/hmdm/HeadwindMDM.java">
package com.hmdm;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;

import java.net.MalformedURLException;
import java.net.URL;

import dalvik.system.PathClassLoader;

/**
 * Higher level Headwind MDM integration API incapsulating reconnection to the service and configuration update
 */
public class HeadwindMDM {

    public interface EventHandler {
        // This method is called when Headwind MDM is ready to answer
        // Get your app settings in this method using MDMService.Preferences.get()
        void onHeadwindMDMConnected();
        // This is just an informative method which doesn't need any actions
        // It should be followed by Connected() method shortly
        void onHeadwindMDMDisconnected();
        // Notification about the configuration change
        // Refresh your app settings in this method using MDMService.Preferences.get()
        void onHeadwindMDMConfigChanged();
    }

    private static HeadwindMDM instance;

    public static HeadwindMDM getInstance() {
        if (instance == null) {
            instance = new HeadwindMDM();
        }
        return instance;
    }

    private MDMService mdmService;
    private boolean mdmConnected = false;
    private boolean mustRun = false;

    private EventHandler eventHandler;
    private Context context;

    private String serverHost;
    private String secondaryServerHost;
    private String serverPath;
    private String deviceId;
    private String custom1;
    private String custom2;
    private String custom3;
    private boolean isManaged;
    private boolean isKiosk;
    private String imei;
    private String serial;
    private int version;
    private String apiKey;
    private int mdmAgentError = 0;

    private BroadcastReceiver configUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(Const.NOTIFICATION_CONFIG_UPDATED) && eventHandler != null) {
                eventHandler.onHeadwindMDMConfigChanged();
            }
        }
    };

    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }

    /**
     * Connect to Headwind MDM service
     * @param context
     * @param eventHandler
     * @return true if Headwind MDM exists, false otherwise
     */
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    public boolean connect(final Context context, final EventHandler eventHandler) {
        mdmService = MDMService.getInstance();
        this.eventHandler = eventHandler;
        this.context = context;
        this.mdmAgentError = 0;

        boolean wasConnected = mdmConnected;
        if (!mdmService.connect(context, resultHandler)) {
            mdmConnected = false;
            return false;
        }

        if (!wasConnected) {
            // We register the receiver only once
            // so connect() method can be called multiple times

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.registerReceiver(configUpdateReceiver, new IntentFilter(Const.NOTIFICATION_CONFIG_UPDATED), Context.RECEIVER_EXPORTED);
            } else {
                context.registerReceiver(configUpdateReceiver, new IntentFilter(Const.NOTIFICATION_CONFIG_UPDATED));
            }
        }

        mustRun = true;
        return true;
    }

    public boolean isConnected() {
        return mdmConnected;
    }

    public void disconnect(Context context) {
        mustRun = false;
        mdmConnected = false;
        try {
            context.unregisterReceiver(configUpdateReceiver);
        } catch (Exception e) {
            // Ignore exception if receiver was not registered
        }
    }

    public String getServerHost() {
        try {
            URL url = new URL(serverHost);
            return url.getHost();
        } catch (MalformedURLException e) {
            return null;
        }
    }

    public String getSecondaryServerHost() {
        try {
            URL url = new URL(secondaryServerHost);
            return url.getHost();
        } catch (MalformedURLException e) {
            return null;
        }
    }

    public String getServerPath() {
        return serverPath;
    }

    public String getDeviceId() {
        return deviceId;
    }

    public String getServerUrl() {
        if (serverPath != null && !serverPath.equals("")) {
            return serverHost + "/" + serverPath;
        } else {
            return serverHost;
        }
    }

    public String getSecondaryServerUrl() {
        if (!serverPath.equals("")) {
            return serverHost + "/" + serverPath;
        } else {
            return serverHost;
        }
    }

    public String getCustom(int number) {
        switch (number) {
            case 1:
                return custom1;
            case 2:
                return custom2;
            case 3:
                return custom3;
            default:
                return null;
        }
    }

    public boolean isManaged() {
        return isManaged;
    }

    public boolean isKiosk() {
        return isKiosk;
    }

    public String getSerial() {
        return serial;
    }

    public String getImei() {
        return imei;
    }

    public int getVersion() {
        return version;
    }

    public int getMdmAgentError() {
        return mdmAgentError;
    }

    public void forceConfigUpdate() {
        if (mdmConnected) {
            mdmAgentError = 0;
            try {
                mdmService.forceConfigUpdate();
            } catch (MDMException e) {
                mdmAgentError = e.mdmError.code;
                e.printStackTrace();
            }
        }
    }

    public boolean setCustom(int number, String value) {
        if (!mdmConnected) {
            return false;
        }
        try {
            mdmAgentError = 0;
            mdmService.setCustom(number, value);
        } catch (MDMException e) {
            mdmAgentError = e.mdmError.code;
            e.printStackTrace();
            return false;
        }
        return true;
    }

    // Get the admin component for applications using "com.hmdm" shared user ID
    // This component could be used to use DevicePolicyManager in those applications
    public ComponentName getAdminComponent(Context context) {
        // We must use the context of Device Owner
        // Since we're using the same shared user, it should be returned without any security issues
        Context deviceOwnerContext = null;
        try {
            deviceOwnerContext = context.createPackageContext(Const.PACKAGE, 0);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        // Android SDK is not supposed to load classes of another application
        // However since we're using the same shared user ID (so it's the same application underhood),
        // we can use a hack to get the required class
        String apkName = null;
        try {
            apkName = context.getPackageManager().getApplicationInfo(Const.PACKAGE, 0).sourceDir;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return null;
        }

        PathClassLoader pathClassLoader = new dalvik.system.PathClassLoader(
                apkName,
                ClassLoader.getSystemClassLoader());

        Class adminReceiverClass = null;
        try {
            adminReceiverClass = Class.forName(Const.ADMIN_RECEIVER_CLASS, true, pathClassLoader);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }

        return new ComponentName(deviceOwnerContext, adminReceiverClass);
    }

    /* Automatic reconnection mechanism */

    public MDMService.ResultHandler resultHandler = new MDMService.ResultHandler() {
        @Override
        public void onMDMConnected() {
            mdmConnected = true;
            mdmAgentError = 0;

            Bundle data = null;
            try {
                version = mdmService.getVersion();
                if (version > MDMService.INITIAL_VERSION && apiKey != null) {
                    data = mdmService.queryConfig(apiKey);
                } else {
                    data = mdmService.queryConfig();
                }

                if (data == null) {
                    throw new MDMException(MDMError.ERROR_NOT_CONFIGURED);
                }

                // NPE can be here! queryConfig() may return null if Headwind MDM
                // is not configured. Not sure how to handle this, though
                serverHost = data.getString(MDMService.KEY_SERVER_HOST);
                secondaryServerHost = data.getString(MDMService.KEY_SECONDARY_SERVER_HOST);
                serverPath = data.getString(MDMService.KEY_SERVER_PATH);
                deviceId = data.getString(MDMService.KEY_DEVICE_ID);
                custom1 = data.getString(MDMService.KEY_CUSTOM_1);
                custom2 = data.getString(MDMService.KEY_CUSTOM_2);
                custom3 = data.getString(MDMService.KEY_CUSTOM_3);
                // null / false values for older launcher API versions or wrong API key
                isManaged = data.getBoolean(MDMService.KEY_IS_MANAGED);
                isKiosk = data.getBoolean(MDMService.KEY_IS_KIOSK);
                imei = data.getString(MDMService.KEY_IMEI);
                serial = data.getString(MDMService.KEY_SERIAL);
            } catch (MDMException e) {
                mdmAgentError = e.mdmError.code;
                e.printStackTrace();
            }

            if (eventHandler != null) {
                eventHandler.onHeadwindMDMConnected();
            }
        }

        @Override
        public void onMDMDisconnected() {
            // This may be raised when Headwind MDM launcher is updated or due to a launcher crash
            mdmConnected = false;
            if (mustRun) {
                if (eventHandler != null) {
                    eventHandler.onHeadwindMDMDisconnected();
                }
                new Handler().postDelayed(new MDMReconnectRunnable(), Const.HMDM_RECONNECT_DELAY_FIRST);
            }
        }
    };

    public class MDMReconnectRunnable implements Runnable {
        @Override
        public void run() {
            if (!mustRun) {
                return;
            }
            if (!mdmService.connect(context, resultHandler)) {
                // Retry in 1 minute
                new Handler().postDelayed(this, Const.HMDM_RECONNECT_DELAY_NEXT);
            }
        }
    }

}
</file>

<file path="lib/build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

apply plugin: 'com.android.library'

android {
    compileSdkVersion 34

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 34
        versionCode 170
        versionName "1.1.7"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    buildFeatures {
        aidl true
    }
    namespace 'com.hmdm'

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'androidx.appcompat:appcompat:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.server;


import com.hmdm.launcher.db.LocationTable;
import com.hmdm.launcher.json.DetailedInfo;
import com.hmdm.launcher.json.DetailedInfoConfigResponse;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.json.RemoteLogConfigResponse;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.json.ServerConfigResponse;

import java.util.List;

import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;

public interface ServerService {

    static final String REQUEST_SIGNATURE_HEADER = "X-Request-Signature";
    static final String CPU_ARCH_HEADER = "X-CPU-Arch";

    @POST("{project}/rest/public/sync/configuration/{number}")
    Call<ResponseBody> enrollAndGetServerConfigRaw(@Path("project") String project,
                                                   @Path("number") String number,
                                                   @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                                   @Header(CPU_ARCH_HEADER) String cpuArch,
                                                   @Body DeviceEnrollOptions createOptions);

    @GET("{project}/rest/public/sync/configuration/{number}")
    Call<ResponseBody> getServerConfigRaw(@Path("project") String project,
                                          @Path("number") String number,
                                          @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                          @Header(CPU_ARCH_HEADER) String cpuArch);

    @POST("{project}/rest/public/sync/configuration/{number}")
    Call<ServerConfigResponse> enrollAndGetServerConfig(@Path("project") String project,
                                                        @Path("number") String number,
                                                        @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                                        @Header(CPU_ARCH_HEADER) String cpuArch,
                                                        @Body DeviceEnrollOptions createOptions);

    @GET("{project}/rest/public/sync/configuration/{number}")
    Call<ServerConfigResponse> getServerConfig(@Path("project") String project,
                                               @Path("number") String number,
                                               @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                               @Header(CPU_ARCH_HEADER) String cpuArch);

    @POST("{project}/rest/public/sync/info")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendDevice(@Path("project") String project, @Body DeviceInfo deviceInfo);

    @GET("{project}/rest/notifications/device/{number}")
    Call<PushResponse> queryPushNotifications(@Path("project") String project,
                                              @Path("number") String number,
                                              @Header(REQUEST_SIGNATURE_HEADER) String signature);

    @GET("{project}/rest/notification/polling/{number}")
    Call<PushResponse> queryPushLongPolling(@Path("project") String project,
                                            @Path("number") String number,
                                            @Header(REQUEST_SIGNATURE_HEADER) String signature);

    @GET( "{project}/rest/plugins/devicelog/log/rules/{number}" )
    Call<RemoteLogConfigResponse> getRemoteLogConfig(@Path("project") String project, @Path("number") String number);

    @POST("{project}/rest/plugins/devicelog/log/list/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendLogs(@Path("project") String project, @Path("number") String number, @Body List<RemoteLogItem> logItems);

    @PUT("{project}/rest/plugins/deviceinfo/deviceinfo/public/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendDetailedInfo(@Path("project") String project, @Path("number") String number, @Body List<DetailedInfo> infoItems);

    @PUT("{project}/rest/plugins/devicelocations/public/update/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendLocations(@Path("project") String project, @Path("number") String number, @Body List<LocationTable.Location> locationItems);

    @GET( "{project}/rest/plugins/deviceinfo/deviceinfo-plugin-settings/device/{number}" )
    Call<DetailedInfoConfigResponse> getDetailedInfoConfig(@Path("project") String project, @Path("number") String number);

    @POST("{project}/rest/plugins/devicereset/public/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmDeviceReset(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

    @POST("{project}/rest/plugins/devicereset/public/reboot/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmReboot(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

    @POST("{project}/rest/plugins/devicereset/public/password/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmPasswordReset(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/BootReceiver.java">
package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;

public class BootReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(Const.LOG_TAG, "Got the BOOT_RECEIVER broadcast");

        SettingsHelper settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());
        if (!settingsHelper.isBaseUrlSet()) {
            // We're here before initializing after the factory reset! Let's ignore this call
            return;
        }

        long lastAppStartTime = settingsHelper.getAppStartTime();
        long bootTime = System.currentTimeMillis() - android.os.SystemClock.elapsedRealtime();
        Log.d(Const.LOG_TAG, "appStartTime=" + lastAppStartTime + ", bootTime=" + bootTime);
        if (lastAppStartTime < bootTime) {
            Log.i(Const.LOG_TAG, "Headwind MDM wasn't started since boot, start initializing services");
        } else {
            Log.i(Const.LOG_TAG, "Headwind MDM is already started, ignoring BootReceiver");
            return;
        }

        Initializer.init(context, () -> {
            Initializer.startServicesAndLoadConfig(context);

            SettingsHelper.getInstance(context).setMainActivityRunning(false);
            if (ProUtils.kioskModeRequired(context)) {
                Log.i(Const.LOG_TAG, "Kiosk mode required, forcing Headwind MDM to run in the foreground");
                // If kiosk mode is required, then we just simulate clicking Home and starting MainActivity
                Intent homeIntent = new Intent(Intent.ACTION_MAIN);
                homeIntent.addCategory(Intent.CATEGORY_HOME);
                homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(homeIntent);
            }
        });
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushMessage.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import org.json.JSONObject;

@JsonIgnoreProperties( ignoreUnknown = true )
public class PushMessage {
    private String messageType;
    private String payload;

    public static final String TYPE_CONFIG_UPDATING = "configUpdating";
    public static final String TYPE_CONFIG_UPDATED = "configUpdated";
    public static final String TYPE_RUN_APP = "runApp";
    public static final String TYPE_UNINSTALL_APP = "uninstallApp";
    public static final String TYPE_DELETE_FILE = "deleteFile";
    public static final String TYPE_PURGE_DIR = "purgeDir";
    public static final String TYPE_DELETE_DIR = "deleteDir";
    public static final String TYPE_PERMISSIVE_MODE = "permissiveMode";
    public static final String TYPE_RUN_COMMAND = "runCommand";
    public static final String TYPE_REBOOT = "reboot";
    public static final String TYPE_EXIT_KIOSK = "exitKiosk";
    public static final String TYPE_CLEAR_DOWNLOADS = "clearDownloadHistory";
    public static final String TYPE_INTENT = "intent";
    public static final String TYPE_GRANT_PERMISSIONS = "grantPermissions";
    public static final String TYPE_ADMIN_PANEL = "adminPanel";

    public String getMessageType() {
        return messageType;
    }

    public void setMessageType( String messageType ) {
        this.messageType = messageType;
    }

    public String getPayload() {
        return payload;
    }

    public void setPayload(String payload) {
        this.payload = payload;
    }

    public JSONObject getPayloadJSON() {
        if (payload != null) {
            try {
                return new JSONObject(payload);
            } catch (Exception e) {
                // Bad payload
            }
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/GetServerConfigTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;
import android.provider.Settings;
import android.util.Log;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.json.ServerConfigResponse;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class GetServerConfigTask extends AsyncTask< Void, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    private ServerService serverService;
    private ServerService secondaryServerService;

    private String serverHost;
    private String urlTemplate = "{project}/rest/public/sync/configuration/{number}";
    private String errorText;
    // There are actually three types of errors: network error, HTTP error and application error
    // First two should be treated similarly and reported only in the foreground mode
    // This flag is introduced to distinguish between HTTP and application errors
    private boolean isDeviceNotFound;
    // This is the only application error which requires reporting in the background
    private String notFoundError = "error.notfound.device";

    public GetServerConfigTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    public String getErrorText() {
        return errorText;
    }

    @Override
    protected Integer doInBackground( Void... voids ) {
        DeviceEnrollOptions enrollOptions = null;
        if (settingsHelper.getConfig() == null) {
            // This is a first start, we need to set up additional options to create a device on demand
            // Even if there's no additional options, we call POST method (enroll) rather than GET (getConfig)
            enrollOptions = new DeviceEnrollOptions();
            enrollOptions.setCustomer(settingsHelper.getEnrollOptionCustomer());
            enrollOptions.setConfiguration(settingsHelper.getEnrollOptionConfigName());
            enrollOptions.setGroups(settingsHelper.getEnrollOptionGroup());
        }

        try {
            serverService = ServerServiceKeeper.getServerServiceInstance(context);
            secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        } catch (Exception e) {
            errorText = "Exception: " + e.getMessage();
            return Const.TASK_NETWORK_ERROR;
        }

        String deviceId = settingsHelper.getDeviceId();
        String signature = "";
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + deviceId);
        } catch (Exception e) {
        }

        isDeviceNotFound = false;
        try {
            ServerConfig serverConfig = null;
            if (enrollOptions == null) {
                serverConfig = BuildConfig.CHECK_SIGNATURE ?
                        getServerConfigSecure(deviceId, signature) :
                        getServerConfigPlain(deviceId, signature);
            } else {
                serverConfig = BuildConfig.CHECK_SIGNATURE ?
                        enrollSecure(deviceId, enrollOptions, signature) :
                        enrollPlain(deviceId, enrollOptions, signature);
            }

            if (serverConfig != null) {
                if (serverConfig.getNewNumber() != null) {
                    RemoteLogger.log(context, Const.LOG_INFO, "Device number changed from " + settingsHelper.getDeviceId() + " to " + serverConfig.getNewNumber());
                    settingsHelper.setDeviceId(serverConfig.getNewNumber());
                    serverConfig.setNewNumber(null);
                    try {
                        PushNotificationMqttWrapper.getInstance().disconnect(context);
                    } catch (Exception e) {
                    }
                }

                settingsHelper.updateConfig(serverConfig);

                // Device already created, erase the device creation options
                settingsHelper.setDeviceIdUse(null);
                settingsHelper.setEnrollOptionCustomer(null);
                settingsHelper.setEnrollOptionConfigName(null);
                settingsHelper.setEnrollOptionGroup(null);

                // Prevent from occasional launch in the kiosk mode without any possibility to exit!
                if (ProUtils.kioskModeRequired(context) &&
                        !settingsHelper.getConfig().getMainApp().equals(context.getPackageName()) &&
                        Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
                        !Settings.canDrawOverlays(context) && !BuildConfig.ENABLE_KIOSK_WITHOUT_OVERLAYS) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Kiosk mode disabled: no permission to draw over other windows.");
                        settingsHelper.getConfig().setKioskMode(false);
                        settingsHelper.updateConfig(settingsHelper.getConfig());
                }

                ProUtils.processConfig(context, serverConfig);

                return Const.TASK_SUCCESS;
            } else {
                return isDeviceNotFound ? Const.TASK_ERROR : Const.TASK_NETWORK_ERROR;
            }
        } catch ( Exception e ) {
            e.printStackTrace();
            buildNetworkErrorText(e.getMessage());
        }

        return Const.TASK_NETWORK_ERROR;
    }

    private ServerConfig getServerConfigPlain(String deviceId, String signature) throws Exception {
        Response<ServerConfigResponse> response = null;
        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.getServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.getServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        }

        if (response.isSuccessful() && Const.STATUS_OK.equals(response.body().getStatus()) && response.body().getData() != null) {
            SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
            return response.body().getData();
        } else {
            isDeviceNotFound = response.body() != null && notFoundError.equals(response.body().getMessage());
            buildTaskErrorText(response);
        }
        return null;
    }

    // Check server signature before accepting server response
    // This is an additional protection against Man-In-The-Middle attacks
    private ServerConfig getServerConfigSecure(String deviceId, String signature) throws Exception {
        Response<ResponseBody> response = null;

        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.getServerConfigRaw(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.getServerConfigRaw(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        }

        if (response.isSuccessful()) {
            String serverResponse = response.body().string();

            ServerConfigResponse serverConfigResponse;
            try {
                serverConfigResponse = new ObjectMapper().readValue(serverResponse, ServerConfigResponse.class);
            } catch (Exception e) {
                errorText = "Failed to parse JSON";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check for application errors before checking the signature
            // Because the errors are not signed
            if (!Const.STATUS_OK.equals(serverConfigResponse.getStatus())) {
                isDeviceNotFound = notFoundError.equals(serverConfigResponse.getMessage());
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check response signature
            String serverSignature = response.headers().get(Const.HEADER_RESPONSE_SIGNATURE);
            if (serverSignature == null) {
                errorText = "Missing " + Const.HEADER_RESPONSE_SIGNATURE + " flag, dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // We need to extract data from the response body
            // Here we assume the specific form of response body: {"status":"OK","message":null,"data":{...}}
            final String dataMarker = "\"data\":";
            int pos = serverResponse.indexOf(dataMarker);
            if (pos == -1) {
                errorText = "Wrong server response, missing data";
                Log.e(Const.LOG_TAG, errorText + ": " + serverResponse);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            String serverData = serverResponse.substring(pos + dataMarker.length(), serverResponse.length() - 1);
            String calculatedSignature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + serverData.replaceAll("\\s", ""));
            if (!calculatedSignature.equalsIgnoreCase(serverSignature)) {
                errorText = "Server signature " + serverSignature + " doesn't match calculated signature " + calculatedSignature + ", dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            return new ObjectMapper().readValue(serverData, ServerConfig.class);
        } else {
            buildTaskErrorTextSecure(response, null);
        }
        return null;
    }

    // Apply extra device creation options (need to be used only at first start when config=null!)
    private ServerConfig enrollPlain(String deviceId, DeviceEnrollOptions createOptions,
                                     String signature) throws Exception {
        Response<ServerConfigResponse> response = null;
        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.enrollAndGetServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI, createOptions).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.enrollAndGetServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI, createOptions).execute();
        }

        if (response.isSuccessful() && Const.STATUS_OK.equals(response.body().getStatus()) && response.body().getData() != null) {
            SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
            return response.body().getData();
        } else {
            isDeviceNotFound = response.body() != null && notFoundError.equals(response.body().getMessage());
            buildTaskErrorText(response);
        }
        return null;
    }

    // Check server signature before accepting server response
    // This is an additional protection against Man-In-The-Middle attacks
    // Apply extra device creation options (need to be used only at first start when config=null!)
    private ServerConfig enrollSecure(String deviceId,
                                      DeviceEnrollOptions createOptions,
                                      String signature) throws Exception {
        Response<ResponseBody> response = null;

        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.
                    enrollAndGetServerConfigRaw(settingsHelper.getServerProject(),
                            deviceId, signature, Build.CPU_ABI, createOptions).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.
                    enrollAndGetServerConfigRaw(settingsHelper.getServerProject(),
                            deviceId, signature, Build.CPU_ABI, createOptions).execute();
        }

        if (response.isSuccessful()) {
            String serverResponse = response.body().string();

            ServerConfigResponse serverConfigResponse;
            try {
                serverConfigResponse = new ObjectMapper().readValue(serverResponse, ServerConfigResponse.class);
            } catch (Exception e) {
                errorText = "Failed to parse JSON";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check for application errors before checking the signature
            // Because the errors are not signed
            if (!Const.STATUS_OK.equals(serverConfigResponse.getStatus())) {
                isDeviceNotFound = notFoundError.equals(serverConfigResponse.getMessage());
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check response signature
            String serverSignature = response.headers().get(Const.HEADER_RESPONSE_SIGNATURE);
            if (serverSignature == null) {
                errorText = "Missing " + Const.HEADER_RESPONSE_SIGNATURE + " flag, dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
            }

            // We need to extract data from the response body
            // Here we assume the specific form of response body: {"status":"OK","message":null,"data":{...}}
            final String dataMarker = "\"data\":";
            int pos = serverResponse.indexOf(dataMarker);
            if (pos == -1) {
                errorText = "Wrong server response, missing data";
                Log.e(Const.LOG_TAG, errorText + ": " + serverResponse);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            String serverData = serverResponse.substring(pos + dataMarker.length(), serverResponse.length() - 1);
            String calculatedSignature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + serverData.replaceAll("\\s", ""));
            if (!calculatedSignature.equalsIgnoreCase(serverSignature)) {
                errorText = "Server signature " + serverSignature + " doesn't match calculated signature " + calculatedSignature + ", dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            return new ObjectMapper().readValue(serverData, ServerConfig.class);
        } else {
            buildTaskErrorTextSecure(response, null);
        }
        return null;
    }

    private void buildTaskErrorText(Response<ServerConfigResponse> response) {
        String message = "HTTP status: " + response.code();
        if (response.isSuccessful()) {
            message += "\n" +
                    "JSON status: " + response.body().getStatus() + "\n" +
                    "JSON message: " + response.body().getMessage();
        }
        buildNetworkErrorText(message);
    }

    private void buildTaskErrorTextSecure(Response<ResponseBody> response, String body) {
        String reason = errorText;
        String message = "HTTP status: " + response.code();
        if (response.isSuccessful()) {
            message += "\n" +
                    "Body: " + body;
        }
        buildNetworkErrorText(message);
        if (reason != null && !reason.equals("")) {
            errorText = reason + "\n\n" + errorText;
        }
    }

    private void buildNetworkErrorText(String message) {
        String url = serverHost + urlTemplate
                .replace("{project}", settingsHelper.getServerProject())
                .replace("{number}", settingsHelper.getDeviceId());

        errorText = url + "\n\n" +
                message;

        String tag = queryTag(message);
        if (tag != null) {
            errorText += "\n\nError tag: " +
                    tag;
        }
    }

    private String queryTag(String message) {
        if (message != null && message.contains("Trust anchor")) {
            return "trust_anchor";
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/InitialSetupActivity.java">
package com.hmdm.launcher.ui;

import android.app.AlertDialog;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.widget.Toast;

import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityInitialSetupBinding;
import com.hmdm.launcher.helper.CertInstaller;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class InitialSetupActivity extends BaseActivity implements ConfigUpdater.UINotifier {
    private ActivityInitialSetupBinding binding;
    private ConfigUpdater configUpdater;
    private SettingsHelper settingsHelper;
    private boolean configuring = false;

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);

        Log.d(Const.LOG_TAG, "Launching the initial setup activity");

        // Here we must already get the Device Owner permissions
        // So install the required certificates
        CertInstaller.installCertificatesFromAssets(this);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_initial_setup);
        binding.setMessage(getString(R.string.initializing_mdm));
        binding.setLoading(true);
    }

    @Override
    protected void onResume() {
        super.onResume();

        settingsHelper = SettingsHelper.getInstance(this);
        settingsHelper.setAppStartTime(System.currentTimeMillis());

        if (!configuring) {
            configuring = true;
            configUpdater = new ConfigUpdater();
            configUpdater.setLoadOnly(true);
            updateConfig();
        }
    }

    private void updateConfig() {
        configUpdater.updateConfig(this, this, true);
    }

    @Override
    public void onConfigUpdateStart() {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateStart");
    }

    @Override
    public void onConfigUpdateServerError(String errorText) {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateServerError");
        displayError(getString(R.string.dialog_server_error_title, concatenateServerUrl(settingsHelper.getBaseUrl(), settingsHelper.getServerProject())), errorText);
    }

    @Override
    public void onConfigUpdateNetworkError(String errorText) {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateNetworkError");
        displayError(getString(R.string.dialog_network_error_title, concatenateServerUrl(settingsHelper.getBaseUrl(), settingsHelper.getServerProject())), errorText);
    }

    @Override
    public void onConfigLoaded() {
        // Set Headwind MDM as the default launcher if required
        final ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            // Device owner should be already granted, so we grant requested permissions early
            boolean deviceOwner = Utils.isDeviceOwner(this);
            Log.d(Const.LOG_TAG, "Device Owner: " + deviceOwner);
            getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE ).edit().putInt(Const.PREFERENCES_DEVICE_OWNER, deviceOwner ?
                    Const.PREFERENCES_ON : Const.PREFERENCES_OFF).commit();
            if (deviceOwner) {
                Utils.autoGrantRequestedPermissions(this, getPackageName(), config.getAppPermissions(), true);
            }

            if (Utils.isDeviceOwner(this) &&
                    (config.getRunDefaultLauncher() == null || !config.getRunDefaultLauncher())) {
                // As per the documentation, setting the default preferred activity should not be done on the main thread
                new AsyncTask<Void, Void, Void>() {
                    @Override
                    protected Void doInBackground(Void... voids) {
                        Utils.setDefaultLauncher(InitialSetupActivity.this);
                        return null;
                    }

                    @Override
                    protected void onPostExecute(Void v) {
                        completeConfig(settingsHelper);
                    }
                }.execute();
                return;
            } else {
                // Headwind MDM works with default system launcher
                // Run services here
                // TODO: permissions required for watchdog services are not yet granted
                // so watchdog services are not being started at this point.
                // Perhaps we need to request these permissions at this step?
                Log.d(Const.LOG_TAG, "Working in background, starting services and installing apps");
                Initializer.init(InitialSetupActivity.this, () -> {
                    Initializer.startServicesAndLoadConfig(InitialSetupActivity.this);
                });
            }
        }
        completeConfig(settingsHelper);
    }

    private void completeConfig(final SettingsHelper settingsHelper) {
        configuring = false;
        if (settingsHelper.getConfig() != null) {
            try {
                Initializer.applyEarlyNonInteractivePolicies(this, settingsHelper.getConfig());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        settingsHelper.setIntegratedProvisioningFlow(true);

        Log.d(Const.LOG_TAG, "Initial setup activity: setup completed");
        setResult(RESULT_OK);
        finish();
    }

    private void displayError(String message, String detailsText) {
        try {
            new AlertDialog.Builder(this)
                    .setMessage(message)
                    .setNeutralButton(R.string.main_activity_details, (dialogInterface, i) -> details(detailsText))
                    .setNegativeButton(R.string.main_activity_wifi, (dialogInterface, i) -> openWiFiSettings())
                    .setPositiveButton(R.string.main_activity_repeat, (dialogInterface, i) -> updateConfig())
                    .create()
                    .show();
        } catch (/*BadToken*/Exception e) {
            // Fatal Exception: android.view.WindowManager$BadTokenException
            // Unable to add window -- token android.os.BinderProxy@4a95f1c is not valid; is your activity running?
            // Shouldn't we reset the device here to avoid hanging up?
            e.printStackTrace();
        }
    }

    private void details(String detailsText) {
        configuring = false;
        ErrorDetailsActivity.display(this, detailsText, true);
    }

    private void openWiFiSettings() {
        configuring = false;
        try {
            startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
        } catch (Exception e) {
            e.printStackTrace();
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void abort() {
        // Factory reset!!!
        if (!Utils.factoryReset(this)) {
            RemoteLogger.log(this, Const.LOG_WARN, "Device reset failed");
        }
        setResult(RESULT_CANCELED);
        finish();
    }

    @Override
    public void onPoliciesUpdated() {
        // Not used in early setup
    }

    @Override
    public void onFileDownloading(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onDownloadProgress(int progress, long total, long current) {
        // Not used in early setup
    }

    @Override
    public void onFileDownloadError(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onFileInstallError(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onAppUpdateStart() {
        // Not used in early setup
    }

    @Override
    public void onAppRemoving(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppDownloading(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppInstalling(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppDownloadError(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppInstallError(String packageName) {
        // Not used in early setup
    }

    @Override
    public void onAppInstallComplete(String packageName) {
        // Not used in early setup
    }

    @Override
    public void onConfigUpdateComplete() {
        // Not used in early setup
    }

    @Override
    public void onAllAppInstallComplete() {
        // Not used in early setup
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/DeviceInfoProvider.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Environment;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.pro.ProUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.List;

public class DeviceInfoProvider {
    public static DeviceInfo getDeviceInfo(Context context, boolean queryPermissions, boolean queryApps) {
        DeviceInfo deviceInfo = new DeviceInfo();
        List<Integer> permissions = deviceInfo.getPermissions();
        List<Application> applications = deviceInfo.getApplications();
        List<RemoteFile> files = deviceInfo.getFiles();

        deviceInfo.setModel(Build.MODEL);

        if (queryPermissions) {
            permissions.add(Utils.checkAdminMode(context) ? 1 : 0);
            permissions.add(Utils.canDrawOverlays(context) ? 1 : 0);
            permissions.add(ProUtils.checkUsageStatistics(context) ? 1 : 0);
            permissions.add(!BuildConfig.USE_ACCESSIBILITY || !ProUtils.checkAccessibilityService(context) ? 0 : 1);
        }

        SettingsHelper config = SettingsHelper.getInstance(context);
        if (queryApps) {
            PackageManager packageManager = context.getPackageManager();
            if (config.getConfig() != null) {
                List<Application> requiredApps = SettingsHelper.getInstance(context).getConfig().getApplications();
                for (Application application : requiredApps) {
                    if (application.isRemove()) {
                        continue;
                    }
                    try {
                        PackageInfo packageInfo = packageManager.getPackageInfo(application.getPkg(), 0);

                        Application installedApp = new Application();
                        installedApp.setName(application.getName());
                        installedApp.setPkg(packageInfo.packageName);
                        installedApp.setVersion(packageInfo.versionName);

                        // Verify there's no duplicates (due to different versions in config), otherwise it causes an error on the server
                        boolean appPresents = false;
                        for (Application a : applications) {
                            if (a.getPkg().equalsIgnoreCase(installedApp.getPkg())) {
                                appPresents = true;
                                break;
                            }
                        }
                        if (!appPresents) {
                            applications.add(installedApp);
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        // Application not installed
                    }
                }

                List<RemoteFile> requiredFiles = SettingsHelper.getInstance(context).getConfig().getFiles();
                for (RemoteFile remoteFile : requiredFiles) {
                    File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                    if (file.exists()) {
                        RemoteFile remoteFileDb = RemoteFileTable.selectByPath(DatabaseHelper.instance(context).getReadableDatabase(),
                                remoteFile.getPath());
                        if (remoteFileDb != null) {
                            files.add(remoteFileDb);
                        } else {
                            // How could that happen? The database entry should exist for each file
                            // Let's recalculate the checksum to check if the file matches
                            try {
                                RemoteFile copy = new RemoteFile(remoteFile);
                                copy.setChecksum(CryptoUtils.calculateChecksum(new FileInputStream(file)));
                                files.add(copy);
                            } catch (FileNotFoundException e) {
                            }
                        }
                    }
                }
            }
        }

        deviceInfo.setDeviceId( SettingsHelper.getInstance( context ).getDeviceId() );

        String phone = DeviceInfoProvider.getPhoneNumber(context, 0);
        if (phone == null || phone.equals("")) {
            phone = config.getConfig().getPhone();
        }
        deviceInfo.setPhone(phone);

        String imei = DeviceInfoProvider.getImei(context, 0);
        if (imei == null || imei.equals("")) {
            imei = config.getConfig().getImei();
        }
        deviceInfo.setImei(imei);

        // Battery
        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);

        Intent batteryStatus = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                context.registerReceiver(null, ifilter, Context.RECEIVER_EXPORTED) :
                context.registerReceiver(null, ifilter);
        int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL) {
            int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            switch (chargePlug) {
                case BatteryManager.BATTERY_PLUGGED_USB:
                    deviceInfo.setBatteryCharging(Const.DEVICE_CHARGING_USB);
                    break;
                case BatteryManager.BATTERY_PLUGGED_AC:
                    deviceInfo.setBatteryCharging(Const.DEVICE_CHARGING_AC);
                    break;
            }
        } else {
            deviceInfo.setBatteryCharging("");
        }

        int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
        int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        deviceInfo.setBatteryLevel(level * 100 / scale);

        deviceInfo.setAndroidVersion(Build.VERSION.RELEASE);
        deviceInfo.setLocation(getLocation(context));
        deviceInfo.setMdmMode(Utils.isDeviceOwner(context));
        deviceInfo.setKioskMode(ProUtils.isKioskModeRunning(context));
        deviceInfo.setLauncherType(Utils.getLauncherVariant());
        deviceInfo.setCpu(Build.CPU_ABI);
        deviceInfo.setSerial(getSerialNumber());

        deviceInfo.setImsi(getImsi(context, 0));
        deviceInfo.setIccid(getIccid(context, 0));
        deviceInfo.setImei2(getImei(context, 1));
        deviceInfo.setImsi2(getImsi(context, 1));
        deviceInfo.setPhone2(getPhoneNumber(context, 1));
        deviceInfo.setIccid2(getIccid(context, 1));

        String launcherPackage = Utils.getDefaultLauncher(context);
        deviceInfo.setLauncherPackage(launcherPackage != null ? launcherPackage : "");
        deviceInfo.setDefaultLauncher(context.getPackageName().equals(launcherPackage));

        deviceInfo.setCustom1(config.getUserCustom1());
        deviceInfo.setCustom2(config.getUserCustom2());
        deviceInfo.setCustom3(config.getUserCustom3());

        return deviceInfo;
    }

    @SuppressWarnings({"MissingPermission"})
    public static DeviceInfo.Location getLocation(Context context) {
        try {
            LocationManager locationManager = (LocationManager)context.getSystemService(Context.LOCATION_SERVICE);
            Location lastLocationGps = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
            Location lastLocationNetwork = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);

            if (lastLocationGps != null || lastLocationNetwork != null) {

                DeviceInfo.Location location = new DeviceInfo.Location();

                Location lastLocation;
                if (lastLocationGps == null || (lastLocationGps.getLatitude() == 0 && lastLocationGps.getLongitude() == 0)) {
                    lastLocation = lastLocationNetwork;
                } else if (lastLocationNetwork == null || (lastLocationNetwork.getLatitude() == 0 && lastLocationNetwork.getLongitude() == 0)) {
                    lastLocation = lastLocationGps;
                } else {
                    // Get the latest location as the best one
                    if (lastLocationGps.getTime() >= lastLocationNetwork.getTime()) {
                        lastLocation = lastLocationGps;
                    } else {
                        lastLocation = lastLocationNetwork;
                    }
                }

                if (lastLocation.getLatitude() == 0 && lastLocation.getLongitude() == 0) {
                    return null;
                }

                location.setLat(lastLocation.getLatitude());
                location.setLon(lastLocation.getLongitude());
                location.setTs(lastLocation.getTime());
                return location;
            }
        } catch (Exception e) {
        }
        return null;
    }

    @SuppressLint("MissingPermission")
    public static String getSerialNumber() {
        String serialNumber = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            try {
                String s = Build.getSerial();
                Log.d(Const.LOG_TAG, "Serial number: " + s);
                return s;
            } catch (SecurityException e) {
                Log.w(Const.LOG_TAG, "Failed to get serial number from Build.getSerial()");
                e.printStackTrace();
            }
        }
        try {
            Class<?> c = Class.forName("android.os.SystemProperties");
            Method get = c.getMethod("get", String.class);
            serialNumber = (String) get.invoke(c, "ril.serialnumber");
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to get serial number from ril.serialnumber");
            e.printStackTrace();
        }
        if (serialNumber != null && !serialNumber.equals("")) {
            return serialNumber;
        }
        Log.d(Const.LOG_TAG, "Build.SERIAL=" + Build.SERIAL);
        return Build.SERIAL;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getPhoneNumber(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getLine1Number();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getIccid(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getSimSerialNumber();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImsi(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getSubscriberId();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImsi(Context context, int slot) {
        String imsi = null;
        try {
            TelephonyManager telephonyManager = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
            // This method is hidden, use reflection
            // Thanks to https://stackoverflow.com/questions/36902916/subscriptionmanager-to-read-imsi-for-dual-sim-devices-ruuning-android-5-1
            Class c = Class.forName("android.telephony.TelephonyManager");
            Method m = c.getMethod("getSubscriberId", new Class[] {int.class});
            Object o = m.invoke(telephonyManager, new Object[]{slot});
            imsi = (String)o;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return imsi;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getPhoneNumber(Context context, int slot) {
        try {
            Utils.autoGrantPhonePermission(context);
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) {
                if (slot == 0) {
                    return getPhoneNumber(context);
                }
                return null;
            }
            SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
            List<SubscriptionInfo> subscriptionList = subscriptionManager.getActiveSubscriptionInfoList();
            if (subscriptionList == null || slot >= subscriptionList.size()) {
                // No mobile info at all
                return null;
            }
            return subscriptionList.get(slot).getNumber();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getIccid(Context context, int slot) {
        try {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) {
                if (slot == 0) {
                    return getPhoneNumber(context);
                }
                return null;
            }
            SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
            List<SubscriptionInfo> subscriptionList = subscriptionManager.getActiveSubscriptionInfoList();
            if (subscriptionList == null || slot >= subscriptionList.size()) {
                // No mobile info at all
                return null;
            }
            return subscriptionList.get(slot).getIccId();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImei(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getDeviceId();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImei(Context context, int slot) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            if (slot == 0) {
                return getImei(context);
            }
            return null;
        }
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getDeviceId(slot);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Get the STB MacAddress
     */
    public static String getMacAddress() {
        try {
            return Utils.loadFileAsString("/sys/class/net/eth0/address")
                    .toUpperCase().substring(0, 17);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BaseAppListAdapter.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.GradientDrawable;
import android.net.Uri;
import android.provider.DocumentsContract;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.core.content.FileProvider;
import androidx.recyclerview.widget.RecyclerView;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ItemAppBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.UnsafeOkHttpClient;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.Utils;
import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.NetworkPolicy;
import com.squareup.picasso.Picasso;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import okhttp3.Cache;
import okhttp3.OkHttpClient;

public class BaseAppListAdapter extends RecyclerView.Adapter<BaseAppListAdapter.ViewHolder> {
    protected LayoutInflater layoutInflater;
    protected List<AppInfo> items;
    protected Map<Integer, AppInfo> shortcuts;        // Keycode -> Application, filled in getInstalledApps()
    protected MainAppListAdapter.OnAppChooseListener appChooseListener;
    protected MainAppListAdapter.SwitchAdapterListener switchAdapterListener;
    protected Activity parentActivity;
    protected SettingsHelper settingsHelper;
    protected int spanCount;
    protected int selectedItem = -1;
    protected RecyclerView.LayoutManager layoutManager;
    protected GradientDrawable selectedItemBorder;
    protected boolean focused = true;
    protected boolean dpadUsed = false;

    protected Picasso picasso = null;

    public BaseAppListAdapter(Activity parentActivity, MainAppListAdapter.OnAppChooseListener appChooseListener, MainAppListAdapter.SwitchAdapterListener switchAdapterListener) {
        layoutInflater = LayoutInflater.from(parentActivity);

        this.appChooseListener = appChooseListener;
        this.switchAdapterListener = switchAdapterListener;
        this.parentActivity = parentActivity;
        this.settingsHelper = SettingsHelper.getInstance(parentActivity);

        boolean isDarkBackground = true;
        ServerConfig config = settingsHelper.getConfig();
        if (config != null && config.getBackgroundColor() != null) {
            try {
                isDarkBackground = !Utils.isLightColor(Color.parseColor(config.getBackgroundColor()));
            } catch (Exception e) {
            }
        }
        selectedItemBorder = new GradientDrawable();
        selectedItemBorder.setColor(0); // transparent background
        selectedItemBorder.setStroke(2, isDarkBackground ? 0xa0ffffff : 0xa0000000); // white or black border with some transparency
    }

    protected void initShortcuts() {
        shortcuts = new HashMap<>();
        for (AppInfo item : items) {
            if (item.keyCode != null) {
                shortcuts.put(item.keyCode, item);
            }
        }
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        ViewHolder viewHolder = new ViewHolder(layoutInflater.inflate(R.layout.item_app, parent, false));
        viewHolder.binding.rootLinearLayout.setOnClickListener(onClickListener);
        viewHolder.binding.rootLinearLayout.setOnLongClickListener(onLongClickListener);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        AppInfo appInfo = items.get(position);
        holder.binding.rootLinearLayout.setTag(appInfo);
        holder.binding.textView.setText(appInfo.name);

        if (settingsHelper.getConfig().getTextColor() != null && !settingsHelper.getConfig().getTextColor().trim().equals("")) {
            try {
                holder.binding.textView.setTextColor(Color.parseColor(settingsHelper.getConfig().getTextColor()));
            } catch (Exception e) {
                // Invalid color
                e.printStackTrace();
            }
        }

        try {
            Integer iconScale = settingsHelper.getConfig().getIconSize();
            if (iconScale == null) {
                iconScale = ServerConfig.DEFAULT_ICON_SIZE;
            }
            int iconSize = parentActivity.getResources().getDimensionPixelOffset(R.dimen.app_icon_size) * iconScale / 100;
            holder.binding.imageView.getLayoutParams().width = iconSize;
            holder.binding.imageView.getLayoutParams().height = iconSize;
            if (appInfo.iconUrl != null) {
                // Load the icon
                if (picasso == null) {
                    Picasso.Builder builder = new Picasso.Builder(parentActivity);
                    if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                        builder.downloader(new OkHttp3Downloader(UnsafeOkHttpClient.getUnsafeOkHttpClient()));
                    } else {
                        // Add signature to all requests to protect against unauthorized API calls
                        // For TRUST_ANY_CERTIFICATE, we won't add signatures because it's unsafe anyway
                        // and is just a workaround to use Headwind MDM on the LAN
                        OkHttpClient clientWithSignature = new OkHttpClient.Builder()
                                .cache(new Cache(new File(parentActivity.getApplication().getCacheDir(), "image_cache"), 1000000L))
                                .addInterceptor(chain -> {
                                    okhttp3.Request.Builder requestBuilder = chain.request().newBuilder();
                                    String signature = InstallUtils.getRequestSignature(chain.request().url().toString());
                                    if (signature != null) {
                                        requestBuilder.addHeader("X-Request-Signature", signature);
                                    }
                                    return chain.proceed(requestBuilder.build());

                                })
                                .build();
                        builder.downloader(new OkHttp3Downloader(clientWithSignature));
                    }
                    builder.listener(new Picasso.Listener() {
                        @Override
                        public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception) {
                            // On fault, get the image from the cache
                            // This is a workaround against a bug in Picasso: it doesn't display cached images by default!
                            picasso.load(appInfo.iconUrl)
                                    .networkPolicy(NetworkPolicy.OFFLINE)
                                    .into(holder.binding.imageView);
                        }
                    });
                    picasso = builder.build();
                }

                picasso.load(appInfo.iconUrl)
                        .into(holder.binding.imageView);
            } else {
                switch (appInfo.type) {
                    case AppInfo.TYPE_APP:
                        holder.binding.imageView.setImageDrawable(parentActivity.getPackageManager().getApplicationIcon(appInfo.packageName));
                        break;
                    case AppInfo.TYPE_WEB:
                        holder.binding.imageView.setImageDrawable(
                                parentActivity.getResources().getDrawable(getDrawableResourceForWebApp(appInfo)));
                        break;
                    case AppInfo.TYPE_INTENT:
                        holder.binding.imageView.setImageDrawable(
                                parentActivity.getResources().getDrawable(getDrawableResourceForIntent(appInfo)));
                        break;
                }
            }

            holder.itemView.setOnFocusChangeListener((v, hasFocus) -> {
                holder.itemView.setBackground(holder.itemView.hasFocus() && dpadUsed ? selectedItemBorder : null);
            });

        } catch (Exception e) {
            // Here we handle PackageManager.NameNotFoundException as well as
            // DeadObjectException (when a device is being turned off)
            e.printStackTrace();
            holder.binding.imageView.setImageResource(R.drawable.ic_android_white_50dp);
        }
    }

    public int getDrawableResourceForWebApp(AppInfo appInfo) {
        if (appInfo.url.startsWith("file://")) {
            if (appInfo.url.endsWith("/")) {
                return R.drawable.localfolder;
            } else {
                return R.drawable.locallink;
            }
        } else {
            return R.drawable.weblink;
        }
    }

    public int getDrawableResourceForIntent(AppInfo appInfo) {
        if (appInfo.intent != null && appInfo.intent.equals("android.intent.action.DIAL")) {
            return R.drawable.dialer;
        } else {
            return R.drawable.settings;
        }
    }

    public static final class ViewHolder extends RecyclerView.ViewHolder{
        ItemAppBinding binding;

        public ViewHolder(View itemView) {
            super(itemView);
            binding = ItemAppBinding.bind(itemView);
        }
    }

    @Override
    public void onAttachedToRecyclerView(final RecyclerView recyclerView) {
        super.onAttachedToRecyclerView(recyclerView);
        layoutManager = recyclerView.getLayoutManager();
    }

    @Override
    public int getItemCount() {
        return items == null ? 0 : items.size();
    }

    public void setSpanCount(int spanCount) {
        this.spanCount = spanCount;
    }

    public void setFocused(boolean focused) {
        selectedItem = focused ? 0 : -1;
        notifyDataSetChanged();
        if (selectedItem == 0 && layoutManager != null) {
            layoutManager.scrollToPosition(selectedItem);
        }
    }

    public interface OnAppChooseListener{
        void onAppChoose(@NonNull AppInfo resolveInfo);
    }

    // Let the parent know that the user wants to switch the adapter
    // Send the direction; if the parent returns true, this means
    // it switched the adapter - unfocus self
    public interface SwitchAdapterListener {
        boolean switchAppListAdapter(BaseAppListAdapter adapter, int direction);
    }

    protected View.OnClickListener onClickListener = v -> {
        if (BuildConfig.SELECTED_ITEM_BY_CLICK && selectedItem >= 0) {
            // Some TV boxes mistakenly generate onClick() for the first item
            // when the OK button is clicked. Here's the workaround
            chooseSelectedItem();
        } else {
            chooseApp((AppInfo) v.getTag());
        }
    };

    protected View.OnLongClickListener onLongClickListener = v -> {
        AppInfo appInfo = (AppInfo) v.getTag();
        if (appInfo.type == AppInfo.TYPE_APP && appInfo.longTap == 1) {
            // Open app settings on long click
            openAppSettings(appInfo);
            return true;
        }
        return false;
    };

    protected void chooseApp(AppInfo appInfo) {
        switch (appInfo.type) {
            case AppInfo.TYPE_APP:
                Intent launchIntent = parentActivity.getPackageManager().getLaunchIntentForPackage(
                        appInfo.packageName);
                if (launchIntent != null) {
                    // These magic flags are found in the source code of the default Android launcher
                    // These flags preserve the app activity stack (otherwise a launch activity appears at the top which is not correct)
                    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                            Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
                    parentActivity.startActivity(launchIntent);
                }
                break;
            case AppInfo.TYPE_WEB:
                if (appInfo.url != null) {
                    Intent i = new Intent(Intent.ACTION_VIEW);

                    Uri uri = Uri.parse(appInfo.url);
                    String mimeType = null;

                    if (uri.getScheme().equals("file")) {
                        // Avoid FileUriExposedException
                        String path = uri.getPath();
                        File file = new File(path);
                        try {
                            uri = FileProvider.getUriForFile(parentActivity, parentActivity.getApplicationContext().getPackageName() + ".provider", file);
                        } catch (/*IllegalArgument*/Exception e) {
                            Toast.makeText(parentActivity, R.string.invalid_web_link, Toast.LENGTH_LONG).show();
                            break;
                        }
                        if (appInfo.url.endsWith("/")) {
                            // This is the directory, we need to specify the MIME type explicitly
                            mimeType = DocumentsContract.Document.MIME_TYPE_DIR;
                        }
                        i.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                    }

                    Log.d(Const.LOG_TAG, "BaseAppListAdapter: opening web app: " + uri.toString());
                    if (mimeType != null) {
                        i.setDataAndType(uri, mimeType);
                    } else {
                        i.setData(uri);
                    }
                    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);

                    if (appInfo.useKiosk != 0) {
                        Log.d(Const.LOG_TAG, "Component: " + Const.KIOSK_BROWSER_PACKAGE_NAME + ".MainActivity");
                        i.setComponent(new ComponentName(Const.KIOSK_BROWSER_PACKAGE_NAME, Const.KIOSK_BROWSER_PACKAGE_NAME + ".MainActivity"));
                    }

                    try {
                        parentActivity.startActivity(i);
                    } catch (ActivityNotFoundException e) {
                        Toast.makeText(parentActivity, R.string.browser_not_found, Toast.LENGTH_LONG).show();
                    } catch (Exception e) {
                        Toast.makeText(parentActivity, R.string.invalid_web_link, Toast.LENGTH_LONG).show();
                    }
                }
                break;
            case AppInfo.TYPE_INTENT:
                if (appInfo.intent != null) {
                    try {
                        Intent i = new Intent(appInfo.intent);
                        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
                        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        parentActivity.startActivity(i);
                    } catch (Exception e) {
                        Toast.makeText(parentActivity, parentActivity.getString(R.string.activity_not_found, appInfo.intent), Toast.LENGTH_LONG).show();
                    }
                }
                break;

        }
        if (appChooseListener != null) {
            appChooseListener.onAppChoose(appInfo);
        }
    }

    public boolean onKey(final int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            dpadUsed = true;
        }
        return false;

        // This code (manual browsing of icons) follows by focusing just 1st item
        // (the workaround is provided by BuildConfig.SELECTED_ITEM_BY_CLICK but it won't work well
        // if an item is selected and another is tapped. Also, (info) and (reload) items become
        // unavailable. So just turn on displaying border by focus here (flag dpadUsed).

/*        AppInfo shortcutAppInfo = shortcuts.get(new Integer(keyCode));
        if (shortcutAppInfo != null) {
            chooseApp(shortcutAppInfo);
            return true;
        }
        if (!focused) {
            return false;
        }

        int switchAdapterDirection = -1;
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (tryMoveSelection(layoutManager, 1)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_RIGHT;
                };
                break;
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (tryMoveSelection(layoutManager, -1)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_LEFT;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (tryMoveSelection(layoutManager, spanCount)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_DOWN;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_UP:
                if (tryMoveSelection(layoutManager, -spanCount)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_UP;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_CENTER:
                chooseSelectedItem();
                return true;
        }
        if (switchAdapterListener != null && switchAdapterListener.switchAppListAdapter(this, switchAdapterDirection)) {
            // Adapter switch accepted, unfocus
            setFocused(false);
        }

        return false; */
    }

    private boolean tryMoveSelection(RecyclerView.LayoutManager lm, int offset) {
        int trySelectedItem = selectedItem + offset;

        if (trySelectedItem < 0) {
            trySelectedItem = 0;
        }
        if (trySelectedItem >= getItemCount()) {
            trySelectedItem = getItemCount() - 1;
        }

        if (trySelectedItem != selectedItem) {
            selectedItem = trySelectedItem;
            notifyDataSetChanged();
            if (lm != null) {
                lm.scrollToPosition(trySelectedItem);
            }
            return true;
        }

        return false;
    }

    private void chooseSelectedItem() {
        if (items == null || selectedItem < 0 || selectedItem >= getItemCount()) {
            return;
        }
        chooseApp(items.get(selectedItem));
    }

    private void openAppSettings(AppInfo appInfo) {
        parentActivity.startActivity(new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
                Uri.parse("package:" + appInfo.packageName)));
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/SettingsHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.helper;

import android.content.Context;
import android.content.SharedPreferences;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.ApplicationSetting;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class SettingsHelper {

    private static final String PREFERENCES_ID = ".helpers.PREFERENCES";
    private static final String PREF_KEY_BASE_URL = ".helpers.BASE_URL";
    private static final String PREF_KEY_SECONDARY_BASE_URL = ".helpers.SECONDARY_BASE_URL";
    private static final String PREF_KEY_SERVER_PROJECT = ".helpers.SERVER_PROJECT";
    private static final String PREF_KEY_DEVICE_ID = ".helpers.DEVICE_ID";
    private static final String PREF_KEY_CUSTOMER = ".helpers.CUSTOMER";
    private static final String PREF_KEY_CONFIG_NAME = ".helpers.CONFIG_NAME";
    private static final String PREF_KEY_GROUP = ".helpers.GROUP";
    private static final String PREF_KEY_DEVICE_ID_USE = ".helpers.DEVICE_ID_USE";
    private static final String PREF_KEY_CONFIG = ".helpers.CONFIG";
    private static final String PREF_KEY_IP_ADDRESS = ".helpers.IP_ADDRESS";
    private static final String PREF_QR_PROVISIONING = ".helpers.QR_PROVISIONING";
    private static final String PREF_CFG_UPDATE_TIMESTAMP = ".helpers.CFG_UPDATE_TIMESTAMP";
    private static final String PREF_KEY_ACTIVITY_RUNNING = ".helpers.ACTIVITY_RUNNING";
    private static final String PREF_KEY_RESTORE_LAUNCHER = ".helpers.NEED_LAUNCHER_RESET";
    private static final String PREF_KEY_INTEGRATED_PROVISIONING_FLOW = ".helpers.INTEGRATED_PROVISIONING_FLOW";
    private static final String PREF_KEY_LAST_APP_UPDATE_STATE = ".helpers.LAST_APP_UPDATE_STATE";
    private static final String PREF_KEY_APP_START_TIME = ".helpers.APP_START_TIME";
    private static final String PREF_KEY_SATELLITE_COUNT = ".helpers.APP_SATELLITE_COUNT";
    private static final String PREF_KEY_USER_CUSTOM_1 = ".helpers.USER_CUSTOM_1";
    private static final String PREF_KEY_USER_CUSTOM_2 = ".helpers.USER_CUSTOM_2";
    private static final String PREF_KEY_USER_CUSTOM_3 = ".helpers.USER_CUSTOM_3";
    // This prefix is for the compatibility with a legacy package name
    private static String PACKAGE_NAME;

    private SharedPreferences sharedPreferences;
    private ServerConfig config;
    private ServerConfig oldConfig;
    private Map<String,ApplicationSetting> appSettings = new HashMap<>();
    private Set<String> allowedClasses = new HashSet<>();

    private static SettingsHelper instance;

    public static SettingsHelper getInstance(Context context) {
        if (instance == null) {
            instance = new SettingsHelper(context);
        }

        return instance;
    }

    public SettingsHelper(Context context) {
        PACKAGE_NAME = context.getPackageName();
        sharedPreferences = context.getSharedPreferences(PACKAGE_NAME + PREFERENCES_ID, Context.MODE_PRIVATE );
        initConfig();
    }

    public void refreshConfig(Context context) {
        if (config == null) {
            sharedPreferences = context.getSharedPreferences(PACKAGE_NAME + PREFERENCES_ID, Context.MODE_PRIVATE );
            initConfig();
        }
    }

    private void initConfig() {
        try {
            if ( sharedPreferences.contains(PACKAGE_NAME + PREF_KEY_CONFIG) ) {
                ObjectMapper mapper = new ObjectMapper();
                config = mapper.readValue(
                        sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CONFIG, "" ),
                        ServerConfig.class );
                updateAppSettingsMap(config);
                updateAllowedClassesSet(config);
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }
    }

    // Warning: this may return false if the launcher has been updated from older version
    public boolean isQrProvisioning() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_QR_PROVISIONING, false);
    }

    public boolean setQrProvisioning(boolean value) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_QR_PROVISIONING, value).commit();
    }

    public boolean isIntegratedProvisioningFlow() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_INTEGRATED_PROVISIONING_FLOW, false);
    }

    public boolean setIntegratedProvisioningFlow(boolean value) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_INTEGRATED_PROVISIONING_FLOW, value).commit();
    }

    public boolean isBaseUrlSet() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_BASE_URL, null ) != null;
    }

    public String getBaseUrl() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_BASE_URL, BuildConfig.BASE_URL );
    }

    public boolean setBaseUrl( String baseUrl ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_BASE_URL, baseUrl ).commit();
    }

    public String getSecondaryBaseUrl() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_SECONDARY_BASE_URL, BuildConfig.SECONDARY_BASE_URL );
    }

    public boolean setSecondaryBaseUrl( String secondaryBaseUrl ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_SECONDARY_BASE_URL, secondaryBaseUrl ).commit();
    }

    public String getServerProject() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_SERVER_PROJECT, BuildConfig.SERVER_PROJECT );
    }

    public boolean setServerProject( String serverProject ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_SERVER_PROJECT, serverProject ).commit();
    }

    public String getDeviceId() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_DEVICE_ID,"" );
    }

    public boolean setDeviceId( String deviceId ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_DEVICE_ID, deviceId ).commit();
    }

    public String getExternalIp() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_IP_ADDRESS, "" );
    }

    public boolean setExternalIp( String externalIp ) {
        if (externalIp == null) {
            externalIp = "";
        }
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_IP_ADDRESS, externalIp ).commit();
    }

    public boolean isMainActivityRunning() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_ACTIVITY_RUNNING, false );
    }

    public boolean setMainActivityRunning(boolean running) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_ACTIVITY_RUNNING, running ).commit();
    }

    public boolean isRestoreLauncher() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_RESTORE_LAUNCHER, false);
    }

    public boolean setRestoreLauncher(boolean restore) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_RESTORE_LAUNCHER, restore ).commit();
    }

    public long getConfigUpdateTimestamp() {
        return sharedPreferences.getLong(PACKAGE_NAME + PREF_CFG_UPDATE_TIMESTAMP, 0);
    }

    public boolean setConfigUpdateTimestamp(long timestamp) {
        return sharedPreferences.edit().putLong(PACKAGE_NAME + PREF_CFG_UPDATE_TIMESTAMP, timestamp).commit();
    }

    public boolean setEnrollOptionCustomer(String customer) {
        if (customer == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_CUSTOMER).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CUSTOMER, customer ).commit();
        }
    }

    public String getEnrollOptionCustomer() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CUSTOMER, null);
    }

    public boolean setDeviceIdUse(String deviceIdUse) {
        if (deviceIdUse == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE, deviceIdUse ).commit();
        }
    }

    public String getDeviceIdUse() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE, null);
    }

    public boolean setLastAppUpdateState(boolean lastAppUpdateState) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_LAST_APP_UPDATE_STATE, lastAppUpdateState).commit();
    }

    public boolean getLastAppUpdateState() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_LAST_APP_UPDATE_STATE, false);
    }

    public boolean setAppStartTime(long time) {
        return sharedPreferences.edit().putLong(PACKAGE_NAME + PREF_KEY_APP_START_TIME, time).commit();
    }

    public long getAppStartTime() {
        return sharedPreferences.getLong(PACKAGE_NAME + PREF_KEY_APP_START_TIME, 0);
    }


    public boolean setSatelliteCount(int count) {
        return sharedPreferences.edit().putInt(PACKAGE_NAME + PREF_KEY_SATELLITE_COUNT, count).commit();
    }

    public int getSatelliteCount() {
        return sharedPreferences.getInt(PACKAGE_NAME + PREF_KEY_SATELLITE_COUNT, 0);
    }

    public boolean setEnrollOptionConfigName(String configName) {
        if (configName == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_CONFIG_NAME).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CONFIG_NAME, configName ).commit();
        }
    }

    public String getEnrollOptionConfigName() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CONFIG_NAME, null);
    }

    public boolean setEnrollOptionGroup(Set<String> group) {
        if (group == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_GROUP).commit();
        } else {
            return sharedPreferences.edit().putStringSet(PACKAGE_NAME + PREF_KEY_GROUP, group).commit();
        }
    }

    public Set<String> getEnrollOptionGroup() {
        return sharedPreferences.getStringSet(PACKAGE_NAME + PREF_KEY_GROUP, null);
    }

    public boolean setUserCustom1(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_1, userCustom).commit();
    }

    public String getUserCustom1() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_1, null);
    }

    public boolean setUserCustom2(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_2, userCustom).commit();
    }

    public String getUserCustom2() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_2, null);
    }

    public boolean setUserCustom3(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_3, userCustom).commit();
    }

    public String getUserCustom3() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_3, null);
    }

    public void updateConfig( ServerConfig config ) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CONFIG, objectMapper.writeValueAsString( config ) ).commit();
        } catch ( Exception e ) {
            e.printStackTrace();
            // Do not apply changes when there's an error while writing settings
            return;
        }
        updateAppSettingsMap(config);
        updateAllowedClassesSet(config);
        this.oldConfig = this.config;
        this.config = config;
    }

    public ServerConfig getConfig() {
        return config;
    }

    public void removeRemoteFile(RemoteFile remoteFile) {
        Iterator<RemoteFile> it = config.getFiles().iterator();
        while (it.hasNext()) {
            RemoteFile file = it.next();
            if ( file.getPath().equals( remoteFile.getPath() ) ) {
                it.remove();
                updateConfig(config);
                return;
            }
        }
    }

    public void removeApplication(Application application) {
        Iterator<Application> it = config.getApplications().iterator();
        while (it.hasNext()) {
            Application app = it.next();
            if (app.getPkg().equals(application.getPkg())) {
                it.remove();
                updateConfig(config);
                return;
            }
        }
    }

    public void removeApplicationUrl(Application application) {
        Iterator<Application> it = config.getApplications().iterator();
        while (it.hasNext()) {
            Application app = it.next();
            if (app.getPkg().equals(application.getPkg())) {
                app.setUrl(null);
                updateConfig(config);
                return;
            }
        }
    }

    private void updateAppSettingsMap(ServerConfig config) {
        if (config == null || config.getApplicationSettings() == null) {
            return;
        }
        appSettings.clear();
        for (ApplicationSetting setting : config.getApplicationSettings()) {
            String key = setting.getPackageId() + "." + setting.getName();
            appSettings.put(key, setting);
        }
    }

    private void updateAllowedClassesSet(ServerConfig config) {
        if (config == null || config.getAllowedClasses() == null) {
            return;
        }
        String[] allowedClassesList = config.getAllowedClasses().split(",");
        for (int n = 0; n < allowedClassesList.length; n++) {
            allowedClassesList[n] = allowedClassesList[n].trim();
        }
        // Is it thread-safe? Hopefully yes
        allowedClasses = new HashSet<>(Arrays.asList(allowedClassesList));
    }

    public String getAppPreference(String packageId, String attr) {
        String key = packageId + "." + attr;
        ApplicationSetting setting = appSettings.get(key);
        if (setting == null) {
            return null;
        }
        return setting.getValue();
    }

    public boolean setAppPreference(String packageId, String attr, String value) {
        String key = packageId + "." + attr;
        ApplicationSetting setting = appSettings.get(key);
        if (setting == null) {
            setting = new ApplicationSetting();
            setting.setPackageId(packageId);
            setting.setName(attr);
            setting.setType(1);     // 1 is string (default value)
            setting.setReadOnly(false);
            appSettings.put(key, setting);
        }
        if (setting.isReadOnly()) {
            return false;
        }
        setting.setValue(value);
        setting.setLastUpdate(System.currentTimeMillis());
        return true;
    }

    public void commitAppPreferences(String packageId) {
        // TODO: send new preferences to server
    }

    public Set<String> getAllowedClasses() {
        return allowedClasses;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/PushNotificationProcessor.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.content.Intent;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Environment;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.DownloadTable;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.Download;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class PushNotificationProcessor {
    public static void process(PushMessage message, Context context) {
        RemoteLogger.log(context, Const.LOG_INFO, "Got Push Message, type " + message.getMessageType());
        if (message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED)) {
            // Update local configuration
            ConfigUpdater.notifyConfigUpdate(context);
            // The configUpdated should be broadcasted after the configuration update is completed
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_RUN_APP)) {
            // Run application
            runApplication(context, message.getPayloadJSON());
            // Do not broadcast this message to other apps
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_UNINSTALL_APP)) {
            // Uninstall application
            AsyncTask.execute(() -> uninstallApplication(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_DELETE_FILE)) {
            // Delete file
            AsyncTask.execute(() -> deleteFile(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_DELETE_DIR)) {
            // Delete directory recursively
            AsyncTask.execute(() -> deleteDir(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_PURGE_DIR)) {
            // Purge directory (delete all files recursively)
            AsyncTask.execute(() -> purgeDir(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_PERMISSIVE_MODE)) {
            // Turn on permissive mode
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_PERMISSIVE_MODE));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_RUN_COMMAND)) {
            // Run a command-line script
            AsyncTask.execute(() -> runCommand(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_REBOOT)) {
            // Reboot a device
            AsyncTask.execute(() -> reboot(context));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_EXIT_KIOSK)) {
            // Temporarily exit kiosk mode
            LocalBroadcastManager.getInstance(context).
                sendBroadcast(new Intent(Const.ACTION_EXIT_KIOSK));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_ADMIN_PANEL)) {
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_ADMIN_PANEL));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_CLEAR_DOWNLOADS)) {
            // Clear download history
            AsyncTask.execute(() -> clearDownloads(context));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_INTENT)) {
            // Run a system intent (like settings or ACTION_VIEW)
            AsyncTask.execute(() -> callIntent(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_GRANT_PERMISSIONS)) {
            // Grant permissions to apps
            AsyncTask.execute(() -> grantPermissions(context, message.getPayloadJSON()));
            return;
        }

        // Send broadcast to all plugins
        Intent intent = new Intent(Const.INTENT_PUSH_NOTIFICATION_PREFIX + message.getMessageType());
        JSONObject jsonObject = message.getPayloadJSON();
        if (jsonObject != null) {
            intent.putExtra(Const.INTENT_PUSH_NOTIFICATION_EXTRA, jsonObject.toString());
        }
        context.sendBroadcast(intent);
    }

    private static void runApplication(Context context, JSONObject payload) {
        if (payload == null) {
            return;
        }
        try {
            String pkg = payload.getString("pkg");
            String action = payload.optString("action", null);
            JSONObject extras = payload.optJSONObject("extra");
            String data = payload.optString("data", null);
            Intent launchIntent = context.getPackageManager().getLaunchIntentForPackage(pkg);
            if (launchIntent != null) {
                if (action != null) {
                    launchIntent.setAction(action);
                }
                if (data != null) {
                    try {
                        launchIntent.setData(Uri.parse(data));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (extras != null) {
                    Iterator<String> keys = extras.keys();
                    String key;
                    while (keys.hasNext()) {
                        key = keys.next();
                        Object value = extras.get(key);
                        if (value instanceof String) {
                            launchIntent.putExtra(key, (String) value);
                        } else if (value instanceof Integer) {
                            launchIntent.putExtra(key, ((Integer) value).intValue());
                        } else if (value instanceof Float) {
                            launchIntent.putExtra(key, ((Float) value).floatValue());
                        } else if (value instanceof Boolean) {
                            launchIntent.putExtra(key, ((Boolean) value).booleanValue());
                        }
                    }
                }

                // These magic flags are found in the source code of the default Android launcher
                // These flags preserve the app activity stack (otherwise a launch activity appears at the top which is not correct)
                launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                        Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
                context.startActivity(launchIntent);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void uninstallApplication(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: no package specified");
            return;
        }
        if (!Utils.isDeviceOwner(context)) {
            // Require device owner for non-interactive uninstallation
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: no device owner");
            return;
        }

        try {
            String pkg = payload.getString("pkg");
            InstallUtils.silentUninstallApplication(context, pkg);
            RemoteLogger.log(context, Const.LOG_INFO, "Uninstalled application: " + pkg);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void deleteFile(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "File delete failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            file.delete();
            RemoteLogger.log(context, Const.LOG_INFO, "Deleted file: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "File delete failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void deleteRecursive(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory()) {
            File[] childFiles = fileOrDirectory.listFiles();
            for (File child : childFiles) {
                deleteRecursive(child);
            }
        }
        fileOrDirectory.delete();
    }

    private static void deleteDir(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory delete failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            deleteRecursive(file);
            RemoteLogger.log(context, Const.LOG_INFO, "Deleted directory: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory delete failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void purgeDir(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            if (!file.isDirectory()) {
                RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: not a directory: " + path);
                return;
            }
            String recursive = payload.optString("recursive");
            File[] childFiles = file.listFiles();
            for (File child : childFiles) {
                if (recursive == null || !recursive.equals("1")) {
                    if (!child.isDirectory()) {
                        child.delete();
                    }
                } else {
                    deleteRecursive(child);
                }
            }
            RemoteLogger.log(context, Const.LOG_INFO, "Purged directory: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void runCommand(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Command failed: no command specified");
            return;
        }

        try {
            String command = payload.getString("command");
            Log.d(Const.LOG_TAG, "Executing a command: " + command);
            String result = SystemUtils.executeShellCommand(command, true);
            String msg = "Executed a command: " + command;
            if (!result.equals("")) {
                if (result.length() > 200) {
                    result = result.substring(0, 200) + "...";
                }
                msg += " Result: " + result;
            }
            RemoteLogger.log(context, Const.LOG_DEBUG, msg);

        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Command failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void reboot(Context context) {
        RemoteLogger.log(context, Const.LOG_WARN, "Rebooting by a Push message");
        if (Utils.checkAdminMode(context)) {
            if (!Utils.reboot(context)) {
                RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed");
            }
        } else {
            RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed: no permissions");
        }
    }

    private static void clearDownloads(Context context) {
        RemoteLogger.log(context, Const.LOG_WARN, "Clear download history by a Push message");
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        List<Download> downloads = DownloadTable.selectAll(db);
        for (Download d: downloads) {
            File file = new File(d.getPath());
            try {
                file.delete();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        DownloadTable.deleteAll(db);
    }

    private static void callIntent(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Calling intent failed: no parameters specified");
            return;
        }

        try {
            String action = payload.getString("action");
            Log.d(Const.LOG_TAG, "Calling intent: " + action);
            JSONObject extras = payload.optJSONObject("extra");
            String data = payload.optString("data", null);
            Intent i = new Intent(action);
            if (data != null) {
                try {
                    i.setData(Uri.parse(data));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (extras != null) {
                Iterator<String> keys = extras.keys();
                String key;
                while (keys.hasNext()) {
                    key = keys.next();
                    Object value = extras.get(key);
                    if (value instanceof String) {
                        i.putExtra(key, (String) value);
                    } else if (value instanceof Integer) {
                        i.putExtra(key, ((Integer) value).intValue());
                    } else if (value instanceof Float) {
                        i.putExtra(key, ((Float) value).floatValue());
                    } else if (value instanceof Boolean) {
                        i.putExtra(key, ((Boolean) value).booleanValue());
                    }
                }
            }
            i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
            i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(i);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Calling intent failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void grantPermissions(Context context, JSONObject payload) {
        if (!Utils.isDeviceOwner(context) && !BuildConfig.SYSTEM_PRIVILEGES) {
            RemoteLogger.log(context, Const.LOG_WARN, "Can't auto grant permissions: no device owner");
        }

        ServerConfig config = SettingsHelper.getInstance(context).getConfig();
        List<String> apps = null;

        if (payload != null) {
            apps = new LinkedList<>();
            String pkg;
            JSONArray pkgs = payload.optJSONArray("pkg");
            if (pkgs != null) {
                for (int i = 0; i < pkgs.length(); i++) {
                    pkg = pkgs.optString(i);
                    if (pkg != null) {
                        apps.add(pkg);
                    }
                }
            } else {
                pkg = payload.optString("pkg");
                if (pkg != null) {
                    apps.add(pkg);
                }
            }
        } else {
            // By default, grant permissions to all packagee having an URL
            apps = new LinkedList<>();
            List<Application> configApps = config.getApplications();
            for (Application app: configApps) {
                if (Application.TYPE_APP.equals(app.getType()) &&
                    app.getUrl() != null && app.getPkg() != null) {
                    apps.add(app.getPkg());
                }
            }
        }

        for (String app: apps) {
            Utils.autoGrantRequestedPermissions(context, app,
                    config.getAppPermissions(), false);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/Const.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

public class Const {

    public static final int TASK_SUCCESS = 0;
    public static final int TASK_ERROR = 1;
    public static final int TASK_NETWORK_ERROR = 2;

    public static final String ACTION_SERVICE_STOP = "SERVICE_STOP";
    public static final String ACTION_SHOW_LAUNCHER = "SHOW_LAUNCHER";
    public static final String ACTION_ENABLE_SETTINGS = "ENABLE_SETTINGS";
    public static final String ACTION_PERMISSIVE_MODE = "PERMISSIVE_MODE";          // Temporary action
    public static final String ACTION_TOGGLE_PERMISSIVE = "TOGGLE_PERMISSIVE";      // Permanent action
    public static final String ACTION_EXIT_KIOSK = "EXIT_KIOSK";
    public static final String ACTION_ADMIN_PANEL = "ADMIN_PANEL";
    public static final String ACTION_STOP_CONTROL = "STOP_CONTROL";
    public static final String ACTION_EXIT = "EXIT";
    public static final String ACTION_HIDE_SCREEN = "HIDE_SCREEN";
    public static final String ACTION_UPDATE_CONFIGURATION = "UPDATE_CONFIGURATION";
    public static final String ACTION_POLICY_VIOLATION = "ACTION_POLICY_VIOLATION";
    public static final String ACTION_ADMIN = "ADMIN";
    public static final String ACTION_INSTALL_COMPLETE = "INSTALL_COMPLETE";
    public static final String ACTION_DISABLE_BLOCK_WINDOW = "DISABLE_BLOCK_WINDOW";

    public static final String EXTRA_ENABLED = "ENABLED";

    public static long CONNECTION_TIMEOUT = 10000;
    public static long LONG_POLLING_READ_TIMEOUT = 300000;
    public static final String STATUS_OK = "OK";
    public static final String ORIENTATION = "ORIENTATION";
    public static final String PACKAGE_NAME = "PACKAGE_NAME";
    public static final String POLICY_VIOLATION_CAUSE = "POLICY_VIOLATION_CAUSE";
    public static final String RESTORED_ACTIVITY = "RESTORED_ACTIVITY";

    public static final int GPS_ON_REQUIRED = 1;
    public static final int GPS_OFF_REQUIRED = 2;
    public static final int MOBILE_DATA_ON_REQUIRED = 3;
    public static final int MOBILE_DATA_OFF_REQUIRED = 4;

    public static final String PREFERENCES = "PREFERENCES";

    public static final int PREFERENCES_ON = 1;
    public static final int PREFERENCES_OFF = 0;

    public static final String PREFERENCES_ADMINISTRATOR = "PREFERENCES_ADMINISTRATOR";
    public static final String PREFERENCES_OVERLAY = "PREFERENCES_OVERLAY";
    public static final String PREFERENCES_USAGE_STATISTICS = "PREFERENCES_USAGE_STATISTICS";
    public static final String PREFERENCES_MANAGE_STORAGE = "PREFERENCES_MANAGE_STORAGE";
    public static final String PREFERENCES_ACCESSIBILITY_SERVICE = "PREFERENCES_ACCESSIBILITY_SERVICE";
    public static final String PREFERENCES_DEVICE_OWNER = "PREFERENCES_DEVICE_OWNER";
    public static final String PREFERENCES_UNKNOWN_SOURCES = "PREFERENCES_UNKNOWN_SOURCES";
    public static final String PREFERENCES_DISABLE_LOCATION = "PREFERENCES_DISABLE_LOCATION";
    public static final String PREFERENCES_MIUI_PERMISSIONS = "PREFERENCES_MIUI_PERMISSIONS";
    public static final String PREFERENCES_MIUI_DEVELOPER = "PREFERENCES_MIUI_DEVELOPER";
    public static final String PREFERENCES_MIUI_OPTIMIZATION = "PREFERENCES_MIUI_OPTIMIZATION";
    public static final String PREFERENCES_LOG_STRING = "PREFERENCES_LOG_STRING";
    public static final String PREFERENCES_DATA_TOKEN = "PREFERENCES_DATA_TOKEN";

    public static final int MIUI_PERMISSIONS = 0;
    public static final int MIUI_DEVELOPER = 1;
    public static final int MIUI_OPTIMIZATION = 2;

    public static final String LOG_TAG = "HeadwindMDM";

    public static final int SETTINGS_UNBLOCK_TIME = 180000;
    public static final int PERMISSIVE_MODE_TIME = 180000;

    public static final String LAUNCHER_RESTARTER_PACKAGE_ID = "com.hmdm.emuilauncherrestarter";
    public static final String LAUNCHER_RESTARTER_OLD_VERSION = "oldVersion";
    public static final String LAUNCHER_RESTARTER_STOP = "stop";

    public static final String SETTINGS_PACKAGE_NAME = "com.android.settings";
    public static final String GSF_PACKAGE_NAME = "com.google.android.gsf";
    public static final String SYSTEM_UI_PACKAGE_NAME = "com.android.systemui";
    public static final String KIOSK_BROWSER_PACKAGE_NAME = "com.hmdm.kiosk";
    public static final String APUPPET_PACKAGE_NAME = "com.hmdm.control";
    public static final String APUPPET_SERVICE_CLASS_NAME = "com.hmdm.control.GestureDispatchService";

    public static final String QR_BASE_URL_ATTR = "com.hmdm.BASE_URL";
    public static final String QR_SECONDARY_BASE_URL_ATTR = "com.hmdm.SECONDARY_BASE_URL";
    public static final String QR_SERVER_PROJECT_ATTR = "com.hmdm.SERVER_PROJECT";
    public static final String QR_DEVICE_ID_ATTR = "com.hmdm.DEVICE_ID";
    public static final String QR_LEGACY_DEVICE_ID_ATTR = "ru.headwind.kiosk.DEVICE_ID";
    public static final String QR_DEVICE_ID_USE_ATTR = "com.hmdm.DEVICE_ID_USE";
    public static final String QR_CUSTOMER_ATTR = "com.hmdm.CUSTOMER";
    public static final String QR_CONFIG_ATTR = "com.hmdm.CONFIG";
    public static final String QR_GROUP_ATTR = "com.hmdm.GROUP";
    public static final String QR_OPEN_WIFI_ATTR = "com.hmdm.OPEN_WIFI";
    public static final String QR_WORK_PROFILE_ATTR = "com.hmdm.WORK_PROFILE";

    public static final int KIOSK_UNLOCK_CLICK_COUNT = 4;

    public static final String INTENT_PUSH_NOTIFICATION_PREFIX = "com.hmdm.push.";
    public static final String INTENT_PUSH_NOTIFICATION_EXTRA = "com.hmdm.PUSH_DATA";

    public static final String WORK_TAG_COMMON = "com.hmdm.launcher";

    public static final String DEVICE_CHARGING_USB = "usb";
    public static final String DEVICE_CHARGING_AC = "ac";

    public static final String WIFI_STATE_FAILED = "failed";
    public static final String WIFI_STATE_INACTIVE = "inactive";
    public static final String WIFI_STATE_SCANNING = "scanning";
    public static final String WIFI_STATE_DISCONNECTED = "disconnected";
    public static final String WIFI_STATE_CONNECTING = "connecting";
    public static final String WIFI_STATE_CONNECTED = "connected";

    public static final String GPS_STATE_INACTIVE = "inactive";
    public static final String GPS_STATE_LOST = "lost";
    public static final String GPS_STATE_ACTIVE = "active";

    public static final String MOBILE_STATE_INACTIVE = "inactive";
    public static final String MOBILE_STATE_DISCONNECTED = "disconnected";
    public static final String MOBILE_STATE_CONNECTED = "connected";

    public static final String MOBILE_SIMSTATE_UNKNOWN = "unknown";
    public static final String MOBILE_SIMSTATE_ABSENT = "absent";
    public static final String MOBILE_SIMSTATE_PIN_REQUIRED = "pinRequired";
    public static final String MOBILE_SIMSTATE_PUK_REQUIRED = "pukRequired";
    public static final String MOBILE_SIMSTATE_LOCKED = "locked";
    public static final String MOBILE_SIMSTATE_READY = "ready";
    public static final String MOBILE_SIMSTATE_NOT_READY = "notReady";
    public static final String MOBILE_SIMSTATE_DISABLED = "disabled";
    public static final String MOBILE_SIMSTATE_ERROR = "error";
    public static final String MOBILE_SIMSTATE_RESTRICTED = "restricted";

    public static final int LOG_ERROR = 1;
    public static final int LOG_WARN = 2;
    public static final int LOG_INFO = 3;
    public static final int LOG_DEBUG = 4;
    public static final int LOG_VERBOSE = 5;

    public static final String PASSWORD_QUALITY_PRESENT = "present";
    public static final String PASSWORD_QUALITY_EASY = "easy";
    public static final String PASSWORD_QUALITY_MODERATE = "moderate";
    public static final String PASSWORD_QUALITY_STRONG = "strong";

    public static final String HEADER_IP_ADDRESS = "X-IP-Address";
    public static final String HEADER_RESPONSE_SIGNATURE = "X-Response-Signature";

    public static final int SCREEN_ORIENTATION_PORTRAIT = 1;
    public static final int SCREEN_ORIENTATION_LANDSCAPE = 2;

    public static final int DIRECTION_LEFT = 0;
    public static final int DIRECTION_RIGHT = 1;
    public static final int DIRECTION_UP = 2;
    public static final int DIRECTION_DOWN = 3;

    public static final int DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC = 300;
    public static final int DEFAULT_PUSH_WORKER_KEEPALIVE_TIME_SEC = 900;
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BaseActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.annotation.SuppressLint;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Handler;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.view.inputmethod.InputMethodManager;
import android.widget.ArrayAdapter;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.google.zxing.integration.android.IntentIntegrator;
import com.google.zxing.integration.android.IntentResult;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.DialogDeviceInfoBinding;
import com.hmdm.launcher.databinding.DialogEnterDeviceIdBinding;
import com.hmdm.launcher.databinding.DialogEnterServerBinding;
import com.hmdm.launcher.databinding.DialogNetworkErrorBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.ServerUrl;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.Utils;

import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

import okhttp3.HttpUrl;

public class BaseActivity extends AppCompatActivity {

    protected ProgressDialog progressDialog;

    protected Dialog enterServerDialog;
    protected DialogEnterServerBinding dialogEnterServerBinding;

    protected Dialog enterDeviceIdDialog;
    protected DialogEnterDeviceIdBinding enterDeviceIdDialogBinding;

    protected Dialog networkErrorDialog;
    protected DialogNetworkErrorBinding dialogNetworkErrorBinding;
    protected String networkErrorDetails;

    protected Dialog deviceInfoDialog;
    protected DialogDeviceInfoBinding dialogDeviceInfoBinding;

    protected void dismissDialog(Dialog dialog) {
        if (dialog != null) {
            try {
                dialog.dismiss();
            } catch (Exception ignored) {
            }
        }
    }

    protected void createAndShowEnterDeviceIdDialog( boolean error, String deviceId ) {
        dismissDialog(enterDeviceIdDialog);
        enterDeviceIdDialog = new Dialog( this );
        enterDeviceIdDialogBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_device_id,
                null,
                false );
        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        String serverUrl = settingsHelper.getBaseUrl();
        String serverPath = settingsHelper.getServerProject();
        if (serverPath.length() > 0) {
            serverUrl += "/" + serverPath;
        }
        enterDeviceIdDialogBinding.deviceIdPrompt.setText(getString(R.string.dialog_enter_device_id_title, serverUrl));
        enterDeviceIdDialogBinding.deviceIdError.setText(getString(R.string.dialog_enter_device_id_error, serverUrl));
        enterDeviceIdDialogBinding.setError( error );
        enterDeviceIdDialog.setCancelable( false );
        enterDeviceIdDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        if (deviceId != null) {
            enterDeviceIdDialogBinding.deviceId.setText(deviceId);
        }

        // Suggest IMEI as ID is an option which could be turned on in the build settings
        // Don't use this by default because the device ID must not be bound to IMEI:
        // if it's bound to IMEI, it becomes difficult to replace the device
        List<String> variantsList = new ArrayList<>();
        if (!BuildConfig.DEVICE_ID_CHOICE.equals("user")) {
            Utils.autoGrantPhonePermission(this);
            String imei = DeviceInfoProvider.getImei(this);
            if (imei != null) {
                variantsList.add(imei);
            }
            String serial = DeviceInfoProvider.getSerialNumber();
            if (serial != null && !serial.equals(Build.UNKNOWN)) {
                variantsList.add(serial);
            }
        }
        if (variantsList.size() > 0) {
            String[] variantsArray = variantsList.toArray(new String[variantsList.size()]);
            enterDeviceIdDialogBinding.deviceId.setThreshold(0);
            enterDeviceIdDialogBinding.deviceId.setAdapter(new ArrayAdapter<String>(this,
                    android.R.layout.select_dialog_item, variantsArray));
        } else {
            enterDeviceIdDialogBinding.showDeviceIdVariants.setVisibility(View.GONE);
        }

        enterDeviceIdDialogBinding.showDeviceIdQrCode.setVisibility(View.VISIBLE);

        enterDeviceIdDialog.setContentView( enterDeviceIdDialogBinding.getRoot() );
        enterDeviceIdDialog.setOnShowListener(dialog -> {
            enterDeviceIdDialogBinding.deviceId.requestFocus();
        });
        enterDeviceIdDialogBinding.deviceId.setOnFocusChangeListener((view, hasFocus) -> {
            if (hasFocus) {
                InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
            }
        });
        enterDeviceIdDialog.show();
    }

    public void showDeviceIdVariants(View view) {
        enterDeviceIdDialogBinding.deviceId.showDropDown();
    }

    public void showDeviceIdQrCode(View view) {
        IntentIntegrator integrator = new IntentIntegrator(this);
        integrator.setOrientationLocked(false);
        integrator.initiateScan();
    }

    public void showErrorDetails(View view) {
        ErrorDetailsActivity.display(this, networkErrorDetails, false);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        try {
            IntentResult result = IntentIntegrator.parseActivityResult(requestCode, resultCode, data);
            if (result != null) {
                if (result.getContents() != null) {
                    updateSettingsFromQr(result.getContents());
                }
            } else {
                Log.d(Const.LOG_TAG, "Failed to parse QR code!");
                super.onActivityResult(requestCode, resultCode, data);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected void updateSettingsFromQr(String qrcode) {
        try {
            Log.d(Const.LOG_TAG, "Get initial settings from the QR code");
            SettingsHelper settingsHelper = SettingsHelper.getInstance(getApplicationContext());
            JSONObject qr = new JSONObject(qrcode);
            JSONObject extras = qr.getJSONObject(DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);

            String deviceId = extras.optString(Const.QR_DEVICE_ID_ATTR, null);
            if (deviceId == null) {
                // Also let's try legacy attribute
                deviceId = extras.optString(Const.QR_LEGACY_DEVICE_ID_ATTR, null);
            }
            if (deviceId != null) {
                Log.d(Const.LOG_TAG, "Device ID: " + deviceId);
                settingsHelper.setDeviceId(deviceId);
            } else {
                Log.d(Const.LOG_TAG, "Device ID is null");
                String deviceIdUse = extras.optString(Const.QR_DEVICE_ID_USE_ATTR, null);
                if (deviceIdUse != null) {
                    Log.d(Const.LOG_TAG, "Device ID use: " + deviceIdUse);
                    // Save for further automatic choice of the device ID
                    settingsHelper.setDeviceIdUse(deviceIdUse);
                }
            }

            String baseUrl = extras.optString(Const.QR_BASE_URL_ATTR, null);
            String secondaryBaseUrl = extras.optString(Const.QR_SECONDARY_BASE_URL_ATTR, null);
            if (baseUrl != null) {
                Log.d(Const.LOG_TAG, "Base URL: " + baseUrl);
                settingsHelper.setBaseUrl(baseUrl);
                // If we don't set the secondary base URL, it will point to app.h-mdm.com by default which is wrong
                if (secondaryBaseUrl == null) {
                    secondaryBaseUrl = baseUrl;
                }
            }
            if (secondaryBaseUrl != null) {
                Log.d(Const.LOG_TAG, "Secondary base URL: " + baseUrl);
                settingsHelper.setSecondaryBaseUrl(secondaryBaseUrl);
            }

            String serverProject = extras.optString(Const.QR_SERVER_PROJECT_ATTR, null);
            if (serverProject != null) {
                Log.d(Const.LOG_TAG, "Project path: " + serverProject);
                settingsHelper.setServerProject(serverProject);
            }

            DeviceEnrollOptions createOptions = new DeviceEnrollOptions();
            createOptions.setCustomer(extras.optString(Const.QR_CUSTOMER_ATTR, null));
            createOptions.setConfiguration(extras.optString(Const.QR_CONFIG_ATTR, null));
            createOptions.setGroups(extras.optString(Const.QR_GROUP_ATTR, null));
            if (createOptions.getCustomer() != null) {
                Log.d(Const.LOG_TAG, "Customer: " + createOptions.getCustomer());
                settingsHelper.setEnrollOptionCustomer(createOptions.getCustomer());
            }
            if (createOptions.getConfiguration() != null) {
                Log.d(Const.LOG_TAG, "Configuration: " + createOptions.getConfiguration());
                settingsHelper.setEnrollOptionConfigName(createOptions.getConfiguration());
            }
            if (createOptions.getGroups() != null) {
                settingsHelper.setEnrollOptionGroup(createOptions.getGroupSet());
            }

        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Invalid QR code contents, got an exception!");
            e.printStackTrace();
            Toast.makeText(this, getString(R.string.qrcode_contents_error,
                    getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
        }
    }

    public void exitDeviceId(View view) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            finishAffinity();
        }
        System.exit(0);
    }

    protected String concatenateServerUrl(String serverName, String serverPath) {
        String serverUrl = serverName;
        if (serverPath != null && serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        return serverUrl;
    }

    protected void createAndShowNetworkErrorDialog(String serverName,
                                                   String serverPath,
                                                   String errorDetails,
                                                   boolean showResetButton,
                                                   boolean showWifiButton) {
        dismissDialog(networkErrorDialog);
        networkErrorDialog = new Dialog( this );
        dialogNetworkErrorBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_network_error,
                null,
                false );
        networkErrorDialog.setCancelable( false );
        networkErrorDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        networkErrorDetails = errorDetails;

        String serverUrl = serverName;
        if (serverPath != null && serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        dialogNetworkErrorBinding.title.setText(getString(R.string.dialog_network_error_title, serverUrl));

        dialogNetworkErrorBinding.resetButton.setVisibility(showResetButton ? View.VISIBLE : View.GONE);
        dialogNetworkErrorBinding.wifiButton.setVisibility(showWifiButton ? View.VISIBLE : View.GONE);

        networkErrorDialog.setContentView( dialogNetworkErrorBinding.getRoot() );
        try {
            networkErrorDialog.show();
        } catch (Exception e) {
            // Unable to add window -- token is not valid; is your activity running?
            e.printStackTrace();
        }
    }


    protected void createAndShowServerDialog(boolean error, String serverName, String serverPath) {
        dismissDialog(enterServerDialog);
        enterServerDialog = new Dialog( this );
        dialogEnterServerBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_server,
                null,
                false );
        dialogEnterServerBinding.setError(error);
        enterServerDialog.setCancelable(false);
        enterServerDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        String serverUrl = serverName;
        if (serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        dialogEnterServerBinding.setServer(serverUrl);

        enterServerDialog.setContentView( dialogEnterServerBinding.getRoot() );
        enterServerDialog.setOnShowListener(dialog -> {
            dialogEnterServerBinding.serverUrl.requestFocus();
        });
        dialogEnterServerBinding.serverUrl.setOnFocusChangeListener((view, hasFocus) -> {
            if (hasFocus) {
                InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
            }
        });
        enterServerDialog.show();
    }

    public boolean saveServerUrlBase() {
        String serverUrl = dialogEnterServerBinding.serverUrl.getText().toString();
        if ( "".equals( serverUrl ) ) {
            dialogEnterServerBinding.setError(true);
            return false;
        } else {
            ServerUrl url = null;
            try {
                url = new ServerUrl(serverUrl);

                // Retrofit uses HttpUrl!
                HttpUrl httpUrl = HttpUrl.parse(serverUrl);
                if (httpUrl == null) {
                    // Malformed URL
                    dialogEnterServerBinding.setError(true);
                    return false;
                }
            } catch (Exception e) {
                // Malformed URL
                dialogEnterServerBinding.setError(true);
                return false;
            }

            SettingsHelper settingsHelper = SettingsHelper.getInstance( this );
            settingsHelper.setBaseUrl(url.baseUrl);
            settingsHelper.setSecondaryBaseUrl(url.baseUrl);
            settingsHelper.setServerProject(url.serverProject);
            dialogEnterServerBinding.setError( false );

            dismissDialog(enterServerDialog);

            Log.i(Const.LOG_TAG, "saveServerUrl(): calling updateConfig()");
            return true;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    protected void createAndShowInfoDialog() {
        dismissDialog(deviceInfoDialog);
        deviceInfoDialog = new Dialog( this );
        dialogDeviceInfoBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_device_info,
                null,
                false );
        deviceInfoDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        deviceInfoDialog.setCancelable( false );

        deviceInfoDialog.setContentView( dialogDeviceInfoBinding.getRoot() );

        dialogDeviceInfoBinding.setSerialNumber(DeviceInfoProvider.getSerialNumber());

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);

        String phone = DeviceInfoProvider.getPhoneNumber(this);
        if (phone == null || phone.equals("")) {
            phone = settingsHelper.getConfig() != null ? settingsHelper.getConfig().getPhone() : "";
        }
        dialogDeviceInfoBinding.setPhone(phone);

        String imei = DeviceInfoProvider.getImei(this);
        if (imei == null || imei.equals("")) {
            imei = settingsHelper.getConfig() != null ? settingsHelper.getConfig().getImei() : "";
        }
        dialogDeviceInfoBinding.setImei(imei);

        dialogDeviceInfoBinding.setDeviceId(SettingsHelper.getInstance(this).getDeviceId());
        dialogDeviceInfoBinding.setVersion(BuildConfig.VERSION_NAME + "-" + Utils.getLauncherVariant());

        String serverPath = SettingsHelper.getInstance(this).getServerProject();
        if (serverPath.length() > 0) {
            serverPath = "/" + serverPath;
        }
        dialogDeviceInfoBinding.setServerUrl(SettingsHelper.getInstance(this).getBaseUrl() + serverPath);

        deviceInfoDialog.show();
    }

    public void closeDeviceInfoDialog( View view ) {
        dismissDialog(deviceInfoDialog);
    }


    public void exitToSystemLauncher( View view ) {
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_SERVICE_STOP ) );
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_EXIT ) );

        // One second delay is required to avoid race between opening a forbidden activity and stopping the locked mode
        progressDialog = new ProgressDialog(this);
        progressDialog.setCancelable(false);
        progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
        progressDialog.setMessage(getString(R.string.switch_off_blockings));
        progressDialog.show();

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            ServerConfig config = settingsHelper.getConfig();
            if (config.getRestrictions() != null && !config.getRestrictions().trim().equals("")) {
                Utils.releaseUserRestrictions(this, config.getRestrictions());
            }
        }

        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                if (progressDialog != null) {
                    progressDialog.dismiss();
                    progressDialog = null;
                }

                openLauncherChoiceDialog();
            }
        }, 1000);
    }

    protected void openLauncherChoiceDialog() {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        startActivity(Intent.createChooser(intent, getString(R.string.select_system_launcher, getString(R.string.white_app_name))));
    }

}
</file>

<file path="app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!-- -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:sharedUserId="com.hmdm">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="29"/>
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<!-- This permission is dangerous and causes blocking by Play Protect in some countries.
     In fact, this permission is currently never used by Headwind MDM.
 -->
<!--    <uses-permission android:name="android.permission.READ_SMS"/>-->
    <uses-permission android:name="android.permission.READ_PHONE_NUMBERS"/>
    <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE"
        tools:ignore="ProtectedPermissions"/>

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>


    <uses-permission android:name="android.permission.GET_TASKS"/>
    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS"
                     tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.INJECT_EVENTS"
        tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/>
    <uses-permission android:name="android.permission.REQUEST_DELETE_PACKAGES"/>
    <uses-permission android:name="android.permission.BLUETOOTH" android:required="false" android:maxSdkVersion="30"/>
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false" android:maxSdkVersion="30"/>
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" android:required="false"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION"/>
    <uses-permission android:name="com.mediatek.permission.CTA_ENABLE_WIFI"/>
    <uses-permission android:name="com.mediatek.permission.CTA_ENABLE_BT"/>
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SYSTEM_EXEMPTED" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.REQUEST_PASSWORD_COMPLEXITY" />
    <uses-permission android:name="android.permission.MASTER_CLEAR"
        tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.WRITE_SETTINGS"
        tools:ignore="ProtectedPermissions"/>

    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_BLUETOOTH" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_CALLS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_DISPLAY" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_FUN" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCALE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCATION" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MICROPHONE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_OVERRIDE_APN" />  <!-- for com.hmdm.apn plugin -->
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_PRINTING" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SMS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_TIME" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_VPN" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WALLPAPER" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WIFI" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WINDOWS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA" />

    <uses-sdk tools:overrideLibrary="com.google.zxing.client.android" />

    <uses-feature android:name="android.hardware.telephony" android:required="false" />
    <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
    <uses-feature android:name="android.software.leanback" android:required="false" />

    <application
        android:icon="@mipmap/ic_launcher"
        android:label="@string/white_app_name"
        android:supportsRtl="true"
        android:requestLegacyExternalStorage="true"
        android:usesCleartextTraffic="true"
        android:networkSecurityConfig="@xml/network_security_config"
        android:theme="@style/AppTheme"
        android:name=".App"
        android:hardwareAccelerated="true"
        tools:ignore="GoogleAppIndexingWarning">

        <activity
            android:name=".ui.MainActivity"
            android:launchMode="singleInstance"
            android:banner="@drawable/banner"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <action android:name="android.app.action.PROVISIONING_SUCCESSFUL"/>

                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.HOME" />
            </intent-filter>
        </activity>
        <activity
            android:name="io.flutter.embedding.android.FlutterActivity"
            android:theme="@style/AppTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize"
            />
        <activity 
            android:name=".ui.AdminActivity"
            android:excludeFromRecents="true" 
            android:exported="false"
        />
        <activity
            android:name=".ui.AdminModeRequestActivity"
            android:excludeFromRecents="true"
            android:exported="false"
            />

        <activity
            android:name="com.journeyapps.barcodescanner.CaptureActivity"
            android:screenOrientation="fullSensor"
            tools:replace="screenOrientation" 
            android:exported="false"/>

        <activity
            android:name=".ui.InitialSetupActivity"
            android:theme="@style/SetupWizardTheme"
            android:permission="android.permission.BIND_DEVICE_ADMIN"
            android:exported="true">
            <intent-filter>
                <action android:name="android.app.action.ADMIN_POLICY_COMPLIANCE" />
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.MdmChoiceSetupActivity"
            android:theme="@style/SetupWizardTheme"
            android:permission="android.permission.BIND_DEVICE_ADMIN"
            android:exported="true">
            <intent-filter>
                <action android:name="android.app.action.GET_PROVISIONING_MODE" />
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.ErrorDetailsActivity"
            android:theme="@style/SetupWizardTheme" 
            android:exported="false"/>

        <receiver
            android:name="com.hmdm.launcher.AdminReceiver"
            android:label="@string/white_app_name"
            android:exported="true"
            android:permission="android.permission.BIND_DEVICE_ADMIN">
            <meta-data
                android:name="android.app.device_admin"
                android:resource="@xml/device_admin" />

            <intent-filter>
                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
                <action android:name="android.app.action.PROFILE_PROVISIONING_COMPLETE" />
            </intent-filter>
        </receiver>

        <receiver android:name="com.hmdm.launcher.receiver.SimChangedReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.SIM_STATE_CHANGED"/>
            </intent-filter>
        </receiver>

        <receiver android:name="com.hmdm.launcher.receiver.ShutdownReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.ACTION_SHUTDOWN" />
                <action android:name="android.intent.action.QUICKBOOT_POWEROFF" />
            </intent-filter>
        </receiver>

        <receiver
            android:name="com.hmdm.launcher.receiver.BootReceiver"
            android:label="BootReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <category android:name="android.intent.category.DEFAULT"/>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON"/>
                <!--For HTC devices-->
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths"/>
        </provider>

        <service android:name=".pro.service.CheckForegroundApplicationService"
            android:exported="true"/>

        <service android:name=".service.PluginApiService" android:enabled="true" android:exported="true">
            <intent-filter>
                <action android:name="com.hmdm.action.Connect" />
            </intent-filter>
        </service>
        <service
            android:name="id.flutter.flutter_background_service.BackgroundService"
            android:foregroundServiceType="location" />

        <!-- Stub -->
        <service android:name=".pro.service.CheckForegroundAppAccessibilityService"
                 android:exported="false"/>

        <service android:name="org.eclipse.paho.android.service.MqttService"
            android:foregroundServiceType="specialUse|systemExempted"
            android:exported="false">
            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="Push notification service"/>
        </service>

        <service android:name=".service.LocationService"
            android:foregroundServiceType="location"
            android:exported="false"/>

        <service android:name=".service.StatusControlService"
            android:exported="false"/>

        <service android:name=".service.PushLongPollingService"
            android:foregroundServiceType="specialUse|systemExempted"
            android:exported="false">
            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="Push notification service"/>
        </service>

    </application>

</manifest>
</file>

<file path="app/src/main/res/values-pt/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrador</string>
    <string name="install_error">Erro na Instalação </string>
    <string name="file_create_error">Erro ao criar ficheiro</string>
    <string name="dialog_enter_device_id_error">O ID não está registrado em %s. Verifique o ID na aba \"Dispositivos\" do painel de controle.</string>
    <string name="dialog_enter_device_id_qrcode">QR code</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Salvar</string>
    <string name="dialog_enter_device_id_exit">Sair</string>
    <string name="dialog_enter_device_id_title">Digite o ID do Dispositivo em %s</string>
    <string name="main_start_preparations">Preparar para iniciar</string>
    <string name="main_downloading_configuration">Atualizando arquivo de configuração</string>
    <string name="main_downloading_content">Atualizando</string>
    <string name="main_update_applications">Instalando e atualizando aplicativos</string>
    <string name="dialog_root_message">Você precisa do acesso ROOT</string>
    <string name="main_application_start">Iniciando Aplicativo</string>
    <string name="main_app_installing">Instalando Aplicativo</string>
    <string name="main_app_downloading">Efetuando Download do Aplicativo</string>
    <string name="main_app_downloading_error">Falha ao efetuar o download do aplicativo</string>
    <string name="main_app_removing">Removendo Aplicativo</string>
    <string name="main_file_downloading">Efetuando Download do Arquivo</string>
    <string name="main_file_downloading_error">Falha ao efetuar o download do arquivo</string>
    <string name="main_activity_repeat">Repetir</string>
    <string name="main_activity_reset">Resetar</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancelar</string>
    <string name="main_activity_details">Detalhes</string>
    <string name="select_system_launcher">Selecione %s como o launcher padrão e marque a opção \'Sempre\':</string>
    <string name="dialog_network_error_title">Erro ao conectar em %s. Por favor verifique a conexão com a internet e tente novamente.</string>
    <string name="main_activity_update_config">Requisitando arquivo de configuração do servidor</string>
    <string name="main_activity_applications_update">Atualizar aplicativos</string>
    <string name="dialog_overlay_settings_title">Permita que o aplicativo desenhe sobre outras janelas.\n\nEsta opção ajuda a bloquear melhor os aplicativos indesejados e ativa o desbloqueio de emergência do modo quiosque.\n\nToque em \"Continuar\" para abrir uma página de configurações. Encontre o item \"%s\", conceda a permissão e toque em \"Voltar\".</string>
    <string name="dialog_manage_storage_title">Por favor, permita que a aplicação gerencie o armazenamento.\n\nEsta opção permite o Headwind MDM gerir ficheiros no seu dispositivo.</string>
    <string name="dialog_history_settings_title">Permita que o aplicativo acesse os dados de uso.\n\nEsta opção permite o controle de aplicativos e configurações.\n\nEsta opção pode causar um esgotamento mais rápido da bateria. Para economizar bateria, pule esta opção (use os serviços de acessibilidade ou o modo quiosque).\n\nToque em \"Continuar\" para abrir uma página de configurações. Encontre o item \"%s\", conceda a permissão e toque em \"Voltar\".</string>
    <string name="dialog_history_settings_continue">Continuar</string>
    <string name="dialog_history_settings_skip">Pular</string>
    <string name="dialog_unknown_sources_title">Por favor permita a instalação de aplicativos de fonte desconhecida. Uma tela de configurações vai ser aberta. Procure \"Fontes desconhecidas\", toque em permitir a instalação e toque em \"Voltar\".</string>
    <string name="dialog_unknown_sources_continue">Continuar</string>
    <string name="dialog_miui_permissions_title">MIUI requer uma configuração manual no seu device. A tela de permissões do aplicativo vai ser aberta. Toque em \"Outras permissões\", ative \"Mostrar Janelas pop-up enquanto está em segundo plano\" e toque em \"Voltar\".</string>
    <string name="dialog_miui_developer_title">MIUI requer uma configuração manual no seu device. Na tela de informações do dispositivo, TOQUE 7 VEZES EM \"NÚMERO DA VERSÃO\". Isso vai ativar as opções de desenvolvedor.</string>
    <string name="dialog_miui_optimization_title">MIUI requer uma configuração manual no seu device. Developer settings window will now open. Scroll the screen down and uncheck \"MIUI optimization\".</string>
    <string name="dialog_administrator_mode_message">Por favor permita que o aplicativo trabalhe no modo administrador do dispositivo. Uma tela de configurações vai ser aberta. Selecione \"Administrador do Dispositivo\", procure por \"%s\", ative como administrador, e toque em \"Voltar\".</string>
    <string name="dialog_administrator_mode_continue">Continuar</string>
    <string name="dialog_administrator_mode_skip">Pular</string>
    <string name="accessibility_service_description">Aplicativo ativo de monitoramento pela aplicação MDM</string>
    <string name="dialog_accessibility_service_message">Por favor permita o acesso aos serviços de acessibilidade. Uma tela de configurações vai ser aberta. Procure o item \"%s\", permita o acesso aos serviços de acessibilidade, e toque em \"Voltar\".</string>
    <string name="dialog_accessibility_service_continue">Continuar</string>
    <string name="dialog_accessibility_service_skip">Pular</string>
    <string name="access_to_app_denied">O pacote não é permitido:</string>
    <string name="access_to_app_denied_2">Por favor, peça ao seu administrador para ativar este pacote na configuração.\n\nClique em \'Fechar\' ou no botão Home para continuar.</string>
    <string name="package_id_copied">O ID do pacote é copiado para a área de transferência</string>
    <string name="dialog_app_not_allowed_close">Fechar</string>
    <string name="dialog_app_not_allowed_admin">Administrador</string>
    <string name="device_id">ID do Dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Número do Serial</string>
    <string name="phone_number">Número do Telefone</string>
    <string name="launcher_version">Versão do Launcher</string>
    <string name="close">Fechar</string>
    <string name="admin_change_device_id">Alterar ID do dispositivo</string>
    <string name="admin_change_server_url">Alterar URL do Servidor</string>
    <string name="admin_allow_settings">Abrir configurações</string>
    <string name="settings_allowed">Você pode alterar as permissões durante 3 minutos.</string>
    <string name="admin_clear_restrictions">Remover restrições</string>
    <string name="permissive_mode_enabled">Você tem permissão para executar todos os aplicativos em 3 minutos.</string>
    <string name="admin_refresh">Atualizar Configuração</string>
    <string name="admin_exit">Sair do Launcher do sistema</string>
    <string name="admin_reset_permissions">Resetar Permissões</string>
    <string name="admin_reset_network">Resetar políticas de rede</string>
    <string name="admin_reset_network_hint">Políticas de rede foram limpas. Você pode ativar a internet e reiniciar a configuração.</string>
    <string name="reboot">Reiniciar Dispositivo</string>
    <string name="reboot_failed">Você não tem permissões para reiniciar o dispositivo.</string>
    <string name="message_turn_on_gps">A Tela de configurações vai abrir. Por favor ATIVE o GPS na tela e toque em voltar.</string>
    <string name="message_turn_off_gps">A Tela de configurações vai abrir. Por favor DESLIGUE o GPS na tela e toque em voltar.</string>
    <string name="message_turn_on_mobile_data">Rede de Dados do Celular está desativada! Por favor abra a barra de status e ATIVE a rede de dados.</string>
    <string name="message_turn_off_mobile_data">Rede de Dados do Celular está ativada. Por favor abra a barra de status e DESATIVE a rede de dados.</string>
    <string name="message_set_password">Sua senha não está com uma senha de boa qualidade. A tela de configurações vai ser aberta. Por favor altere sua senha e toque em Voltar.</string>
    <string name="switch_off_blockings">Desligando Restrições...</string>
    <string name="kiosk_mode_requires_overlays">Modo Kiosk desativado: Sem permissões para sobrepor outros aplicativos. Por favor habilite %s para sobrepor os aplicativos.</string>
    <string name="enter_admin_password">Digite a senha do Administrador</string>
    <string name="wrong_password">Senha inválida</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Cancelar</string>
    <string name="internal_error">Ocorreu um erro interno no aplicativo. Por favor reinicie o dispositivo e tente novamente.</string>
    <string name="empty_configuration">Configuração não efetuada, tente buscar a configuração do servidor novamente!</string>
    <string name="permissions_reset_hint">Feche o painel administrador para verificar e buscar permissões.</string>
    <string name="dialog_enter_server_error">Por favor digite uma URL válida do servidor.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Digite a URL do servidor</string>
    <string name="critical_server_failure">Ocorreu um problema no servidor! Por favor corrija o erro e reinicie %s, ou remova completamente e reinstale.</string>
    <string name="dialog_permission_title">O Aplicativo requer permissões para iniciar. Por favor garanta as permissões necessárias.</string>
    <string name="main_activity_exit">Sair</string>
    <string name="browser_not_found">A página web não pode ser aberta porque um navegador não foi encontrado. Por favor adicione o navegador nas configurações do dispositivo.</string>
    <string name="invalid_web_link">Não é possível abrir o link da web porque não está bem formado. Entre em contato com seu administrador para obter detalhes.</string>
    <string name="activity_not_found">Não é possível executar a ação %s porque a atividade não foi encontrada.</string>
    <string name="location_service_text">Localização do dispositivo está ativa</string>
    <string name="qrcode_contents_error">QR code com conteúdo inválido. Por favor gere o QR Code de provisionamento no painel administrativo %s.</string>
    <string name="device_locked">Este dispositivo (%s) está bloqueado pelo administrador.</string>
    <string name="fault_loop_detected">Oops, ocorreu uma falha no launcher do seu dispositivo! Por favor contate o administrador do sistema.</string>
    <string name="mqtt_service_text">As notificações push estão ativas</string>
    <string name="background_location">%s requer permissão de localização em segundo plano. Clique em \'Continuar\' para abrir as permissões, clique em \'Local\' e permita determinar o local sempre.</string>
    <string name="location_disable">Desativar localização</string>
    <string name="background_location_continue">Continuar</string>
    <string name="initializing_mdm">Inicializando o aplicativo de gerenciamento de dispositivo móvel ...</string>
    <string name="dialog_server_error_title">O servidor MDM %s retornou uma resposta inválida. Entre em contato com o seu administrador.</string>
    <string name="mdm_choice_message">Este dispositivo será totalmente gerenciado por sua organização. Seus dados não serão privados e podem ser apagados ou revisados por seu administrador de TI a qualquer momento.</string>
    <string name="work_profile_message">Este dispositivo receberá um perfil de trabalho gerenciado pertencente à sua organização. O perfil de trabalho é separado do seu perfil privado e você pode alternar entre os perfis a qualquer momento.</string>
    <string name="overlays_not_supported">Infelizmente, as sobreposições não são suportadas pelo seu dispositivo.</string>
    <string name="admin_not_supported">Seu dispositivo não tem opção de administrador do dispositivo. Clique em Pular para continuar.</string>
    <string name="manage_storage_not_supported">O seu dispositivo não tem opção para gerir o armazenamento externo.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.LinkedList;
import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerConfig {

    private String newNumber;

    private String backgroundColor;
    private String textColor;
    private String backgroundImageUrl;
    private String password;
    private String phone;
    private String imei;
    private Integer iconSize;
    private String title;
    private boolean displayStatus;

    private Boolean gps;
    private Boolean bluetooth;
    private Boolean wifi;
    private Boolean mobileData;

    private Boolean kioskMode;
    private String mainApp;

    private Boolean lockStatusBar;
    private Integer systemUpdateType;
    private String systemUpdateFrom;
    private String systemUpdateTo;
    private String appUpdateFrom;
    private String appUpdateTo;
    private String downloadUpdates;

    private Boolean factoryReset;
    private Boolean reboot;
    private Boolean lock;
    private String lockMessage;
    private String passwordReset;

    private String pushOptions;
    private Integer keepaliveTime;
    private String requestUpdates;
    private Boolean disableLocation;
    private String appPermissions;

    private Boolean usbStorage;
    private Boolean autoBrightness;
    private Integer brightness;
    private Boolean manageTimeout;
    private Integer timeout;
    private Boolean lockVolume;
    private Boolean manageVolume;
    private Integer volume;
    private String passwordMode;
    private String timeZone;
    private String allowedClasses;

    private Integer orientation;
    private Boolean kioskHome;
    private Boolean kioskRecents;
    private Boolean kioskNotifications;
    private Boolean kioskSystemInfo;
    private Boolean kioskKeyguard;
    private Boolean kioskLockButtons;
    private String restrictions;

    private String description;
    private String custom1;
    private String custom2;
    private String custom3;

    private Boolean runDefaultLauncher;

    private String newServerUrl;

    private boolean lockSafeSettings;
    private boolean permissive;
    private boolean kioskExit;
    private boolean disableScreenshots;
    private boolean autostartForeground;

    private boolean showWifi;

    private String appName;
    private String vendor;

    private List<Application> applications = new LinkedList();

    private List<ApplicationSetting> applicationSettings = new LinkedList();

    private List<RemoteFile> files = new LinkedList();

    private List<Action> actions = new LinkedList();

    public static final String TITLE_NONE = "none";
    public static final String TITLE_DEVICE_ID = "deviceId";
    public static final String TITLE_DESCRIPTION = "description";
    public static final String TITLE_CUSTOM1 = "custom1";
    public static final String TITLE_CUSTOM2 = "custom2";
    public static final String TITLE_CUSTOM3 = "custom3";
    public static final String TITLE_IMEI = "imei";
    public static final String TITLE_SERIAL = "serialNumber";
    public static final String TITLE_EXTERNAL_IP = "externalIp";
    public static final int DEFAULT_ICON_SIZE = 100;

    public static final int SYSTEM_UPDATE_DEFAULT = 0;
    public static final int SYSTEM_UPDATE_INSTANT = 1;
    public static final int SYSTEM_UPDATE_SCHEDULE = 2;
    public static final int SYSTEM_UPDATE_MANUAL = 3;

    public static final String PUSH_OPTIONS_MQTT_WORKER = "mqttWorker";
    public static final String PUSH_OPTIONS_MQTT_ALARM = "mqttAlarm";
    public static final String PUSH_OPTIONS_POLLING = "polling";

    public static final String APP_PERMISSIONS_ASK_LOCATION = "asklocation";
    public static final String APP_PERMISSIONS_DENY_LOCATION = "denylocation";
    public static final String APP_PERMISSIONS_ASK_ALL = "askall";

    public ServerConfig() {}

    public String getNewNumber() {
        return newNumber;
    }

    public void setNewNumber(String newNumber) {
        this.newNumber = newNumber;
    }

    public String getBackgroundColor() {
        return backgroundColor;
    }

    public void setBackgroundColor( String backgroundColor ) {
        this.backgroundColor = backgroundColor;
    }

    public String getTextColor() {
        return textColor;
    }

    public void setTextColor( String textColor ) {
        this.textColor = textColor;
    }

    public String getBackgroundImageUrl() {
        return backgroundImageUrl;
    }

    public void setBackgroundImageUrl( String backgroundImageUrl ) {
        this.backgroundImageUrl = backgroundImageUrl;
    }

    public List< Application > getApplications() {
        return applications;
    }

    public void setApplications( List< Application > applications ) {
        this.applications = applications;
    }

    public List< ApplicationSetting > getApplicationSettings() {
        return applicationSettings;
    }

    public void setApplicationSettings( List< ApplicationSetting > applicationSettings ) {
        this.applicationSettings = applicationSettings;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword( String password ) {
        this.password = password;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getImei() {
        return imei;
    }

    public void setImei(String imei) {
        this.imei = imei;
    }

    public Integer getIconSize() {
        return iconSize;
    }

    public void setIconSize(Integer iconSize) {
        this.iconSize = iconSize;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public boolean isDisplayStatus() {
        return displayStatus;
    }

    public void setDisplayStatus(boolean displayStatus) {
        this.displayStatus = displayStatus;
    }

    public Boolean getGps() {
        return gps;
    }

    public void setGps(Boolean gps) {
        this.gps = gps;
    }

    public Boolean getBluetooth() {
        return bluetooth;
    }

    public void setBluetooth(Boolean bluetooth) {
        this.bluetooth = bluetooth;
    }

    public Boolean getWifi() {
        return wifi;
    }

    public void setWifi(Boolean wifi) {
        this.wifi = wifi;
    }

    public Boolean getMobileData() {
        return mobileData;
    }

    public void setMobileData(Boolean mobileData) {
        this.mobileData = mobileData;
    }

    public Boolean getKioskMode() {
        return kioskMode;
    }

    public boolean isKioskMode() {
        return kioskMode != null && kioskMode;
    }

    public void setKioskMode(Boolean kioskMode) {
        this.kioskMode = kioskMode;
    }

    public String getMainApp() {
        return mainApp;
    }

    public void setMainApp(String mainApp) {
        this.mainApp = mainApp;
    }

    public Boolean getLockStatusBar() {
        return lockStatusBar;
    }

    public void setLockStatusBar(Boolean lockStatusBar) {
        this.lockStatusBar = lockStatusBar;
    }

    public Integer getSystemUpdateType() {
        return systemUpdateType;
    }

    public void setSystemUpdateType(Integer systemUpdateType) {
        this.systemUpdateType = systemUpdateType;
    }

    public String getSystemUpdateFrom() {
        return systemUpdateFrom;
    }

    public void setSystemUpdateFrom(String systemUpdateFrom) {
        this.systemUpdateFrom = systemUpdateFrom;
    }

    public String getSystemUpdateTo() {
        return systemUpdateTo;
    }

    public void setSystemUpdateTo(String systemUpdateTo) {
        this.systemUpdateTo = systemUpdateTo;
    }

    public String getAppUpdateFrom() {
        return appUpdateFrom;
    }

    public void setAppUpdateFrom(String appUpdateFrom) {
        this.appUpdateFrom = appUpdateFrom;
    }

    public String getAppUpdateTo() {
        return appUpdateTo;
    }

    public void setAppUpdateTo(String appUpdateTo) {
        this.appUpdateTo = appUpdateTo;
    }

    public String getDownloadUpdates() {
        return downloadUpdates;
    }

    public void setDownloadUpdates(String downloadUpdates) {
        this.downloadUpdates = downloadUpdates;
    }

    public Boolean getFactoryReset() {
        return factoryReset;
    }

    public void setFactoryReset(Boolean factoryReset) {
        this.factoryReset = factoryReset;
    }

    public Boolean getReboot() {
        return reboot;
    }

    public void setReboot(Boolean reboot) {
        this.reboot = reboot;
    }

    public Boolean getLock() {
        return lock;
    }

    public void setLock(Boolean lock) {
        this.lock = lock;
    }

    public String getLockMessage() {
        return lockMessage;
    }

    public void setLockMessage(String lockMessage) {
        this.lockMessage = lockMessage;
    }

    public String getPasswordReset() {
        return passwordReset;
    }

    public void setPasswordReset(String passwordReset) {
        this.passwordReset = passwordReset;
    }

    public String getPushOptions() {
        return pushOptions;
    }

    public void setPushOptions(String pushOptions) {
        this.pushOptions = pushOptions;
    }

    public Integer getKeepaliveTime() {
        return keepaliveTime;
    }

    public void setKeepaliveTime(Integer keepaliveTime) {
        this.keepaliveTime = keepaliveTime;
    }

    public String getRequestUpdates() {
        return requestUpdates;
    }

    public void setRequestUpdates(String requestUpdates) {
        this.requestUpdates = requestUpdates;
    }

    public Boolean getDisableLocation() {
        return disableLocation;
    }

    public void setDisableLocation(Boolean disableLocation) {
        this.disableLocation = disableLocation;
    }

    public String getAppPermissions() {
        return appPermissions;
    }

    public void setAppPermissions(String appPermissions) {
        this.appPermissions = appPermissions;
    }

    public Boolean getUsbStorage() {
        return usbStorage;
    }

    public void setUsbStorage(Boolean usbStorage) {
        this.usbStorage = usbStorage;
    }

    public Boolean getAutoBrightness() {
        return autoBrightness;
    }

    public void setAutoBrightness(Boolean autoBrightness) {
        this.autoBrightness = autoBrightness;
    }

    public Integer getBrightness() {
        return brightness;
    }

    public void setBrightness(Integer brightness) {
        this.brightness = brightness;
    }

    public Boolean getManageTimeout() {
        return manageTimeout;
    }

    public void setManageTimeout(Boolean manageTimeout) {
        this.manageTimeout = manageTimeout;
    }

    public Integer getTimeout() {
        return timeout;
    }

    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }

    public Boolean getLockVolume() {
        return lockVolume;
    }

    public void setLockVolume(Boolean lockVolume) {
        this.lockVolume = lockVolume;
    }

    public Boolean getManageVolume() {
        return manageVolume;
    }

    public void setManageVolume(Boolean manageVolume) {
        this.manageVolume = manageVolume;
    }

    public Integer getVolume() {
        return volume;
    }

    public void setVolume(Integer volume) {
        this.volume = volume;
    }

    public String getPasswordMode() {
        return passwordMode;
    }

    public void setPasswordMode(String passwordMode) {
        this.passwordMode = passwordMode;
    }

    public String getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

    public String getAllowedClasses() {
        return allowedClasses;
    }

    public void setAllowedClasses(String allowedClasses) {
        this.allowedClasses = allowedClasses;
    }

    public Integer getOrientation() {
        return orientation;
    }

    public void setOrientation(Integer orientation) {
        this.orientation = orientation;
    }

    public Boolean getKioskHome() {
        return kioskHome;
    }

    public void setKioskHome(Boolean kioskHome) {
        this.kioskHome = kioskHome;
    }

    public Boolean getKioskRecents() {
        return kioskRecents;
    }

    public void setKioskRecents(Boolean kioskRecents) {
        this.kioskRecents = kioskRecents;
    }

    public Boolean getKioskNotifications() {
        return kioskNotifications;
    }

    public void setKioskNotifications(Boolean kioskNotifications) {
        this.kioskNotifications = kioskNotifications;
    }

    public Boolean getKioskSystemInfo() {
        return kioskSystemInfo;
    }

    public void setKioskSystemInfo(Boolean kioskSystemInfo) {
        this.kioskSystemInfo = kioskSystemInfo;
    }

    public Boolean getKioskKeyguard() {
        return kioskKeyguard;
    }

    public void setKioskKeyguard(Boolean kioskKeyguard) {
        this.kioskKeyguard = kioskKeyguard;
    }

    public Boolean getKioskLockButtons() {
        return kioskLockButtons;
    }

    public void setKioskLockButtons(Boolean kioskLockButtons) {
        this.kioskLockButtons = kioskLockButtons;
    }

    public Boolean getRunDefaultLauncher() {
        return runDefaultLauncher;
    }

    public void setRunDefaultLauncher(Boolean runDefaultLauncher) {
        this.runDefaultLauncher = runDefaultLauncher;
    }

    public String getNewServerUrl() {
        return newServerUrl;
    }

    public void setNewServerUrl(String newServerUrl) {
        this.newServerUrl = newServerUrl;
    }

    public boolean isLockSafeSettings() {
        return lockSafeSettings;
    }

    public void setLockSafeSettings(boolean lockSafeSettings) {
        this.lockSafeSettings = lockSafeSettings;
    }

    public boolean isPermissive() {
        return permissive;
    }

    public void setPermissive(boolean permissive) {
        this.permissive = permissive;
    }

    public boolean isKioskExit() {
        return kioskExit;
    }

    public void setKioskExit(boolean kioskExit) {
        this.kioskExit = kioskExit;
    }

    public boolean isDisableScreenshots() {
        return disableScreenshots;
    }

    public void setDisableScreenshots(boolean disableScreenshots) {
        this.disableScreenshots = disableScreenshots;
    }

    public boolean isAutostartForeground() {
        return autostartForeground;
    }

    public void setAutostartForeground(boolean autostartForeground) {
        this.autostartForeground = autostartForeground;
    }

    public boolean isShowWifi() {
        return showWifi;
    }

    public void setShowWifi(boolean showWifi) {
        this.showWifi = showWifi;
    }

    public String getAppName() {
        return appName;
    }

    public void setAppName(String appName) {
        this.appName = appName;
    }

    public String getVendor() {
        return vendor;
    }

    public void setVendor(String vendor) {
        this.vendor = vendor;
    }

    public String getRestrictions() {
        return restrictions;
    }

    public void setRestrictions(String restrictions) {
        this.restrictions = restrictions;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getCustom1() {
        return custom1;
    }

    public void setCustom1(String custom1) {
        this.custom1 = custom1;
    }

    public String getCustom2() {
        return custom2;
    }

    public void setCustom2(String custom2) {
        this.custom2 = custom2;
    }

    public String getCustom3() {
        return custom3;
    }

    public void setCustom3(String custom3) {
        this.custom3 = custom3;
    }

    public List<RemoteFile> getFiles() {
        return files;
    }

    public void setFiles(List<RemoteFile> files) {
        this.files = files;
    }

    public List<Action> getActions() {
        return actions;
    }

    public void setActions(List<Action> actions) {
        this.actions = actions;
    }
}
</file>

<file path="app/src/main/res/values-zh-rCN/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理员</string>
	<string name="install_error">安装错误</string>
	<string name="file_create_error">创建文件错误</string>
	<string name="dialog_enter_device_id_error">该ID未在%s处註册。从控制面板的“设备”标籤中获取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二维码</string>
	<string name="dialog_enter_device_id_variants">变体</string>
	<string name="dialog_enter_device_id_save">储存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s输入设备ID</string>
	<string name="main_start_preparations">準备开始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新数据</string>
	<string name="main_update_applications">安装和更新应用程序</string>
	<string name="dialog_root_message">您需要ROOT权限</string>
	<string name="main_application_start">开始申请</string>
	<string name="main_app_installing">安装应用程序</string>
	<string name="main_app_downloading">下载申请书</string>
	<string name="main_app_downloading_error">无法下载软件包</string>
	<string name="main_app_removing">卸载应用程序</string>
	<string name="main_file_downloading">下载文件</string>
	<string name="main_file_downloading_error">下载文件失败</string>
	<string name="main_activity_repeat">重试</string>
	<string name="main_activity_reset">重启</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">细节</string>
	<string name="select_system_launcher">选择%s作为默认启动器，然後选中“始终”：</string>
	<string name="dialog_network_error_title">连接到%s时出错。请检查互联网连接，然後重试。</string>
	<string name="main_activity_update_config">从服务器请求配置文件</string>
	<string name="main_activity_applications_update">更新应用程序</string>
	<string name="dialog_overlay_settings_title">请允许应用程序在其他窗口上绘制。\n\n此选项有助于更好地阻止不需要的应用程序，并启用自助服务终端模式的紧急解锁。\n\n点按“继续”以打开设置表。 找到 \"%s\" 项目，授予权限，然后点击 \"Back\"。</string>
	<string name="dialog_manage_storage_title">请允许该应用管理存储。\n\n此选项允许 Headwind MDM 管理您设备上的文件。</string>
	<string name="dialog_history_settings_title">请允许该应用访问使用数据。\n\n此选项启用对应用程序和设置的控制。\n\n此选项可能会导致更快的电池消耗。 要节省电池电量，请跳过此选项（改用无障碍服务或信息亭模式）。\n\n点按“继续”以打开设置表。 找到 \"%s\" 项目，授予权限，然后点击 \"Back\"。</string>
	<string name="dialog_history_settings_continue">继续</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">请允许从未知来源进行安装。现在将打开一个设置表。找到“未知来源”，允许安装，然後单击“上一步”。</string>
	<string name="dialog_unknown_sources_continue">继续</string>
	<string name="dialog_miui_permissions_title">MIUI要求手动设置自定义权限。现在将打开“应用程序权限”窗口。轻按\"其他权限\"，允许\"在後台运行时显示弹出窗口\"，然後单击\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手动设置设备。在信息屏幕上，点击TAP 7 TIMES \" BUILD NUMBER \"。这将启用开发人员设置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手动设置设备。开发人员设置窗口现在将打开。向下滚动屏幕，然後取消选中“ MIUI优化”。</string>
	<string name="dialog_administrator_mode_message">请允许该应用在设备管理员模式下运行。现在将打开一个设置表。选择\"设备管理员\"，找到\"%s\"项目，激活（Activate）管理员，然後点击\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">继续</string>
	<string name="dialog_administrator_mode_skip">跳跃</string>
	<string name="accessibility_service_description">通过MDM应用程序进行活动的应用程序监视</string>
	<string name="dialog_accessibility_service_message">请允许该应用使用辅助功能。现在将打开一个设置表。找到\"%s\"项，允许使用辅助功能，然後点击\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">继续</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允许使用以下包裹：</string>
	<string name="access_to_app_denied_2">请请求管理员在配置中启用此程序包。\n\n单击“关闭”或“主页”按钮继续。</string>
	<string name="package_id_copied">包 ID 已复制到剪贴板</string>
	<string name="dialog_app_not_allowed_close">关闭</string>
	<string name="dialog_app_not_allowed_admin">管理员</string>
	<string name="device_id">设备编号</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列号</string>
	<string name="phone_number">电话号码</string>
	<string name="launcher_version">启动器版本</string>
	<string name="close">关闭</string>
	<string name="admin_change_device_id">更改设备ID</string>
	<string name="admin_change_server_url">更改服务器URL</string>
	<string name="admin_allow_settings">打开设置</string>
	<string name="settings_allowed">您可以在3分钟内更改设置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分钟内运行所有应用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系统启动器</string>
	<string name="admin_reset_permissions">检查权限</string>
	<string name="admin_reset_network">重置网络策略</string>
	<string name="admin_reset_network_hint">清除网络策略。现在，您可以启用网络并重新加载配置。</string>
	<string name="reboot">重启设备</string>
	<string name="reboot_failed">没有足够的权限来重新启动设备。</string>
	<string name="message_turn_on_gps">设置屏幕将打开。请在此屏幕上打开GPS位置，然後单击返回。</string>
	<string name="message_turn_off_gps">设置屏幕将打开。请在此屏幕上关闭GPS位置，然後单击返回。</string>
	<string name="message_turn_on_mobile_data">移动数据已禁用！请打开状态栏，然後打开移动数据。</string>
	<string name="message_turn_off_mobile_data">启用了移动数据。请打开状态栏，然後关闭移动数据。</string>
	<string name="message_set_password">您的密码质量不够好。设置屏幕将打开。请更改密码，然後单击“上一步”。</string>
	<string name="switch_off_blockings">关闭限制...</string>
	<string name="kiosk_mode_requires_overlays">单一模式已禁用：没有权限绘製其他窗口。请允许%s在其他窗口上绘製。</string>
	<string name="enter_admin_password">输入管理员密码</string>
	<string name="wrong_password">密码错误</string>
	<string name="dialog_enter_password_login">登录</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">该应用程序遇到内部错误。请重新启动设备，然後重试该操作。</string>
	<string name="empty_configuration">未设置配置，请尝试从服务器获取！</string>
	<string name="permissions_reset_hint">关闭管理面板以检查并请求权限。</string>
	<string name="dialog_enter_server_error">请输入有效的服务器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">请输入服务器网址</string>
	<string name="critical_server_failure">由於服务器故障而退出！请解决此问题，然後重新启动%s，或将其完全删除并重新安装。</string>
	<string name="dialog_permission_title">该应用需要权限才能运行。请授予请求的权限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到浏览器，因此无法打开网页。请在设备配置中添加浏览器应用。</string>
	<string name="invalid_web_link">无法打开 Web 链接，因为它的格式不正确。 有关详细信息，请联系您的管理员。</string>
	<string name="activity_not_found">无法执行操作 %s，因为未找到该活动。</string>
	<string name="location_service_text">设备位置受到监控</string>
	<string name="qrcode_contents_error">无效的QR码内容。请在%s Web面板中生成预配置QR码。</string>
	<string name="device_locked">此设备 (%s) 已被管理员锁定。</string>
	<string name="fault_loop_detected">启动器发生了无法恢复的故障！请与系统管理员联繫。</string>
	<string name="mqtt_service_text">推送通知处于活动状态</string>
	<string name="background_location">%s 需要后台位置权限。 单击\'继续\' 打开权限，单击\'位置\' 并允许始终确定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">继续</string>
	<string name="initializing_mdm">正在初始化移动设备管理应用程序...</string>
	<string name="dialog_server_error_title">MDM 服务器 %s 返回无效响应。 请联系您的管理员。</string>
	<string name="mdm_choice_message">此设备将由您的组织完全管理。 您的数据不会是私密的，您的 IT 管理员可以随时删除或查看您的数据。</string>
	<string name="work_profile_message">此设备将获得属于您的组织的受管理工作配置文件。 工作资料与您的私人资料分开，您可以随时在资料之间切换。</string>
	<string name="overlays_not_supported">不幸的是，您的设备不支持覆盖。</string>
	<string name="admin_not_supported">您的设备没有设备管理员选项。 单击跳过以继续。</string>
	<string name="manage_storage_not_supported">您的设备没有管理外部存储的选项。</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rHK/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理員</string>
	<string name="install_error">安裝錯誤</string>
	<string name="file_create_error">建立文件時出錯</string>
	<string name="dialog_enter_device_id_error">該ID未在%s處註冊。從控制面板的“設備”標籤中獲取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二維碼</string>
	<string name="dialog_enter_device_id_variants">變體</string>
	<string name="dialog_enter_device_id_save">儲存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s輸入設備ID</string>
	<string name="main_start_preparations">準備開始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新數據</string>
	<string name="main_update_applications">安裝和更新應用程序</string>
	<string name="dialog_root_message">您需要ROOT權限</string>
	<string name="main_application_start">開始申請</string>
	<string name="main_app_installing">安裝應用程序</string>
	<string name="main_app_downloading">下載申請書</string>
	<string name="main_app_downloading_error">無法下載軟件包</string>
	<string name="main_app_removing">卸載應用程序</string>
	<string name="main_file_downloading">下載文件</string>
	<string name="main_file_downloading_error">下載文件失敗</string>
	<string name="main_activity_repeat">重試</string>
	<string name="main_activity_reset">重啟</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">細節</string>
	<string name="select_system_launcher">選擇%s作為默認啟動器，然後選中“始終”：</string>
	<string name="dialog_network_error_title">連接到%s時出錯。請檢查互聯網連接，然後重試。</string>
	<string name="main_activity_update_config">從服務器請求配置文件</string>
	<string name="main_activity_applications_update">更新應用程序</string>
	<string name="dialog_overlay_settings_title">請允許應用程序在其他窗口上繪製。\n\n此選項有助於更好地阻止不需要的應用程序，並啟用自助服務終端模式的緊急解鎖。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_manage_storage_title">請允許應用程式管理儲存。\n\n此選項可讓 Headwind MDM 管理您裝置上的檔案。</string>
	<string name="dialog_history_settings_title">請允許該應用訪問使用數據。\n\n此選項啟用對應用程序和設置的控制。\n\n此選項可能會導致更快的電池消耗。 要節省電池電量，請跳過此選項（改用無障礙服務或信息亭模式）。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_history_settings_continue">繼續</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">請允許從未知來源進行安裝。現在將打開一個設置表。找到“未知來源”，允許安裝，然後單擊“上一步”。</string>
	<string name="dialog_unknown_sources_continue">繼續</string>
	<string name="dialog_miui_permissions_title">MIUI要求手動設置自定義權限。現在將打開“應用程序權限”窗口。輕按\"其他權限\"，允許\"在後台運行時顯示彈出窗口\"，然後單擊\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手動設置設備。在信息屏幕上，點擊TAP 7 TIMES \" BUILD NUMBER \"。這將啟用開發人員設置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手動設置設備。開發人員設置窗口現在將打開。向下滾動屏幕，然後取消選中“ MIUI優化”。</string>
	<string name="dialog_administrator_mode_message">請允許該應用在設備管理員模式下運行。現在將打開一個設置表。選擇\"設備管理員\"，找到\"%s\"項目，激活（Activate）管理員，然後點擊\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">繼續</string>
	<string name="dialog_administrator_mode_skip">跳躍</string>
	<string name="accessibility_service_description">通過MDM應用程序進行活動的應用程序監視</string>
	<string name="dialog_accessibility_service_message">請允許該應用使用輔助功能。現在將打開一個設置表。找到\"%s\"項，允許使用輔助功能，然後點擊\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">繼續</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允許使用以下包裹：</string>
	<string name="access_to_app_denied_2">請請求管理員在設定中啟用此程式包。\n\n按一下「關閉」或「首頁」按鈕繼續。</string>
	<string name="package_id_copied">包 ID 已複製到剪貼簿</string>
	<string name="dialog_app_not_allowed_close">關閉</string>
	<string name="dialog_app_not_allowed_admin">管理員</string>
	<string name="device_id">設備編號</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列號</string>
	<string name="phone_number">電話號碼</string>
	<string name="launcher_version">啟動器版本</string>
	<string name="close">關閉</string>
	<string name="admin_change_device_id">更改設備ID</string>
	<string name="admin_change_server_url">更改服務器URL</string>
	<string name="admin_allow_settings">打開設置</string>
	<string name="settings_allowed">您可以在3分鐘內更改設置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分鐘內運行所有應用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系統啟動器</string>
	<string name="admin_reset_permissions">檢查權限</string>
	<string name="admin_reset_network">重置網絡策略</string>
	<string name="admin_reset_network_hint">清除網絡策略。現在，您可以啟用網絡並重新加載配置。</string>
	<string name="reboot">重啟設備</string>
	<string name="reboot_failed">沒有足夠的權限來重新啟動設備。</string>
	<string name="message_turn_on_gps">設置屏幕將打開。請在此屏幕上打開GPS位置，然後單擊返回。</string>
	<string name="message_turn_off_gps">設置屏幕將打開。請在此屏幕上關閉GPS位置，然後單擊返回。</string>
	<string name="message_turn_on_mobile_data">移動數據已禁用！請打開狀態欄，然後打開移動數據。</string>
	<string name="message_turn_off_mobile_data">啟用了移動數據。請打開狀態欄，然後關閉移動數據。</string>
	<string name="message_set_password">您的密碼質量不夠好。設置屏幕將打開。請更改密碼，然後單擊“上一步”。</string>
	<string name="switch_off_blockings">關閉限制...</string>
	<string name="kiosk_mode_requires_overlays">單一模式已禁用：沒有權限繪製其他窗口。請允許%s在其他窗口上繪製。</string>
	<string name="enter_admin_password">輸入管理員密碼</string>
	<string name="wrong_password">密碼錯誤</string>
	<string name="dialog_enter_password_login">登錄</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">該應用程序遇到內部錯誤。請重新啟動設備，然後重試該操作。</string>
	<string name="empty_configuration">未設置配置，請嘗試從服務器獲取！</string>
	<string name="permissions_reset_hint">關閉管理面板以檢查並請求權限。</string>
	<string name="dialog_enter_server_error">請輸入有效的服務器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">請輸入服務器網址</string>
	<string name="critical_server_failure">由於服務器故障而退出！請解決此問題，然後重新啟動%s，或將其完全刪除並重新安裝。</string>
	<string name="dialog_permission_title">該應用需要權限才能運行。請授予請求的權限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到瀏覽器，因此無法打開網頁。請在設備配置中添加瀏覽器應用。</string>
	<string name="invalid_web_link">無法打開 Web 鏈接，因為它的格式不正確。 有關詳細信息，請聯繫您的管理員。</string>
	<string name="activity_not_found">無法執行操作 %s，因為未找到該活動。</string>
	<string name="location_service_text">設備位置受到監控</string>
	<string name="qrcode_contents_error">無效的QR碼內容。請在%s Web面板中生成預配置QR碼。</string>
	<string name="device_locked">此設備 (%s) 已被管理員鎖定。</string>
	<string name="fault_loop_detected">糟糕，啟動器發生了無法恢復的故障！請與系統管理員聯繫。</string>
	<string name="mqtt_service_text">推送通知處於活動狀態</string>
	<string name="background_location">%s 需要後台位置權限。 單擊\'繼續\' 打開權限，單擊\'位置\' 並允許始終確定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">繼續</string>
	<string name="initializing_mdm">正在初始化移動設備管理應用程序...</string>
	<string name="dialog_server_error_title">MDM 服務器 %s 返回無效響應。 請聯繫您的管理員。</string>
	<string name="mdm_choice_message">此設備將由您的組織完全管理。 您的數據不會是私密的，您的 IT 管理員可以隨時刪除或查看您的數據。</string>
	<string name="work_profile_message">此設備將獲得屬於您的組織的受管理工作配置文件。 工作資料與您的私人資料分開，您可以隨時在資料之間切換。</string>
	<string name="overlays_not_supported">不幸的是，您的設備不支持覆蓋。</string>
	<string name="admin_not_supported">您的設備沒有設備管理員選項。 單擊跳過以繼續。</string>
	<string name="manage_storage_not_supported">您的裝置沒有管理外部儲存的選項。</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rTW/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理員</string>
	<string name="install_error">安裝錯誤</string>
	<string name="file_create_error">建立文件時出錯</string>
	<string name="dialog_enter_device_id_error">該ID未在%s處註冊。從控制面板的“設備”標籤中獲取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二維碼</string>
	<string name="dialog_enter_device_id_variants">變體</string>
	<string name="dialog_enter_device_id_save">儲存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s輸入設備ID</string>
	<string name="main_start_preparations">準備開始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新數據</string>
	<string name="main_update_applications">安裝和更新應用程序</string>
	<string name="dialog_root_message">您需要ROOT權限</string>
	<string name="main_application_start">開始申請</string>
	<string name="main_app_installing">安裝應用程序</string>
	<string name="main_app_downloading">下載申請書</string>
	<string name="main_app_downloading_error">無法下載軟件包</string>
	<string name="main_app_removing">卸載應用程序</string>
	<string name="main_file_downloading">下載文件</string>
	<string name="main_file_downloading_error">下載文件失敗</string>
	<string name="main_activity_repeat">重試</string>
	<string name="main_activity_reset">重啟</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">細節</string>
	<string name="select_system_launcher">選擇%s作為默認啟動器，然後選中“始終”：</string>
	<string name="dialog_network_error_title">連接到%s時出錯。請檢查互聯網連接，然後重試。</string>
	<string name="main_activity_update_config">從服務器請求配置文件</string>
	<string name="main_activity_applications_update">更新應用程序</string>
	<string name="dialog_overlay_settings_title">請允許應用程序在其他窗口上繪製。\n\n此選項有助於更好地阻止不需要的應用程序，並啟用自助服務終端模式的緊急解鎖。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_manage_storage_title">請允許應用程式管理儲存。\n\n此選項可讓 Headwind MDM 管理您裝置上的檔案。</string>
	<string name="dialog_history_settings_title">請允許該應用訪問使用數據。\n\n此選項啟用對應用程序和設置的控制。\n\n此選項可能會導致更快的電池消耗。 要節省電池電量，請跳過此選項（改用無障礙服務或信息亭模式）。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_history_settings_continue">繼續</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">請允許從未知來源進行安裝。現在將打開一個設置表。找到“未知來源”，允許安裝，然後單擊“上一步”。</string>
	<string name="dialog_unknown_sources_continue">繼續</string>
	<string name="dialog_miui_permissions_title">MIUI要求手動設置自定義權限。現在將打開“應用程序權限”窗口。輕按\"其他權限\"，允許\"在後台運行時顯示彈出窗口\"，然後單擊\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手動設置設備。在信息屏幕上，點擊TAP 7 TIMES \" BUILD NUMBER \"。這將啟用開發人員設置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手動設置設備。開發人員設置窗口現在將打開。向下滾動屏幕，然後取消選中“ MIUI優化”。</string>
	<string name="dialog_administrator_mode_message">請允許該應用在設備管理員模式下運行。現在將打開一個設置表。選擇\"設備管理員\"，找到\"%s\"項目，激活（Activate）管理員，然後點擊\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">繼續</string>
	<string name="dialog_administrator_mode_skip">跳躍</string>
	<string name="accessibility_service_description">通過MDM應用程序進行活動的應用程序監視</string>
	<string name="dialog_accessibility_service_message">請允許該應用使用輔助功能。現在將打開一個設置表。找到\"%s\"項，允許使用輔助功能，然後點擊\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">繼續</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允許使用以下包裹：</string>
	<string name="access_to_app_denied_2">請請求管理員在設定中啟用此程式包。\n\n按一下「關閉」或「首頁」按鈕繼續。</string>
	<string name="package_id_copied">包 ID 已複製到剪貼簿</string>
	<string name="dialog_app_not_allowed_close">關閉</string>
	<string name="dialog_app_not_allowed_admin">管理員</string>
	<string name="device_id">設備編號</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列號</string>
	<string name="phone_number">電話號碼</string>
	<string name="launcher_version">啟動器版本</string>
	<string name="close">關閉</string>
	<string name="admin_change_device_id">更改設備ID</string>
	<string name="admin_change_server_url">更改服務器URL</string>
	<string name="admin_allow_settings">打開設置</string>
	<string name="settings_allowed">您可以在3分鐘內更改設置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分鐘內運行所有應用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系統啟動器</string>
	<string name="admin_reset_permissions">檢查權限</string>
	<string name="admin_reset_network">重置網絡策略</string>
	<string name="admin_reset_network_hint">清除網絡策略。現在，您可以啟用網絡並重新加載配置。</string>
	<string name="reboot">重啟設備</string>
	<string name="reboot_failed">沒有足夠的權限來重新啟動設備。</string>
	<string name="message_turn_on_gps">設置屏幕將打開。請在此屏幕上打開GPS位置，然後單擊返回。</string>
	<string name="message_turn_off_gps">設置屏幕將打開。請在此屏幕上關閉GPS位置，然後單擊返回。</string>
	<string name="message_turn_on_mobile_data">移動數據已禁用！請打開狀態欄，然後打開移動數據。</string>
	<string name="message_turn_off_mobile_data">啟用了移動數據。請打開狀態欄，然後關閉移動數據。</string>
	<string name="message_set_password">您的密碼質量不夠好。設置屏幕將打開。請更改密碼，然後單擊“上一步”。</string>
	<string name="switch_off_blockings">關閉限制...</string>
	<string name="kiosk_mode_requires_overlays">單一模式已禁用：沒有權限繪製其他窗口。請允許%s在其他窗口上繪製。</string>
	<string name="enter_admin_password">輸入管理員密碼</string>
	<string name="wrong_password">密碼錯誤</string>
	<string name="dialog_enter_password_login">登錄</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">該應用程序遇到內部錯誤。請重新啟動設備，然後重試該操作。</string>
	<string name="empty_configuration">未設置配置，請嘗試從服務器獲取！</string>
	<string name="permissions_reset_hint">關閉管理面板以檢查並請求權限。</string>
	<string name="dialog_enter_server_error">請輸入有效的服務器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">請輸入服務器網址</string>
	<string name="critical_server_failure">由於服務器故障而退出！請解決此問題，然後重新啟動%s，或將其完全刪除並重新安裝。</string>
	<string name="dialog_permission_title">該應用需要權限才能運行。請授予請求的權限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到瀏覽器，因此無法打開網頁。請在設備配置中添加瀏覽器應用。</string>
	<string name="invalid_web_link">無法打開 Web 鏈接，因為它的格式不正確。 有關詳細信息，請聯繫您的管理員。</string>
	<string name="activity_not_found">無法執行操作 %s，因為未找到該活動。</string>
	<string name="location_service_text">設備位置受到監控</string>
	<string name="qrcode_contents_error">無效的QR碼內容。請在%s Web面板中生成預配置QR碼。</string>
	<string name="device_locked">此設備 (%s) 已被管理員鎖定。</string>
	<string name="fault_loop_detected">糟糕，啟動器發生了無法恢復的故障！請與系統管理員聯繫。</string>
	<string name="mqtt_service_text">推送通知處於活動狀態</string>
	<string name="background_location">%s 需要後台位置權限。 單擊\'繼續\' 打開權限，單擊\'位置\' 並允許始終確定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">繼續</string>
	<string name="initializing_mdm">正在初始化移動設備管理應用程序...</string>
	<string name="dialog_server_error_title">MDM 服務器 %s 返回無效響應。 請聯繫您的管理員。</string>
	<string name="mdm_choice_message">此設備將由您的組織完全管理。 您的數據不會是私密的，您的 IT 管理員可以隨時刪除或查看您的數據。</string>
	<string name="work_profile_message">此設備將獲得屬於您的組織的受管理工作配置文件。 工作資料與您的私人資料分開，您可以隨時在資料之間切換。</string>
	<string name="overlays_not_supported">不幸的是，您的設備不支持覆蓋。</string>
	<string name="admin_not_supported">您的設備沒有設備管理員選項。 單擊跳過以繼續。</string>
	<string name="manage_storage_not_supported">您的裝置沒有管理外部儲存的選項。</string>
</resources>
</file>

<file path="app/src/main/res/values-ar/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">مسؤول</string>
    <string name="install_error">خطأ في التثبيت</string>
    <string name="file_create_error">خطأ في إنشاء الملف</string>
    <string name="dialog_enter_device_id_error">هذا ID غير مسجل في %s. احصل على ID من علامة التبويب \"الأجهزة\" بلوحة التحكم.</string>
    <string name="dialog_enter_device_id_qrcode">QR رمز</string>
    <string name="dialog_enter_device_id_variants">المتغيرات</string>
    <string name="dialog_enter_device_id_save">حفظ</string>
    <string name="dialog_enter_device_id_exit">خروج</string>
    <string name="dialog_enter_device_id_title">أدخل ID الجهاز في %s</string>
    <string name="main_start_preparations">تستعد للبدء</string>
    <string name="main_downloading_configuration">تحديث ملف الاعدادات</string>
    <string name="main_downloading_content">تحديث البيانات</string>
    <string name="main_update_applications">تثبيت وتحديث التطبيقات</string>
    <string name="dialog_root_message">أنت بحاجة إلى الوصول إلى ROOT</string>
    <string name="main_application_start">بدء التطبيق</string>
    <string name="main_app_installing">تثبيت التطبيق</string>
    <string name="main_app_downloading">تحميل التطبيق</string>
    <string name="main_app_downloading_error">فشل تحميل الحزمة</string>
    <string name="main_app_removing">إلغاء تثبيت التطبيق</string>
    <string name="main_activity_repeat">أعد المحاولة</string>
    <string name="main_activity_reset">إعادة تعيين</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">إلغاء</string>
    <string name="main_activity_details">تفاصيل</string>
    <string name="select_system_launcher">حدد %s كمشغل افتراضي وحدد \"دائمًا\":</string>
    <string name="dialog_network_error_title">خطأ في الاتصال بالخادم %s. يرجى التحقق من الاتصال بالإنترنت وحاول مرة أخرى.</string>
    <string name="main_activity_update_config">طلب ملف الاعدادات من الخادم</string>
    <string name="main_activity_applications_update">تحديث التطبيقات</string>
    <string name="dialog_overlay_settings_title">يرجى السماح للتطبيق بالرسم فوق النوافذ الأخرى.\n\nيساعد هذا الخيار في حظر التطبيقات غير المرغوب فيها بشكل أفضل ، ويتيح فتح وضع الكشك في حالات الطوارئ.\n\nانقر فوق متابعة لفتح ورقة الإعدادات. ابحث عن عنصر %s ، وامنح الإذن ، ثم انقر فوق رجوع.</string>
    <string name="dialog_manage_storage_title">يرجى السماح للتطبيق بإدارة التخزين.\n\n يسمح هذا الخيار لتطبيق Headwind MDM بإدارة الملفات على جهازك.</string>
    <string name="dialog_history_settings_title">يرجى السماح للتطبيق بالوصول إلى بيانات الاستخدام.\n\n يتيح هذا الخيار التحكم في التطبيقات والإعدادات.\n\nقد يتسبب هذا الخيار في استنزاف أسرع للبطارية. لحفظ البطارية ، تخطي هذا الخيار (استخدم خدمات إمكانية الوصول أو وضع الكشك بدلاً من ذلك).\n\nانقر فوق متابعة لفتح ورقة الإعدادات. ابحث عن عنصر %s ، وامنح الإذن ، ثم انقر فوق رجوع.\n\n</string>
    <string name="dialog_history_settings_continue">استمر</string>
    <string name="dialog_history_settings_skip">تخطى</string>
    <string name="dialog_unknown_sources_title">الرجاء السماح بالتثبيت من مصادر غير معروفة. سيتم الآن فتح ورقة الإعدادات. ابحث عن \"مصادر غير معروفة\" ، واسمح بالتثبيت وانقر على \"رجوع\".</string>
    <string name="dialog_unknown_sources_continue">استمر</string>
    <string name="dialog_miui_permissions_title">تتطلب MIUI الإعداد اليدوي للأذونات المخصصة. سيتم فتح نافذة أذونات التطبيق الآن. انقر على \"أذونات أخرى\" ، واسمح ب \"عرض النوافذ المنبثقة أثناء التشغيل في الخلفية\" وانقر على \"رجوع\".</string>
    <string name="dialog_administrator_mode_message">يرجى السماح للتطبيق بالعمل في وضع مشرف الجهاز. سيتم فتح ورقة الإعدادات الآن. حدد \"مشرفو الأجهزة\" ، وابحث عن عنصر \"%s\" ، وقم بتنشيط المشرف ، ثم انقر فوق \"رجوع\".</string>
    <string name="dialog_administrator_mode_continue">استمر</string>
    <string name="dialog_administrator_mode_skip">تخطى</string>
    <string name="accessibility_service_description">مراقبة نشطة للتطبيق بواسطة تطبيق MDM</string>
    <string name="dialog_accessibility_service_message">يرجى السماح للتطبيق باستخدام خدمات إمكانية الوصول. سيتم فتح ورقة الإعدادات الآن. ابحث عن عنصر \"%s\" ، واسمح باستخدام خدمات إمكانية الوصول ، وانقر على \"رجوع\".</string>
    <string name="dialog_accessibility_service_continue">استمر</string>
    <string name="dialog_accessibility_service_skip">تخطى</string>
    <string name="access_to_app_denied">الحزمة غير مسموح بها:</string>
    <string name="access_to_app_denied_2">الرجاء مطالبة المسؤول بتمكين هذه الحزمة في التكوين.\n\nانقر فوق \'إغلاق\' أو زر الصفحة الرئيسية للمتابعة.</string>
    <string name="package_id_copied">يتم نسخ معرف الحزمة إلى الحافظة</string>
    <string name="dialog_app_not_allowed_close">أغلق</string>
    <string name="dialog_app_not_allowed_admin">مسؤول</string>
    <string name="device_id">ID الجهاز</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">رقم متسلسل</string>
    <string name="phone_number">رقم الهاتف</string>
    <string name="launcher_version">نسخة مشغل</string>
    <string name="close">أغلق</string>
    <string name="admin_change_device_id">تغيير ID الجهاز</string>
    <string name="admin_change_server_url">تغيير عنوان URL للخادم</string>
    <string name="admin_allow_settings">أفتح الإعدادات</string>
    <string name="settings_allowed">يُسمح لك بتغيير الإعدادات في غضون 3 دقائق.</string>
    <string name="admin_clear_restrictions">قيود واضحة</string>
    <string name="permissive_mode_enabled">يُسمح لك بتشغيل جميع التطبيقات في غضون 3 دقائق.</string>
    <string name="admin_refresh">تحديث التكوين</string>
    <string name="admin_exit">الخروج إلى مشغل النظام</string>
    <string name="admin_reset_permissions">تحقق من الأذونات</string>
    <string name="admin_reset_network">إعادة تعيين سياسة الشبكة</string>
    <string name="admin_reset_network_hint">تم مسح سياسات الشبكة. يمكنك الآن تمكين الشبكة وإعادة تحميل التكوين.</string>
    <string name="reboot">"    جهاز إعادة التشغيل "</string>
    <string name="reboot_failed">لا توجد حقوق كافية لإعادة تشغيل الجهاز.</string>
    <string name="message_turn_on_gps">ستفتح شاشة الإعدادات. يرجى تشغيل موقع GPS على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="message_turn_off_gps">ستفتح شاشة الإعدادات. يرجى إيقاف تشغيل موقع GPS على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="message_turn_on_mobile_data">ستفتح شاشة الإعدادات. الرجاء تشغيل بيانات الجوال على هذه الشاشة والنقر فوق \"رجوع\".</string>
    <string name="message_turn_off_mobile_data">ستفتح شاشة الإعدادات. يرجى إيقاف تشغيل بيانات الجوال على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="switch_off_blockings">جارٍ إطفاء القيود ...</string>
    <string name="kiosk_mode_requires_overlays">تم تعطيل وضع Kiosk: لا يوجد إذن للرسم فوق النوافذ الأخرى. يُرجى السماح لـ %s بالرسم فوق النوافذ الأخرى.</string>
    <string name="enter_admin_password">أدخل كلمة مرور المسؤول</string>
    <string name="wrong_password">كلمة مرور خاطئة</string>
    <string name="dialog_enter_password_login">تسجيل الدخول</string>
    <string name="dialog_enter_password_cancel">إلغاء</string>
    <string name="internal_error">واجه التطبيق خطأ داخليًا. يرجى إعادة تشغيل الجهاز وإعادة محاولة الإجراء.</string>
    <string name="empty_configuration">لم يتم تعيين الاعدادات ، إعادة محاولة الحصول عليه من الخادم!</string>
    <string name="permissions_reset_hint">أغلق لوحة الإدارة للتحقق وطلب الأذونات.</string>
    <string name="dialog_enter_server_error">الرجاء إدخال عنوان URL صالح للخادم.</string>
    <string name="dialog_enter_server_ok">حسنا</string>
    <string name="dialog_enter_server_title">يرجى إدخال عنوان URL للخادم</string>
    <string name="critical_server_failure">خروج بسبب خطأ في الخادم! يُرجى إصلاح المشكلة وإعادة تشغيل برنامج %s ، أو إزالته تمامًا وإعادة التثبيت.</string>
    <string name="dialog_permission_title">يتطلب التطبيق أذونات للتشغيل. يرجى منح الأذونات المطلوبة.</string>
    <string name="main_activity_exit">خروج</string>
    <string name="browser_not_found">لا يمكن فتح صفحة الويب لأن المستعرض غير موجود. الرجاء إضافة تطبيق متصفح إلى اعدادات الجهاز.</string>
    <string name="invalid_web_link">لا يمكن فتح رابط الويب لأنه غير منسق بشكل جيد. يرجى الاتصال بالمسؤول للحصول على التفاصيل.</string>
    <string name="activity_not_found">لا يمكن تنفيذ الإجراء %s لأنه لم يتم العثور على النشاط.</string>
    <string name="location_service_text">يتم مراقبة موقع الجهاز</string>
    <string name="qrcode_contents_error">محتويات رمز QR غير صالحة. يرجى إنشاء رمز الاستجابة السريعة التوفير في لوحة الويب %s.</string>
    <string name="main_file_downloading">تحميل الملف</string>
    <string name="main_file_downloading_error">فشل تحميل الملف</string>
    <string name="message_set_password">جودة كلمة المرور الخاصة بك غير كافية. ستفتح شاشة الإعدادات الآن. يرجى تغيير كلمة المرور الخاصة بك والنقر فوق \"رجوع\".</string>
    <string name="device_locked">تم قفل هذا الجهاز (%s) من قبل المسؤول.</string>
    <string name="fault_loop_detected">المشغل معطل ولا يمكن استعادته! الرجاء الإبلاغ عن هذه المشكلة إلى المسؤول.</string>
    <string name="dialog_miui_optimization_title">يتطلب MIUI التكوين اليدوي. سيتم الآن فتح شاشة إعدادات المطور. قم بالتمرير لأسفل الشاشة وإيقاف تشغيل علامة \"MIUI التحسين\".</string>
    <string name="dialog_miui_developer_title">يتطلب MIUI الاعدادات اليدوي. ستفتح الشاشة الآن ، اضغط على 7 مرات على \"رقم التجميع\". سيؤدي هذا إلى فتح إعدادات المطور.</string>
    <string name="mqtt_service_text">التنبيهات الفورية نشطة</string>
    <string name="background_location">يتطلب %s إذن موقع الخلفية. انقر فوق \"متابعة\" لفتح الأذونات ، وانقر فوق \"الموقع\" واسمح بتحديد الموقع دائمًا.</string>
    <string name="location_disable">تعطيل الموقع</string>
    <string name="background_location_continue">يكمل</string>
    <string name="initializing_mdm">جاري تهيئة تطبيق إدارة الجهاز المحمول ...</string>
    <string name="dialog_server_error_title">أرجع خادم MDM%s استجابة غير صالحة. الرجاء الاتصال بالمسؤول الخاص بك.</string>
    <string name="mdm_choice_message">ستتم إدارة هذا الجهاز بالكامل بواسطة مؤسستك. لن تكون بياناتك خاصة ويمكن مسحها أو مراجعتها بواسطة مسؤول تكنولوجيا المعلومات في أي وقت.</string>
    <string name="work_profile_message">سيحصل هذا الجهاز على ملف شخصي للعمل مُدار ينتمي إلى مؤسستك. يتم فصل الملف الشخصي للعمل عن ملفك الشخصي الخاص ويمكنك التبديل بين الملفات الشخصية في أي وقت.</string>
    <string name="overlays_not_supported">للأسف لا يدعم جهازك التراكبات.</string>
    <string name="admin_not_supported">جهازك ليس لديه خيار مسؤول الجهاز. انقر فوق تخطي للمتابعة.</string>
    <string name="manage_storage_not_supported">لا يتوفر لجهازك خيار لإدارة وحدة التخزين الخارجية.</string>
</resources>
</file>

<file path="app/src/main/res/values-es/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrador</string>
    <string name="install_error">Error instalando </string>
    <string name="file_create_error">Error al crear el archivo</string>
    <string name="dialog_enter_device_id_error">Esta ID no esta registrada en %s. Verifica la ID en la pestaña  \"Dispositivos\" del panel de control.</string>
    <string name="dialog_enter_device_id_qrcode">Codigo QR</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Guardar</string>
    <string name="dialog_enter_device_id_exit">Salir</string>
    <string name="dialog_enter_device_id_title">Ingresa la ID del dispositivo en %s</string>
    <string name="main_start_preparations">Preprarando para iniciar</string>
    <string name="main_downloading_configuration">Actualizando archivo de configuracion</string>
    <string name="main_downloading_content">Actualizando datos</string>
    <string name="main_update_applications">Instalando y actualizando aplicaciones</string>
    <string name="dialog_root_message">Usted necesita acceso ROOT</string>
    <string name="main_application_start">Iniciando aplicacion</string>
    <string name="main_app_installing">Instalando Aplicacion</string>
    <string name="main_app_downloading">Descargando aplicacion</string>
    <string name="main_app_downloading_error">Fallo la descarga del paquete</string>
    <string name="main_app_removing">Desinstalando aplicacion</string>
    <string name="main_file_downloading">Descargando archivo</string>
    <string name="main_file_downloading_error">Fallo la descarga del archivo</string>
    <string name="main_activity_repeat">Reintentar</string>
    <string name="main_activity_reset">Limpiar</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancelar</string>
    <string name="main_activity_details">Detalles</string>
    <string name="select_system_launcher">Seleccione %s como launcher por defecto y seleccione \'Siempre\':</string>
    <string name="dialog_network_error_title">Error conectando a %s. Por favor, verifique la coneccion a Internet y reintente.</string>
    <string name="main_activity_update_config">Solicitando archivo de configuracion desde el servidor</string>
    <string name="main_activity_applications_update">Actualizando aplicaciones</string>
    <string name="dialog_overlay_settings_title">Permita que la aplicación se dibuje sobre otras ventanas.\n\nEsta opción ayuda a bloquear mejor las aplicaciones no deseadas y habilita el desbloqueo de emergencia del modo quiosco.\n\nToca \"Continuar\" para abrir una hoja de configuración. Busque el elemento \"%s\", conceda el permiso y toque \"Atrás\".</string>
    <string name="dialog_manage_storage_title">Permita que la aplicación administre el almacenamiento.\n\nEsta opción permite que Headwind MDM administre archivos en su dispositivo.</string>
    <string name="dialog_history_settings_title">Permita que la aplicación acceda a los datos de uso.\n\nEsta opción habilita el control de aplicaciones y configuraciones.\n\nEsta opción puede hacer que la batería se agote más rápido. Para ahorrar batería, omita esta opción (utilice los servicios de accesibilidad o el modo quiosco).\n\nToca \"Continuar\" para abrir una hoja de configuración. Busque el elemento \"%s\", conceda el permiso y toque \"Atrás\".</string>
    <string name="dialog_history_settings_continue">Continuar</string>
    <string name="dialog_history_settings_skip">Omitir</string>
    <string name="dialog_unknown_sources_title">Por favor, permita la instalacion desde fuentes desconocidas. La pantalla de configuracion sera abierta ahora. Encuentre la opcion \"Fuentes Desconocidas\", permita la instalacion y presione \"Atras\".</string>
    <string name="dialog_unknown_sources_continue">Continuar</string>
    <string name="dialog_miui_permissions_title">MIUI requiere la configruacion manual de otros permisos. La pantalla de configuracion sera abierta ahora. Presione \"Otros permisos\", permita \"Mostrar ventanas emergentes ejecutandose en segundo plano\" y presione \"Atras\".</string>
    <string name="dialog_miui_developer_title">MIUI requiere la configruacion manual de otros permisos. En la pantalla de informacion, PRESIONE 7 VECES EN \"NUMERO DE COMPILACION\". Esto habilitara las opciones de desarrollador.</string>
    <string name="dialog_miui_optimization_title">MIUI requiere la configruacion manual de otros permisos. La pantalla de configuracion de desarrollador sera abierta ahora. Baje hacia abajo y destilde \"Optimizacion MIUI\".</string>
    <string name="dialog_administrator_mode_message">Por favor, permita a la aplicacion trabajar en modo Administrador. La pantalla de configuracion sera abierta ahora. Seleccione \"Administrador de Dispositivo\", encuentre la opcion \"%s\", active los permisos de administrador y presione \"Atras\".</string>
    <string name="dialog_administrator_mode_continue">Continuar</string>
    <string name="dialog_administrator_mode_skip">Omitir</string>
    <string name="accessibility_service_description">Monitoreo activo por la aplicación MDM</string>
    <string name="dialog_accessibility_service_message">Por favor, permita a la aplicacion trabajar con opciones de accesibilidad. La pantalla de configuracion sera abierta ahora. Encuentre la opcion \"%s\", permita el uso de servicios de accesibilidad, and presione \"Atras\".</string>
    <string name="dialog_accessibility_service_continue">Continuar</string>
    <string name="dialog_accessibility_service_skip">Omitir</string>
    <string name="access_to_app_denied">El paquete no está permitido:</string>
    <string name="access_to_app_denied_2">Pídale a su administrador que habilite este paquete en la configuración.\n\nHaga clic en el botón \'Cerrar\' o Inicio para continuar.</string>
    <string name="package_id_copied">El ID del paquete se copia al portapapeles.</string>
    <string name="dialog_app_not_allowed_close">Cerrar</string>
    <string name="dialog_app_not_allowed_admin">Administrador</string>
    <string name="device_id">ID Dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numero de Serie</string>
    <string name="phone_number">Numero de Telefono</string>
    <string name="launcher_version">Version Launcher</string>
    <string name="close">Cerrar</string>
    <string name="admin_change_device_id">Cambiar ID Dispositivo</string>
    <string name="admin_change_server_url">Cambiar URL Servidor</string>
    <string name="admin_allow_settings">Abrir Configuracion</string>
    <string name="settings_allowed">Usted esta autorizado a cambiar la configuracion por 3 minutos.</string>
    <string name="admin_clear_restrictions">Eliminar restricciones</string>
    <string name="permissive_mode_enabled">Puede ejecutar todas las aplicaciones en 3 minutos.</string>
    <string name="admin_refresh">Actualizar configuracion</string>
    <string name="admin_exit">Salir al Inicio</string>
    <string name="admin_reset_permissions">Verificar permisos</string>
    <string name="admin_reset_network">Restablecer la política de red</string>
    <string name="admin_reset_network_hint">Se borran las políticas de red. Ahora puede habilitar la red y volver a cargar la configuración.</string>
    <string name="reboot">Reiniciar Dispositivo</string>
    <string name="reboot_failed">No posee suficientes permisos para reiniciar el dispositivo.</string>
    <string name="message_turn_on_gps">La pantalla de configuracion se abrira ahora. Por favor, habilite la localizacion por GPS y presione Atras.</string>
    <string name="message_turn_off_gps">La pantalla de configuracion se abrira ahora. Por favor, deshabilite la localizacion por GPS y presione Atras.</string>
    <string name="message_turn_on_mobile_data">Los datos moviles estan desactivados! Por favor, abra la barra de estado y habilite los mismos.</string>
    <string name="message_turn_off_mobile_data">Mobile data are enabled. Por favor, abra la barra de estado y deshabilite los mismos.</string>
    <string name="message_set_password">Tu contraseña no es suficientemente segura. La pantalla de configuracion se abrira ahora. Por favor, cambie la contraseña y presione Atras.</string>
    <string name="switch_off_blockings">Deshabilitando restricciones...</string>
    <string name="kiosk_mode_requires_overlays">Modo Kiosk deshabilitado: no se encontro permiso para sobreponerse a otras ventanas. Por favor, permita a %s sobreponerse a ventanas.</string>
    <string name="enter_admin_password">Ingrese la contraseña de Administrador</string>
    <string name="wrong_password">Contraseña invalida.</string>
    <string name="dialog_enter_password_login">Ingresar</string>
    <string name="dialog_enter_password_cancel">Cancelar</string>
    <string name="internal_error">La aplicacion encontro un error interno. Por favor, reincie el dispositivo y reintente esta accion.</string>
    <string name="empty_configuration">La configuracion no pudo ser descargada, reintentando descargarla del servidor.</string>
    <string name="permissions_reset_hint">Cierre el panel de administrador para verificar los permisos.</string>
    <string name="dialog_enter_server_error">Por favor, ingrese una URL valida.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Por favor, ingrese la URL del servidor</string>
    <string name="critical_server_failure">¡El servidor ha presentando una falla! Por favor, solucione el problema y reinicie %s, o realice una nueva instalacion.</string>
    <string name="dialog_permission_title">La aplicacion requiere permisos para ejecutarse. Por favor, conceda los permisos solicitados.</string>
    <string name="main_activity_exit">Salir</string>
    <string name="browser_not_found">No se pudo abrir la pagina web porque no se encontro el explorador web. Por favor, añada un explorador web a la configuracion del dispositivo.</string>
    <string name="invalid_web_link">No se puede abrir el enlace web porque no está bien formado. Póngase en contacto con su administrador para obtener más información.</string>
    <string name="activity_not_found">No se puede realizar la acción %s porque no se encuentra la actividad.</string>
    <string name="location_service_text">La localizacion del dispositivo esta siendo monitoreada</string>
    <string name="qrcode_contents_error">Codigo QR invalido. Por favor, genere un nuevo QR desde el panel de administrador de %s.</string>
    <string name="device_locked">Este dispositivo (%s) ha sido bloqueado por el administrador.</string>
    <string name="fault_loop_detected">Lo sentimos, la aplicacion encontro un error inrecuperable. Por favor, contacte con su administrador de sistemas.</string>
    <string name="mqtt_service_text">Las notificaciones push están activas</string>
    <string name="background_location">%s requiere el permiso de ubicación en segundo plano. Haga clic en \'Continuar\' para abrir los permisos, haga clic en \'Ubicación\' y permita determinar la ubicación siempre.</string>
    <string name="location_disable">Deshabilitar ubicación</string>
    <string name="background_location_continue">Continuar</string>
    <string name="initializing_mdm">Inicialización de la aplicación de gestión de dispositivos móviles ...</string>
    <string name="dialog_server_error_title">El servidor MDM %s devolvió una respuesta no válida. Comuníquese con su administrador.</string>
    <string name="mdm_choice_message">Este dispositivo será completamente administrado por su organización. Sus datos no serán privados y su administrador de TI puede borrarlos o revisarlos en cualquier momento.</string>
    <string name="work_profile_message">Este dispositivo obtendrá un perfil de trabajo administrado que pertenece a su organización. El perfil de trabajo está separado de su perfil privado y puede cambiar de perfil en cualquier momento.</string>
    <string name="overlays_not_supported">Lamentablemente, las superposiciones no son compatibles con su dispositivo.</string>
    <string name="admin_not_supported">Su dispositivo no tiene ninguna opción de administrador de dispositivos. Haga clic en Omitir para continuar.</string>
    <string name="manage_storage_not_supported">Su dispositivo no tiene ninguna opción para administrar el almacenamiento externo.</string>
</resources>
</file>

<file path="app/src/main/res/values-fr/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrateur</string>
    <string name="install_error">Erreur lors de l\'installation</string>
    <string name="file_create_error">Erreur lors de la création du fichier</string>
    <string name="dialog_enter_device_id_error">Ce ID n\'est pas enregistrée au %s. Obtenez ID dans \'onglet \"Appareils\" du panneau de contrôle.</string>
    <string name="dialog_enter_device_id_qrcode">Code QR</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Sauvegarder</string>
    <string name="dialog_enter_device_id_exit">Sortir</string>
    <string name="dialog_enter_device_id_title">Entrer ID de l\'appareil à %s</string>
    <string name="main_start_preparations">Préparation du démarrage</string>
    <string name="main_downloading_configuration">Mise à jour du fichier de configuration</string>
    <string name="main_downloading_content">Mise à jour des données</string>
    <string name="main_update_applications">Installation et mise à jour des applications</string>
    <string name="dialog_root_message">Vous avez besoin d\'un accès ROOT</string>
    <string name="main_application_start">Démarrage de l\'application</string>
    <string name="main_app_installing">Installation de l\'application</string>
    <string name="main_app_downloading">Téléchargement de l\'application</string>
    <string name="main_app_downloading_error">Echec du téléchargement du package</string>
    <string name="main_app_removing">Désinstallation de l\'application</string>
    <string name="main_file_downloading">Téléchargement du fichier</string>
    <string name="main_file_downloading_error">Echec du téléchargement du fichier</string>
    <string name="main_activity_repeat">Recommencez</string>
    <string name="main_activity_reset">Effacer</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Annuler</string>
    <string name="main_activity_details">Détails</string>
    <string name="select_system_launcher">Choisissez %s comme lanceur par défaut et vérifiez \"Toujours\":</string>
    <string name="dialog_network_error_title">Erreur de connexion au serveur %s. Veuillez vérifier la connexion Internet et réessayer.</string>
    <string name="main_activity_update_config">Demander le fichier de configuration au serveur</string>
    <string name="main_activity_applications_update">Mise à jour des applications</string>
    <string name="dialog_overlay_settings_title">Veuillez autoriser l\'app à dessiner sur d\'autres fenêtres.\n\nCette option permet de mieux bloquer les applications indésirables et permet le déverrouillage d\'urgence du mode kiosque.\n\nAppuyez sur \"Continuer\" pour ouvrir une feuille de paramètres. Recherchez l\'élément \"%s\", accordez l\'autorisation et appuyez sur \"Retour\".</string>
    <string name="dialog_manage_storage_title">Veuillez autoriser l\'app à gérer le stockage.\n\nCette option permet à Headwind MDM de gérer les fichiers sur votre appareil.</string>
    <string name="dialog_history_settings_title">Veuillez autoriser l\'app à accéder aux données d\'utilisation.\n\nCette option permet de contrôler les apps et les paramètres.\n\nCette option peut entraîner une décharge plus rapide de la batterie. Pour économiser la batterie, ignorez cette option (utilisez plutôt les services d\'accessibilité ou le mode kiosque).\n\nAppuyez sur \"Continuer\" pour ouvrir une feuille de paramètres. Recherchez l\'élément \"%s\", accordez l\'autorisation et appuyez sur \"Retour\".</string>
    <string name="dialog_history_settings_continue">Continuer</string>
    <string name="dialog_history_settings_skip">Passer</string>
    <string name="dialog_unknown_sources_title">Veuillez autoriser l\'installation à partir de sources inconnues. Une fiche de paramètres s\'ouvrira. Trouvez \"Sources inconnues\", autorisez l\'installation et cliquez sur \"Retour\".</string>
    <string name="dialog_unknown_sources_continue">Continuer</string>
    <string name="dialog_miui_permissions_title">MIUI nécessite une configuration manuelle des autorisations personnalisées. La fenêtre des autorisations de l\'app s\'ouvrira. Appuyez sur \"Autres autorisations\", autorisez \"Afficher les fenêtres pop-up lors de l\'exécution en arrière-plan\" et cliquez sur \"Retour\".</string>
    <string name="dialog_miui_developer_title">MIUI nécessite une configuration manuelle de votre appareil. Sur l\'écran d\'informations, TAP 7 FOIS SUR \"NUMÉRO DE CONSTRUCTION\". Cela activera les paramètres du développeur.</string>
    <string name="dialog_miui_optimization_title">MIUI nécessite une configuration manuelle de votre appareil. La fenêtre des paramètres du développeur va maintenant s\'ouvrir. Faites défiler l\'écran vers le bas et décochez \"Optimisation MIUI\".</string>
    <string name="dialog_administrator_mode_message">Veuillez autoriser l\'app à fonctionner en mode administrateur de l\'appareil. Une fiche de paramètres s\'ouvrira. Sélectionnez \"Administrateurs de l\'appareil\", recherchez l\'élément \"%s\", activez l\'administrateur et appuyez sur \"Retour\".</string>
    <string name="dialog_administrator_mode_continue">Continuer</string>
    <string name="dialog_administrator_mode_skip">Passer</string>
    <string name="accessibility_service_description">Surveillance active des apps par l\'application MDM</string>
    <string name="dialog_accessibility_service_message">Veuillez autoriser \'app à utiliser les services d\'accessibilité. Une fiche de paramètres s\'ouvrira. Trouvez l\'élément \"%s\", autorisez l\'utilisation des services d\'accessibilité, et appuyez sur \"Retour\".</string>
    <string name="dialog_accessibility_service_continue">Continuer</string>
    <string name="dialog_accessibility_service_skip">Passer</string>
    <string name="access_to_app_denied">Le colis n\'est pas autorisé:</string>
    <string name="access_to_app_denied_2">Veuillez demander à votre administrateur d\'activer ce package dans la configuration.\n\nCliquez sur \'Fermer\' ou sur le bouton Accueil pour continuer.</string>
    <string name="package_id_copied">L\'ID du package est copié dans le presse-papiers</string>
    <string name="dialog_app_not_allowed_close">Fermer</string>
    <string name="dialog_app_not_allowed_admin">Administrateur</string>
    <string name="device_id">ID de l\'appareil</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numéro de série</string>
    <string name="phone_number">Numéro de téléphone</string>
    <string name="launcher_version">Version du lanceur</string>
    <string name="close">Fermer</string>
    <string name="admin_change_device_id">Changer l\'ID de l\'appareil</string>
    <string name="admin_change_server_url">Changer URL du serveur</string>
    <string name="admin_allow_settings">Ouvrir les paramètres</string>
    <string name="settings_allowed">Vous avez 3 minutes pour modifier les paramètres.</string>
    <string name="admin_clear_restrictions">Supprimer les restrictions</string>
    <string name="permissive_mode_enabled">Vous êtes autorisé à exécuter toutes les applications dans les 3 minutes.</string>
    <string name="admin_refresh">Actualiser la configuration</string>
    <string name="admin_exit">Quitter vers le lanceur de système</string>
    <string name="admin_reset_permissions">Vérifier les autorisations</string>
    <string name="admin_reset_network">Effacer la politique de réseau</string>
    <string name="admin_reset_network_hint">Les stratégies réseau sont effacées. Vous pouvez maintenant activer le réseau et recharger la configuration.</string>
    <string name="reboot">Redémarrer l\'appareil</string>
    <string name="reboot_failed">Pas assez de droits pour redémarrer l\'appareil.</string>
    <string name="message_turn_on_gps">L\'écran des paramètres s\'ouvre. Veuillez activer la localisation GPS sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_off_gps">L\'écran des paramètres s\'ouvre. Veuillez DÉSACTIVER la localisation GPS sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_on_mobile_data">L\'écran des paramètres s\'ouvre. Veuillez activer les données mobiles sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_off_mobile_data">L\'écran des paramètres s\'ouvre. Veuillez désactiver les données mobiles sur cet écran et cliquez sur Retour.</string>
    <string name="message_set_password">La qualité de votre mot de passe n\'est pas suffisante. L\'écran des paramètres s\'ouvre. Veuillez changer le mot de passe et cliquez sur Retour.</string>
    <string name="switch_off_blockings">Désactiver les restrictions...</string>
    <string name="kiosk_mode_requires_overlays">Mode kiosk désactivé : pas de permission pour passer par-dessus d\'autres fenêtres. Veuillez permettre à %s de passer par-dessus d\'autres fenêtres.</string>
    <string name="enter_admin_password">Entrez le mot de passe administrateur</string>
    <string name="wrong_password">Mauvais mot de passe</string>
    <string name="dialog_enter_password_login">S\'identifier</string>
    <string name="dialog_enter_password_cancel">Annuler</string>
    <string name="internal_error">L\'app a rencontré une erreur interne. Veuillez redémarrer l\'appareil et réessayer l\'action.</string>
    <string name="empty_configuration">La configuration n\'est pas définie, essayant à nouveau de l\'obtenir du serveur!</string>
    <string name="permissions_reset_hint">Fermez le panneau d\'administration pour vérifier et demander des autorisations.</string>
    <string name="dialog_enter_server_error">Veuillez saisir une URL de serveur valide.</string>
    <string name="dialog_enter_server_ok">D\'accord</string>
    <string name="dialog_enter_server_title">Veuillez saisir URL du serveur</string>
   <string name="critical_server_failure">Quittez en raison d\'une panne du serveur! Veuillez résoudre le problème et redémarrer %s, ou supprimez-le complètement et réinstallez-le.</string>
    <string name="dialog_permission_title">L\'app nécessite les autorisations pour s\'exécuter. Veuillez accorder les autorisations demandées.</string>
    <string name="main_activity_exit">Sortie</string>
    <string name="browser_not_found">Impossible d\'ouvrir la page Web car le navigateur est introuvable. Veuillez ajouter une app de navigateur à la configuration de l\'appareil.</string>
    <string name="invalid_web_link">Impossible d\'ouvrir le lien Web car il n\'est pas bien formé. Veuillez contacter votre administrateur pour plus de détails.</string>
    <string name="activity_not_found">Impossible d\'effectuer l\'action %s car l\'activité est introuvable.</string>
    <string name="location_service_text">La localisation de l\'appareil est surveillée</string>
    <string name="qrcode_contents_error">Contenu du code QR non valide. Veuillez générer le code QR de provisionnement dans le panneau Web %s.</string>
    <string name="device_locked">Cet appareil (%s) a été verrouillé par l\'administrateur.</string>
    <string name="fault_loop_detected">Oups, le lanceur a eu une faute irrémédiable! Veuillez contacter votre administrateur système.</string>
    <string name="mqtt_service_text">Les notifications push sont actives</string>
    <string name="background_location">%s requiert l\'autorisation d\'emplacement en arrière-plan. Cliquez sur \'Continuer\' pour ouvrir les autorisations, cliquez sur \'Emplacement\' et autorisez toujours à déterminer l\'emplacement.</string>
    <string name="location_disable">Désactiver l\'emplacement</string>
    <string name="background_location_continue">Continuer</string>
    <string name="initializing_mdm">Initialisation de l\'application de gestion des appareils mobiles...</string>
    <string name="dialog_server_error_title">Le serveur MDM %s a renvoyé une réponse non valide. Veuillez contacter votre administrateur.</string>
    <string name="mdm_choice_message">Cet appareil sera entièrement géré par votre organisation. Vos données ne seront pas privées et pourront être effacées ou révisées par votre administrateur informatique à tout moment.</string>
    <string name="work_profile_message">Cet appareil recevra un profil professionnel géré appartenant à votre organisation. Le profil professionnel est séparé de votre profil privé et vous pouvez basculer entre les profils à tout moment.</string>
    <string name="overlays_not_supported">Malheureusement, les superpositions ne sont pas prises en charge par votre appareil.</string>
    <string name="admin_not_supported">Votre appareil n\'a pas d\'option d\'administrateur d\'appareil. Cliquez sur Ignorer pour continuer.</string>
    <string name="manage_storage_not_supported">Votre appareil n\'a aucune option pour gérer le stockage externe.</string>
</resources>
</file>

<file path="app/src/main/res/values-ru/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Администратор</string>
    <string name="install_error">Ошибка установки</string>
    <string name="file_create_error">Ошибка создания файла</string>
    <string name="dialog_enter_device_id_error">Этот ID не зарегистрирован на сервере %s, найдите ID на сервере в разделе \"Устройства\".</string>
    <string name="dialog_enter_device_id_qrcode">QR код</string>
    <string name="dialog_enter_device_id_variants">Варианты</string>
    <string name="dialog_enter_device_id_save">Сохранить</string>
    <string name="dialog_enter_device_id_exit">Выход</string>
    <string name="dialog_enter_device_id_title">Введите ID устройства на сервере %s</string>
    <string name="main_start_preparations">Подготовка к запуску</string>
    <string name="main_downloading_configuration">Обновляем файл конфигурации</string>
    <string name="main_downloading_content">Обновляем данные</string>
    <string name="main_update_applications">Устанавливаем и обновляем приложения</string>
    <string name="dialog_root_message">Для использования приложения необходимы ROOT права на устройстве</string>
    <string name="main_application_start">Запускаем приложение</string>
    <string name="main_app_installing">Устанавливаем приложение</string>
    <string name="main_app_downloading">Скачиваем приложение</string>
    <string name="main_app_downloading_error">Не удалось скачать приложение</string>
    <string name="main_app_removing">Удаляем приложение</string>
    <string name="main_file_downloading">Скачиваем файл</string>
    <string name="main_file_downloading_error">Не удалось скачать файл</string>
    <string name="main_activity_repeat">Повтор</string>
    <string name="main_activity_reset">Сброс</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Отмена</string>
    <string name="main_activity_details">Детали</string>
    <string name="select_system_launcher">Выберите %s в качестве лаунчера и укажите \'Всегда\':</string>
    <string name="dialog_network_error_title">Произошла ошибка подключения к серверу %s. Проверьте своё интернет подключение и попробуйте снова.</string>
    <string name="main_activity_update_config">Запрашиваем конфигурацию с сервера</string>
    <string name="main_activity_applications_update">Обновляем приложения</string>
    <string name="dialog_overlay_settings_title">Пожалуйста, разрешите наложение поверх других окон.\n\nЭтот параметр помогает лучше блокировать нежелательные приложения и включает аварийный выход из режима киоска.\n\nНажмите \"Продолжить\", чтобы открыть страницу настроек. Найдите элемент \"%s\", дайте разрешение и нажмите \"Назад\".</string>
    <string name="dialog_manage_storage_title">Пожалуйста, разрешите приложению управлять хранилищем.\n\nЭта опция позволяет Headwind MDM управлять файлами на вашем устройстве.</string>
    <string name="dialog_history_settings_title">Пожалуйста, разрешите доступ к данным об использовании.\n\nЭта опция позволяет контролировать приложения и настройки.\n\nЭто может вызвать более быстрый разряд батареи. Чтобы сэкономить заряд батареи, пропустите этот параметр (вместо этого используйте специальные возможности или режим киоска).\n\nНажмите \"Продолжить\", чтобы открыть страницу настроек. Найдите элемент \"%s\", дайте разрешение и нажмите \"Назад\".</string>
    <string name="dialog_history_settings_continue">Продолжить</string>
    <string name="dialog_history_settings_skip">Без разрешения</string>
    <string name="dialog_unknown_sources_title">Пожалуйста, разрешите установку приложений из неизвестных источников. Сейчас откроется окно настроек Android, найдите \"Неизвестные источники\", включите разрешение и нажмите \"Назад\".</string>
    <string name="dialog_unknown_sources_continue">Продолжить</string>
    <string name="dialog_miui_permissions_title">MIUI требует ручной установки некоторых разрешений. Сейчас откроется окно разрешений. Нажмите \"Другие разрешения\", разрешите \"Отображать всплывающие окна, когда запущено в фоновом режиме\", и нажмите \"Назад\".</string>
    <string name="dialog_miui_developer_title">MIUI требует ручной настройки. Сейчас откроется экран, НАЖМИТЕ 7 РАЗ НА \"НОМЕР СБОРКИ\". Это откроет настройки разработчика.</string>
    <string name="dialog_miui_optimization_title">MIUI требует ручной настройки. Сейчас откроется экран настроек разработчика. Пролистайте экран вниз и выключите флаг \"Оптимизация MIUI\".</string>
    <string name="dialog_administrator_mode_message">Пожалуйста, разрешите установить приложение в качеcтве администратора устройства. Сейчас откроется окно настроек Android, выберите пункт \"Администраторы устройства\", в открывшемся списке найдите пункт \"%s\", активируйте приложение и нажмите \"Назад\".</string>
    <string name="dialog_administrator_mode_continue">Продолжить</string>
    <string name="dialog_administrator_mode_skip">Без разрешения</string>
    <string name="accessibility_service_description">Сервис мониторинга состояния рабочего стола</string>
    <string name="dialog_accessibility_service_message">Пожалуйста, разрешите приложению использовать специальные возможности. Сейчас откроется окно настроек Android, выберите пункт \"%s\", в открывшемся окне активируйте приложение и нажмите \"Назад\".</string>
    <string name="dialog_accessibility_service_continue">Продолжить</string>
    <string name="dialog_accessibility_service_skip">Без разрешения</string>
    <string name="access_to_app_denied">Пакет не разрешен:</string>
    <string name="access_to_app_denied_2">Пожалуйста, попросите администратора разрешить пакет в конфигурации.\n\nНажмите \'Закрыть\' или кнопку Home для продолжения.</string>
    <string name="package_id_copied">Идентификатор пакета скопирован в буфер обмена</string>
    <string name="dialog_app_not_allowed_close">Закрыть</string>
    <string name="dialog_app_not_allowed_admin">Администратор</string>
    <string name="device_id">ID устройства</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Серийный номер</string>
    <string name="phone_number">Номер телефона</string>
    <string name="launcher_version">Версия лаунчера</string>
    <string name="close">Закрыть</string>
    <string name="admin_change_device_id">Изменить ID устройства</string>
    <string name="admin_change_server_url">Изменить URL сервера</string>
    <string name="admin_allow_settings">Открыть настройки</string>
    <string name="settings_allowed">Изменение настроек разрешено в течение 3 минут</string>
    <string name="admin_clear_restrictions">Снять ограничения</string>
    <string name="permissive_mode_enabled">Вам разрешено запускать все приложения в течение 3 минут.</string>
    <string name="admin_refresh">Обновить конфигурацию</string>
    <string name="admin_reset_permissions">Проверить разрешения</string>
    <string name="admin_reset_network">Сброс политик сети</string>
    <string name="admin_reset_network_hint">Сетевые политики сброшены. Вы можете включить сеть и обновить конфигурацию устройства.</string>
    <string name="admin_exit">Выйти в системный лаунчер</string>
    <string name="reboot">Перезагрузка</string>
    <string name="reboot_failed">Не удалось перезагрузить устройство - не хватает прав.</string>
    <string name="message_turn_on_gps">Сейчас откроется экран настроек. Пожалуйста, включите на нем определение местоположения по GPS.</string>
    <string name="message_turn_off_gps">Сейчас откроется экран настроек. Пожалуйста, ВЫКЛЮЧИТЕ на нем определение местоположения по GPS.</string>
    <string name="message_turn_on_mobile_data">Мобильные данные выключены. Пожалуйста, откройте статус-бар и включите мобильные данные.</string>
    <string name="message_turn_off_mobile_data">Мобильные данные включены. Пожалуйста, откройте статус-бар и ВЫКЛЮЧИТЕ мобильные данные.</string>
    <string name="message_set_password">Качество вашего пароля недостаточно. Сейчас откроется экран настроек. Пожалуйста, измените пароль и нажмите Назад.</string>
    <string name="switch_off_blockings">Отключаем блокировку...</string>
    <string name="kiosk_mode_requires_overlays">Режим киоска не включен: не выдано разрешение на отображение поверх других окон приложению %s.</string>
    <string name="enter_admin_password">Введите пароль администратора</string>
    <string name="wrong_password">Неверный пароль</string>
    <string name="dialog_enter_password_login">Войти</string>
    <string name="dialog_enter_password_cancel">Отмена</string>
    <string name="internal_error">В оболочке возникла ошибка. Пожалуйста, перезагрузите устройство и повторите действие ещё раз.</string>
    <string name="empty_configuration">Конфигурация еще не получена, пытаемся скачать еще раз!</string>
    <string name="permissions_reset_hint">Чтобы проверить и заново запросить разрешения - закройте экран администратора.</string>
    <string name="dialog_enter_server_error">Пожалуйста, введите валидный URL сервера.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Введите URL сервера</string>
    <string name="critical_server_failure">Завершение работы из-за ошибки сервера! Исправьте ошибку и перезапустите %s, или удалите и установите лаунчер заново.</string>
    <string name="dialog_permission_title">Приложение требует разрешений для работы. Пожалуйста, предоставьте требуемые разрешения.</string>
    <string name="main_activity_exit">Выход</string>
    <string name="browser_not_found">Невозможно открыть веб-страницу: браузер не найден. Пожалуйста, добавьте приложение-браузер в конфигурацию устройства.</string>
    <string name="invalid_web_link">Не удается открыть веб-ссылку, поскольку она имеет неправильный формат. Пожалуйста, свяжитесь с вашим администратором для получения подробной информации.</string>
    <string name="activity_not_found">Невозможно выполнить действие %s, поскольку activity не найдена.</string>
    <string name="location_service_text">Местоположение устройства передается на сервер</string>
    <string name="qrcode_contents_error">Неверное содержимое QR кода. Пожалуйста, сформируйте QR код на сервере %s.</string>
    <string name="device_locked">Это устройство (%s) заблокировано администратором.</string>
    <string name="fault_loop_detected">Лаунчер сломался и его не восстановить! Пожалуйста, сообщите об этой проблеме администратору.</string>
    <string name="mqtt_service_text">Push-уведомления активны</string>
    <string name="background_location">%s требует разрешения на определение местоположения в фоне. Нажмите \'Далее\', чтобы открыть разрешения. Выберите \'Местоположение\', и разрешите определение местоположения всегда.</string>
    <string name="location_disable">Отключить местоположение</string>
    <string name="background_location_continue">Далее</string>
    <string name="initializing_mdm">Инициализация приложения, управляющего мобильным устройством...</string>
    <string name="dialog_server_error_title">MDM сервер %s вернул неверный ответ. Пожалуйста, свяжитесь с администратором.</string>
    <string name="mdm_choice_message">Это устройство будет полностью управляться вашей организацией. Ваши данные не будут конфиденциальными и могут быть удалены или просмотрены вашим ИТ-администратором в любое время.</string>
    <string name="work_profile_message">Это устройство получит управляемый рабочий профиль, принадлежащий вашей организации. Рабочий профиль отделен от вашего личного профиля, и вы можете переключаться между профилями в любое время.</string>
    <string name="overlays_not_supported">К сожалению, наложение окон не поддерживается вашим устройством.</string>
    <string name="admin_not_supported">На вашем устройстве нет возможности администратора устройства. Нажмите Пропустить, чтобы продолжить.</string>
    <string name="manage_storage_not_supported">Ваше устройство не имеет возможности управления внешним хранилищем.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/InstallUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.annotation.TargetApi;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.util.Log;

import androidx.core.content.FileProvider;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.RemoteFile;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class InstallUtils {

    public static void generateApplicationsForInstallList(Context context, List<Application> applications,
                                                          List<Application> applicationsForInstall,
                                                          Map<String, File> pendingInstallations) {
        PackageManager packageManager = context.getPackageManager();

        // First handle apps to be removed, then apps to be installed
        // We process only applications of type "app" (default) and skip web links and others
        for (Application a : applications) {
            if ((a.getType() == null || a.getType().equals(Application.TYPE_APP)) && a.isRemove() &&
                !isInList(applicationsForInstall, a)) {
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): marking app " + a.getPkg() + " to remove");
                applicationsForInstall.add(a);
            }
        }
        for (Application a : applications) {
            if ((a.getType() == null || a.getType().equals(Application.TYPE_APP)) && !a.isRemove() &&
                    !pendingInstallations.containsKey(a.getPkg()) && !isInList(applicationsForInstall, a)) {
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): marking app " + a.getPkg() + " to install");
                applicationsForInstall.add(a);
            }
        }
        Iterator< Application > it = applicationsForInstall.iterator();

        while ( it.hasNext() ) {
            Application application = it.next();
            if ( (application.getUrl() == null || application.getUrl().trim().equals("")) && !application.isRemove() ) {
                // An app without URL is a system app which doesn't require installation
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " is system, skipping");
                it.remove();
                continue;
            }

            try {
                PackageInfo packageInfo = packageManager.getPackageInfo( application.getPkg(), 0 );

                if (application.isRemove() && !application.getVersion().equals("0") &&
                        !areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode())) {
                    // If a removal is required, but the app version doesn't match, do not remove
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " version not match: "
                            + application.getVersion() + " " + packageInfo.versionName + ", skipping");
                    it.remove();
                    continue;
                }

                if (!application.isRemove() && !upgradingHmdmFreeToFull(context, application, packageInfo) &&
                        (application.isSkipVersion() || application.getVersion().equals("0") ||
                                areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode()))) {
                    // If installation is required, but the app of the same version already installed, do not install
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " versions match: "
                            + application.getVersion() + " " + packageInfo.versionName + ", skipping");
                    it.remove();
                    continue;
                }

                if (!application.isRemove() &&
                        compareVersions(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode()) > 0) {
                    // Downgrade requested!
                    // It will only succeed if a higher version is marked as "Remove"
                    // Let's check that condition to avoid failed attempts to install and downloads of the lower version each time
                    RemoteLogger.log(context, Const.LOG_DEBUG, "Downgrade requested for " + application.getPkg() +
                            ": installed version " + packageInfo.versionName + ", required version " + application.getVersion());
                    boolean canDowngrade = false;
                    for (Application a : applications) {
                        if (a.getPkg().equalsIgnoreCase(application.getPkg()) && a.isRemove() &&
                                areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, a.getVersion(), a.getCode())) {
                            // Current version will be removed
                            canDowngrade = true;
                            break;
                        }
                    }
                    if (canDowngrade) {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Current version of " + application.getPkg() + " will be removed, downgrade allowed");
                    } else {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Ignoring downgrade request for " + application.getPkg() + ": remove current version first!");
                        it.remove();
                        continue;
                    }
                }
            } catch ( PackageManager.NameNotFoundException e ) {
                // The app isn't installed, let's keep it in the "To be installed" list
                if (application.isRemove()) {
                    // The app requires removal but already removed, remove from the list so do nothing with the app
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " not found, nothing to remove");
                    it.remove();
                    continue;
                }
            }
        }
    }

    private static boolean isInList(List<Application> applicationsForInstall, Application a) {
        for (Application b : applicationsForInstall) {
            if (a.getPkg().equalsIgnoreCase(b.getPkg()) &&
                    a.getVersion().equalsIgnoreCase(b.getVersion()) &&
                    a.isRemove() == b.isRemove()) {
                return true;
            }
        }
        return false;
    }

    // Free and full versions of Headwind MDM launcher have the same version name but different version codes
    // This is a dirty hack determining the full version by the URL
    // It's however better to use different versions, for example 5.16.1 for free and 5.16.2 for full
    private static boolean upgradingHmdmFreeToFull(Context context, Application application, PackageInfo packageInfo) {
        if (!application.getPkg().equals(context.getPackageName())) {
            return false;
        }
        return Utils.getLauncherVariant().equals("opensource") && application.getUrl().endsWith("master.apk");
    }

    private static boolean areVersionsEqual(String v1, int c1, String v2, Integer c2) {
        if (c2 != null && c2 != 0) {
            // If version code is present, let's compare version codes instead of names
            return c1 == c2;
        }

        if (v1 == null || v2 == null) {
            // Exceptional case, we should never be here but this shouldn't crash the app with NPE
            return v1 == v2;
        }

        // Compare only digits (in Android 9 EMUI on Huawei Honor 8A, getPackageInfo doesn't get letters!)
        String v1d = v1.replaceAll("[^\\d.]", "");
        String v2d = v2.replaceAll("[^\\d.]", "");
        return v1d.equals(v2d);
    }

    // Returns -1 if v1 < v2, 0 if v1 == v2 and 1 if v1 > v2
    public static int compareVersions(String v1, int c1, String v2, Integer c2) {
        if (c2 != null && c2 != 0) {
            // If version code is present, let's compare version codes instead of names
            if (c1 < c2) {
                return -1;
            } else if (c1 > c2) {
                return 1;
            } else {
                return 0;
            }
        }

        // Exceptional cases: null values
        if (v1 == null && v2 == null) {
            return 0;
        }
        if (v1 == null) {
            return -1;
        }
        if (v2 == null) {
            return 1;
        }
        // Versions are numbers separated by a dot
        String v1d = v1.replaceAll("[^\\d.]", "");
        String v2d = v2.replaceAll("[^\\d.]", "");

        String[] v1n = v1d.split("\\.");
        String[] v2n = v2d.split("\\.");

        // One version could contain more digits than another
        int count = v1n.length < v2n.length ? v1n.length : v2n.length;

        for (int n = 0; n < count; n++) {
            try {
                int n1 = Integer.parseInt(v1n[n]);
                int n2 = Integer.parseInt(v2n[n]);
                if (n1 < n2) {
                    return -1;
                } else if (n1 > n2) {
                    return 1;
                }
                // If major version numbers are equals, continue to compare minor version numbers
            } catch (Exception e) {
                return 0;
            }
        }

        // Here we are if common parts are equal
        // Now we decide that if a version has more parts, it is considered as greater
        if (v1n.length < v2n.length) {
            return -1;
        } else if (v1n.length > v2n.length) {
            return 1;
        }
        return 0;
    }

    public static void generateFilesForInstallList(Context context, List<RemoteFile> files,
                                                          List<RemoteFile> filesForInstall) {
        for (RemoteFile remoteFile : files) {
            File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
            if (remoteFile.isRemove()) {
                if (file.exists()) {
                    filesForInstall.add(remoteFile);
                }
            } else {
                if (!file.exists()) {
                    filesForInstall.add(remoteFile);
                } else {
                    RemoteFile remoteFileDb = RemoteFileTable.selectByPath(DatabaseHelper.instance(context).getReadableDatabase(),
                            remoteFile.getPath());
                    if (remoteFileDb == null ||
                            // Entry not found in the database
                            // This means, a file was created by a third party
                            // We overwrite the file (and save the entry in the database after overwriting in ConfigUpdater.loadAndInstallFiles())
                            remoteFileDb.getLastUpdate() < remoteFile.getLastUpdate()) {
                        // File has been already downloaded by Headwind MDM,
                        // let's check lastUpdate (checksum is not reliable because of possible variable content)
                        // We only overwrite a file if the file on the server is newer than the file on the device
                        // (on the device, we save the lastUpdate from the server, we don't check the actual file update date)
                        // Which means, the file may be later changed by a third party app
                        filesForInstall.add(remoteFile);
                    }
                }
            }
        }
    }


        public interface DownloadProgress {
        void onDownloadProgress(final int progress, final long total, final long current);
    }

    public static String getAppTempPath(Context context, String strUrl) {
        File tempFile = new File(context.getExternalFilesDir(null), getFileName(strUrl));
        return tempFile.getAbsolutePath();
    }

    public static File downloadFile(Context context, String strUrl, DownloadProgress progressHandler ) throws Exception {
        File tempFile = new File(context.getExternalFilesDir(null), getFileName(strUrl));
        if (tempFile.exists()) {
            tempFile.delete();
        }

        try {
            try {
                tempFile.createNewFile();
            } catch (Exception e) {
                e.printStackTrace();

                tempFile = File.createTempFile(getFileName(strUrl), "temp");
            }

            URL url = new URL(strUrl);

            HttpURLConnection connection;
            if (BuildConfig.TRUST_ANY_CERTIFICATE && url.getProtocol().toLowerCase().equals("https")) {
                connection = (HttpsURLConnection) url.openConnection();
                ((HttpsURLConnection) connection).setHostnameVerifier(DO_NOT_VERIFY);
            } else {
                connection = (HttpURLConnection) url.openConnection();
            }
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Accept-Encoding", "identity");
            connection.setConnectTimeout((int) Const.CONNECTION_TIMEOUT);
            connection.setReadTimeout((int) Const.CONNECTION_TIMEOUT);
            String signature = getRequestSignature(strUrl);
            if (signature != null) {
                connection.setRequestProperty("X-Request-Signature", signature);
            }
            connection.connect();

            if (connection.getResponseCode() != 200) {
                throw new Exception("Bad server response for " + strUrl + ": " + connection.getResponseCode());
            }

            int lengthOfFile = connection.getContentLength();

            progressHandler.onDownloadProgress(0, lengthOfFile, 0);

            InputStream is = connection.getInputStream();
            DataInputStream dis = new DataInputStream(is);

            byte[] buffer = new byte[1024];
            int length;
            long total = 0;

            FileOutputStream fos = new FileOutputStream(tempFile);
            while ((length = dis.read(buffer)) > 0) {
                total += length;
                progressHandler.onDownloadProgress(
                        (int) ((total * 100.0f) / lengthOfFile),
                        lengthOfFile,
                        total);
                fos.write(buffer, 0, length);
            }
            fos.flush();
            fos.close();

            dis.close();
        } catch (Exception e) {
            tempFile.delete();
            throw e;
        }

        return tempFile;
    }

    public static String getRequestSignature(String strUrl) {
        int index = strUrl.indexOf("/files/", 0);
        if (index == -1) {
            // Seems to be an external resource, do not add signature
            return null;
        }
        index += "/files/".length();
        String filepath = strUrl.substring(index);

        try {
            return CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + filepath);
        } catch (Exception e) {
        }
        return null;
    }

    private static String getFileName(String strUrl) {
        int slashIndex = strUrl.lastIndexOf("/");
        return slashIndex >= 0 ? strUrl.substring(slashIndex) : strUrl;
    }

    public interface InstallErrorHandler {
        public void onInstallError(String msg);
    }

    public static void silentInstallApplication(Context context, File file, String packageName, InstallErrorHandler errorHandler) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        if (file.getName().endsWith(".xapk")) {
            List<File> files = XapkUtils.extract(context, file);
            XapkUtils.install(context, files, packageName, errorHandler);
            return;
        }

        try {
            Log.i(Const.LOG_TAG, "Installing " + packageName);
            FileInputStream in = new FileInputStream(file);
            PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
            PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(
                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);
            params.setAppPackageName(packageName);
            // set params
            int sessionId = packageInstaller.createSession(params);
            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            OutputStream out = session.openWrite("COSU", 0, -1);
            byte[] buffer = new byte[65536];
            int c;
            while ((c = in.read(buffer)) != -1) {
                out.write(buffer, 0, c);
            }
            session.fsync(out);
            in.close();
            out.close();

            session.commit(createIntentSender(context, sessionId, packageName));
            Log.i(Const.LOG_TAG, "Installation session committed");

        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "PackageInstaller error: " + e.getMessage());
            e.printStackTrace();
            errorHandler.onInstallError(e.getMessage());
        }
    }

    public static IntentSender createIntentSender(Context context, int sessionId, String packageName) {
        Intent intent = new Intent(Const.ACTION_INSTALL_COMPLETE);
        if (packageName != null) {
            intent.putExtra(Const.PACKAGE_NAME, packageName);
        }
        PendingIntent pendingIntent = PendingIntent.getBroadcast(
                context,
                sessionId,
                intent,
                PendingIntent.FLAG_MUTABLE | PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT);
        return pendingIntent.getIntentSender();
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void silentUninstallApplication(Context context, String packageName) {
        PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
        try {
            packageInstaller.uninstall(packageName, createIntentSender(context, 0, null));
        } catch (Exception e) {
            // If we're trying to remove an unexistent app, it causes an exception so just ignore it
        }
    }

    public static void requestInstallApplication(Context context, File file, InstallErrorHandler errorHandler) {
        if (file.getName().endsWith(".xapk")) {
            XapkUtils.install(context, XapkUtils.extract(context, file), null, errorHandler);
            return;
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            Uri uri = FileProvider.getUriForFile( context,
                    context.getApplicationContext().getPackageName() + ".provider",
                    file );
            intent.setDataAndType( uri, "application/vnd.android.package-archive" );
            // Let's set Intent.FLAG_ACTIVITY_NEW_TASK here
            // Some devices report:
            // android.util.AndroidRuntimeException
            // Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?
            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                context.startActivity(intent);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            Uri apkUri = Uri.fromFile( file );
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(apkUri, "application/vnd.android.package-archive");
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(intent);
        }
    }

    public static void requestUninstallApplication(Context context, String packageName) {
        Uri packageUri = Uri.parse("package:" + packageName);
        Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageUri);
        // Let's set Intent.FLAG_ACTIVITY_NEW_TASK here
        // Some devices report:
        // android.util.AndroidRuntimeException
        // Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
            context.startActivity(intent);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String getPackageInstallerStatusMessage(int status) {
        switch (status) {
            case PackageInstaller.STATUS_PENDING_USER_ACTION:
                return "PENDING_USER_ACTION";
            case PackageInstaller.STATUS_SUCCESS:
                return "SUCCESS";
            case PackageInstaller.STATUS_FAILURE:
                return "FAILURE_UNKNOWN";
            case PackageInstaller.STATUS_FAILURE_BLOCKED:
                return "BLOCKED";
            case PackageInstaller.STATUS_FAILURE_ABORTED:
                return "ABORTED";
            case PackageInstaller.STATUS_FAILURE_INVALID:
                return "INVALID";
            case PackageInstaller.STATUS_FAILURE_CONFLICT:
                return "CONFLICT";
            case PackageInstaller.STATUS_FAILURE_STORAGE:
                return "STORAGE";
            case PackageInstaller.STATUS_FAILURE_INCOMPATIBLE:
                return "INCOMPATIBLE";
        }
        return "UNKNOWN";
    }

    // always verify the host - dont check for certificate
    final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };

    /**
     * Trust every server - dont check for any certificate
     * This should be called at the app start if TRUST_ANY_CERTIFICATE is set to true
     */
    public static void initUnsafeTrustManager() {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[] {};
            }

            public void checkClientTrusted(X509Certificate[] chain,
                                           String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain,
                                           String authType) throws CertificateException {
            }
        } };

        // Install the all-trusting trust manager
        try {
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection
                    .setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void deleteTempApk(File file) {
        try {
            if (file.getName().endsWith(".xapk")) {
                // For XAPK, we need to remove the directory with the same name
                String path = file.getAbsolutePath();
                File directory = new File(path.substring(0, path.length() - 5));
                if (directory.exists()) {
                    deleteRecursive(directory);
                }
            }
            if (file.exists()) {
                file.delete();
            }
        } catch (Exception e) {
        }
    }

    private static void deleteRecursive(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory())
            for (File child : fileOrDirectory.listFiles())
                deleteRecursive(child);

        fileOrDirectory.delete();
    }

    public static void clearTempFiles(Context context) {
        try {
            File filesDir = context.getExternalFilesDir(null);
            for (File child : filesDir.listFiles()) {
                if (child.getName().equalsIgnoreCase("MqttConnection")) {
                    // These are names which should be kept here
                    continue;
                }
                if (child.isDirectory()) {
                    deleteRecursive(child);
                } else {
                    child.delete();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</file>

<file path="app/src/main/res/values/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="white_app_name" translatable="false">MDM Agent</string>
    <string name="app_name" translatable="false">Headwind MDM</string>
    <string name="admin_title">Administrator</string>
    <string name="vendor" translatable="false">h-mdm.com</string>
    <string name="install_error">Error installing</string>
    <string name="file_create_error">Error creating file</string>
    <string name="dialog_enter_device_id_error">This ID is not registered at %s. Get the ID from \"Devices\" tab of the control panel.</string>
    <string name="dialog_enter_device_id_qrcode">QR code</string>
    <string name="dialog_enter_device_id_variants">Variants</string>
    <string name="dialog_enter_device_id_save">Save</string>
    <string name="dialog_enter_device_id_exit">Exit</string>
    <string name="dialog_enter_device_id_title">Enter the device ID at %s</string>
    <string name="main_start_preparations">Preparing to start</string>
    <string name="main_downloading_configuration">Updating configuration file</string>
    <string name="main_downloading_content">Updating data</string>
    <string name="main_update_applications">Installing and updating applications</string>
    <string name="dialog_root_message">You need ROOT access</string>
    <string name="main_application_start">Starting application</string>
    <string name="main_app_installing">Installing application</string>
    <string name="main_app_downloading">Downloading application</string>
    <string name="main_app_downloading_error">Failed to download the package</string>
    <string name="main_app_removing">Uninstalling application</string>
    <string name="main_file_downloading">Downloading file</string>
    <string name="main_file_downloading_error">Failed to download the file</string>
    <string name="main_activity_repeat">Retry</string>
    <string name="main_activity_reset">Reset</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancel</string>
    <string name="main_activity_details">Details</string>
    <string name="select_system_launcher">Select %s as a default launcher and check \'Always\':</string>
    <string name="dialog_network_error_title">Error connecting to %s. Please check the Internet connection and try again.</string>
    <string name="main_activity_update_config">Requesting configuration file from server</string>
    <string name="main_activity_applications_update">Updating applications</string>
    <string name="dialog_overlay_settings_title">Please allow the app to draw over other windows.\n\nThis option aids the blocking of unwanted apps, and enables emergency unlocking of the kiosk mode.\n\nTap \"Continue\" to open the settings. Find the \"%s\" item, grant the permission, then tap \"Back\".</string>
    <string name="dialog_manage_storage_title">Please allow the app to manage storage.\n\nThis option allows Headwind MDM to manage files on your device.</string>
    <string name="dialog_history_settings_title">Please allow the app to access usage data.\n\nThis option enables control of apps and settings.\n\nThis option may cause faster battery drain. To save battery, skip this option (use accessibility services or kiosk mode instead).\n\nTap \"Continue\" to open the settings. Find the \"%s\" item, grant the permission, then tap \"Back\".</string>
    <string name="dialog_history_settings_continue">Continue</string>
    <string name="dialog_history_settings_skip">Skip</string>
    <string name="dialog_unknown_sources_title">Please allow installation from unknown sources. A settings sheet will now open. Find \"Unknown sources\", allow the installation and click \"Back\".</string>
    <string name="dialog_unknown_sources_continue">Continue</string>
    <string name="dialog_miui_permissions_title">MIUI requires manual setup of custom permissions. App permissions window will now open. Tap \"Other permissions\", allow \"Display pop-up windows while running in the background\" and click \"Back\".</string>
    <string name="dialog_miui_developer_title">MIUI requires manual setup of your device. On the info screen, TAP 7 TIMES ON \"BUILD NUMBER\". This will enable developer settings.</string>
    <string name="dialog_miui_optimization_title">MIUI requires manual setup of your device. Developer settings window will now open. Scroll the screen down and uncheck \"MIUI optimization\".</string>
    <string name="dialog_administrator_mode_message">Please allow the app to work in the device administrator mode. A Settings sheet will now open. Select \"Device administrators\", find the \"%s\" item, activate the administrator, and tap \"Back\".</string>
    <string name="dialog_administrator_mode_continue">Continue</string>
    <string name="dialog_administrator_mode_skip">Skip</string>
    <string name="accessibility_service_description">Active app monitoring by the MDM application</string>
    <string name="dialog_accessibility_service_message">Please allow the app to use accessibility services. A Settings sheet will now open. Find the \"%s\" item, allow to use accessibility services, and tap \"Back\".</string>
    <string name="dialog_accessibility_service_continue">Continue</string>
    <string name="dialog_accessibility_service_skip">Skip</string>
    <string name="access_to_app_denied">The package is not allowed:</string>
    <string name="access_to_app_denied_2">Please ask your administrator to enable this package in the configuration.\n\nClick \'Close\' or Home button to proceed.</string>
    <string name="package_id_copied">The package ID is copied to the clipboard</string>
    <string name="dialog_app_not_allowed_close">Close</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">Device ID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Serial number</string>
    <string name="phone_number">Phone number</string>
    <string name="launcher_version">Launcher version</string>
    <string name="close">Close</string>
    <string name="admin_change_device_id">Change device ID</string>
    <string name="admin_change_server_url">Change server URL</string>
    <string name="admin_allow_settings">Open settings</string>
    <string name="settings_allowed">You are allowed to change settings for 3 minutes.</string>
    <string name="admin_clear_restrictions">Clear restrictions</string>
    <string name="permissive_mode_enabled">You are allowed to run all apps for 3 minutes.</string>
    <string name="admin_refresh">Update configuration</string>
    <string name="admin_exit">Exit to system launcher</string>
    <string name="admin_reset_permissions">Check permissions</string>
    <string name="admin_reset_network">Reset network policy</string>
    <string name="admin_reset_network_hint">Network policies are cleared. You can now enable the network and reload the configuration.</string>
    <string name="reboot">Reboot device</string>
    <string name="reboot_failed">Not enough rights to reboot the device.</string>
    <string name="message_turn_on_gps">The settings screen will open. Please turn on GPS location on this screen and click Back.</string>
    <string name="message_turn_off_gps">The settings screen will open. Please TURN OFF GPS location on this screen and click Back.</string>
    <string name="message_turn_on_mobile_data">Mobile data is disabled! Please open the status bar and turn on mobile data.</string>
    <string name="message_turn_off_mobile_data">Mobile data is enabled. Please open the status bar and TURN OFF mobile data.</string>
    <string name="message_set_password">Your password quality is not good enough. The settings screen will open. Please change the password and click Back.</string>
    <string name="switch_off_blockings">Switching off restrictions...</string>
    <string name="kiosk_mode_requires_overlays">Kiosk mode disabled: no permission to draw over other windows. Please allow %s to draw over other windows.</string>
    <string name="enter_admin_password">Enter administrator password</string>
    <string name="wrong_password">Wrong password</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Cancel</string>
    <string name="internal_error">The app encountered an internal error. Please reboot the device and retry the action.</string>
    <string name="empty_configuration">The configuration is not set, retrying to get from the server!</string>
    <string name="permissions_reset_hint">Close the admin panel to check and request permissions.</string>
    <string name="dialog_enter_server_error">Please enter a valid server URL.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Please enter the server URL</string>
    <string name="dialog_enter_server_hint" translatable="false">http://hmdm.example.com:8080/hmdm/</string>
    <string name="critical_server_failure">Quit due to server fault! Please fix the issue and restart %s, or remove it completely and reinstall.</string>
    <string name="dialog_permission_title">The app requires the permissions to run. Please grant the requested permissions.</string>
    <string name="main_activity_exit">Exit</string>
    <string name="browser_not_found">Cannot open the webpage because the browser is not found. Please add a browser app to the device configuration.</string>
    <string name="invalid_web_link">Cannot open the web link because it is not well-formed. Please contact your administrator for details.</string>
    <string name="activity_not_found">Cannot perform the action %s because the activity is not found.</string>
    <string name="location_service_text">Device location is monitored</string>
    <string name="qrcode_contents_error">Invalid QR code contents. Please generate the provisioning QR code in the %s web panel.</string>
    <string name="device_locked">This device (%s) has been locked by the administrator.</string>
    <string name="fault_loop_detected">Oops, the launcher got an unrecoverable fault! Please contact your system administrator.</string>
    <string name="mqtt_service_text">Push notifications are active</string>
    <string name="background_location">%s requires the background location permission. Click \'Continue\' to open permissions, click \'Location\' and allow to determine location always.</string>
    <string name="location_disable">Disable location</string>
    <string name="background_location_continue">Continue</string>
    <string name="initializing_mdm">Initializing the mobile device management application...</string>
    <string name="dialog_server_error_title">MDM server %s returned an invalid response. Please contact your administrator.</string>
    <string name="mdm_choice_message">This device will be fully managed by your organization. Your data won\'t be private and can be erased or reviewed by your IT admin at any time.</string>
    <string name="work_profile_message">This device will get a managed work profile belonging to your organization. The work profile is separated from your private profile and you may switch between profiles at any time.</string>
    <string name="overlays_not_supported">Unfortunately overlays are not supported by your device.</string>
    <string name="admin_not_supported">Your device has no device administrator option. Click Skip to continue.</string>
    <string name="manage_storage_not_supported">Your device has no option to manage the external storage.</string>

    <string-array name="certificates" translatable="false">
        <!-- If you want to install custom SSL certificates, place them in assets folder
             in the PEM format and list the file names here in the <item> tag. -->
        <!--
        <item>custom_ca.cer</item>
        -->
        <item>isrg_root_x1.pem</item>
    </string-array>
</resources>
</file>

<file path="app/src/main/res/values-de/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrator</string>
    <string name="install_error">Fehler beim Installieren</string>
    <string name="file_create_error">Fehler beim Erstellen der Datei</string>
    <string name="dialog_enter_device_id_error">Diese ID ist bei %s nicht registriert. Rufen Sie die ID auf der Registerkarte \"Geräte\" des Bedienfelds ab.</string>
    <string name="dialog_enter_device_id_qrcode">QR-Code</string>
    <string name="dialog_enter_device_id_variants">Varianten</string>
    <string name="dialog_enter_device_id_save">Speichern</string>
    <string name="dialog_enter_device_id_exit">Beenden</string>
    <string name="dialog_enter_device_id_title">Geben Sie die Geräte-ID unter %s ein</string>
    <string name="main_start_preparations">Vorbereiten des Starts</string>
    <string name="main_downloading_configuration">Aktualisieren der Konfigurationsdatei</string>
    <string name="main_downloading_content">Aktualisieren von Daten</string>
    <string name="main_update_applications">Installieren und Aktualisieren von Anwendungen</string>
    <string name="dialog_root_message">Sie benötigen einen ROOT-Zugriff</string>
    <string name="main_application_start">Anwendung starten</string>
    <string name="main_app_installing">Installieren der Anwendung</string>
    <string name="main_app_downloading">Anwendung herunterladen</string>
    <string name="main_app_downloading_error">Fehler beim Herunterladen des Pakets</string>
    <string name="main_app_removing">Anwendung deinstallieren</string>
    <string name="main_file_downloading">Datei herunterladen</string>
    <string name="main_file_downloading_error">Fehler beim Herunterladen der Datei</string>
    <string name="main_activity_repeat">Wiederholen</string>
    <string name="main_activity_reset">Zurücksetzen</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Abbrechen</string>
    <string name="main_activity_details">Details</string>
    <string name="select_system_launcher">Wählen Sie %s als Standardstarter aus und aktivieren Sie \'Immer \':</string>
    <string name="dialog_network_error_title">Fehler beim Verbinden mit %s. Bitte überprüfen Sie die Internetverbindung und versuchen Sie es erneut.</string>
    <string name="main_activity_update_config">Konfigurationsdatei vom Server anfordern</string>
    <string name="main_activity_applications_update">Aktualisieren von Anwendungen</string>
    <string name="dialog_overlay_settings_title">Bitte erlauben Sie der App, über andere Fenster zu zeichnen.\n\nDiese Option hilft, unerwünschte Apps besser zu blockieren und ermöglicht die Notentsperrung des Kioskmodus.\n\nTippen Sie auf \"Weiter\", um ein Einstellungsblatt zu öffnen. Suchen Sie das Element \"%s\", erteilen Sie die Berechtigung und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_manage_storage_title">Bitte erlauben Sie der App, den Speicher zu verwalten.\n\nDiese Option ermöglicht Headwind MDM, Dateien auf Ihrem Gerät zu verwalten.</string>
    <string name="dialog_history_settings_title">Bitte erlauben Sie der App, auf Nutzungsdaten zuzugreifen.\n\nDiese Option ermöglicht die Steuerung von Apps und Einstellungen.\n\nDiese Option kann zu einer schnelleren Entladung der Batterie führen. Um Batterie zu sparen, überspringen Sie diese Option (verwenden Sie stattdessen die Bedienungshilfen oder den Kioskmodus).\n\nTippen Sie auf \"Weiter\", um ein Einstellungsblatt zu öffnen. Suchen Sie das Element \"%s\", erteilen Sie die Berechtigung und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_history_settings_continue">Weiter</string>
    <string name="dialog_history_settings_skip">Überspringen</string>
    <string name="dialog_unknown_sources_title">Bitte erlauben Sie die Installation aus unbekannten Quellen. Ein Einstellungsblatt wird nun geöffnet. Suchen Sie nach \"Unbekannten Quellen\", erlauben Sie die Installation und klicken Sie auf \"Zurück\".</string>
    <string name="dialog_unknown_sources_continue">Weiter</string>
    <string name="dialog_miui_permissions_title">MIUI erfordert die manuelle Einrichtung benutzerdefinierter Berechtigungen. Das Fenster mit den App-Berechtigungen wird jetzt geöffnet. Tippen Sie auf \"Andere Berechtigungen\", erlauben Sie \"Popup-Fenster anzeigen, während Sie im Hintergrund ausgeführt werden\" und klicken Sie auf \"Zurück\".</string>
    <string name="dialog_miui_developer_title">MIUI erfordert die manuelle Einrichtung Ihres Geräts. Tippen Sie auf dem Infobildschirm 7 MAL AUF \"BUILD NUMBER\". Dadurch werden die Entwicklereinstellungen aktiviert.</string>
    <string name="dialog_miui_optimization_title">MIUI erfordert die manuelle Einrichtung Ihres Geräts. Das Fenster mit den Entwicklereinstellungen wird jetzt geöffnet. Scrollen Sie auf dem Bildschirm nach unten und deaktivieren Sie \"MIUI-Optimierung\".</string>
    <string name="dialog_administrator_mode_message">Bitte lassen Sie die App im Geräteadministratormodus arbeiten. Ein Einstellungsblatt wird jetzt geöffnet. Wählen Sie \"Geräteadministratoren\", suchen Sie das Element \"%s\", aktivieren Sie den Administrator und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_administrator_mode_continue">Weiter</string>
    <string name="dialog_administrator_mode_skip">Überspringen</string>
    <string name="accessibility_service_description">Aktive App-Überwachung durch MDM-Anwendung</string>
    <string name="dialog_accessibility_service_message">Bitte erlauben Sie der App, Eingabehilfedienste zu verwenden. Ein Einstellungsblatt wird jetzt geöffnet. Suchen Sie das Element \"%s\", erlauben Sie die Verwendung von Eingabehilfen und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_accessibility_service_continue">Weiter</string>
    <string name="dialog_accessibility_service_skip">Überspringen</string>
    <string name="access_to_app_denied">Das Paket ist nicht erlaubt:</string>
    <string name="access_to_app_denied_2">Bitten Sie Ihren Administrator, dieses Paket in der Konfiguration zu aktivieren.\n\nKlicken Sie auf die Schaltfläche \'Schließen\' oder die Startseite, um fortzufahren.</string>
    <string name="package_id_copied">Die Paket-ID wird in die Zwischenablage kopiert</string>
    <string name="dialog_app_not_allowed_close">Schließen</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">Geräte-ID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Seriennummer</string>
    <string name="phone_number">Telefonnummer</string>
    <string name="launcher_version">Launcher-Version</string>
    <string name="close">Schließen</string>
    <string name="admin_change_device_id">Geräte-ID ändern</string>
    <string name="admin_change_server_url">Server-URL ändern</string>
    <string name="admin_allow_settings">Öffnen Sie die Einstellungen</string>
    <string name="settings_allowed">Sie können die Einstellungen innerhalb von 3 Minuten ändern.</string>
    <string name="admin_clear_restrictions">Einschränkungen entfernen</string>
    <string name="permissive_mode_enabled">Sie dürfen alle Apps innerhalb von 3 Minuten ausführen.</string>
    <string name="admin_refresh">Konfiguration aktualisieren</string>
    <string name="admin_exit">Beenden Sie den Systemstarter</string>
    <string name="admin_reset_permissions">Berechtigungen prüfen</string>
    <string name="admin_reset_network">Netzwerkrichtlinie zurücksetzen</string>
    <string name="admin_reset_network_hint">Netzwerkrichtlinien werden gelöscht. Sie können jetzt das Netzwerk aktivieren und die Konfiguration neu laden.</string>
    <string name="reboot">Gerät neu starten</string>
    <string name="reboot_failed">Nicht genügend Rechte zum Neustart des Geräts.</string>
    <string name="message_turn_on_gps">Der Einstellungsbildschirm wird geöffnet. Bitte schalten Sie die GPS-Position auf diesem Bildschirm ein und klicken Sie auf Zurück.</string>
    <string name="message_turn_off_gps">Der Einstellungsbildschirm wird geöffnet. Bitte schalten Sie den GPS-Standort auf diesem Bildschirm aus und klicken Sie auf Zurück.</string>
    <string name="message_turn_on_mobile_data">Mobile Daten sind deaktiviert! Bitte öffnen Sie die Statusleiste und aktivieren Sie mobile Daten.</string>
    <string name="message_turn_off_mobile_data">Mobile Daten sind aktiviert. Bitte öffnen Sie die Statusleiste und schalten Sie die mobilen Daten aus.</string>
    <string name="message_set_password">Ihre Passwortqualität ist nicht gut genug. Der Einstellungsbildschirm wird geöffnet. Bitte ändern Sie das Passwort und klicken Sie auf Zurück.</string>
    <string name="switch_off_blockings">Einschränkungen ausschalten ...</string>
    <string name="kiosk_mode_requires_overlays">Kioskmodus deaktiviert: Keine Berechtigung zum Zeichnen über andere Fenster. Bitte erlauben Sie %s, über andere Fenster zu zeichnen.</string>
    <string name="enter_admin_password">Geben Sie das Administratorkennwort ein</string>
    <string name="wrong_password">Falsches Passwort</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Abbrechen</string>
    <string name="internal_error">Die App hat einen internen Fehler festgestellt. Bitte starten Sie das Gerät neu und wiederholen Sie die Aktion.</string>
    <string name="empty_configuration">Die Konfiguration ist nicht festgelegt und versucht erneut, vom Server abzurufen!</string>
    <string name="permissions_reset_hint">Schließen Sie das Admin-Fenster, um Berechtigungen zu überprüfen und anzufordern.</string>
    <string name="dialog_enter_server_error">Bitte geben Sie eine gültige Server-URL ein.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Bitte geben Sie die Server-URL ein</string>
    <string name="critical_server_failure">Beenden wegen Serverfehler! Bitte beheben Sie das Problem und starten Sie %s neu oder entfernen Sie es vollständig und installieren Sie es neu.</string>
    <string name="dialog_permission_title">Für die Ausführung der App sind die Berechtigungen erforderlich. Bitte erteilen Sie die angeforderten Berechtigungen.</string>
    <string name="main_activity_exit">Beenden Sie</string>
    <string name="browser_not_found">Die Webseite kann nicht geöffnet werden, da der Browser nicht gefunden wird. Bitte fügen Sie der Gerätekonfiguration eine Browser-App hinzu.</string>
    <string name="invalid_web_link">Der Weblink kann nicht geöffnet werden, da er nicht wohlgeformt ist. Wenden Sie sich für Einzelheiten bitte an Ihren Administrator.</string>
    <string name="activity_not_found">Die Aktion %s kann nicht ausgeführt werden, da die Aktivität nicht gefunden wurde.</string>
    <string name="location_service_text">Der Gerätestandort wird überwacht</string>
    <string name="qrcode_contents_error">Ungültiger Inhalt des QR-Codes. Bitte generieren Sie den Bereitstellungs-QR-Code im Webpanel von %s.</string>
    <string name="device_locked">Dieses Gerät (%s) wurde vom Administrator gesperrt.</string>
    <string name="fault_loop_detected">Hoppla, der Launcher hat einen nicht behebbaren Fehler! Bitte wenden Sie sich an Ihren Systemadministrator.</string>
    <string name="mqtt_service_text">Push-Benachrichtigungen sind aktiv</string>
    <string name="background_location">%s erfordert die Berechtigung zum Standort im Hintergrund. Klicken Sie auf \'Weiter\', um die Berechtigungen zu öffnen, klicken Sie auf \'Standort\' und erlauben Sie, den Standort immer zu bestimmen.</string>
    <string name="location_disable">Standort deaktivieren</string>
    <string name="background_location_continue">Weiter</string>
    <string name="initializing_mdm">Initialisieren der Anwendung zur Verwaltung mobiler Geräte...</string>
    <string name="dialog_server_error_title">MDM-Server %s hat eine ungültige Antwort zurückgegeben. Bitte wenden Sie sich an Ihren Administrator.</string>
    <string name="mdm_choice_message">Dieses Gerät wird vollständig von Ihrer Organisation verwaltet. Ihre Daten sind nicht privat und können jederzeit von Ihrem IT-Administrator gelöscht oder überprüft werden.</string>
    <string name="work_profile_message">Dieses Gerät erhält ein verwaltetes Arbeitsprofil, das Ihrer Organisation gehört. Das Arbeitsprofil ist von Ihrem privaten Profil getrennt und Sie können jederzeit zwischen den Profilen wechseln.</string>
    <string name="overlays_not_supported">Leider werden Overlays von Ihrem Gerät nicht unterstützt.</string>
    <string name="admin_not_supported">Ihr Gerät verfügt über keine Geräteadministratoroption. Klicken Sie auf Überspringen, um fortzufahren.</string>
    <string name="manage_storage_not_supported">Ihr Gerät verfügt nicht über die Möglichkeit, den externen Speicher zu verwalten.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/ConfigUpdater.java">
package com.hmdm.launcher.helper;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInstaller;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.DownloadTable;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.json.Action;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.Download;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.worker.DetailedInfoWorker;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.service.PushLongPollingService;
import com.hmdm.launcher.task.ConfirmDeviceResetTask;
import com.hmdm.launcher.task.ConfirmPasswordResetTask;
import com.hmdm.launcher.task.ConfirmRebootTask;
import com.hmdm.launcher.task.GetRemoteLogConfigTask;
import com.hmdm.launcher.task.GetServerConfigTask;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class ConfigUpdater {

    public static interface UINotifier {
        void onConfigUpdateStart();
        void onConfigUpdateServerError(String errorText);
        void onConfigUpdateNetworkError(String errorText);
        void onConfigLoaded();
        void onPoliciesUpdated();
        void onFileDownloading(final RemoteFile remoteFile);
        void onDownloadProgress(final int progress, final long total, final long current);
        void onFileDownloadError(final RemoteFile remoteFile);
        void onFileInstallError(final RemoteFile remoteFile);
        void onAppUpdateStart();
        void onAppRemoving(final Application application);
        void onAppDownloading(final Application application);
        void onAppInstalling(final Application application);
        void onAppDownloadError(final Application application);
        void onAppInstallError(final String packageName);
        void onAppInstallComplete(final String packageName);
        void onConfigUpdateComplete();
        void onAllAppInstallComplete();
    };

    private boolean configInitializing;
    private Context context;
    private UINotifier uiNotifier;
    private SettingsHelper settingsHelper;
    private Handler handler = new Handler(Looper.getMainLooper());
    private List<RemoteFile> filesForInstall = new LinkedList();
    private List< Application > applicationsForInstall = new LinkedList();
    private List< Application > applicationsForRun = new LinkedList();
    private Map<String, File> pendingInstallations = new HashMap<String,File>();
    private BroadcastReceiver appInstallReceiver;
    private boolean retry = true;
    private boolean loadOnly = false;
    private boolean userInteraction;

    public List<Application> getApplicationsForRun() {
        return applicationsForRun;
    }

    public static void notifyConfigUpdate(final Context context) {
        if (SettingsHelper.getInstance(context).isMainActivityRunning()) {
            Log.d(Const.LOG_TAG, "Main activity is running, using activity updater");
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_UPDATE_CONFIGURATION));
        } else {
            Log.d(Const.LOG_TAG, "Main activity is not running, creating a new ConfigUpdater");
            new ConfigUpdater().updateConfig(context, null, false);
        }
    }

    public static void forceConfigUpdate(final Context context) {
        forceConfigUpdate(context, null, false);
    }

    public static void forceConfigUpdate(final Context context, final UINotifier notifier, final boolean userInteraction) {
        new ConfigUpdater().updateConfig(context, notifier, userInteraction);
    }

    public void setLoadOnly(boolean loadOnly) {
        this.loadOnly = loadOnly;
    }

    public void updateConfig(final Context context, final UINotifier uiNotifier, final boolean userInteraction) {
        if ( configInitializing ) {
            Log.i(Const.LOG_TAG, "updateConfig(): configInitializing=true, exiting");
            return;
        }

        Log.i(Const.LOG_TAG, "updateConfig(): set configInitializing=true");
        configInitializing = true;
        DetailedInfoWorker.requestConfigUpdate(context);
        this.context = context;
        this.uiNotifier = uiNotifier;
        this.userInteraction = userInteraction;

        // Work around a strange bug with stale SettingsHelper instance: re-read its value
        settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());

        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            Utils.releaseUserRestrictions(context, settingsHelper.getConfig().getRestrictions());
            // Explicitly release restrictions of installing/uninstalling apps
            Utils.releaseUserRestrictions(context, "no_install_apps,no_uninstall_apps");
        }

        if (uiNotifier != null) {
            uiNotifier.onConfigUpdateStart();
        }
        new GetServerConfigTask( context ) {
            @Override
            protected void onPostExecute( Integer result ) {
                super.onPostExecute( result );
                configInitializing = false;
                Log.i(Const.LOG_TAG, "updateConfig(): set configInitializing=false after getting config");

                switch ( result ) {
                    case Const.TASK_SUCCESS:
                        RemoteLogger.log(context, Const.LOG_INFO, "Configuration updated");
                        updateRemoteLogConfig();
                        break;
                    case Const.TASK_ERROR:
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to update config: server error");
                        if (uiNotifier != null) {
                            uiNotifier.onConfigUpdateServerError(getErrorText());
                        }
                        break;
                    case Const.TASK_NETWORK_ERROR:
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to update config: network error");
                        if (retry) {
                            // Retry the request once because WiFi may not yet be initialized
                            retry = false;
                            handler.postDelayed(new Runnable() {
                                @Override
                                public void run() {
                                    updateConfig(context, uiNotifier, userInteraction);
                                }
                            }, 15000);
                        } else {
                            if (settingsHelper.getConfig() != null && !userInteraction) {
                                if (uiNotifier != null && settingsHelper.getConfig().isShowWifi()) {
                                    // Show network error dialog with Wi-Fi settings
                                    // if it is required by the web panel
                                    // so the user can set up WiFi even in kiosk mode
                                    uiNotifier.onConfigUpdateNetworkError(getErrorText());
                                } else {
                                    updateRemoteLogConfig();
                                }
                            } else {
                                if (uiNotifier != null) {
                                    uiNotifier.onConfigUpdateNetworkError(getErrorText());
                                }
                            }
                        }
                        break;
                }
            }
        }.execute();
    }

    public void skipConfigLoad() {
        updateRemoteLogConfig();
    }

    private void updateRemoteLogConfig() {
        Log.i(Const.LOG_TAG, "updateRemoteLogConfig(): get logging configuration");

        GetRemoteLogConfigTask task = new GetRemoteLogConfigTask(context) {
            @Override
            protected void onPostExecute( Integer result ) {
                super.onPostExecute( result );
                Log.i(Const.LOG_TAG, "updateRemoteLogConfig(): result=" + result);
                boolean deviceOwner = Utils.isDeviceOwner(context);
                RemoteLogger.log(context, Const.LOG_INFO, "Device owner: " + deviceOwner);
                if (deviceOwner) {
                    setSelfPermissions(settingsHelper.getConfig() != null ? settingsHelper.getConfig().getAppPermissions() : null);
                }
                try {
                    if (settingsHelper.getConfig() != null && uiNotifier != null) {
                        uiNotifier.onConfigLoaded();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (!loadOnly) {
                    checkServerMigration();
                } else {
                    Log.d(Const.LOG_TAG, "LoadOnly flag set, finishing the update flow");
                }
                // If loadOnly flag is set, we finish the flow here
            }
        };
        task.execute();
    }

    private void setSelfPermissions(String appPermissionStrategy) {
        Utils.autoGrantRequestedPermissions(context, context.getPackageName(),
                appPermissionStrategy, true);
    }

    private void checkServerMigration() {
        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getNewServerUrl() != null &&
                !settingsHelper.getConfig().getNewServerUrl().trim().equals("")) {
            try {
                final MigrationHelper migrationHelper = new MigrationHelper(settingsHelper.getConfig().getNewServerUrl().trim());
                if (migrationHelper.needMigrating(context)) {
                    // Before migration, test that new URL is working well
                    migrationHelper.tryNewServer(context, new MigrationHelper.CompletionHandler() {
                        @Override
                        public void onSuccess() {
                            // Everything is OK, migrate!
                            RemoteLogger.log(context, Const.LOG_INFO, "Migrated to " + settingsHelper.getConfig().getNewServerUrl().trim());
                            settingsHelper.setBaseUrl(migrationHelper.getBaseUrl());
                            settingsHelper.setSecondaryBaseUrl(migrationHelper.getBaseUrl());
                            settingsHelper.setServerProject(migrationHelper.getServerProject());
                            ServerServiceKeeper.resetServices();
                            configInitializing = false;
                            updateConfig(context, uiNotifier, false);
                        }

                        @Override
                        public void onError(String cause) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to migrate to " + settingsHelper.getConfig().getNewServerUrl().trim() + ": " + cause);
                            setupPushService();
                        }
                    });
                    return;
                }
            } catch (Exception e) {
                // Malformed URL
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to migrate to " + settingsHelper.getConfig().getNewServerUrl().trim() + ": malformed URL");
            }
        }
        setupPushService();
    }

    private void setupPushService() {
        Log.d(Const.LOG_TAG, "setupPushService() called");
        String pushOptions = null;
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            pushOptions = settingsHelper.getConfig().getPushOptions();
            Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
            if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
                keepaliveTime = newKeepaliveTime;
            }
        }
        if (BuildConfig.ENABLE_PUSH && pushOptions != null) {
            if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
                try {
                    URL url = new URL(settingsHelper.getBaseUrl());
                    Runnable nextRunnable = () -> {
                        checkFactoryReset();
                    };
                    PushNotificationMqttWrapper.getInstance().connect(context, url.getHost(), BuildConfig.MQTT_PORT,
                            pushOptions, keepaliveTime, settingsHelper.getDeviceId(), nextRunnable, nextRunnable);
                } catch (Exception e) {
                    e.printStackTrace();
                    checkFactoryReset();
                }
            } else {
                try {
                    Intent serviceStartIntent = new Intent(context, PushLongPollingService.class);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceStartIntent);
                    } else {
                        context.startService(serviceStartIntent);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }

                checkFactoryReset();
            }
        } else {
            checkFactoryReset();
        }
    }

    private void checkFactoryReset() {
        Log.d(Const.LOG_TAG, "checkFactoryReset() called");
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getFactoryReset() != null && config.getFactoryReset()) {
            // We got a factory reset request, let's confirm and erase everything!
            RemoteLogger.log(context, Const.LOG_INFO, "Device reset by server request");
            ConfirmDeviceResetTask confirmTask = new ConfirmDeviceResetTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    // Do a factory reset if we can
                    if (result == null || result != Const.TASK_SUCCESS ) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to confirm device reset on server");
                    } else if (Utils.checkAdminMode(context)) {
                        // no_factory_reset restriction doesn't prevent against admin's reset action
                        // So we do not need to release this restriction prior to resetting the device
                        if (!Utils.factoryReset(context)) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Device reset failed");
                        }
                    } else {
                        RemoteLogger.log(context, Const.LOG_WARN, "Device reset failed: no permissions");
                    }
                    // If we can't, proceed the initialization flow
                    checkRemoteReboot();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            deviceInfo.setFactoryReset(Utils.checkAdminMode(context));
            confirmTask.execute(deviceInfo);

        } else {
            checkRemoteReboot();
        }
    }

    private void checkRemoteReboot() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getReboot() != null && config.getReboot()) {
            // Log and confirm reboot before rebooting
            RemoteLogger.log(context, Const.LOG_INFO, "Rebooting by server request");
            ConfirmRebootTask confirmTask = new ConfirmRebootTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    if (result == null || result != Const.TASK_SUCCESS ) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to confirm reboot on server");
                    } else if (Utils.checkAdminMode(context)) {
                        if (!Utils.reboot(context)) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed");
                        }
                    } else {
                        RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed: no permissions");
                    }
                    checkPasswordReset();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            confirmTask.execute(deviceInfo);

        } else {
            checkPasswordReset();
        }

    }

    private void checkPasswordReset() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getPasswordReset() != null) {
            if (Utils.passwordReset(context, config.getPasswordReset())) {
                RemoteLogger.log(context, Const.LOG_INFO, "Password successfully changed");
            } else {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to reset password");
            }

            ConfirmPasswordResetTask confirmTask = new ConfirmPasswordResetTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    setDefaultLauncher();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            confirmTask.execute(deviceInfo);

        } else {
            setDefaultLauncher();
        }
    }

    private void setDefaultLauncher() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (Utils.isDeviceOwner(context) && config != null) {
            // "Run default launcher" means we should not set Headwind MDM as a default launcher
            // and clear the setting if it has been already set
            boolean needSetLauncher = (config.getRunDefaultLauncher() == null || !config.getRunDefaultLauncher());
            String defaultLauncher = Utils.getDefaultLauncher(context);

            // As per the documentation, setting the default preferred activity should not be done on the main thread
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    if (needSetLauncher && !context.getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.setDefaultLauncher(context);
                    } else if (!needSetLauncher && context.getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.clearDefaultLauncher(context);
                    }
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    updatePolicies();
                }
            }.execute();
            return;
        }
        updatePolicies();
    }

    private void updatePolicies() {
        // Update miscellaneous device policies here

        // Set up a proxy server
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && Utils.isDeviceOwner(context)) {
            String proxyUrl = settingsHelper.getAppPreference(context.getPackageName(), "proxy");
            if (proxyUrl != null) {
                proxyUrl = proxyUrl.trim();
                if (proxyUrl.equals("0")) {
                    // null stays for "no changes" (most users won't even know about an option to set up a proxy)
                    // "0" stays for "clear the proxy previously set up"
                    proxyUrl = null;
                }
                Utils.setProxy(context, proxyUrl);
            }
        }

        if (uiNotifier != null) {
            uiNotifier.onPoliciesUpdated();
        }
        Log.d(Const.LOG_TAG, "updatePolicies(): proceed to updating files");
        checkAndUpdateFiles();
    }

    private void checkAndUpdateFiles() {
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                ServerConfig config = settingsHelper.getConfig();
                // This may be a long procedure due to checksum calculation so execute it in the background thread
                InstallUtils.generateFilesForInstallList(context, config.getFiles(), filesForInstall);
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                loadAndInstallFiles();
            }
        }.execute();
    }

    public static class RemoteFileStatus {
        public RemoteFile remoteFile;
        public boolean downloaded;
        public boolean installed;
    }

    private void loadAndInstallFiles() {
        boolean isGoodNetworkForUpdate = userInteraction || checkUpdateNetworkRestriction(settingsHelper.getConfig(), context);
        if (filesForInstall.size() > 0 && !isGoodNetworkForUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Updating files not enabled: waiting for WiFi connection");
        }
        if (filesForInstall.size() > 0 && isGoodNetworkForUpdate) {
            RemoteFile remoteFile = filesForInstall.remove(0);

            new AsyncTask<RemoteFile, Void, RemoteFileStatus>() {

                @Override
                protected RemoteFileStatus doInBackground(RemoteFile... remoteFiles) {
                    final RemoteFile remoteFile = remoteFiles[0];
                    RemoteFileStatus remoteFileStatus = null;

                    if (remoteFile.isRemove()) {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Removing file: " + remoteFile.getPath());
                        File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                        try {
                            if (file.exists()) {
                                file.delete();
                            }
                            RemoteFileTable.deleteByPath(DatabaseHelper.instance(context).getWritableDatabase(), remoteFile.getPath());
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to remove file: " +
                                    remoteFile.getPath() + ": " + e.getMessage());
                            e.printStackTrace();
                        }

                    } else if (remoteFile.getUrl() != null) {
                        if (uiNotifier != null) {
                            uiNotifier.onFileDownloading(remoteFile);
                        }
                        // onFileDownloading() method contents
                        // updateMessageForFileDownloading(remoteFile.getPath());

                        remoteFileStatus = new RemoteFileStatus();
                        remoteFileStatus.remoteFile = remoteFile;

                        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
                        Download lastDownload = DownloadTable.selectByPath(dbHelper.getReadableDatabase(), remoteFile.getPath());
                        if (!canDownload(lastDownload, remoteFile.getPath())) {
                            // Do not make further attempts to download if there were earlier download or installation errors
                            return remoteFileStatus;
                        }

                        File file = null;
                        try {
                            RemoteLogger.log(context, Const.LOG_DEBUG, "Downloading file: " + remoteFile.getPath());
                            file = InstallUtils.downloadFile(context, remoteFile.getUrl(),
                                    new InstallUtils.DownloadProgress() {
                                        @Override
                                        public void onDownloadProgress(final int progress, final long total, final long current) {
                                            if (uiNotifier != null) {
                                                uiNotifier.onDownloadProgress(progress, total, current);
                                            }
                                            // onDownloadProgress() method contents
                                            /*handler.post(new Runnable() {
                                                @Override
                                                public void run() {
                                                    binding.progress.setMax(100);
                                                    binding.progress.setProgress(progress);

                                                    binding.setFileLength(total);
                                                    binding.setDownloadedLength(current);
                                                }
                                            });*/
                                        }
                                    });
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN,
                                    "Failed to download file " + remoteFile.getPath() + ": " + e.getMessage());
                            e.printStackTrace();
                            // Save the download attempt in the database
                            saveFailedAttempt(context, lastDownload, remoteFile.getUrl(), remoteFile.getPath(), false, false);
                        }

                        if (file != null) {
                            remoteFileStatus.downloaded = true;
                            File finalFile = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                            try {
                                if (finalFile.exists()) {
                                    finalFile.delete();
                                }
                                if (!remoteFile.isVarContent()) {
                                    FileUtils.moveFile(file, finalFile);
                                } else {
                                    String imei = DeviceInfoProvider.getImei(context, 0);
                                    if (imei == null || imei.equals("")) {
                                        imei = settingsHelper.getConfig().getImei();
                                    }
                                    createFileFromTemplate(file, finalFile, settingsHelper.getDeviceId(), imei, settingsHelper.getConfig());
                                }
                                RemoteFileTable.insert(dbHelper.getWritableDatabase(), remoteFile);
                                remoteFileStatus.installed = true;
                                if (lastDownload != null) {
                                    DownloadTable.deleteByPath(dbHelper.getWritableDatabase(), lastDownload.getPath());
                                }
                            } catch (Exception e) {
                                RemoteLogger.log(context, Const.LOG_WARN,
                                        "Failed to create file " + remoteFile.getPath() + ": " + e.getMessage());
                                e.printStackTrace();
                                // Remove initial file because we don't want to install this file any more
                                try {
                                    if (file.exists()) {
                                        file.delete();
                                    }
                                } catch (Exception e1) {
                                    e1.printStackTrace();
                                }
                                remoteFileStatus.installed = false;
                                // Save the install attempt in the database
                                saveFailedAttempt(context, lastDownload, remoteFile.getUrl(), remoteFile.getPath(), true, false);
                            }
                        } else {
                            remoteFileStatus.downloaded = false;
                            remoteFileStatus.installed = false;
                        }
                    }

                    return remoteFileStatus;
                }

                @Override
                protected void onPostExecute(RemoteFileStatus fileStatus) {
                    if (fileStatus != null) {
                        if (!fileStatus.installed) {
                            filesForInstall.add( 0, fileStatus.remoteFile );
                            if (uiNotifier != null) {
                                if (!fileStatus.downloaded) {
                                    uiNotifier.onFileDownloadError(fileStatus.remoteFile);
                                } else {
                                    uiNotifier.onFileInstallError(fileStatus.remoteFile);
                                }
                            }
                            // onFileDownloadError() method contents
                            /*
                            if (!ProUtils.kioskModeRequired(context)) {
                                // Notify the error dialog that we're downloading a file, not an app
                                downloadingFile = true;
                                createAndShowFileNotDownloadedDialog(fileStatus.remoteFile.getUrl());
                                binding.setDownloading( false );
                            } else {
                                // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
                                // Note: view is not used in this method so just pass null there
                                confirmDownloadFailureClicked(null);
                            }
                             */
                            return;
                        }
                    }
                    Log.i(Const.LOG_TAG, "loadAndInstallFiles(): proceed to next file");
                    loadAndInstallFiles();
                }

            }.execute(remoteFile);
        } else {
            Log.i(Const.LOG_TAG, "loadAndInstallFiles(): Proceed to certificate installation");
            installCertificates();
        }
    }

    // Save failed attempt to download or install a file or an app in the database to avoid infinite loops
    private void saveFailedAttempt(Context context, Download lastDownload, String url, String path, boolean downloaded, boolean installed) {
        if (lastDownload == null) {
            lastDownload = new Download();
            lastDownload.setUrl(url);
            lastDownload.setPath(path);
            lastDownload.setAttempts(0);
        }
        if (!downloaded) {
            lastDownload.setAttempts(lastDownload.getAttempts() + 1);
            lastDownload.setLastAttemptTime(System.currentTimeMillis());
        }
        lastDownload.setDownloaded(downloaded);
        lastDownload.setInstalled(installed);
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        DownloadTable.insert(dbHelper.getWritableDatabase(), lastDownload);
    }

    // In background mode, we do not attempt to download files or apps in two cases:
    // 1. Installation failed
    // 2. Downloading in a mobile network is limited
    private boolean canDownload(Download lastDownload, String objectId) {
        if (userInteraction || lastDownload == null) {
            return true;
        }
        if (lastDownload.isDownloaded() && !lastDownload.isInstalled()) {
            RemoteLogger.log(context, Const.LOG_INFO, "Skip download due to previous install failure: " + objectId);
            return false;
        }
        ServerConfig config = SettingsHelper.getInstance(context).getConfig();
        if ("limited".equals(config.getDownloadUpdates())) {
            ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
            if (activeNetwork == null) {
                RemoteLogger.log(context, Const.LOG_INFO, "Skip downloading " + objectId + ": no active network");
                return false;
            }
            Log.d(Const.LOG_TAG, "Active network; " + activeNetwork.getTypeName() + ", download attempts: " + lastDownload.getAttempts());
            if (activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE &&
            !lastDownload.isDownloaded() && lastDownload.getAttempts() > 3) {
                RemoteLogger.log(context, Const.LOG_INFO, "Skip download due to previous download failures: " + objectId);
                return false;
            }
        }
        return true;
    }

    private void installCertificates() {
        final String certPaths = settingsHelper.getAppPreference(context.getPackageName(), "certificates");
        if (certPaths != null) {
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    CertInstaller.installCertificatesFromFiles(context, certPaths.trim());
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    checkAndUpdateApplications();
                }
            }.execute();
        } else {
            checkAndUpdateApplications();
        }
    }

    private void checkAndUpdateApplications() {
        Log.i(Const.LOG_TAG, "checkAndUpdateApplications(): starting update applications");
        if (uiNotifier != null) {
            uiNotifier.onAppUpdateStart();
        }
        // onAppUpdateStart() method contents
        /*
        binding.setMessage( getString( R.string.main_activity_applications_update ) );
        configInitialized = true;
         */
        configInitializing = false;

        ServerConfig config = settingsHelper.getConfig();
        InstallUtils.generateApplicationsForInstallList(context, config.getApplications(), applicationsForInstall, pendingInstallations);

        Log.i(Const.LOG_TAG, "checkAndUpdateApplications(): list size=" + applicationsForInstall.size());

        registerAppInstallReceiver(config != null ? config.getAppPermissions() : null);
        loadAndInstallApplications();
    }

    private class ApplicationStatus {
        public Application application;
        public boolean installed;
    }

    // Here we avoid ConcurrentModificationException by executing all operations with applicationForInstall list in a main thread
    private void loadAndInstallApplications() {
        boolean isGoodTimeForAppUpdate = userInteraction || checkAppUpdateTimeRestriction(settingsHelper.getConfig());
        if (applicationsForInstall.size() > 0 && !isGoodTimeForAppUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Application update not enabled. Scheduled time: " + settingsHelper.getConfig().getAppUpdateFrom());
        }
        boolean isGoodNetworkForUpdate = userInteraction || checkUpdateNetworkRestriction(settingsHelper.getConfig(), context);
        if (applicationsForInstall.size() > 0 && !isGoodNetworkForUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Application update not enabled: waiting for WiFi connection");
        }
        if (applicationsForInstall.size() > 0 && isGoodTimeForAppUpdate && isGoodNetworkForUpdate) {
            Application application = applicationsForInstall.remove(0);

            new AsyncTask<Application, Void, ApplicationStatus>() {

                @Override
                protected ApplicationStatus doInBackground(Application... applications) {
                    final Application application = applications[0];
                    ApplicationStatus applicationStatus = null;

                    if (application.isRemove()) {
                        // Remove the app
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Removing app: " + application.getPkg());
                        if (uiNotifier != null) {
                            uiNotifier.onAppRemoving(application);
                        }
                        // onAppRemoving() method contents
                        //updateMessageForApplicationRemoving( application.getName() );
                        uninstallApplication(application.getPkg());

                    } else if (application.getUrl() == null) {
                        handler.post( new Runnable() {
                            @Override
                            public void run() {
                                Log.i(Const.LOG_TAG, "loadAndInstallApplications(): proceed to next app");
                                loadAndInstallApplications();
                            }
                        } );

                    } else if (application.getUrl().startsWith("market://details")) {
                        RemoteLogger.log(context, Const.LOG_INFO, "Installing app " + application.getPkg() + " from Google Play");
                        installApplicationFromPlayMarket(application.getUrl(), application.getPkg());
                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;
                        applicationStatus.installed = true;

                    } else if (application.getUrl().startsWith("file:///")) {
                        RemoteLogger.log(context, Const.LOG_INFO, "Installing app " + application.getPkg() + " from SD card");
                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;
                        File file = null;
                        try {
                            Log.d(Const.LOG_TAG, "URL: " + application.getUrl());
                            file = new File(new URL(application.getUrl()).toURI());
                            if (file != null) {
                                Log.d(Const.LOG_TAG, "Path: " + file.getAbsolutePath());
                                if (uiNotifier != null) {
                                    uiNotifier.onAppInstalling(application);
                                }
                                // onAppInstalling() method contents
                                //updateMessageForApplicationInstalling(application.getName());
                                installApplication(file, application.getPkg(), application.getVersion());
                                applicationStatus.installed = true;
                            } else {
                                applicationStatus.installed = false;
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            applicationStatus.installed = false;
                        }

                    } else {
                        if (uiNotifier != null) {
                            uiNotifier.onAppDownloading(application);
                        }
                        // onAppDownloading() method contents
                        //updateMessageForApplicationDownloading(application.getName());

                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;

                        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
                        String tempPath = InstallUtils.getAppTempPath(context, application.getUrl());
                        Download lastDownload = DownloadTable.selectByPath(dbHelper.getReadableDatabase(), tempPath);
                        if (!canDownload(lastDownload, application.getPkg())) {
                            // Do not make further attempts to download if there were earlier download or installation errors
                            applicationStatus.installed = false;
                            return applicationStatus;
                        }

                        File file = null;
                        try {
                            RemoteLogger.log(context, Const.LOG_DEBUG, "Downloading app: " + application.getPkg());
                            file = InstallUtils.downloadFile(context, application.getUrl(),
                                    new InstallUtils.DownloadProgress() {
                                        @Override
                                        public void onDownloadProgress(final int progress, final long total, final long current) {
                                            if (uiNotifier != null) {
                                                uiNotifier.onDownloadProgress(progress, total, current);
                                            }
                                            /*
                                            handler.post(new Runnable() {
                                                @Override
                                                public void run() {
                                                    binding.progress.setMax(100);
                                                    binding.progress.setProgress(progress);

                                                    binding.setFileLength(total);
                                                    binding.setDownloadedLength(current);
                                                }
                                            });
                                             */
                                        }
                                    });
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to download app " + application.getPkg() + ": " + e.getMessage());
                            e.printStackTrace();
                            // Save the download attempt in the database
                            saveFailedAttempt(context, lastDownload, application.getUrl(), tempPath, false, false);
                        }

                        if (file != null) {
                            if (uiNotifier != null) {
                                uiNotifier.onAppInstalling(application);
                            }
                            // onAppInstalling() method contents
                            //updateMessageForApplicationInstalling(application.getName());
                            installApplication(file, application.getPkg(), application.getVersion());
                            applicationStatus.installed = true;
                            // Here we remove app from pending downloads
                            // If it fails to install, we'll remember it and do not download any more
                            if (lastDownload != null) {
                                DownloadTable.deleteByPath(dbHelper.getWritableDatabase(), lastDownload.getPath());
                            }
                        } else {
                            applicationStatus.installed = false;
                        }
                    }

                    return applicationStatus;
                }

                @Override
                protected void onPostExecute(ApplicationStatus applicationStatus) {
                    if (applicationStatus != null) {
                        if (applicationStatus.installed) {
                            if (applicationStatus.application.isRunAfterInstall()) {
                                applicationsForRun.add(applicationStatus.application);
                            }
                        } else {
                            applicationsForInstall.add( 0, applicationStatus.application );
                            if (uiNotifier != null) {
                                uiNotifier.onAppDownloadError(applicationStatus.application);
                            }
                            // onAppDownloadError() method contents
                            /*
                            if (!ProUtils.kioskModeRequired(MainActivity.this)) {
                                // Notify the error dialog that we're downloading an app
                                downloadingFile = false;
                                createAndShowFileNotDownloadedDialog(applicationStatus.application.getName());
                                binding.setDownloading( false );
                            } else {
                                // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
                                // Note: view is not used in this method so just pass null there
                                confirmDownloadFailureClicked(null);
                            }
                             */
                        }
                    }
                }

            }.execute(application);
        } else {
            // App install receiver is unregistered after all apps are installed or a timeout happens
            //unregisterAppInstallReceiver();
            lockRestrictions();
        }
    }

    private void lockRestrictions() {
        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            Utils.lockUserRestrictions(context, settingsHelper.getConfig().getRestrictions());
        }
        notifyThreads();
    }

    private void notifyThreads() {
        ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            Intent intent = new Intent(Const.ACTION_TOGGLE_PERMISSIVE);
            intent.putExtra(Const.EXTRA_ENABLED, config.isPermissive() || config.isKioskMode());
            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
        }
        setActions();
    }

    private void setActions() {
        final ServerConfig config = settingsHelper.getConfig();
        // As per the documentation, setting the default preferred activity should not be done on the main thread
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                // If kiosk browser is installed, make it a default browser
                // This is a temporary solution! Perhaps user wants only to open specific hosts / schemes
                if (Utils.isDeviceOwner(context)) {
                    if (config.getActions() != null && config.getActions().size() > 0) {
                        for (Action action : config.getActions()) {
                            Utils.setAction(context, action);
                        }
                    }
                }
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                if (uiNotifier != null) {
                    uiNotifier.onConfigUpdateComplete();
                }

                // Send notification about the configuration update to all plugins
                Intent intent = new Intent(Const.INTENT_PUSH_NOTIFICATION_PREFIX + PushMessage.TYPE_CONFIG_UPDATED);
                context.sendBroadcast(intent);

                RemoteLogger.log(context, Const.LOG_VERBOSE, "Update flow completed");
                if (pendingInstallations.size() > 0) {
                    // Some apps are still pending installation
                    // Let's wait until they're all installed
                    // Then notify UI about that so it could refresh the screen
                    waitForInstallComplete();
                } else {
                    unregisterAppInstallReceiver();
                }

                // onConfigUpdateComplete() method contents
                /*
                Log.i(Const.LOG_TAG, "Showing content from setActions()");
                showContent(settingsHelper.getConfig());
                 */
            }
        }.execute();
    }

    private void waitForInstallComplete() {
        new AsyncTask<Void, Void, Void>() {

            @Override
            protected Void doInBackground(Void... voids) {
                for (int n = 0; n < 60; n++) {
                    if (pendingInstallations.size() == 0) {
                        break;
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                unregisterAppInstallReceiver();
                if (uiNotifier != null) {
                    uiNotifier.onAllAppInstallComplete();
                }
                return null;
            }
        }.execute();
    }


    @SuppressLint("WrongConstant,UnspecifiedRegisterReceiverFlag")
    private void registerAppInstallReceiver(final String appPermissionStrategy) {
        // Here we handle the completion of the silent app installation in the device owner mode
        // These intents are not delivered to LocalBroadcastManager
        if (appInstallReceiver == null) {
            Log.d(Const.LOG_TAG, "Install completion receiver prepared");
            appInstallReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(Const.ACTION_INSTALL_COMPLETE)) {
                        int status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0);
                        switch (status) {
                            case PackageInstaller.STATUS_PENDING_USER_ACTION:
                                RemoteLogger.log(context, Const.LOG_INFO, "Request user confirmation to install");
                                Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);

                                // Fix the Intent Redirection vulnerability
                                // https://support.google.com/faqs/answer/9267555
                                ComponentName name = confirmationIntent.resolveActivity(context.getPackageManager());
                                int flags = confirmationIntent.getFlags();
                                if (name != null && !name.getPackageName().equals(context.getPackageName()) &&
                                        (flags & Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0 &&
                                        (flags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == 0) {
                                    confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                                    try {
                                        context.startActivity(confirmationIntent);
                                    } catch (Exception e) {
                                    }
                                } else {
                                    Log.e(Const.LOG_TAG, "Intent redirection detected, ignoring the fault intent!");
                                }
                                break;
                            case PackageInstaller.STATUS_SUCCESS:
                                String packageName = intent.getStringExtra(Const.PACKAGE_NAME);
                                if (packageName != null) {
                                    RemoteLogger.log(context, Const.LOG_DEBUG, "App " + packageName + " installed successfully");
                                    Log.i(Const.LOG_TAG, "Install complete: " + packageName);
                                    File file = pendingInstallations.get(packageName);
                                    if (file != null) {
                                        pendingInstallations.remove(packageName);
                                        InstallUtils.deleteTempApk(file);
                                    }
                                    if (BuildConfig.SYSTEM_PRIVILEGES || Utils.isDeviceOwner(context)) {
                                        // Always grant all dangerous rights to the app
                                        Utils.autoGrantRequestedPermissions(context, packageName,
                                                appPermissionStrategy, false);
                                        if (BuildConfig.SYSTEM_PRIVILEGES && packageName.equals(Const.APUPPET_PACKAGE_NAME)) {
                                            // Automatically grant required permissions to aPuppet if we can
                                            // Note: device owner can only grant permissions to self, not to other apps!
                                            try {
                                                SystemUtils.autoSetAccessibilityPermission(context,
                                                        Const.APUPPET_PACKAGE_NAME, Const.APUPPET_SERVICE_CLASS_NAME);
                                                SystemUtils.autoSetOverlayPermission(context,
                                                        Const.APUPPET_PACKAGE_NAME);
                                            } catch (Exception e) {
                                                e.printStackTrace();
                                            }
                                        }
                                    }
                                    if (uiNotifier != null) {
                                        uiNotifier.onAppInstallComplete(packageName);
                                    }
                                } else {
                                    RemoteLogger.log(context, Const.LOG_DEBUG, "App installed successfully");
                                }
                                break;
                            default:
                                // Installation failure
                                String extraMessage = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE);
                                String statusMessage = InstallUtils.getPackageInstallerStatusMessage(status);
                                packageName = intent.getStringExtra(Const.PACKAGE_NAME);
                                String logRecord = "Install failed: " + statusMessage;
                                if (packageName != null) {
                                    logRecord = packageName + " " + logRecord;
                                }
                                if (extraMessage != null && extraMessage.length() > 0) {
                                    logRecord += ", extra: " + extraMessage;
                                }
                                RemoteLogger.log(context, Const.LOG_ERROR, logRecord);
                                if (packageName != null) {
                                    File file = pendingInstallations.get(packageName);
                                    if (file != null) {
                                        pendingInstallations.remove(packageName);
                                        InstallUtils.deleteTempApk(file);
                                        // Save failed install attempt to prevent next downloads
                                        saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                                    }
                                }

                                break;
                        }
                        loadAndInstallApplications();
                    }
                }
            };
        } else {
            // Renewed the configuration multiple times?
            unregisterAppInstallReceiver();
        }

        try {
            Log.d(Const.LOG_TAG, "Install completion receiver registered");
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.registerReceiver(appInstallReceiver, new IntentFilter(Const.ACTION_INSTALL_COMPLETE), Context.RECEIVER_EXPORTED);
            } else {
                context.registerReceiver(appInstallReceiver, new IntentFilter(Const.ACTION_INSTALL_COMPLETE));
            }
        } catch (Exception e) {
            // On earlier Android versions (4, 5):
            // Fatal Exception: android.content.ReceiverCallNotAllowedException
            // BroadcastReceiver components are not allowed to register to receive intents
            e.printStackTrace();
        }
    }

    private void unregisterAppInstallReceiver() {
        if (appInstallReceiver != null) {
            try {
                Log.d(Const.LOG_TAG, "Install completion receiver unregistered");
                context.unregisterReceiver(appInstallReceiver);
            } catch (Exception e) {
                // Receiver not registered
                e.printStackTrace();
            }
            appInstallReceiver = null;
        }
    }

    private void installApplicationFromPlayMarket(final String uri, final String packageName) {
        RemoteLogger.log(context, Const.LOG_DEBUG, "Asking user to install app " + packageName);
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(uri));
        try {
            context.startActivity(intent);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Failed to run app install activity for " + packageName);
        }
    }

    // This function is called from a background thread
    private void installApplication( File file, final String packageName, final String version ) {
        if (packageName.equals(context.getPackageName()) &&
                context.getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID) != null) {
            // Restart self in EMUI: there's no auto restart after update in EMUI, we must use a helper app
            startLauncherRestarter();
        }
        String versionData = version == null || version.equals("0") ? "" : " " + version;
        if (Utils.isDeviceOwner(context) || BuildConfig.SYSTEM_PRIVILEGES) {
            pendingInstallations.put(packageName, file);
            RemoteLogger.log(context, Const.LOG_INFO, "Silently installing app " + packageName + versionData);
            InstallUtils.silentInstallApplication(context, file, packageName, new InstallUtils.InstallErrorHandler() {
                @Override
                public void onInstallError(String msg) {
                    Log.i(Const.LOG_TAG, "installApplication(): error installing app " + packageName);
                    pendingInstallations.remove(packageName);
                    if (file.exists()) {
                        file.delete();
                    }
                    if (uiNotifier != null) {
                        uiNotifier.onAppInstallError(packageName);
                    }
                    if (msg != null) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to install app " + packageName + ": " + msg);
                    }
                    // Save failed install attempt to prevent next downloads
                    saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                    /*
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            new AlertDialog.Builder(MainActivity.this)
                                    .setMessage(getString(R.string.install_error) + " " + packageName)
                                    .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {
                                            checkAndStartLauncher();
                                        }
                                    })
                                    .create()
                                    .show();
                        }
                    });
                     */
                }
            });
        } else {
            RemoteLogger.log(context, Const.LOG_INFO, "Asking user to install app " + packageName + versionData);
            InstallUtils.requestInstallApplication(context, file, new InstallUtils.InstallErrorHandler() {
                @Override
                public void onInstallError(String msg) {
                    pendingInstallations.remove(packageName);
                    if (file.exists()) {
                        file.delete();
                    }
                    if (msg != null) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to install app " + packageName + ": " + msg);
                    }
                    // Save failed install attempt to prevent next downloads
                    saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            loadAndInstallApplications();
                        }
                    });
                }
            });
        }
    }

    private void uninstallApplication(final String packageName) {
        if (Utils.isDeviceOwner(context) || BuildConfig.SYSTEM_PRIVILEGES) {
            RemoteLogger.log(context, Const.LOG_INFO, "Silently uninstall app " + packageName);
            InstallUtils.silentUninstallApplication(context, packageName);
        } else {
            RemoteLogger.log(context, Const.LOG_INFO, "Asking user to uninstall app " + packageName);
            InstallUtils.requestUninstallApplication(context, packageName);
        }
    }

    // The following algorithm of launcher restart works in EMUI:
    // Run EMUI_LAUNCHER_RESTARTER activity once and send the old version number to it.
    // The restarter application will check the launcher version each second, and restart it
    // when it is changed.
    private void startLauncherRestarter() {
        // Sending an intent before updating, otherwise the launcher may be terminated at any time
        Intent intent = context.getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
        if (intent == null) {
            Log.i("LauncherRestarter", "No restarter app, please add it in the config!");
            return;
        }
        intent.putExtra(Const.LAUNCHER_RESTARTER_OLD_VERSION, BuildConfig.VERSION_NAME);
        context.startActivity(intent);
        Log.i("LauncherRestarter", "Calling launcher restarter from the launcher");
    }

    // Create a new file from the template file
    // (replace DEVICE_NUMBER, IMEI, CUSTOM* by their values)
    private void createFileFromTemplate(File srcFile, File dstFile, String deviceId, String imei, ServerConfig config) throws IOException {
        // We are supposed to process only small text files
        // So here we are reading the whole file, replacing variables, and save the content
        // It is not optimal for large files - it would be better to replace in a stream (how?)
        String content = FileUtils.readFileToString(srcFile);
        content = content.replace("DEVICE_NUMBER", deviceId)
                .replace("IMEI", imei != null ? imei : "")
                .replace("CUSTOM1", config.getCustom1() != null ? config.getCustom1() : "")
                .replace("CUSTOM2", config.getCustom2() != null ? config.getCustom2() : "")
                .replace("CUSTOM3", config.getCustom3() != null ? config.getCustom3() : "");
        FileUtils.writeStringToFile(dstFile, content);
    }

    public boolean isPendingAppInstall() {
        return applicationsForInstall.size() > 0;
    }

    public void repeatDownloadFiles() {
        loadAndInstallFiles();
    }

    public void repeatDownloadApps() {
        loadAndInstallApplications();
    }

    public void skipDownloadFiles() {
        Log.d(Const.LOG_TAG, "File download skipped, continue updating files");
        if (filesForInstall.size() > 0) {
            RemoteFile remoteFile = filesForInstall.remove(0);
            settingsHelper.removeRemoteFile(remoteFile);
        }
        loadAndInstallFiles();
    }

    public void skipDownloadApps() {
        Log.d(Const.LOG_TAG, "App download skipped, continue updating applications");
        if (applicationsForInstall.size() > 0) {
            Application application = applicationsForInstall.remove(0);
            // Mark this app not to download any more until the config is refreshed
            // But we should not remove the app from a list because it may be
            // already installed!
            settingsHelper.removeApplicationUrl(application);
        }
        loadAndInstallApplications();
    }

    public static boolean checkUpdateNetworkRestriction(ServerConfig config, Context context) {
        if (!"wifi".equals(config.getDownloadUpdates())) {
            return true;
        }
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        return activeNetwork != null && activeNetwork.getType() != ConnectivityManager.TYPE_MOBILE;
    }

    public static boolean checkAppUpdateTimeRestriction(ServerConfig config) {
        if (config.getAppUpdateFrom() == null || config.getAppUpdateTo() == null) {
            return true;
        }

        Date date = new Date();
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.setTime(date);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int minute = calendar.get(Calendar.MINUTE);

        int appUpdateFromHour = 0;
        try {
            appUpdateFromHour = Integer.parseInt(config.getAppUpdateFrom().substring(0, 2));
        } catch (Exception e) {
            e.printStackTrace();
        }
        int appUpdateFromMinute = 0;
        try {
            appUpdateFromMinute = Integer.parseInt(config.getAppUpdateFrom().substring(3));
        } catch (Exception e) {
            e.printStackTrace();
        }

        int appUpdateToHour = 0;
        try {
            appUpdateToHour = Integer.parseInt(config.getAppUpdateTo().substring(0, 2));
        } catch (Exception e) {
            e.printStackTrace();
        }
        int appUpdateToMinute = 0;
        try {
            appUpdateToMinute = Integer.parseInt(config.getAppUpdateTo().substring(3));
        } catch (Exception e) {
            e.printStackTrace();
        }

        minute += 60 * hour;
        appUpdateFromMinute += 60 * appUpdateFromHour;
        appUpdateToMinute += 60 * appUpdateToHour;

        if (appUpdateFromMinute == appUpdateToMinute) {
            // This is incorrect. Perhaps the admin meant "24 hours" so return true
            return true;
        }

        if (appUpdateFromMinute < appUpdateToMinute) {
            // Midnight not included
            return appUpdateFromMinute <= minute && minute <= appUpdateToMinute;
        }

        // Midnight included
        return minute >= appUpdateFromMinute || minute <= appUpdateToMinute;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/Utils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.Manifest;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.Service;
import android.app.admin.DevicePolicyManager;
import android.app.admin.SystemUpdatePolicy;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.graphics.Color;
import android.media.AudioManager;
import android.net.ConnectivityManager;
import android.net.ProxyInfo;
import android.os.Build;
import android.os.UserManager;
import android.provider.Settings;
import android.util.Log;
import android.view.WindowManager;

import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.Action;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.ui.MainActivity;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class Utils {
    public static boolean isDeviceOwner(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        return dpm != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && dpm.isDeviceOwnerApp(context.getPackageName());
    }

    // In the open source variant, there are no flavors, so by default it's "opensource"
    public static String getLauncherVariant() {
        return BuildConfig.FLAVOR == null || BuildConfig.FLAVOR.equals("") ? "opensource" : BuildConfig.FLAVOR;
    }

    // Automatically grant permission to get phone state (for IMEI and serial)
    @TargetApi(Build.VERSION_CODES.M)
    public static boolean autoGrantPhonePermission(Context context) {
        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                    context.getPackageName(), Manifest.permission.READ_PHONE_STATE) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
                boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                        context.getPackageName(), Manifest.permission.READ_PHONE_STATE, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
                if (!success) {
                    return false;
                }
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                        context.getPackageName(), Manifest.permission.READ_PHONE_NUMBERS) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                            context.getPackageName(), Manifest.permission.READ_PHONE_NUMBERS, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
                    if (!success) {
                        return false;
                    }
                }
                // This permission is dangerous and causes blocking by Play Protect in some countries.
                //     In fact, this permission is currently never used by Headwind MDM.
//                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
//                        context.getPackageName(), Manifest.permission.READ_SMS) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
//                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
//                            context.getPackageName(), Manifest.permission.READ_SMS, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
//                    if (!success) {
//                        return false;
//                    }
//                }
            }
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            e.printStackTrace();
            return false;
        } catch (/* SecurityException */ Exception e) {
            // No active admin ComponentInfo (not sure why could that happen)
            e.printStackTrace();
            return false;
        }
        Log.i(Const.LOG_TAG, "READ_PHONE_STATE automatically granted");
        return true;
    }

    // Automatically get dangerous permissions
    // Notice: default (null) app permission strategy is "Grant all"
    @TargetApi(Build.VERSION_CODES.M)
    public static boolean autoGrantRequestedPermissions(Context context, String packageName,
                                                        @Nullable String appPermissionStrategy,
                                                        boolean forceSdCardPermissions) {
        int locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;
        int otherPermissionsState = DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;

        // Determine the app permission strategy
        if (ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
        } else if (ServerConfig.APP_PERMISSIONS_DENY_LOCATION.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;
        } else if (ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
            if (!packageName.equals(context.getPackageName())) {
                otherPermissionsState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
            }
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            List<String> permissions = getRuntimePermissions(context.getPackageManager(), packageName);

            // Some devices do not include SD card permissions in the list of runtime permissions
            // So the files could not be read or written.
            // Here we add SD card permissions manually (device owner can grant them!)
            // This is done for the Headwind MDM launcher only
            if (forceSdCardPermissions) {
                boolean hasReadExtStorage = false;
                boolean hasWriteExtStorage = false;
                for (String s : permissions) {
                    if (s.equals(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                        hasReadExtStorage = true;
                    }
                    if (s.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                        hasWriteExtStorage = true;
                    }
                }
                if (!hasReadExtStorage) {
                    permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
                }
                if (!hasWriteExtStorage) {
                    permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);
                }
            }

            for (String permission : permissions) {
                int permissionState = isLocationPermission(permission) ? locationPermissionState : otherPermissionsState;
                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                        packageName, permission) != permissionState) {
                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                            packageName, permission, permissionState);
                    if (!success) {
                        Log.w(Const.LOG_TAG, "Failed to grant permission " + permission);
                        return false;
                    } else {
                        Log.d(Const.LOG_TAG, "Permission " + permission + " granted to package " + packageName);
                    }
                }
            }
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            e.printStackTrace();
            return false;
        } catch (/* SecurityException */ Exception e) {
            // No active admin ComponentInfo (not sure why could that happen)
            e.printStackTrace();
            return false;
        }
        Log.i(Const.LOG_TAG, "Permissions automatically granted");
        return true;
    }

    public static boolean isLocationPermission(String permission) {
        return Manifest.permission.ACCESS_COARSE_LOCATION.equals(permission) ||
               Manifest.permission.ACCESS_FINE_LOCATION.equals(permission) ||
               Manifest.permission.ACCESS_BACKGROUND_LOCATION.equals(permission);
    }

    private static List<String> getRuntimePermissions(PackageManager packageManager, String packageName) {
        List<String> permissions = new ArrayList<>();
        PackageInfo packageInfo;
        try {
            packageInfo =
                    packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
        } catch (PackageManager.NameNotFoundException e) {
            return permissions;
        }

        boolean manageStorage = false;
        if (packageInfo != null && packageInfo.requestedPermissions != null) {
            for (String requestedPerm : packageInfo.requestedPermissions) {
                if (requestedPerm.equals(Manifest.permission.MANAGE_EXTERNAL_STORAGE)) {
                    manageStorage = true;
                }
                if (isRuntimePermission(packageManager, requestedPerm)) {
                    permissions.add(requestedPerm);
                }
            }
            // There's a bug in Android 11+: MANAGE_EXTERNAL_STORAGE can't be automatically granted
            // but if Headwind MDM is granting WRITE_EXTERNAL_STORAGE, then the app can't request
            // MANAGE_EXTERNAL_STORAGE, it's locked!
            // So the workaround is do not request WRITE_EXTERNAL_STORAGE in this case
            if (manageStorage && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                permissions.removeIf(s -> (s.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE) ||
                        s.equals(Manifest.permission.READ_EXTERNAL_STORAGE)));
            }
        }
        return permissions;
    }

    private static boolean isRuntimePermission(PackageManager packageManager, String permission) {
        try {
            PermissionInfo pInfo = packageManager.getPermissionInfo(permission, 0);
            if (pInfo != null) {
                if ((pInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)
                        == PermissionInfo.PROTECTION_DANGEROUS) {
                    return true;
                }
            }
        } catch (PackageManager.NameNotFoundException e) {
        }
        return false;
    }

    public static int OverlayWindowType() {
        // https://stackoverflow.com/questions/45867533/system-alert-window-permission-on-api-26-not-working-as-expected-permission-den
        if (  Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ) {
            return WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
        } else {
            return WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
        }
    }

    public static boolean isLightColor(int color) {
        final int THRESHOLD = 0xA0;
        int red = Color.red(color);
        int green = Color.green(color);
        int blue = Color.blue(color);
        return red >= THRESHOLD && green >= THRESHOLD && blue >= THRESHOLD;
    }

    @TargetApi(Build.VERSION_CODES.M)
    public static void setSystemUpdatePolicy(Context context, int systemUpdateType, String scheduledFrom, String scheduledTo) {
        DevicePolicyManager devicePolicyManager = (DevicePolicyManager)context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName deviceAdmin = LegacyUtils.getAdminComponentName(context);

        SystemUpdatePolicy currentPolicy = null;
        try {
            currentPolicy = devicePolicyManager.getSystemUpdatePolicy();
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            Log.e(Const.LOG_TAG, "Failed to set system update policy: " + e.getMessage());
            return;
        }
        if (currentPolicy != null) {
            // Check if policy type shouldn't be changed
            if (systemUpdateType == ServerConfig.SYSTEM_UPDATE_INSTANT && currentPolicy.getPolicyType() == SystemUpdatePolicy.TYPE_INSTALL_AUTOMATIC ||
                systemUpdateType == ServerConfig.SYSTEM_UPDATE_MANUAL && currentPolicy.getPolicyType() == SystemUpdatePolicy.TYPE_POSTPONE) {
                return;
            }
        }
        SystemUpdatePolicy newPolicy = null;
        switch (systemUpdateType) {
            case ServerConfig.SYSTEM_UPDATE_INSTANT:
                newPolicy = SystemUpdatePolicy.createAutomaticInstallPolicy();
                break;
            case ServerConfig.SYSTEM_UPDATE_SCHEDULE:
                // Here we use update window times
                if (scheduledFrom != null && scheduledTo != null) {
                    int windowStart = getMinutesFromString(scheduledFrom);
                    int windowEnd = getMinutesFromString(scheduledTo);
                    if (windowStart == -1) {
                        Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: wrong start time: " + scheduledFrom);
                        return;
                    }
                    if (windowEnd == -1) {
                        Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: wrong end time: " + scheduledFrom);
                        return;
                    }
                    newPolicy = SystemUpdatePolicy.createWindowedInstallPolicy(windowStart, windowEnd);
                } else {
                    Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: update window is not set on server");
                    return;
                }
                break;
            case ServerConfig.SYSTEM_UPDATE_MANUAL:
                newPolicy = SystemUpdatePolicy.createPostponeInstallPolicy();
                break;
        }
        try {
            devicePolicyManager.setSystemUpdatePolicy(deviceAdmin, newPolicy);
        } catch (Exception e) {
            Log.e(Const.LOG_TAG, "Failed to set system update policy: " + e.getMessage());
        }
    }

    private static int getMinutesFromString(String s) {
        try {
            // s has a fixed format: hh:mm with heading zeroes
            String hours = s.substring(0, 2);
            String minutes = s.substring(3, 5);
            int h = Integer.parseInt(hours);
            int m = Integer.parseInt(minutes);
            return h * 60 + m;
        } catch (Exception e) {
            return -1;
        }
    }

    public static boolean canInstallPackages(Context context) {
        if (BuildConfig.SYSTEM_PRIVILEGES) {
            return true;
        }
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            // Global setting works for Android 7 and below
            try {
                return Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.INSTALL_NON_MARKET_APPS) == 1;
            } catch (Settings.SettingNotFoundException e) {
                return true;
            }
        } else {
            return context.getPackageManager().canRequestPackageInstalls();
        }
    }

    public static boolean canDrawOverlays(Context context) {
        return Build.VERSION.SDK_INT < Build.VERSION_CODES.M ||
                Settings.canDrawOverlays(context);
    }

    public static boolean checkAdminMode(Context context) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            boolean isAdminActive = dpm.isAdminActive(adminComponentName);
//            RemoteLogger.log(context, Const.LOG_DEBUG, "Admin component active: " + isAdminActive);
            return isAdminActive;
        } catch (Exception e) {
//            RemoteLogger.log(context, Const.LOG_WARN, "Failed to get device administrator status: " + e.getMessage());
            return true;
        }
    }

    public static boolean factoryReset(Context context) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                dpm.wipeData(0);
            } else {
                dpm.wipeDevice(0);
            }
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean reboot(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
            return false;
        }
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            dpm.reboot(adminComponentName);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private static String getDataToken(Context context) {
        String token = context.getSharedPreferences(Const.PREFERENCES, Context.MODE_PRIVATE).getString(Const.PREFERENCES_DATA_TOKEN, null);
        if (token == null) {
            token = java.util.UUID.randomUUID().toString();
            context.getSharedPreferences(Const.PREFERENCES, Context.MODE_PRIVATE)
                    .edit()
                    .putString(Const.PREFERENCES_DATA_TOKEN, token)
                    .commit();
        }
        return token;
    }

    public static void initPasswordReset(Context context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            try {
                String token = getDataToken(context);
                DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
                ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
                if (dpm.setResetPasswordToken(adminComponentName, token.getBytes())) {
                    if (!dpm.isResetPasswordTokenActive(adminComponentName)) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Password reset token will be activated once the user enters the current password next time.");
                    }
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to setup password reset token, password reset requests will fail");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static boolean passwordReset(Context context, String password) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
                boolean tokenActive = dpm.isResetPasswordTokenActive(adminComponentName);
                if (!tokenActive) {
                    return false;
                }
                return dpm.resetPasswordWithToken(adminComponentName, password, getDataToken(context).getBytes(), 0);
            } else {
                return dpm.resetPassword(password, 0);
            }
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean isMobileDataEnabled(Context context) {
        ConnectivityManager cm = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
        // A hack: use private API
        // https://stackoverflow.com/questions/12686899/test-if-background-data-and-packet-data-is-enabled-or-not?rq=1
        try {
            Class clazz = Class.forName(cm.getClass().getName());
            Method method = clazz.getDeclaredMethod("getMobileDataEnabled");
            method.setAccessible(true); // Make the method callable
            // get the setting for "mobile data"
            return (Boolean) method.invoke(cm);
        } catch (Exception e) {
            // Let it will be true by default
            return true;
        }

    }

    public static boolean isPackageInstalled(Context context, String targetPackage){
        PackageManager pm = context.getPackageManager();
        try {
            PackageInfo info = pm.getPackageInfo(targetPackage,PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
        return true;
    }

    public static boolean isMiui(Context context) {
        return isPackageInstalled(context, "com.miui.home") ||
                isPackageInstalled(context, "com.miui.securitycenter");
    }

    public static boolean lockSafeBoot(Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_SAFE_BOOT);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean lockUsbStorage(boolean lock, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            try {
                // Deprecated way to lock USB
                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
                    Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.USB_MASS_STORAGE_ENABLED, 0);
                } else {
                    Settings.Global.putInt(context.getContentResolver(), Settings.Global.USB_MASS_STORAGE_ENABLED, 0);
                }
            } catch (Exception e) {
                return false;
            }
            return true;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock) {
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_USB_FILE_TRANSFER);
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA);
            } else {
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_USB_FILE_TRANSFER);
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setBrightnessPolicy(Boolean auto, Integer brightness, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (auto == null) {
                // This means we should unlock brightness
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_BRIGHTNESS);
            } else {
                // Managed brightness
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_BRIGHTNESS);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    // This option is available in Android 9 and above
                    if (auto) {
                        devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS_MODE, "1");
                    } else {
                        devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS_MODE, "0");
                        if (brightness != null) {
                            devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS, "" + brightness);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setScreenTimeoutPolicy(Boolean lock, Integer timeout, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock == null || !lock) {
                // This means we should unlock screen timeout
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT);
            } else {
                // Managed screen timeout
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && timeout != null) {
                    // This option is available in Android 9 and above
                    devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_OFF_TIMEOUT, "" + (timeout * 1000));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean lockVolume(Boolean lock, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock == null || !lock) {
                Log.d(Const.LOG_TAG, "Unlocking volume");
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_ADJUST_VOLUME);
            } else {
                Log.d(Const.LOG_TAG, "Locking volume");
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_ADJUST_VOLUME);
            }
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to lock/unlock volume: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setVolume(int percent, Context context) {
        int[] streams = {
            AudioManager.STREAM_VOICE_CALL,
            AudioManager.STREAM_SYSTEM,
            AudioManager.STREAM_RING,
            AudioManager.STREAM_MUSIC,
            AudioManager.STREAM_ALARM
        };
        try {
            AudioManager audioManager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
            for (int s : streams) {
                setVolumeInternal(audioManager, s, percent);

                int v = audioManager.getStreamVolume(s);
                if (v == 0) {
                    v = 1;
                }
            }
            return true;
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to set volume: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    private static void setVolumeInternal(AudioManager audioManager, int stream, int percent) throws Exception {
        int maxVolume = audioManager.getStreamMaxVolume(stream);
        int volume = (maxVolume * percent) / 100;
        audioManager.setStreamVolume(stream, volume, 0);
    }

    public static boolean disableScreenshots(Boolean disabled, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            devicePolicyManager.setScreenCaptureDisabled(adminComponentName, disabled);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    // Returns true if the current password is good enough, or false elsewhere
    public static boolean setPasswordMode(String passwordMode, Context context) {
        // This function works with a (deprecated) device admin as well
        // So we don't check that it has device owner rights!
        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (passwordMode == null) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_PRESENT)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 1);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_EASY)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 6);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_MODERATE)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 8);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_STRONG)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_COMPLEX);
                devicePolicyManager.setPasswordMinimumLowerCase(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumUpperCase(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumNumeric(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumSymbols(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 8);
            }
            boolean result = devicePolicyManager.isActivePasswordSufficient();
            if (passwordMode != null) {
                RemoteLogger.log(context, Const.LOG_DEBUG, "Active password quality sufficient: " + result);
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            // If the app doesn't have enough rights, let's leave password quality as is
            if (passwordMode != null) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to update password quality: " + e.getMessage());
            }
            return true;
        }
    }

    public static boolean setTimeZone(String timeZone, Context context) {
        if (!Utils.isDeviceOwner(context) || timeZone == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
            return true;
        }

        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (timeZone.equals("auto")) {
                // Note: in Android 11, there is a special method for setting auto time zone
                devicePolicyManager.setGlobalSetting(adminComponentName, Settings.Global.AUTO_TIME_ZONE, "1");
            } else {
                devicePolicyManager.setGlobalSetting(adminComponentName, Settings.Global.AUTO_TIME_ZONE, "0");
                return devicePolicyManager.setTimeZone(adminComponentName, timeZone);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return true;
        }
        return true;
    }

    @SuppressLint("SourceLockedOrientationActivity")
    public static void setOrientation(Activity activity, ServerConfig config) {
        String loggedOrientation = "unspecified";
        if (config.getOrientation() != null && config.getOrientation() != 0) {
            switch (config.getOrientation()) {
                case Const.SCREEN_ORIENTATION_PORTRAIT:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
                    loggedOrientation = "portrait";
                    break;
                case Const.SCREEN_ORIENTATION_LANDSCAPE:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
                    loggedOrientation = "landscape";
                    break;
                default:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
                    break;
            }
        } else {
            activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
        }
        Log.i(Const.LOG_TAG, "Set orientation: " + loggedOrientation);
    }

    public static boolean isLauncherIntent(Intent intent) {
        if (intent == null) {
            return false;
        }
        Set<String> categories = intent.getCategories();
        if (categories == null) {
            return false;
        }
        for (String c : categories) {
            if (c.equals(Intent.CATEGORY_LAUNCHER)) {
                return true;
            }
        }
        return false;
    }

    public static String getDefaultLauncher(Context context) {
        ActivityInfo defaultLauncherInfo = getDefaultLauncherInfo(context);
        if (defaultLauncherInfo != null) {
            return defaultLauncherInfo.packageName;
        } else {
            return null;
        }
    }

    public static ActivityInfo getDefaultLauncherInfo(Context context) {
        PackageManager localPackageManager = context.getPackageManager();
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        ResolveInfo info = localPackageManager.resolveActivity(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        if (info == null || info.activityInfo == null) {
            return null;
        }
        return info.activityInfo;
    }

    public static boolean isServiceRunning(Context context, Class<?> serviceClass) {
        try {
            ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningServiceInfo> runningServices = manager.getRunningServices(Integer.MAX_VALUE);
            for (ActivityManager.RunningServiceInfo service : runningServices) {
                if (serviceClass.getName().equals(service.service.getClassName())) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void setDefaultLauncher(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        IntentFilter filter = new IntentFilter(Intent.ACTION_MAIN);
        filter.addCategory(Intent.CATEGORY_HOME);
        filter.addCategory(Intent.CATEGORY_DEFAULT);

        ComponentName activity = new ComponentName(context, MainActivity.class);
        setPreferredActivity(context, filter, activity, "Set Headwind MDM as default launcher");
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void clearDefaultLauncher(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        IntentFilter filter = new IntentFilter(Intent.ACTION_MAIN);
        filter.addCategory(Intent.CATEGORY_HOME);
        filter.addCategory(Intent.CATEGORY_DEFAULT);

        setPreferredActivity(context, filter, null, "Reset default launcher");
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void setAction(Context context, Action action) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        try {
            IntentFilter filter = new IntentFilter("android.intent.action." + action.getAction());

            if (action.getCategories() != null && action.getCategories().length() > 0) {
                String[] categories = action.getCategories().split(",");
                for (String category : categories) {
                    filter.addCategory("android.intent.category." + category);
                }
            }

            if (action.getMimeTypes() != null && action.getMimeTypes().length() > 0) {
                String[] mimeTypes = action.getMimeTypes().split(",");
                for (String mimeType : mimeTypes) {
                    try {
                        filter.addDataType(mimeType);
                    } catch (IntentFilter.MalformedMimeTypeException e) {
                    }
                }
            }

            if (action.getSchemes() != null && action.getSchemes().length() > 0) {
                String[] schemes = action.getSchemes().split(",");
                for (String scheme : schemes) {
                    filter.addDataScheme(scheme);
                }

                if (action.getHosts() != null && action.getHosts().length() > 0) {
                    String[] hosts = action.getHosts().split(",");
                    for (String host : hosts) {
                        String[] hostport = host.split(":");
                        switch (hostport.length) {
                            case 0:
                                break;
                            case 1:
                                filter.addDataAuthority(hostport[0], null);
                                break;
                            case 2:
                                filter.addDataAuthority(hostport[0], hostport[1]);
                                break;
                        }
                    }
                }
            }

            ComponentName activity = new ComponentName(action.getPackageId(), action.getActivity());
            if (activity != null) {
                setPreferredActivity(context, filter, activity, "Set " + action.getPackageId() + "/" + action.getActivity() + " as default for " + action.getAction());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private static void setPreferredActivity(Context context, IntentFilter filter, ComponentName activity, String logMessage) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        // Set the activity as the preferred option for the device.
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm =
                (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        try {
            if (activity != null) {
                dpm.addPersistentPreferredActivity(adminComponentName, filter, activity);
            } else {
                dpm.clearPackagePersistentPreferredActivities(adminComponentName, context.getPackageName());
            }
            RemoteLogger.log(context, Const.LOG_DEBUG, logMessage + " - success");
        } catch (Exception e) {
            e.printStackTrace();
            RemoteLogger.log(context, Const.LOG_WARN, logMessage + " - failure: " + e.getMessage());
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void releaseUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.clearUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void lockUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.addUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void unlockUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.clearUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    // Setting proxyUrl=null clears the proxy previously set up
    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static boolean setProxy(Context context, String proxyUrl) {
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        try {
            ProxyInfo proxyInfo = null;
            if (proxyUrl != null) {
                String[] parts = proxyUrl.split(":");
                if (parts.length != 2) {
                    Log.d(Const.LOG_TAG, "Invalid proxy URL: " + proxyUrl);
                    return false;
                }
                int port = Integer.parseInt(parts[1]);
                proxyInfo = ProxyInfo.buildDirectProxy(parts[0], port);
            }
            dpm.setRecommendedGlobalProxy(adminComponentName, proxyInfo);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Load file content to String
     */
    public static String loadFileAsString(String filePath) throws java.io.IOException {
        StringBuffer fileData = new StringBuffer();
        BufferedReader reader = new BufferedReader(new FileReader(filePath));
        char[] buf = new char[1024];
        int numRead = 0;
        while((numRead = reader.read(buf)) != -1){
            String readData = String.valueOf(buf, 0, numRead);
            fileData.append(readData);
        }
        reader.close();
        return fileData.toString();
    }


    /**
     * Load input stream as String
     */
    public static String loadStreamAsString(InputStreamReader inputStreamReader) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(inputStreamReader);
            StringBuilder sb = new StringBuilder();
            String s;
            while ((s = reader.readLine()) != null) {
                sb.append(s + "\n");
            }
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    /**
     * Write String to file
     */
    public static boolean writeStringToFile(String fileName, String fileContent, boolean overwrite) {
        try {
            File file = new File(fileName);
            if (file.exists()) {
                if (overwrite) {
                    file.delete();
                } else {
                    return false;
                }
            }

            file.createNewFile();
            FileOutputStream fos = new FileOutputStream(file);
            OutputStreamWriter writer = new OutputStreamWriter(fos);
            writer.append(fileContent);
            writer.close();
            fos.close();
            return true;
        } catch (Exception e) {
            return false;
        }

    }

    /**
     * Starting foreground service of special use
     */
    public static void startStableForegroundService(Service service, int notificationId, Notification notification) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            int serviceType = Utils.isDeviceOwner(service) ?
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_SYSTEM_EXEMPTED :
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE;
            try {
                service.startForeground(notificationId, notification, serviceType);
            } catch (/* ForegroundServiceTypeNotAllowed*/Exception e) {
                service.startForeground(notificationId, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE);
            }
        } else {
            service.startForeground(notificationId, notification);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MainActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.Manifest;
import android.app.Dialog;
import android.app.admin.DevicePolicyManager;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.graphics.drawable.GradientDrawable;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.SystemClock;
import android.provider.Settings;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Surface;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AlertDialog;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.GridLayoutManager;

import com.github.anrwatchdog.ANRWatchDog;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityMainBinding;
import com.hmdm.launcher.databinding.DialogAccessibilityServiceBinding;
import com.hmdm.launcher.databinding.DialogAdministratorModeBinding;
import com.hmdm.launcher.databinding.DialogEnterPasswordBinding;
import com.hmdm.launcher.databinding.DialogFileDownloadingFailedBinding;
import com.hmdm.launcher.databinding.DialogHistorySettingsBinding;
import com.hmdm.launcher.databinding.DialogManageStorageBinding;
import com.hmdm.launcher.databinding.DialogMiuiPermissionsBinding;
import com.hmdm.launcher.databinding.DialogOverlaySettingsBinding;
import com.hmdm.launcher.databinding.DialogPermissionsBinding;
import com.hmdm.launcher.databinding.DialogSystemSettingsBinding;
import com.hmdm.launcher.databinding.DialogUnknownSourcesBinding;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.pro.service.CheckForegroundAppAccessibilityService;
import com.hmdm.launcher.pro.service.CheckForegroundApplicationService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.server.UnsafeOkHttpClient;
import com.hmdm.launcher.service.LocationService;
import com.hmdm.launcher.service.PluginApiService;
import com.hmdm.launcher.service.StatusControlService;
import com.hmdm.launcher.task.GetServerConfigTask;
import com.hmdm.launcher.task.SendDeviceInfoTask;
import com.hmdm.launcher.ui.custom.StatusBarUpdater;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.CrashLoopProtection;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.PreferenceLogger;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.SendDeviceInfoWorker;
import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.NetworkPolicy;
import com.squareup.picasso.Picasso;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import io.flutter.embedding.android.FlutterActivity;
import okhttp3.Cache;
import okhttp3.OkHttpClient;

import io.flutter.embedding.android.FlutterFragment;
import io.flutter.embedding.engine.FlutterEngine;
import io.flutter.embedding.engine.FlutterEngineCache;
import io.flutter.embedding.engine.dart.DartExecutor;
import io.flutter.plugin.common.MethodChannel;
public class MainActivity
        extends BaseActivity
        implements View.OnLongClickListener, BaseAppListAdapter.OnAppChooseListener,
        BaseAppListAdapter.SwitchAdapterListener, View.OnClickListener,
        ConfigUpdater.UINotifier {

    private static final String CHANNEL = "com.hmdm.flutter/location"; // Add this line

    private static final int PERMISSIONS_REQUEST = 1000;

    private ActivityMainBinding binding;
    private SettingsHelper settingsHelper;

    private Dialog fileNotDownloadedDialog;
    private DialogFileDownloadingFailedBinding dialogFileDownloadingFailedBinding;

    private Dialog enterPasswordDialog;
    private DialogEnterPasswordBinding dialogEnterPasswordBinding;

    private Dialog overlaySettingsDialog;
    private DialogOverlaySettingsBinding dialogOverlaySettingsBinding;

    private Dialog historySettingsDialog;
    private DialogHistorySettingsBinding dialogHistorySettingsBinding;

    private Dialog manageStorageDialog;
    private DialogManageStorageBinding dialogManageStorageBinding;

    private Dialog miuiPermissionsDialog;
    private DialogMiuiPermissionsBinding dialogMiuiPermissionsBinding;

    private Dialog unknownSourcesDialog;
    private DialogUnknownSourcesBinding dialogUnknownSourcesBinding;

    private Dialog administratorModeDialog;
    private DialogAdministratorModeBinding dialogAdministratorModeBinding;

    private Dialog accessibilityServiceDialog;
    private DialogAccessibilityServiceBinding dialogAccessibilityServiceBinding;

    private Dialog systemSettingsDialog;
    private DialogSystemSettingsBinding dialogSystemSettingsBinding;

    private Dialog permissionsDialog;
    private DialogPermissionsBinding dialogPermissionsBinding;

    private Handler handler = new Handler();
    private View applicationNotAllowed;
    private View lockScreen;

    private SharedPreferences preferences;

    private MainAppListAdapter mainAppListAdapter;
    private BottomAppListAdapter bottomAppListAdapter;
    private int spanCount;
    private StatusBarUpdater statusBarUpdater = new StatusBarUpdater();

    private static boolean configInitialized = false;
    // This flag is used to exit kiosk to avoid looping in onResume()
    private static boolean interruptResumeFlow = false;
    private static final int BOOT_DURATION_SEC = 120;
    private static final int PAUSE_BETWEEN_AUTORUNS_SEC = 5;
    private boolean sendDeviceInfoScheduled = false;
    // This flag notifies "download error" dialog what we're downloading: application or file
    // We cannot send this flag as the method parameter because dialog calls MainActivity methods
    private boolean downloadingFile = false;

    private int kioskUnlockCounter = 0;

    private boolean configFault = false;

    private boolean needSendDeviceInfoAfterReconfigure = false;
    private boolean needRedrawContentAfterReconfigure = false;
    private boolean orientationLocked = false;

    private int REQUEST_CODE_GPS_STATE_CHANGE = 1;

    // This flag is used by the broadcast receiver to determine what to do if it gets a policy violation report
    private boolean isBackground;

    private ANRWatchDog anrWatchDog;

    private int lastNetworkType;

    private ConfigUpdater configUpdater = new ConfigUpdater();

    private Picasso picasso = null;

    private BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            switch ( intent.getAction() ) {
                case Const.ACTION_UPDATE_CONFIGURATION:
                    RemoteLogger.log(context, Const.LOG_DEBUG, "Update configuration by MainActivity");
                    updateConfig(false);
                    break;
                case Const.ACTION_HIDE_SCREEN:
                    ServerConfig serverConfig = SettingsHelper.getInstance(MainActivity.this).getConfig();
                    if (serverConfig.getLock() != null && serverConfig.getLock()) {
                        // Device is locked by the server administrator!
                        showLockScreen();
                    } else if ( applicationNotAllowed != null &&
                            (!ProUtils.kioskModeRequired(MainActivity.this) || !ProUtils.isKioskAppInstalled(MainActivity.this)) ) {
                        TextView textView = ( TextView ) applicationNotAllowed.findViewById( R.id.package_id );
                        textView.setText(intent.getStringExtra(Const.PACKAGE_NAME));

                        applicationNotAllowed.setVisibility( View.VISIBLE );
                        // This ensures requestFocus() happens after layout, when it's safe and guaranteed to work.
                        applicationNotAllowed.post(() -> {
                            View button = applicationNotAllowed.findViewById(R.id.layout_application_not_allowed_continue);
                            button.requestFocus();
                        });
                        handler.postDelayed( new Runnable() {
                            @Override
                            public void run() {
                                applicationNotAllowed.setVisibility( View.GONE );
                            }
                        }, 20000 );
                    }
                    break;

                case Const.ACTION_DISABLE_BLOCK_WINDOW:
                    if ( applicationNotAllowed != null) {
                        applicationNotAllowed.setVisibility(View.GONE);
                    }
                    break;

                case Const.ACTION_EXIT:
                    finish();
                    break;

                case Const.ACTION_POLICY_VIOLATION:
                    if (isBackground) {
                        // If we're in the background, let's bring Headwind MDM to top and the notification will be raised in onResume
                        Intent restoreLauncherIntent = new Intent(context, MainActivity.class);
                        restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivity(restoreLauncherIntent);
                    } else {
                        // Calling startActivity always calls onPause / onResume which is not what we want
                        // So just show dialog if it isn't already shown
                        if (systemSettingsDialog == null || !systemSettingsDialog.isShowing()) {
                            notifyPolicyViolation(intent.getIntExtra(Const.POLICY_VIOLATION_CAUSE, 0));
                        }
                    }
                    break;

                case Const.ACTION_EXIT_KIOSK:
                    ServerConfig config = settingsHelper.getConfig();
                    if (config != null) {
                        config.setKioskMode(false);
                        RemoteLogger.log(MainActivity.this, Const.LOG_INFO, "Exit kiosk by admin command");
                        showContent(config);
                    }
                    break;

                case Const.ACTION_ADMIN_PANEL:
                    openAdminPanel();
                    break;
            }

        }
    };

    private final BroadcastReceiver stateChangeReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            // Log new connection type
            if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
                ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                if (null != activeNetwork) {
                    if (lastNetworkType != activeNetwork.getType()) {
                        lastNetworkType = activeNetwork.getType();
                        RemoteLogger.log(MainActivity.this, Const.LOG_DEBUG, "Network type changed: " + activeNetwork.getTypeName());
                    }
                } else {
                    if (lastNetworkType != -1) {
                        lastNetworkType = -1;
                        RemoteLogger.log(MainActivity.this, Const.LOG_DEBUG, "Network connection lost");
                    }
                }
            }

            try {
                applyEarlyPolicies(settingsHelper.getConfig());
            } catch (Exception e) {
            }
        }
    };


    private GradientDrawable selectedManageButtonBorder = new GradientDrawable();
    private ImageView exitView;
    private long exitFirstTapTime = 0;
    private int exitTapCount = 0;
    private ImageView infoView;
    private ImageView updateView;

    private View statusBarView;
    private View rightToolbarView;

    private boolean firstStartAfterProvisioning = false;


    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        Log.d("messi scored", "onCreate: ");
        super.onCreate( savedInstanceState );


        Intent intent = getIntent();
        Log.d(Const.LOG_TAG, "MainActivity started" + (intent != null && intent.getAction() != null ?
                ", action: " + intent.getAction() : ""));
        if (intent != null && "android.app.action.PROVISIONING_SUCCESSFUL".equalsIgnoreCase(intent.getAction())) {
            firstStartAfterProvisioning = true;
        }

        if (CrashLoopProtection.isCrashLoopDetected(this)) {
            Toast.makeText(MainActivity.this, R.string.fault_loop_detected, Toast.LENGTH_LONG).show();
            return;
        }

        // Disable crashes to avoid "select a launcher" popup
        // Crashlytics will show an exception anyway!
        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                e.printStackTrace();

                ProUtils.sendExceptionToCrashlytics(e);

                CrashLoopProtection.registerFault(MainActivity.this);
                // Restart launcher if there's a launcher restarter (and we're not in a crash loop)
                if (!CrashLoopProtection.isCrashLoopDetected(MainActivity.this)) {
                    Intent intent = getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
                    if (intent != null) {
                        startActivity(intent);
                    }
                }
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                    finishAffinity();
                }
                System.exit(0);
            }
        });


        if (BuildConfig.ANR_WATCHDOG) {
            anrWatchDog = new ANRWatchDog();
            anrWatchDog.start();
        }

        // Prevent showing the lock screen during the app download/installation
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        binding.setMessage(getString( R.string.main_start_preparations));
        binding.loading.setVisibility(View.VISIBLE);

        settingsHelper = SettingsHelper.getInstance(this);
        preferences = getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);

        settingsHelper.setAppStartTime(System.currentTimeMillis());

        Initializer.init(this, () -> {

            // Try to start services in onCreate(), this may fail, we will try again on each onResume.
            startServicesWithRetry();

            initReceiver();

            IntentFilter intentFilter = new IntentFilter();
            intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
            intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
            intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                registerReceiver(stateChangeReceiver, intentFilter, Context.RECEIVER_EXPORTED);
            } else {
                registerReceiver(stateChangeReceiver, intentFilter);
            }

            if (!getIntent().getBooleanExtra(Const.RESTORED_ACTIVITY, false)) {
                startAppsAtBoot();
            }

            settingsHelper.setMainActivityRunning(true);
        });
        try {
            // Instantiate a FlutterEngine.
            FlutterEngine flutterEngine = new FlutterEngine(this);

            // Start executing Dart code to kick off the background service.
            flutterEngine.getDartExecutor().executeDartEntrypoint(
                    DartExecutor.DartEntrypoint.createDefault()
            );

            // Cache the FlutterEngine to be used by FlutterActivity or other parts of the app.
            FlutterEngineCache
                    .getInstance()
                    .put("my_flutter_engine", flutterEngine);

            Log.d("FLUTTER_SERVICE", "Headless Flutter engine started successfully.");

        } catch (Exception e) {
            Log.e("FLUTTER_SERVICE", "Failed to start headless Flutter engine.", e);
        }
    }

    // On some Android firmwares, onResume is called before onCreate, so the fields are not initialized
    // Here we initialize all required fields to avoid crash at startup
    private void reinitApp() {
        if (binding == null) {
            binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
            binding.setMessage(getString(R.string.main_start_preparations));
            binding.loading.setVisibility(View.VISIBLE);
        }

        if (settingsHelper == null) {
            settingsHelper = SettingsHelper.getInstance(this);
        }
        if (preferences == null) {
            preferences = getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_CODE_GPS_STATE_CHANGE) {
            // User changed GPS state, let's update location service
            startLocationServiceWithRetry();
        }
    }

    private void initReceiver() {
        IntentFilter intentFilter = new IntentFilter(Const.ACTION_UPDATE_CONFIGURATION);
        intentFilter.addAction(Const.ACTION_HIDE_SCREEN);
        intentFilter.addAction(Const.ACTION_EXIT);
        intentFilter.addAction(Const.ACTION_POLICY_VIOLATION);
        intentFilter.addAction(Const.ACTION_EXIT_KIOSK);
        intentFilter.addAction(Const.ACTION_ADMIN_PANEL);
        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, intentFilter);
    }

    @Override
    protected void onResume() {
        super.onResume();

        isBackground = false;

        // On some Android firmwares, onResume is called before onCreate, so the fields are not initialized
        // Here we initialize all required fields to avoid crash at startup
        reinitApp();

        statusBarUpdater.startUpdating(this, binding.clock, binding.batteryState);

        startServicesWithRetry();

        if (interruptResumeFlow) {
            interruptResumeFlow = false;
            return;
        }

        if (!BuildConfig.SYSTEM_PRIVILEGES) {
            if (firstStartAfterProvisioning) {
                firstStartAfterProvisioning = false;
                waitForProvisioning(10);
            } else {
                setDefaultLauncherEarly();
            }
        } else {
            setSelfAsDeviceOwner();
        }
    }

    private void lockOrientation() {
        int orientation = getResources().getConfiguration().orientation;
        int rotation = getWindowManager().getDefaultDisplay().getRotation();
        Log.d(Const.LOG_TAG, "Lock orientation: orientation=" + orientation + ", rotation=" + rotation);
        if (orientation == Configuration.ORIENTATION_PORTRAIT) {
            setRequestedOrientation(rotation < Surface.ROTATION_180 ? ActivityInfo.SCREEN_ORIENTATION_PORTRAIT : ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
        } else {
            setRequestedOrientation(rotation < Surface.ROTATION_180 ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
        }
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (mainAppListAdapter != null && event.getAction() == KeyEvent.ACTION_UP) {
            if (!mainAppListAdapter.onKey(keyCode)) {
                if (bottomAppListAdapter != null) {
                    return bottomAppListAdapter.onKey(keyCode);
                }
            };
        }
        return super.onKeyUp(keyCode, event);
    }

    // Workaround against crash "App is in background" on Android 9: this is an Android OS bug
    // https://stackoverflow.com/questions/52013545/android-9-0-not-allowed-to-start-service-app-is-in-background-after-onresume
    private void startServicesWithRetry() {
        try {
            startServices();
        } catch (Exception e) {
            // Android OS bug!!!
            e.printStackTrace();

            // Repeat an attempt to start services after one second
            handler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        startServices();
                    } catch (Exception e) {
                        // Still failed, now give up!
                        // startService may fail after resuming, but the service may be already running (there's a WorkManager)
                        // So if we get an exception here, just ignore it and hope the app will work further
                        e.printStackTrace();
                    }
                }
            }, 1000);
        }
    }

    private void startAppsAtBoot() {
        // Let's assume that we start within two minutes after boot
        // This should work even for slow devices
        long uptimeMillis = SystemClock.uptimeMillis();
        if (uptimeMillis > BOOT_DURATION_SEC * 1000) {
            return;
        }
        final ServerConfig config = settingsHelper.getConfig();
        if (config == null || config.getApplications() == null) {
            // First start
            return;
        }

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                boolean appStarted = false;
                for (Application application : config.getApplications()) {
                    if (application.isRunAtBoot()) {
                        // Delay start of each application to 5 sec
                        try {
                            Thread.sleep(PAUSE_BETWEEN_AUTORUNS_SEC * 1000);
                        } catch (InterruptedException e) {
                        }
                        Intent launchIntent = getPackageManager().getLaunchIntentForPackage(application.getPkg());
                        if (launchIntent != null) {
                            startActivity(launchIntent);
                            appStarted = true;
                        }
                    }
                }
                // Hide apps after start to avoid users confusion
                if (appStarted && !config.isAutostartForeground()) {
                    try {
                        Thread.sleep(PAUSE_BETWEEN_AUTORUNS_SEC * 1000);
                    } catch (InterruptedException e) {
                    }
                    // Notice: if MainActivity will be destroyed after running multiple apps at startup,
                    // we can get the looping here, because startActivity will create a new instance!
                    // That's why we put a boolean extra preventing apps from start
                    Intent intent = new Intent(MainActivity.this, MainActivity.class);
                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                    intent.putExtra(Const.RESTORED_ACTIVITY, true);
                    startActivity(intent);
                }

                return null;
            }
        }.execute();

    }

    // Does not seem to work, though. See the comment to SystemUtils.becomeDeviceOwner()
    private void setSelfAsDeviceOwner() {
        // We set self as device owner each time so we could trace errors if device owner setup fails
        if (Utils.isDeviceOwner(this)) {
            checkAndStartLauncher();
            return;
        }

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                if (!SystemUtils.becomeDeviceOwnerByCommand(MainActivity.this)) {
                    SystemUtils.becomeDeviceOwnerByXmlFile(MainActivity.this);
                };
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                setDefaultLauncherEarly();
            }
        }.execute();
    }


    private void startServices() {
        // Foreground apps checks are not available in a free version: services are the stubs
        if (preferences.getInt(Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            startService(new Intent(MainActivity.this, CheckForegroundApplicationService.class));
        }
        if (BuildConfig.USE_ACCESSIBILITY &&
            preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            startService(new Intent(MainActivity.this, CheckForegroundAppAccessibilityService.class));
        }
        startService(new Intent(MainActivity.this, StatusControlService.class));

        // Moved to onResume!
        // https://stackoverflow.com/questions/51863600/java-lang-illegalstateexception-not-allowed-to-start-service-intent-from-activ
        startService(new Intent(MainActivity.this, PluginApiService.class));

        // Send pending logs to server
        RemoteLogger.resetState();
        RemoteLogger.sendLogsToServer(MainActivity.this);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode,
                                           String[] permissions, int[] grantResults) {
        if (requestCode == PERMISSIONS_REQUEST) {
            if (Utils.isDeviceOwner(this)) {
                // Even in device owner mode, if "Ask for location" is requested by the admin,
                // let's ask permissions (so do nothing here, fall through)
                if (settingsHelper.getConfig() == null || !ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(settingsHelper.getConfig().getAppPermissions()) &&
                        !ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(settingsHelper.getConfig().getAppPermissions())) {
                    // This may be called on Android 10, not sure why; just continue the flow
                    Log.i(Const.LOG_TAG, "Called onRequestPermissionsResult: permissions=" + Arrays.toString(permissions) +
                            ", grantResults=" + Arrays.toString(grantResults));
                    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                    return;
                }
            }

            boolean locationDisabled = false;
            for (int n = 0; n < permissions.length; n++) {
                if (permissions[n].equals(Manifest.permission.ACCESS_FINE_LOCATION)) {
                    if (grantResults[n] != PackageManager.PERMISSION_GRANTED) {
                        // The user didn't allow to determine location, this is not critical, just ignore it
                        preferences.edit().putInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_ON).commit();
                        locationDisabled = true;
                    }
                }
            }

            boolean requestPermissions = false;
            for (int n = 0; n < permissions.length; n++) {
                if (grantResults[n] != PackageManager.PERMISSION_GRANTED) {
                    if (permissions[n].equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION) &&
                            (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q || locationDisabled)) {
                        // Background location is not available on Android 9 and below
                        // Also we don't need to grant background location permission if we don't grant location at all
                        continue;
                    }

                    if (permissions[n].equals(Manifest.permission.ACCESS_FINE_LOCATION) &&
                            locationDisabled) {
                        // Skip fine location permission if user intentionally disabled it
                        continue;
                    }

                    // Let user know that he need to grant permissions
                     requestPermissions = true;
                }
            }

            if (requestPermissions) {
                createAndShowPermissionsDialog();
            }
        }
    }

    // AdminReceiver may be called later than onCreate() and onResume()
    // so the launcher setup and other methods requiring device owner permissions may fail
    // Here we wait up to 10 seconds until the app gets the device owner permissions
    private void waitForProvisioning(int attempts) {
        if (Utils.isDeviceOwner(this) || attempts <= 0) {
            setDefaultLauncherEarly();
        } else {
            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    waitForProvisioning(attempts - 1);
                }
            }, 1000);
        }
    }

    private void setDefaultLauncherEarly() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (BuildConfig.SET_DEFAULT_LAUNCHER_EARLY && config == null && Utils.isDeviceOwner(this)) {
            // At first start, temporarily set Headwind MDM as a default launcher
            // to prevent the user from clicking Home to stop running Headwind MDM
            String defaultLauncher = Utils.getDefaultLauncher(this);

            // As per the documentation, setting the default preferred activity should not be done on the main thread
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    if (!getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.setDefaultLauncher(MainActivity.this);
                    }
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    checkAndStartLauncher();
                }
            }.execute();
            return;
        }
        checkAndStartLauncher();
    }


    private void checkAndStartLauncher() {

        boolean deviceOwner = Utils.isDeviceOwner(this);
        preferences.edit().putInt(Const.PREFERENCES_DEVICE_OWNER, deviceOwner ?
            Const.PREFERENCES_ON : Const.PREFERENCES_OFF).commit();

        int miuiPermissionMode = preferences.getInt(Const.PREFERENCES_MIUI_PERMISSIONS, -1);
        if (miuiPermissionMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_PERMISSIONS, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_PERMISSIONS)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int miuiDeveloperMode = preferences.getInt(Const.PREFERENCES_MIUI_DEVELOPER, -1);
        if (miuiDeveloperMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_DEVELOPER, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_DEVELOPER)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int miuiOptimizationMode = preferences.getInt(Const.PREFERENCES_MIUI_OPTIMIZATION, -1);
        if (miuiOptimizationMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_OPTIMIZATION, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_OPTIMIZATION)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int unknownSourceMode = preferences.getInt(Const.PREFERENCES_UNKNOWN_SOURCES, -1);
        if (!deviceOwner && unknownSourceMode == -1) {
            if (checkUnknownSources()) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_UNKNOWN_SOURCES, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int administratorMode = preferences.getInt( Const.PREFERENCES_ADMINISTRATOR, - 1 );
//        RemoteLogger.log(this, Const.LOG_DEBUG, "Saved device admin state: " + administratorMode);
        if ( administratorMode == -1 ) {
            if (checkAdminMode()) {
                RemoteLogger.log(this, Const.LOG_DEBUG, "Saving device admin state as 1 (TRUE)");
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int overlayMode = preferences.getInt( Const.PREFERENCES_OVERLAY, - 1 );
        if (ProUtils.isPro() && overlayMode == -1 && needRequestOverlay()) {
            if ( checkAlarmWindow() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_OVERLAY, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int usageStatisticsMode = preferences.getInt( Const.PREFERENCES_USAGE_STATISTICS, - 1 );
        if (ProUtils.isPro() && usageStatisticsMode == -1 && needRequestUsageStats()) {
            if ( checkUsageStatistics() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_ON ).
                        commit();

                // If usage statistics is on, there's no need to turn on accessibility services
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF ).
                        commit();
            } else {
                return;
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            int manageStorageMode = preferences.getInt(Const.PREFERENCES_MANAGE_STORAGE, -1);
            if (manageStorageMode == -1) {
                if (checkManageStorage()) {
                    preferences.
                            edit().
                            putInt(Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_ON).
                            commit();
                } else {
                    return;
                }
            }
        }

        int accessibilityService = preferences.getInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, - 1 );
        // Check the same condition as for usage stats here
        // because accessibility is used as a secondary condition when usage stats is not available
        if (ProUtils.isPro() && BuildConfig.USE_ACCESSIBILITY && accessibilityService == -1 && needRequestUsageStats()) {
            if ( checkAccessibilityService() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_ON ).
                        commit();
            } else {
                createAndShowAccessibilityServiceDialog();
                return;
            }
        }

        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getLockStatusBar() != null && settingsHelper.getConfig().getLockStatusBar()) {
            // If the admin requested status bar lock (may be required for some early Samsung devices), block the status bar and right bar (App list) expansion
            statusBarView = ProUtils.preventStatusBarExpansion(this);
            rightToolbarView = ProUtils.preventApplicationsList(this);
        }

        createApplicationNotAllowedScreen();
        createLockScreen();
        startLauncher();
    }

    private void createAndShowPermissionsDialog() {
        dismissDialog(permissionsDialog);
        permissionsDialog = new Dialog( this );
        dialogPermissionsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_permissions,
                null,
                false );
        permissionsDialog.setCancelable( false );
        permissionsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        permissionsDialog.setContentView( dialogPermissionsBinding.getRoot() );
        permissionsDialog.show();
    }

    public void permissionsRetryClicked(View view) {
        dismissDialog(permissionsDialog);
        startLauncher();
    }

    public void permissionsExitClicked(View view) {
        dismissDialog(permissionsDialog);
        finish();
    }

    private void createAndShowAccessibilityServiceDialog() {
        dismissDialog(accessibilityServiceDialog);
        accessibilityServiceDialog = new Dialog( this );
        dialogAccessibilityServiceBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_accessibility_service,
                null,
                false );
        dialogAccessibilityServiceBinding.hint.setText(
                getString(R.string.dialog_accessibility_service_message, getString(R.string.white_app_name)));
        accessibilityServiceDialog.setCancelable( false );
        accessibilityServiceDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        accessibilityServiceDialog.setContentView( dialogAccessibilityServiceBinding.getRoot() );
        accessibilityServiceDialog.show();
    }

    public void skipAccessibilityService( View view ) {
        try { accessibilityServiceDialog.dismiss(); }
        catch ( Exception e ) { e.printStackTrace(); }
        accessibilityServiceDialog = null;

        preferences.
                edit().
                putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF ).
                commit();

        checkAndStartLauncher();
    }

    public void setAccessibilityService( View view ) {
        try { accessibilityServiceDialog.dismiss(); }
        catch ( Exception e ) { e.printStackTrace(); }
        accessibilityServiceDialog = null;

        Intent intent = new Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS);
        startActivityForResult(intent, 0);
    }

    // Accessibility services are needed in the Pro-version only
    private boolean checkAccessibilityService() {
        return ProUtils.checkAccessibilityService(this);
    }

    private void createLauncherButtons() {
        createExitButton();
        createInfoButton();
        createUpdateButton();
    }

    private void createButtons() {
        ServerConfig config = settingsHelper.getConfig();
        if (ProUtils.kioskModeRequired(this) && !getPackageName().equals(settingsHelper.getConfig().getMainApp())) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
                    !Settings.canDrawOverlays( this ) &&
                    !BuildConfig.ENABLE_KIOSK_WITHOUT_OVERLAYS) {
                RemoteLogger.log(this, Const.LOG_WARN, "Kiosk mode disabled: no permission to draw over other windows.");
                Toast.makeText(this, getString(R.string.kiosk_mode_requires_overlays,
                        getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
                config.setKioskMode(false);
                settingsHelper.updateConfig(config);
                createLauncherButtons();
                return;
            }
            View kioskUnlockButton = null;
            if (config.isKioskExit()) {     // Should be true by default, but false on older web panel versions
                kioskUnlockButton = ProUtils.createKioskUnlockButton(this);
            }
            if (kioskUnlockButton != null) {
                kioskUnlockButton.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        kioskUnlockCounter++;
                        if (kioskUnlockCounter >= Const.KIOSK_UNLOCK_CLICK_COUNT) {
                            // We are in the main app: let's open launcher activity
                            interruptResumeFlow = true;
                            Intent restoreLauncherIntent = new Intent(MainActivity.this, MainActivity.class);
                            restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
                            startActivity(restoreLauncherIntent);
                            createAndShowEnterPasswordDialog();
                            kioskUnlockCounter = 0;
                        }
                    }
                });
            }
        } else {
            createLauncherButtons();
        }
    }

    private void startLauncher() {
        createButtons();

        if (configUpdater.isPendingAppInstall()) {
            // Here we go after completing the user confirmed app installation
            configUpdater.repeatDownloadApps();
        } else if ( !checkPermissions(true)) {
            // Permissions are requested inside checkPermissions, so do nothing here
            Log.i(Const.LOG_TAG, "startLauncher: requesting permissions");
        } else if (!settingsHelper.isBaseUrlSet() && BuildConfig.REQUEST_SERVER_URL) {
            // For common public version, here's an option to change the server
            createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
        } else if ( settingsHelper.getDeviceId().length() == 0 ) {
            Log.d(Const.LOG_TAG, "Device ID is empty");
            Utils.autoGrantPhonePermission(this);
            if (!SystemUtils.autoSetDeviceId(this)) {
                createAndShowEnterDeviceIdDialog(false, null);
            } else {
                // Retry after automatical setting of device ID
                // We shouldn't get looping here because autoSetDeviceId cannot return true if deviceId.length == 0
                startLauncher();
            }
        } else if (!configInitialized) {
            Log.i(Const.LOG_TAG, "Updating configuration in startLauncher()");
            boolean userInteraction = true;
            boolean integratedProvisioningFlow = settingsHelper.isIntegratedProvisioningFlow();
            if (integratedProvisioningFlow) {
                // InitialSetupActivity just started and this is the first start after
                // the admin integrated provisioning flow, we need to show the process of loading apps
                // Notice the config is not null because it's preloaded in InitialSetupActivity
                settingsHelper.setIntegratedProvisioningFlow(false);
            }
            if (settingsHelper.getConfig() != null && !integratedProvisioningFlow) {
                // If it's not the first start, let's update in the background, show the content first!
                showContent(settingsHelper.getConfig());
                userInteraction = false;
            }
            updateConfig(userInteraction);
        } else {
            showContent(settingsHelper.getConfig());
        }
    }

    private boolean checkAdminMode() {
        if (!Utils.checkAdminMode(this)) {
            createAndShowAdministratorDialog();
            return false;
        }
        return true;
    }

    private boolean needRequestUsageStats() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (config == null) {
            // The app hasn't been properly provisioned because
            // config should be initialized in a setup activity.
            // So we request permissions anyway.
            return true;
        }
        // Usage stats is only required to detect unwanted apps
        // when permissive mode is off and kiosk mode is also off
        return !config.isPermissive() && !config.isKioskMode();
    }

    // Access to usage statistics is required in the Pro-version only
    private boolean checkUsageStatistics() {
        if (!ProUtils.checkUsageStatistics(this)) {
            if (SystemUtils.autoSetUsageStatsPermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (ProUtils.checkUsageStatistics(this)) {
                    return true;
                }
            }
            createAndShowHistorySettingsDialog();
            return false;
        }
        return true;
    }

    @RequiresApi(api = Build.VERSION_CODES.R)
    private boolean checkManageStorage() {
        if (!Environment.isExternalStorageManager()) {
            if (SystemUtils.autoSetStoragePermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (Environment.isExternalStorageManager()) {
                    return true;
                }
            }
            createAndShowManageStorageDialog();
            return false;
        }
        return true;
    }

    private boolean needRequestOverlay() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (config == null) {
            // The app hasn't been properly provisioned because
            // config should be initialized in a setup activity.
            // So we request permissions anyway.
            return true;
        }
        if (config.isKioskMode() && config.isKioskExit()) {
            // We need to draw the kiosk exit button
            return true;
        }
        if (!config.isKioskMode() && !config.isPermissive()) {
            // Overlay window is required to block unwanted apps
            return true;
        }
        return false;
    }

    private boolean checkAlarmWindow() {
        if (ProUtils.isPro() && !Utils.canDrawOverlays(this)) {
            if (SystemUtils.autoSetOverlayPermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (Utils.canDrawOverlays(this)) {
                    return true;
                }
            }
            createAndShowOverlaySettingsDialog();
            return false;
        } else {
            return true;
        }
    }

    private boolean checkMiuiPermissions(int screen) {
        // Permissions to open popup from background first appears in MIUI 11 (Android 9)
        // Also a workaround against https://qa.h-mdm.com/3119/
        if (Utils.isMiui(this) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
            createAndShowMiuiPermissionsDialog(screen);
            // It is not known how to check this setting programmatically, so return true
            return true;
        }
        return false;
    }

    private boolean checkUnknownSources() {
        if ( !Utils.canInstallPackages(this) ) {
            createAndShowUnknownSourcesDialog();
            return false;
        } else {
            return true;
        }
    }

    private WindowManager.LayoutParams overlayLockScreenParams() {
        WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = Utils.OverlayWindowType();
        layoutParams.gravity = Gravity.RIGHT;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL|WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

        layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.format = PixelFormat.TRANSPARENT;

        return layoutParams;
    }

    private void createApplicationNotAllowedScreen() {
        if ( applicationNotAllowed != null ) {
            return;
        }
        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));

        applicationNotAllowed = LayoutInflater.from( this ).inflate( R.layout.layout_application_not_allowed, null );
        applicationNotAllowed.findViewById( R.id.layout_application_not_allowed_continue ).setOnClickListener( new View.OnClickListener() {
            @Override
            public void onClick( View v ) {
                applicationNotAllowed.setVisibility( View.GONE );
            }
        } );
        applicationNotAllowed.findViewById( R.id.layout_application_not_allowed_admin ).setOnClickListener( new View.OnClickListener() {
            @Override
            public void onClick( View v ) {
                applicationNotAllowed.setVisibility( View.GONE );
                createAndShowEnterPasswordDialog();
            }
        } );
        final TextView tvPackageId = applicationNotAllowed.findViewById(R.id.package_id);
        tvPackageId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                    ClipData clip = ClipData.newPlainText("Package ID", tvPackageId.getText().toString());
                    clipboard.setPrimaryClip(clip);
                    Toast.makeText(MainActivity.this, R.string.package_id_copied, Toast.LENGTH_LONG).show();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        applicationNotAllowed.setVisibility( View.GONE );

        try {
            manager.addView( applicationNotAllowed, overlayLockScreenParams() );
        } catch ( Exception e ) {
            // No permission to show overlays; let's try to add view to main view
            try {
                RelativeLayout root = findViewById(R.id.activity_main);
                root.addView(applicationNotAllowed);
            } catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }
    }

    private void createLockScreen() {
        if ( lockScreen != null ) {
            return;
        }

        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));

        // Reuse existing "Application not allowed" screen but hide buttons
        lockScreen = LayoutInflater.from( this ).inflate( R.layout.layout_application_not_allowed, null );
        lockScreen.findViewById( R.id.layout_application_not_allowed_continue ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.layout_application_not_allowed_admin ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.package_id ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.message2 ).setVisibility(View.GONE);
        TextView textView = lockScreen.findViewById( R.id.message );
        textView.setText(getString(R.string.device_locked, SettingsHelper.getInstance(this).getDeviceId()));

        lockScreen.setVisibility( View.GONE );

        try {
            manager.addView( lockScreen, overlayLockScreenParams() );
        } catch ( Exception e ) {
            // No permission to show overlays; let's try to add view to main view
            try {
                RelativeLayout root = findViewById(R.id.activity_main);
                root.addView(lockScreen);
            } catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }
    }

    private boolean isDarkBackground() {
        try {
            ServerConfig config = settingsHelper.getConfig();
            if (config.getBackgroundColor() != null) {
                int color = Color.parseColor(config.getBackgroundColor());
                return !Utils.isLightColor(color);
            }
        } catch (Exception e) {
        }
        return true;
    }

    private ImageView createManageButton(int imageResource, int imageResourceBlack, int offset) {
        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        layoutParams.addRule(RelativeLayout.CENTER_VERTICAL);
        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);

        int offsetRight = 0;
        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getLockStatusBar() != null && settingsHelper.getConfig().getLockStatusBar()) {
            // If we lock the right bar, let's shift buttons to avoid overlapping
            offsetRight = getResources().getDimensionPixelOffset(R.dimen.prevent_applications_list_width);
        }

        RelativeLayout view = new RelativeLayout(this);
        // Offset is multiplied by 2 because the view is centered. Yeah I know its an Induism)
        view.setPadding(0, offset * 2, offsetRight, 0);
        view.setLayoutParams(layoutParams);

        ImageView manageButton = new ImageView( this );
        manageButton.setImageResource(isDarkBackground() ? imageResource : imageResourceBlack);
        view.addView(manageButton);

        selectedManageButtonBorder.setColor(0); // transparent background
        selectedManageButtonBorder.setStroke(2, isDarkBackground() ? 0xa0ffffff : 0xa0000000); // white or black border with some transparency
        manageButton.setOnFocusChangeListener((v, hasFocus) -> {
            v.setBackground(hasFocus ? selectedManageButtonBorder : null);
        });

        try {
            RelativeLayout root = findViewById(R.id.activity_main);
            root.addView(view);
        } catch ( Exception e ) { e.printStackTrace(); }
        return manageButton;
    }

    private void createExitButton() {
        if ( exitView != null ) {
            return;
        }
        exitView = createManageButton(R.drawable.ic_vpn_key_opaque_24dp, R.drawable.ic_vpn_key_black_24dp, 0);
        exitView.setOnClickListener(view -> {
            if (view.hasFocus()) {
                // 6 subsequent taps within 3 secs open the hidden password view
                long now = System.currentTimeMillis();
                if (exitFirstTapTime < now - 3000) {
                    exitFirstTapTime = now;
                    exitTapCount = 1;
                } else {
                    exitTapCount++;
                    if (exitTapCount >= 6) {
                        exitFirstTapTime = 0;
                        exitTapCount = 0;
                        createAndShowEnterPasswordDialog();
                    }
                }
            }
        });
        exitView.setOnLongClickListener(this);
    }
    private void createFlutterButton() {
        if ( exitView != null ) {
            return;
        }
        exitView = createManageButton(R.drawable.ic_bg_service_small, R.drawable.ic_bg_service_small, 0);
        exitView.setOnClickListener(view -> {
            if (view.hasFocus()) {
                // 6 subsequent taps within 3 secs open the hidden password view
                long now = System.currentTimeMillis();
                if (exitFirstTapTime < now - 3000) {
                    exitFirstTapTime = now;
                    exitTapCount = 1;
                } else {
                    exitTapCount++;
                    if (exitTapCount >= 6) {
                        exitFirstTapTime = 0;
                        exitTapCount = 0;
                        createAndShowEnterPasswordDialog();
                    }
                }
            }
        });
        exitView.setOnLongClickListener(this);
    }
    private void createInfoButton() {
        if ( infoView != null ) {
            return;
        }
        infoView = createManageButton(R.drawable.ic_info_opaque_24dp, R.drawable.ic_info_black_24dp,
                getResources().getDimensionPixelOffset(R.dimen.info_icon_margin));
        infoView.setOnClickListener(this);
    }

    private void createUpdateButton() {
        if ( updateView != null ) {
            return;
        }
        updateView = createManageButton(R.drawable.ic_system_update_opaque_24dp, R.drawable.ic_system_update_black_24dp,
                (int)(2.05f * getResources().getDimensionPixelOffset(R.dimen.info_icon_margin)));
        updateView.setOnClickListener(this);
    }

    // The userInteraction flag denotes whether the config has been updated from the UI or in the background
    // If this flag is set to true, network error dialog is displayed, and app update schedule is ignored
    private void updateConfig( final boolean userInteraction ) {
        needSendDeviceInfoAfterReconfigure = true;
        needRedrawContentAfterReconfigure = true;
        if (!orientationLocked && !BuildConfig.DISABLE_ORIENTATION_LOCK) {
            lockOrientation();
            orientationLocked = true;
        }
        configUpdater.updateConfig(this, this, userInteraction);
    }

    // Workaround against crash "App is in background" on Android 9: this is an Android OS bug
    // https://stackoverflow.com/questions/52013545/android-9-0-not-allowed-to-start-service-app-is-in-background-after-onresume
    private void startLocationServiceWithRetry() {
        try {
            startLocationService();
        } catch (Exception e) {
            // Android OS bug!!!
            e.printStackTrace();

            // Repeat an attempt to start service after one second
            handler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        startLocationService();
                    } catch (Exception e) {
                        // Still failed, now give up!
                        e.printStackTrace();
                    }
                }
            }, 1000);
        }
    }

    private void startLocationService() {
        ServerConfig config = settingsHelper.getConfig();
        Intent intent = new Intent(this, LocationService.class);
        intent.setAction(config.getRequestUpdates() != null ? config.getRequestUpdates() : LocationService.ACTION_STOP);
        startService(intent);
    }

    @Override
    public void onConfigUpdateStart() {
        binding.setMessage( getString( R.string.main_activity_update_config ) );
    }

    @Override
    public void onConfigUpdateServerError(String errorText) {
        if ( enterDeviceIdDialog != null ) {
            enterDeviceIdDialogBinding.setError( true );
            enterDeviceIdDialog.show();
        } else {
            networkErrorDetails = errorText;
            createAndShowEnterDeviceIdDialog( true, settingsHelper.getDeviceId() );
        }
    }

    @Override
    public void onConfigUpdateNetworkError(String errorText) {
        if (ProUtils.isKioskModeRunning(this) && settingsHelper.getConfig() != null &&
                !getPackageName().equals(settingsHelper.getConfig().getMainApp())) {
            interruptResumeFlow = true;
            Intent restoreLauncherIntent = new Intent(MainActivity.this, MainActivity.class);
            restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
            startActivity(restoreLauncherIntent);
        }
        // Do not show the reset button if the launcher is installed by scanning a QR code
        // Only show the reset button on manual setup at first start (when config is not yet loaded)
        createAndShowNetworkErrorDialog(settingsHelper.getBaseUrl(), settingsHelper.getServerProject(), errorText,
                settingsHelper.getConfig() == null && !settingsHelper.isQrProvisioning(),
                settingsHelper.getConfig() == null || (settingsHelper.getConfig() != null && settingsHelper.getConfig().isShowWifi()));
    }

    @Override
    public void onConfigLoaded() {
        applyEarlyPolicies(settingsHelper.getConfig());
    }

    @Override
    public void onPoliciesUpdated() {
        startLocationServiceWithRetry();
    }

    @Override
    public void onFileDownloading(RemoteFile remoteFile) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_file_downloading) + " " + remoteFile.getPath());
                binding.setDownloading( true );
            }
        } );
    }

    @Override
    public void onDownloadProgress(final int progress, final long total, final long current) {
        handler.post(new Runnable() {
            @Override
            public void run() {
                binding.progress.setMax(100);
                binding.progress.setProgress(progress);

                binding.setFileLength(total);
                binding.setDownloadedLength(current);
            }
        });
    }

    @Override
    public void onFileDownloadError(RemoteFile remoteFile) {
        if (!ProUtils.kioskModeRequired(this) && !isContentShown()) {
            // Notify the error dialog that we're downloading a file, not an app
            downloadingFile = true;
            createAndShowFileNotDownloadedDialog(remoteFile.getUrl());
            binding.setDownloading( false );
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadFiles();
        }
    }

    @Override
    public void onFileInstallError(RemoteFile remoteFile) {
        if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {
            try {
                new AlertDialog.Builder(MainActivity.this)
                        .setMessage(getString(R.string.file_create_error) + " " + remoteFile.getPath())
                        .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                configUpdater.skipDownloadFiles();
                            }
                        })
                        .create()
                        .show();
            } catch (Exception e) {
                // Activity closed before showing a dialog, just ignore this exception
                e.printStackTrace();
            }
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadFiles();
        }
    }

    @Override
    public void onAppUpdateStart() {
        binding.setMessage( getString( R.string.main_activity_applications_update ) );
        configInitialized = true;
    }

    @Override
    public void onAppInstalling(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_installing) + " " + application.getName());
                binding.setDownloading( false );
            }
        } );
    }

    @Override
    public void onAppDownloadError(Application application) {
        if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {
            // Notify the error dialog that we're downloading an app
            downloadingFile = false;
            createAndShowFileNotDownloadedDialog(application.getName());
            binding.setDownloading( false );
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadApps();
        }
    }

    @Override
    public void onAppInstallError(String packageName) {
        handler.post(new Runnable() {
            @Override
            public void run() {
                if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {

                    try {
                        new AlertDialog.Builder(MainActivity.this)
                                .setMessage(getString(R.string.install_error) + " " + packageName)
                                .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialog, int which) {
                                        configUpdater.repeatDownloadApps();
                                    }
                                })
                                .create()
                                .show();
                    } catch (Exception e) {
                        // Activity closed before showing a dialog, just ignore this exception
                        e.printStackTrace();
                    }
                } else {
                    // Avoid unexpected messages when the config is updated "silently"
                    // (in kiosk mode or when user is seeing the desktop
                    configUpdater.repeatDownloadApps();
                }
            }
        });
    }

    @Override
    public void onAppInstallComplete(String packageName) {

    }

    @Override
    public void onConfigUpdateComplete() {
        SharedPreferences preferences = getApplicationContext().getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        String deviceAdminLog = PreferenceLogger.getLogString(preferences);
        if (deviceAdminLog != null && !deviceAdminLog.equals("")) {
            RemoteLogger.log(this, Const.LOG_DEBUG, deviceAdminLog);
            PreferenceLogger.clearLogString(preferences);
        }
        Log.i(Const.LOG_TAG, "Showing content from setActions()");
        settingsHelper.refreshConfig(this);         // Avoid NPE in showContent()
        showContent(settingsHelper.getConfig());
    }

    @Override
    public void onAllAppInstallComplete() {
        Log.i(Const.LOG_TAG, "Refreshing content - new apps installed");
        settingsHelper.refreshConfig(this);         // Avoid NPE in showContent()
        handler.post(new Runnable() {
            @Override
            public void run() {
                showContent(settingsHelper.getConfig());
            }
        });
    }

    @Override
    public void onAppDownloading(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_downloading) + " " + application.getName());
                binding.setDownloading(true);
            }
        } );
    }

    @Override
    public void onAppRemoving(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_removing) + " " + application.getName());
                binding.setDownloading(false);
            }
        } );
    }

    private boolean applyEarlyPolicies(ServerConfig config) {
        Initializer.applyEarlyNonInteractivePolicies(this, config);
        return true;
    }

    // Network policies are applied after getting all applications
    // These are interactive policies so can't be used when in background mode
    private boolean applyLatePolicies(ServerConfig config) {
        // To delay opening the settings activity
        boolean dialogWillShow = false;

        if (config.getGps() != null) {
            LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
            if (lm != null) {
                boolean enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
                if (config.getGps() && !enabled) {
                    dialogWillShow = true;
                    // System settings dialog should return result so we could re-initialize location service
                    postDelayedSystemSettingDialog(getString(R.string.message_turn_on_gps),
                            new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);

                } else if (!config.getGps() && enabled) {
                    dialogWillShow = true;
                    postDelayedSystemSettingDialog(getString(R.string.message_turn_off_gps),
                            new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                }
            }
        }

        if (config.getMobileData() != null) {
            ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm != null && !dialogWillShow) {
                try {
                    boolean enabled = Utils.isMobileDataEnabled(this);
                    //final Intent mobileDataSettingsIntent = new Intent();
                    // One more hack: open the data transport activity
                    // https://stackoverflow.com/questions/31700842/which-intent-should-open-data-usage-screen-from-settings
                    //mobileDataSettingsIntent.setComponent(new ComponentName("com.android.settings",
                    //        "com.android.settings.Settings$DataUsageSummaryActivity"));
                    //Intent mobileDataSettingsIntent = new Intent(Intent.ACTION_MAIN);
                    //mobileDataSettingsIntent.setClassName("com.android.phone", "com.android.phone.NetworkSetting");
                    Intent mobileDataSettingsIntent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);
                    // Mobile data are turned on/off in the status bar! No settings (as the user can go back in settings and do something nasty)
                    if (config.getMobileData() && !enabled) {
                        postDelayedSystemSettingDialog(getString(R.string.message_turn_on_mobile_data), /*mobileDataSettingsIntent*/null);
                    } else if (!config.getMobileData() && enabled) {
                        postDelayedSystemSettingDialog(getString(R.string.message_turn_off_mobile_data), /*mobileDataSettingsIntent*/null);
                    }
                } catch (Exception e) {
                    // Some problem accessible private API
                }
            }
        }

        if (!Utils.setPasswordMode(config.getPasswordMode(), this)) {
            Intent updatePasswordIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);
            // Different Android versions/builds use different activities to setup password
            // So we have to enable temporary access to settings here (and only here!)
            postDelayedSystemSettingDialog(getString(R.string.message_set_password), updatePasswordIntent, null, true);
        }
        return true;
    }

    private boolean isContentShown() {
        if (binding != null) {
            return binding.getShowContent() != null && binding.getShowContent();
        }
        return false;
    }

    private void showContent(ServerConfig config ) {
        if (!applyEarlyPolicies(config)) {
            // Here we go when the settings window is opened;
            // Next time we're here after we returned from the Android settings through onResume()
            return;
        }

        applyLatePolicies(config);

        sendDeviceInfoAfterReconfigure();
        scheduleDeviceInfoSending();
        scheduleInstalledAppsRun();

        if (config.getLock() != null && config.getLock()) {
            showLockScreen();
            return;
        } else {
            hideLockScreen();
        }

        // Run default launcher option
        if (config.getRunDefaultLauncher() != null && config.getRunDefaultLauncher() &&
            !getPackageName().equals(Utils.getDefaultLauncher(this)) && !Utils.isLauncherIntent(getIntent())) {
            openDefaultLauncher();
            return;
        }

        if (orientationLocked && !BuildConfig.DISABLE_ORIENTATION_LOCK) {
            Utils.setOrientation(this, config);
            orientationLocked = false;
        }

        if (ProUtils.kioskModeRequired(this)) {
            String kioskApp = settingsHelper.getConfig().getMainApp();
            if (kioskApp != null && kioskApp.trim().length() > 0 &&
                    // If Headwind MDM itself is set as kiosk app, the kiosk mode is already turned on;
                    // So here we just proceed to drawing the content
                    (!kioskApp.equals(getPackageName()) || !ProUtils.isKioskModeRunning(this))) {
                if (ProUtils.getKioskAppIntent(kioskApp, this) != null && startKiosk(kioskApp)) {
                    getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                    return;
                } else {
                    Log.e(Const.LOG_TAG, "Kiosk mode failed, proceed with the default flow");
                }
            } else {
                if (kioskApp != null && kioskApp.equals(getPackageName()) && ProUtils.isKioskModeRunning(this)) {
                    // Here we go if the configuration is changed when launcher is in the kiosk mode
                    ProUtils.updateKioskAllowedApps(kioskApp, this, false);
                    ProUtils.updateKioskOptions(this);
                } else {
                    Log.e(Const.LOG_TAG, "Kiosk mode disabled: please setup the main app!");
                }
            }
        } else {
            if (ProUtils.isKioskModeRunning(this)) {
                // Turn off kiosk and show desktop if it is turned off in the configuration
                ProUtils.unlockKiosk(this);
                openDefaultLauncher();
            }
        }

        // TODO: Somehow binding is null here which causes a crash. Not sure why this could happen.
        if ( config.getBackgroundColor() != null ) {
            try {
                binding.activityMainContentWrapper.setBackgroundColor(Color.parseColor(config.getBackgroundColor()));
            } catch (Exception e) {
                // Invalid color
                e.printStackTrace();
                binding.activityMainContentWrapper.setBackgroundColor( getResources().getColor(R.color.defaultBackground));
            }
        } else {
            binding.activityMainContentWrapper.setBackgroundColor( getResources().getColor(R.color.defaultBackground));
        }
        updateTitle(config);

        statusBarUpdater.updateControlsState(config.isDisplayStatus(), isDarkBackground());

        if (mainAppListAdapter == null || needRedrawContentAfterReconfigure) {
            needRedrawContentAfterReconfigure = false;

            if ( config.getBackgroundImageUrl() != null && config.getBackgroundImageUrl().length() > 0 ) {
                if (picasso == null) {
                    // Initialize it once because otherwise it doesn't work offline
                    Picasso.Builder builder = new Picasso.Builder(this);
                    if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                        builder.downloader(new OkHttp3Downloader(UnsafeOkHttpClient.getUnsafeOkHttpClient()));
                    } else {
                        // Add signature to all requests to protect against unauthorized API calls
                        // For TRUST_ANY_CERTIFICATE, we won't add signatures because it's unsafe anyway
                        // and is just a workaround to use Headwind MDM on the LAN
                        OkHttpClient clientWithSignature = new OkHttpClient.Builder()
                                .cache(new Cache(new File(getApplication().getCacheDir(), "image_cache"), 1000000L))
                                .addInterceptor(chain -> {
                                    okhttp3.Request.Builder requestBuilder = chain.request().newBuilder();
                                    String signature = InstallUtils.getRequestSignature(chain.request().url().toString());
                                    if (signature != null) {
                                        requestBuilder.addHeader("X-Request-Signature", signature);
                                    }
                                    return chain.proceed(requestBuilder.build());

                                })
                                .build();
                        builder.downloader(new OkHttp3Downloader(clientWithSignature));
                    }
                    builder.listener(new Picasso.Listener()
                    {
                        @Override
                        public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception)
                        {
                            // On fault, get the background image from the cache
                            // This is a workaround against a bug in Picasso: it doesn't display cached images by default!
                            picasso.load(config.getBackgroundImageUrl())
                                    .networkPolicy(NetworkPolicy.OFFLINE)
                                    .fit()
                                    .centerCrop()
                                    .into(binding.activityMainBackground);
                        }
                    });
                    picasso = builder.build();
                }

                picasso.load(config.getBackgroundImageUrl())
                    // fit and centerCrop is a workaround against a crash on too large images on some devices
                    .fit()
                    .centerCrop()
                    .into(binding.activityMainBackground);

            } else {
                binding.activityMainBackground.setImageDrawable(null);
            }

            Display display = getWindowManager().getDefaultDisplay();
            Point size = new Point();
            display.getSize(size);

            int width = size.x;
            int itemWidth = getResources().getDimensionPixelSize(R.dimen.app_list_item_size);

            spanCount = (int) (width * 1.0f / itemWidth);
            mainAppListAdapter = new MainAppListAdapter(this, this, this);
            mainAppListAdapter.setSpanCount(spanCount);

            binding.activityMainContent.setLayoutManager(new GridLayoutManager(this, spanCount));
            binding.activityMainContent.setAdapter(mainAppListAdapter);
            mainAppListAdapter.notifyDataSetChanged();

            int bottomAppCount = AppShortcutManager.getInstance().getInstalledAppCount(this, true);
            if (bottomAppCount > 0) {
                bottomAppListAdapter = new BottomAppListAdapter(this, this, this);
                bottomAppListAdapter.setSpanCount(spanCount);

                binding.activityBottomLayout.setVisibility(View.VISIBLE);
                binding.activityBottomLine.setLayoutManager(new GridLayoutManager(this, bottomAppCount < spanCount ? bottomAppCount : spanCount));
                binding.activityBottomLine.setAdapter(bottomAppListAdapter);
                bottomAppListAdapter.notifyDataSetChanged();
            } else {
                bottomAppListAdapter = null;
                binding.activityBottomLayout.setVisibility(View.GONE);
            }
        }
        binding.loading.setVisibility(View.GONE);
        binding.setShowContent(true);
        // We can now sleep, uh
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        Log.d("FLUTTER_LAUNCHER", "showContent() is complete. Finding the Flutter button.");
        Button flutterButton = findViewById(R.id.openFlutterButton);

        if (flutterButton == null) {
            Log.e("FLUTTER_LAUNCHER", "ERROR: The Flutter button is NULL even in showContent(). Check the XML file and ID.");
        } else {
            Log.d("FLUTTER_LAUNCHER", "Flutter button found successfully! Setting the listener.");
            flutterButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    Log.d("FLUTTER_LAUNCHER", "Button clicked! Launching FlutterActivity.");
                    startActivity(
                            FlutterActivity.createDefaultIntent(MainActivity.this)
                    );
                }
            });
        }
    }

    // Added an option to delay restarting the kiosk app
    // Because some apps need time to finish their work
    private boolean startKiosk(String kioskApp) {
        String kioskDelayStr = settingsHelper.getAppPreference(getPackageName(), "kiosk_restart_delay_ms");
        int kioskDelay = 0;
        try {
            if (kioskDelayStr != null) {
                kioskDelay = Integer.parseInt(kioskDelayStr);
            }
        } catch (/*NumberFormat*/Exception e) {
        }
        if (kioskDelay == 0) {
            // Standard flow: no delay as earlier
            return ProUtils.startCosuKioskMode(kioskApp, MainActivity.this, false);
        } else {
            // Delayed kiosk start
            handler.postDelayed(() -> ProUtils.startCosuKioskMode(kioskApp, MainActivity.this, false), kioskDelay);
            return true;
        }
    }

    private void showLockScreen() {
        if (lockScreen == null) {
            createLockScreen();
            if (lockScreen == null) {
                // Why cannot we create the lock screen? Give up and return
                // The locked device will show the launcher, but still cannot run any application
                return;
            }
        }
        String lockAdminMessage = settingsHelper.getConfig().getLockMessage();
        String lockMessage = getString(R.string.device_locked, SettingsHelper.getInstance(this).getDeviceId());
        if (lockAdminMessage != null) {
            lockMessage += " " + lockAdminMessage;
        }
        TextView textView = lockScreen.findViewById( R.id.message );
        textView.setText(lockMessage);
        lockScreen.setVisibility(View.VISIBLE);
    }

    private void hideLockScreen() {
        if (lockScreen != null && lockScreen.getVisibility() == View.VISIBLE) {
            lockScreen.setVisibility(View.GONE);
        }
    }

    private void notifyPolicyViolation(int cause) {
        switch (cause) {
            case Const.GPS_ON_REQUIRED:
                postDelayedSystemSettingDialog(getString(R.string.message_turn_on_gps),
                        new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                break;
            case Const.GPS_OFF_REQUIRED:
                postDelayedSystemSettingDialog(getString(R.string.message_turn_off_gps),
                        new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                break;
            case Const.MOBILE_DATA_ON_REQUIRED:
                createAndShowSystemSettingDialog(getString(R.string.message_turn_on_mobile_data), null, 0);
                break;
            case Const.MOBILE_DATA_OFF_REQUIRED:
                createAndShowSystemSettingDialog(getString(R.string.message_turn_off_mobile_data), null, 0);
                break;
        }
    }

    // Run default launcher (Headwind MDM) as if the user clicked Home button
    private void openDefaultLauncher() {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(intent);
    }

    // If we updated the configuration, let's send the final state to the server
    private void sendDeviceInfoAfterReconfigure() {
        if (needSendDeviceInfoAfterReconfigure) {
            needSendDeviceInfoAfterReconfigure = false;
            SendDeviceInfoTask sendDeviceInfoTask = new SendDeviceInfoTask(this);
            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(this, true, true);
            sendDeviceInfoTask.execute(deviceInfo);
        }
    }

    private void scheduleDeviceInfoSending() {
        if (sendDeviceInfoScheduled) {
            return;
        }
        sendDeviceInfoScheduled = true;
        SendDeviceInfoWorker.scheduleDeviceInfoSending(this);
    }

    private void scheduleInstalledAppsRun() {
        List<Application> applicationsForRun = configUpdater.getApplicationsForRun();

        if (applicationsForRun.size() == 0) {
            return;
        }
        int pause = PAUSE_BETWEEN_AUTORUNS_SEC;
        while (applicationsForRun.size() > 0) {
            final Application application = applicationsForRun.get(0);
            applicationsForRun.remove(0);
            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    Intent launchIntent = getPackageManager().getLaunchIntentForPackage(application.getPkg());
                    if (launchIntent != null) {
                        startActivity(launchIntent);
                    }
                }
            }, pause * 1000);
            pause += PAUSE_BETWEEN_AUTORUNS_SEC;
        }
    }

    private void updateTitle(ServerConfig config) {
        String titleType = config.getTitle();
        if (titleType != null) {
            if (titleType.equals(ServerConfig.TITLE_NONE)) {
                binding.activityMainTitle.setVisibility(View.GONE);
                return;
            }
            if (config.getTextColor() != null) {
                try {
                    binding.activityMainTitle.setTextColor(Color.parseColor(settingsHelper.getConfig().getTextColor()));
                } catch (Exception e) {
                    // Invalid color
                    e.printStackTrace();
                }
            }
            binding.activityMainTitle.setVisibility(View.VISIBLE);
            String imei = DeviceInfoProvider.getImei(this);
            if (imei == null) {
                imei = "";
            }
            String serial = DeviceInfoProvider.getSerialNumber();
            if (serial == null) {
                serial = "";
            }
            String ip = SettingsHelper.getInstance(this).getExternalIp();
            if (ip == null) {
                ip = "";
            }
            String titleText = titleType
                    .replace(ServerConfig.TITLE_DEVICE_ID, SettingsHelper.getInstance(this).getDeviceId())
                    .replace(ServerConfig.TITLE_DESCRIPTION, config.getDescription() != null ? config.getDescription() : "")
                    .replace(ServerConfig.TITLE_CUSTOM1, config.getCustom1() != null ? config.getCustom1() : "")
                    .replace(ServerConfig.TITLE_CUSTOM2, config.getCustom2() != null ? config.getCustom2() : "")
                    .replace(ServerConfig.TITLE_CUSTOM3, config.getCustom3() != null ? config.getCustom3() : "")
                    .replace(ServerConfig.TITLE_IMEI, imei)
                    .replace(ServerConfig.TITLE_SERIAL, serial)
                    .replace(ServerConfig.TITLE_EXTERNAL_IP, ip)
                    .replace("\\n", "\n");
            binding.activityMainTitle.setText(titleText);
        } else {
            binding.activityMainTitle.setVisibility(View.GONE);
        }

    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        settingsHelper.setMainActivityRunning(false);

        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));
        if ( applicationNotAllowed != null ) {
            try { manager.removeView( applicationNotAllowed ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( statusBarView != null ) {
            try { manager.removeView( statusBarView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( rightToolbarView != null ) {
            try { manager.removeView( rightToolbarView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( exitView != null ) {
            try { manager.removeView( exitView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( infoView != null ) {
            try { manager.removeView( infoView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( updateView != null ) {
            try { manager.removeView( updateView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        try {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
            unregisterReceiver(stateChangeReceiver);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();

        isBackground = true;

        statusBarUpdater.stopUpdating();

        dismissDialog(fileNotDownloadedDialog);
        dismissDialog(enterServerDialog);
        dismissDialog(enterDeviceIdDialog);
        dismissDialog(networkErrorDialog);
        dismissDialog(enterPasswordDialog);
        dismissDialog(historySettingsDialog);
        dismissDialog(unknownSourcesDialog);
        dismissDialog(overlaySettingsDialog);
        dismissDialog(administratorModeDialog);
        dismissDialog(deviceInfoDialog);
        dismissDialog(accessibilityServiceDialog);
        dismissDialog(systemSettingsDialog);
        dismissDialog(permissionsDialog);

        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_SHOW_LAUNCHER ) );
    }

    private void createAndShowAdministratorDialog() {
        dismissDialog(administratorModeDialog);
        administratorModeDialog = new Dialog( this );
        dialogAdministratorModeBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_administrator_mode,
                null,
                false );
        dialogAdministratorModeBinding.hint.setText(
                getString(R.string.dialog_administrator_mode_message, getString(R.string.white_app_name)));
        administratorModeDialog.setCancelable( false );
        administratorModeDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        administratorModeDialog.setContentView( dialogAdministratorModeBinding.getRoot() );
        administratorModeDialog.show();
    }

    public void skipAdminMode( View view ) {
        dismissDialog(administratorModeDialog);

        RemoteLogger.log(this, Const.LOG_INFO, "Manually skipped the device admin permissions setup");
        preferences.
                edit().
                putInt( Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_OFF ).
                commit();

        checkAndStartLauncher();
    }

    public void setAdminMode( View view ) {
        dismissDialog(administratorModeDialog);
        // Use a proxy activity because of an Android bug (see comment to AdminModeRequestActivity!)
        startActivity( new Intent( MainActivity.this, AdminModeRequestActivity.class ) );
    }

    private void createAndShowFileNotDownloadedDialog(String fileName) {
        dismissDialog(fileNotDownloadedDialog);
        fileNotDownloadedDialog = new Dialog( this );
        dialogFileDownloadingFailedBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_file_downloading_failed,
                null,
                false );
        int errorTextResource = this.downloadingFile ? R.string.main_file_downloading_error : R.string.main_app_downloading_error;
        dialogFileDownloadingFailedBinding.title.setText( getString(errorTextResource) + " " + fileName );
        fileNotDownloadedDialog.setCancelable( false );
        fileNotDownloadedDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        fileNotDownloadedDialog.setContentView( dialogFileDownloadingFailedBinding.getRoot() );
        try {
            fileNotDownloadedDialog.show();
        } catch (Exception e) {
            // BadTokenException ignored
        }
    }

    public void repeatDownloadClicked( View view ) {
        dismissDialog(fileNotDownloadedDialog);
        if (downloadingFile) {
            configUpdater.repeatDownloadFiles();
        } else {
            configUpdater.repeatDownloadApps();
        }
    }

    public void confirmDownloadFailureClicked( View view ) {
        dismissDialog(fileNotDownloadedDialog);

        if (downloadingFile) {
            configUpdater.skipDownloadFiles();
        } else {
            configUpdater.skipDownloadApps();
        }
    }

    private void createAndShowHistorySettingsDialog() {
        dismissDialog(historySettingsDialog);
        historySettingsDialog = new Dialog( this );
        dialogHistorySettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_history_settings,
                null,
                false );
        dialogHistorySettingsBinding.hint.setText(
                getString(R.string.dialog_history_settings_title, getString(R.string.white_app_name)));
        historySettingsDialog.setCancelable( false );
        historySettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        historySettingsDialog.setContentView( dialogHistorySettingsBinding.getRoot() );
        historySettingsDialog.show();
    }

    public void historyWithoutPermission( View view ) {
        dismissDialog(historySettingsDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueHistory( View view ) {
        dismissDialog(historySettingsDialog);

        startActivity( new Intent( Settings.ACTION_USAGE_ACCESS_SETTINGS ) );
    }

    private void createAndShowManageStorageDialog() {
        dismissDialog(manageStorageDialog);
        manageStorageDialog = new Dialog( this );
        dialogManageStorageBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_manage_storage,
                null,
                false );
        manageStorageDialog.setCancelable( false );
        manageStorageDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        manageStorageDialog.setContentView( dialogManageStorageBinding.getRoot() );
        manageStorageDialog.show();
    }

    public void storageWithoutPermission(View view) {
        dismissDialog(manageStorageDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueStorage(View view) {
        dismissDialog(manageStorageDialog);
        try {
            Intent intent = new Intent();
            intent.setAction(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
            Uri uri = Uri.fromParts("package", this.getPackageName(), null);
            intent.setData(uri);
            startActivity(intent);
        } catch (Exception e) {
            try {
                Intent intent = new Intent();
                intent.setAction(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);
                startActivity(intent);
            } catch (Exception e1) {
                Toast.makeText(this, R.string.manage_storage_not_supported, Toast.LENGTH_LONG).show();
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_OFF ).
                        commit();
                checkAndStartLauncher();
            }
        }
    }

    private void createAndShowOverlaySettingsDialog() {
        dismissDialog(overlaySettingsDialog);
        overlaySettingsDialog = new Dialog( this );
        dialogOverlaySettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_overlay_settings,
                null,
                false );
        dialogOverlaySettingsBinding.hint.setText(
                getString(R.string.dialog_overlay_settings_title, getString(R.string.white_app_name)));
        overlaySettingsDialog.setCancelable( false );
        overlaySettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        overlaySettingsDialog.setContentView( dialogOverlaySettingsBinding.getRoot() );
        overlaySettingsDialog.show();
    }

    public void overlayWithoutPermission( View view ) {
        dismissDialog(overlaySettingsDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_OVERLAY, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueOverlay( View view ) {
        dismissDialog(overlaySettingsDialog);

        Intent intent = new Intent( Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                Uri.parse( "package:" + getPackageName() ) );
        try {
            startActivityForResult(intent, 1001);
        } catch (/* ActivityNotFound*/Exception e) {
            Toast.makeText(this, R.string.overlays_not_supported, Toast.LENGTH_LONG).show();
            overlayWithoutPermission(view);
        }
    }


    public void saveDeviceId( View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString();
        if ( "".equals( deviceId ) ) {
            return;
        } else {
            settingsHelper.setDeviceId( deviceId );
            enterDeviceIdDialogBinding.setError( false );

            dismissDialog(enterDeviceIdDialog);

            if ( checkPermissions( true ) ) {
                Log.i(Const.LOG_TAG, "saveDeviceId(): calling updateConfig()");
                updateConfig( true );
            }
        }
    }


    public void saveServerUrl( View view ) {
        if (saveServerUrlBase()) {
            ServerServiceKeeper.resetServices();
            checkAndStartLauncher();
        }
    }


    public void networkErrorRepeatClicked( View view ) {
        dismissDialog(networkErrorDialog);

        Log.i(Const.LOG_TAG, "networkErrorRepeatClicked(): calling updateConfig()");
        updateConfig( true );
    }

    public void networkErrorResetClicked( View view ) {
        dismissDialog(networkErrorDialog);

        Log.i(Const.LOG_TAG, "networkErrorResetClicked(): calling updateConfig()");
        settingsHelper.setDeviceId("");
        settingsHelper.setBaseUrl("");
        settingsHelper.setSecondaryBaseUrl("");
        settingsHelper.setServerProject("");
        createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
    }

    public void networkErrorWifiClicked( View view ) {
        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        if (ProUtils.kioskModeRequired(this) && ProUtils.isKioskModeRunning(this)) {
            String kioskApp = settingsHelper.getConfig().getMainApp();
            ProUtils.startCosuKioskMode(kioskApp, this, true);
        }
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
            }
        }, 500);
    }

    public void networkErrorCancelClicked(View view) {
        dismissDialog(networkErrorDialog);

        if (configFault) {
            Log.i(Const.LOG_TAG, "networkErrorCancelClicked(): no configuration available, quit");
            Toast.makeText(this, getString(R.string.critical_server_failure,
                    getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
            finish();
            return;
        }

        Log.i(Const.LOG_TAG, "networkErrorCancelClicked()");
        if ( settingsHelper.getConfig() != null ) {
            showContent( settingsHelper.getConfig() );
            configUpdater.skipConfigLoad();
        } else {
            Log.i(Const.LOG_TAG, "networkErrorCancelClicked(): no configuration available, retrying");
            Toast.makeText(this, R.string.empty_configuration, Toast.LENGTH_LONG).show();
            configFault = true;
            updateConfig( false );
        }
    }

    public void networkErrorDetailsClicked(View view) {
        ErrorDetailsActivity.display(this, networkErrorDetails, false);
    }

    private boolean checkPermissions( boolean startSettings ) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            return true;
        }

        // If the user didn't grant permissions, let him know and do not request until he confirms he want to retry
        if (permissionsDialog != null && permissionsDialog.isShowing()) {
            return false;
        }

        if (Utils.isDeviceOwner(this)) {
            if (settingsHelper.getConfig() != null && (ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(settingsHelper.getConfig().getAppPermissions()) ||
                    ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(settingsHelper.getConfig().getAppPermissions()))) {
                // Even in device owner mode, if "Ask for location" is requested by the admin,
                // let's ask permissions (so do nothing here, fall through)
            } else {
                // Do not request permissions if we're the device owner
                // They are added automatically
                return true;
            }
        }

        if (preferences.getInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            if ((Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                (Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                    checkSelfPermission(Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {

                if (startSettings) {
                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_EXTERNAL_STORAGE,
                                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    } else {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    }
                }
                return false;
            } else {
                return true;
            }
        } else {
            return checkLocationPermissions(startSettings);
        }
    }

    // Location permissions request on Android 10 and above is rather tricky (shame on Google for their stupid logic!!!)
    // So it's implemented in a separate method
    @RequiresApi(api = Build.VERSION_CODES.M)
    private boolean checkLocationPermissions(boolean startSettings) {
        if ((Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                (Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||
                (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED) ||
                checkSelfPermission(Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {

            if (startSettings) {
                boolean activeModeLocation = false;
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    try {
                        activeModeLocation = checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED &&
                                checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED /* &&
                                !ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION)*/;
                    } catch (Exception e) {
                        // On some older models:
                        // java.lang.IllegalArgumentException
                        // Unknown permission: android.permission.ACCESS_BACKGROUND_LOCATION
                        // Update: since there's the Android version check, we should never be here!
                        e.printStackTrace();
                    }
                }

                if (activeModeLocation) {
                    // The following flow happened
                    // The user has enabled locations, but when the app prompted for the background location,
                    // the user clicked "Locations only in active mode".
                    // In this case, requestPermissions won't show dialog any more!
                    // So we need to open the general permissions dialog
                    // Let's confirm with the user once again, then display the settings sheet
                    try {
                        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
                        new AlertDialog.Builder(MainActivity.this)
                                .setMessage(getString(R.string.background_location, getString(R.string.white_app_name)))
                                .setPositiveButton(R.string.background_location_continue, (dialog, which) -> {
                                    startActivity(new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
                                            Uri.fromParts("package", getPackageName(), null)));
                                })
                                .setNegativeButton(R.string.location_disable, (dialog, which) -> {
                                    preferences.edit().putInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_ON).commit();
                                    // Continue the main flow!
                                    startLauncher();
                                })
                                .create()
                                .show();
                    } catch (Exception e) {
                        // Activity closed before showing a dialog, just ignore this exception
                        e.printStackTrace();
                    }
                } else {
                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_EXTERNAL_STORAGE,
                                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                                Manifest.permission.ACCESS_FINE_LOCATION,
                                Manifest.permission.ACCESS_BACKGROUND_LOCATION,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    } else {
                        requestPermissions(new String[]{
                                Manifest.permission.ACCESS_FINE_LOCATION,
// This location can't be requested here: the dialog fails to show when we use SDK 30+
// https://developer.android.com/develop/sensors-and-location/location/permissions#request-location-access-runtime
//                                Manifest.permission.ACCESS_BACKGROUND_LOCATION,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    }
                }
            }
            return false;
        } else {
            return true;
        }

    }

    private void createAndShowEnterPasswordDialog() {
        dismissDialog(enterPasswordDialog);
        enterPasswordDialog = new Dialog( this );
        dialogEnterPasswordBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_password,
                null,
                false );
        enterPasswordDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        enterPasswordDialog.setCancelable( false );

        enterPasswordDialog.setContentView( dialogEnterPasswordBinding.getRoot() );
        dialogEnterPasswordBinding.setLoading( false );
        try {
            enterPasswordDialog.show();
        } catch (Exception e) {
            // Sometimes here we get a Fatal Exception: android.view.WindowManager$BadTokenException
            // Unable to add window -- token android.os.BinderProxy@f307de for displayid = 0 is not valid; is your activity running?
            Toast.makeText(getApplicationContext(), R.string.internal_error, Toast.LENGTH_LONG).show();
        }
    }

    public void closeEnterPasswordDialog( View view ) {
        dismissDialog(enterPasswordDialog);
        if (ProUtils.kioskModeRequired(this)) {
            checkAndStartLauncher();
            updateConfig(false);
        }
    }

    public void checkAdministratorPassword( View view ) {
        dialogEnterPasswordBinding.setLoading( true );
        GetServerConfigTask task = new GetServerConfigTask( this ) {
            @Override
            protected void onPostExecute( Integer result ) {
                dialogEnterPasswordBinding.setLoading( false );

                String masterPassword = CryptoHelper.getMD5String( "12345678" );
                if ( settingsHelper.getConfig() != null && settingsHelper.getConfig().getPassword() != null ) {
                    masterPassword = settingsHelper.getConfig().getPassword();
                }

                if ( CryptoHelper.getMD5String( dialogEnterPasswordBinding.password.getText().toString() ).
                        equals( masterPassword ) ) {
                    dismissDialog(enterPasswordDialog);
                    dialogEnterPasswordBinding.setError( false );
                    openAdminPanel();
                } else {
                    dialogEnterPasswordBinding.setError( true );
                }
            }
        };
        task.execute();
    }

    private void openAdminPanel() {
        if (ProUtils.kioskModeRequired(MainActivity.this)) {
            ProUtils.unlockKiosk(MainActivity.this);
        }
        RemoteLogger.log(MainActivity.this, Const.LOG_INFO, "Administrator panel opened");
        startActivity( new Intent( MainActivity.this, AdminActivity.class ) );
    }

    private void createAndShowUnknownSourcesDialog() {
        dismissDialog(unknownSourcesDialog);
        unknownSourcesDialog = new Dialog( this );
        dialogUnknownSourcesBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_unknown_sources,
                null,
                false );
        unknownSourcesDialog.setCancelable( false );
        unknownSourcesDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        unknownSourcesDialog.setContentView( dialogUnknownSourcesBinding.getRoot() );
        unknownSourcesDialog.show();
    }

    public void continueUnknownSources( View view ) {
        dismissDialog(unknownSourcesDialog);
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            startActivity(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS));
        } else {
            // In Android Oreo and above, permission to install packages are set per each app
            startActivity(new Intent(android.provider.Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, Uri.parse("package:" + getPackageName())));
        }
    }

    private void createAndShowMiuiPermissionsDialog(int screen) {
        dismissDialog(miuiPermissionsDialog);
        miuiPermissionsDialog = new Dialog( this );
        dialogMiuiPermissionsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_miui_permissions,
                null,
                false );
        miuiPermissionsDialog.setCancelable( false );
        miuiPermissionsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        switch (screen) {
            case Const.MIUI_PERMISSIONS:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_permissions_title);
                break;
            case Const.MIUI_DEVELOPER:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_developer_title);
                break;
            case Const.MIUI_OPTIMIZATION:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_optimization_title);
                break;
        }

        miuiPermissionsDialog.setContentView( dialogMiuiPermissionsBinding.getRoot() );
        miuiPermissionsDialog.show();
    }

    public void continueMiuiPermissions( View view ) {
        String titleText = dialogMiuiPermissionsBinding.title.getText().toString();
        dismissDialog(miuiPermissionsDialog);

        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        Intent intent;
        if (titleText.equals(getString(R.string.dialog_miui_permissions_title))) {
            intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            Uri uri = Uri.fromParts("package", getPackageName(), null);
            intent.setData(uri);
        } else if (titleText.equals(getString(R.string.dialog_miui_developer_title))) {
            intent = new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS);
        } else {
            // if (titleText.equals(getString(R.string.dialog_miui_optimization_title))
            intent = new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS);
        }
        try {
            startActivity(intent);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onBackPressed() {}

    @Override
    public void onAppChoose( @NonNull AppInfo resolveInfo ) {

    }

    @Override
    public boolean switchAppListAdapter(BaseAppListAdapter adapter, int direction) {
        if (adapter == mainAppListAdapter && bottomAppListAdapter != null &&
                (direction == Const.DIRECTION_RIGHT || direction == Const.DIRECTION_DOWN)) {
            bottomAppListAdapter.setFocused(true);
            return true;
        } else if (adapter == bottomAppListAdapter &&
                (direction == Const.DIRECTION_LEFT || direction == Const.DIRECTION_UP)) {
            mainAppListAdapter.setFocused(true);
            return true;
        }
        return false;
    }

    @Override
    public boolean onLongClick( View v ) {
        createAndShowEnterPasswordDialog();
        return true;
    }

    @Override
    public void onClick( View v ) {
        if (v.equals(infoView)) {
            createAndShowInfoDialog();
        } else if (v.equals(updateView)) {
            if (enterDeviceIdDialog != null && enterDeviceIdDialog.isShowing()) {
                Log.i(Const.LOG_TAG, "Occasional update request when device info is entered, ignoring!");
                return;
            }
            Log.i(Const.LOG_TAG, "updating config on request");
            binding.loading.setVisibility(View.VISIBLE);
            binding.setShowContent(false);
            getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
            updateConfig(true);
        }
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent) {
        postDelayedSystemSettingDialog(message, settingsIntent, null);
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode) {
        postDelayedSystemSettingDialog(message, settingsIntent, requestCode, false);
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode, final boolean forceEnableSettings) {
        if (settingsIntent != null) {
            // If settings are controlled by usage stats, safe settings are allowed, so we need to enable settings in accessibility mode only
            // Accessibility mode is only enabled when usage stats is off
            if (preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON || forceEnableSettings) {
                LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
            }
            LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_STOP_CONTROL));
        }
        // Delayed start prevents the race of ENABLE_SETTINGS handle and tapping "Next" button
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                createAndShowSystemSettingDialog(message, settingsIntent, requestCode);
            }
        }, 5000);
    }

    private void createAndShowSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode) {
        dismissDialog(systemSettingsDialog);
        systemSettingsDialog = new Dialog( this );
        dialogSystemSettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_system_settings,
                null,
                false );
        systemSettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        systemSettingsDialog.setCancelable( false );

        systemSettingsDialog.setContentView( dialogSystemSettingsBinding.getRoot() );

        dialogSystemSettingsBinding.setMessage(message);

        // Since we need to send Intent to the listener, here we don't use "event" attribute in XML resource as everywhere else
        systemSettingsDialog.findViewById(R.id.continueButton).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dismissDialog(systemSettingsDialog);
                if (settingsIntent == null) {
                    return;
                }
                // Enable settings once again, because the dialog may be shown more than 3 minutes
                // This is not necessary: the problem is resolved by clicking "Continue" in a popup window
                /*LocalBroadcastManager.getInstance( MainActivity.this ).sendBroadcast( new Intent( Const.ACTION_ENABLE_SETTINGS ) );
                // Open settings with a slight delay so Broadcast would certainly be handled
                handler.postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        startActivity(settingsIntent);
                    }
                }, 300);*/
                try {
                    startActivityOptionalResult(settingsIntent, requestCode);
                } catch (/*ActivityNotFound*/Exception e) {
                    // Open settings by default
                    startActivityOptionalResult(new Intent(android.provider.Settings.ACTION_SETTINGS), requestCode);
                }
            }
        });

        try {
            systemSettingsDialog.show();
        } catch (Exception e) {
            // BadTokenException: activity closed before dialog is shown
            RemoteLogger.log(this, Const.LOG_WARN, "Failed to open a popup system dialog! " + e.getMessage());
            e.printStackTrace();
            systemSettingsDialog = null;
        }
    }

    private void startActivityOptionalResult(Intent intent, Integer requestCode) {
        if (requestCode != null) {
            startActivityForResult(intent, requestCode);
        } else {
            startActivity(intent);
        }
    }

    // The following algorithm of launcher restart works in EMUI:
    // Run EMUI_LAUNCHER_RESTARTER activity once and send the old version number to it.
    // The restarter application will check the launcher version each second, and restart it
    // when it is changed.
    private void startLauncherRestarter() {
        // Sending an intent before updating, otherwise the launcher may be terminated at any time
        Intent intent = getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
        if (intent == null) {
            Log.i("LauncherRestarter", "No restarter app, please add it in the config!");
            return;
        }
        intent.putExtra(Const.LAUNCHER_RESTARTER_OLD_VERSION, BuildConfig.VERSION_NAME);
        startActivity(intent);
        Log.i("LauncherRestarter", "Calling launcher restarter from the launcher");
    }

    // Create a new file from the template file
    // (replace DEVICE_NUMBER, IMEI, CUSTOM* by their values)
    private void createFileFromTemplate(File srcFile, File dstFile, String deviceId, ServerConfig config) throws IOException {
        // We are supposed to process only small text files
        // So here we are reading the whole file, replacing variables, and save the content
        // It is not optimal for large files - it would be better to replace in a stream (how?)
        String content = FileUtils.readFileToString(srcFile);
        content = content.replace("DEVICE_NUMBER", deviceId)
                .replace("CUSTOM1", config.getCustom1() != null ? config.getCustom1() : "")
                .replace("CUSTOM2", config.getCustom2() != null ? config.getCustom2() : "")
                .replace("CUSTOM3", config.getCustom3() != null ? config.getCustom3() : "");
        FileUtils.writeStringToFile(dstFile, content);
    }
}
</file>

<file path="app/build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
    repositories {
        jcenter()
    }
}
apply plugin: 'com.android.application'

repositories {
    jcenter()
    mavenCentral()
}

android {
    compileSdkVersion 34
    defaultConfig {
        applicationId "com.hmdm.launcher"
        minSdkVersion 24
        targetSdkVersion 34
        versionCode 15250
        versionName "6.26"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        dataBinding {
            enabled = true
        }
        buildFeatures {
            aidl true
            buildConfig = true
        }
        namespace 'com.hmdm.launcher'
        multiDexEnabled true

        // Default URL of the web panel (scheme + host!)
        buildConfigField("String", "BASE_URL", "\"https://app.h-mdm.com\"")
        // URL of the secondary address of your web panel, called when the primary host is not available.
        // Could be equal to the BASE_URL parameter
        buildConfigField("String", "SECONDARY_BASE_URL", "\"https://app.h-mdm.com\"")
        // Relative path of the web panel on the server. Keep it empty if installed in the root
        buildConfigField("String", "SERVER_PROJECT", "\"\"")
        // This parameter manages how the device ID should be set up at first start
        // "user" - user enters it manually
        // "suggest" - user can select among few predefined values (IMEI, serial, MAC)
        // "imei", "serial", "mac" - set the selected parameter as device ID without user interaction
        buildConfigField("String", "DEVICE_ID_CHOICE", "\"user\"")
        // Enables Push notifications. Setting it to false will stop automatic configuration updates after changing it on the server.
        buildConfigField("Boolean", "ENABLE_PUSH", "true")
        // MQTT port for Push notifications
        buildConfigField("Integer", "MQTT_PORT", "31000")
        // Set this parameter to true if you'll grant system privileges to Headwind MDM (signing it by system keys).
        // This will enable silent installation and the launcher will try to get the device owner rights by updating system files.
        // This may be useful, for example, when your device doesn't have QR code provisioning capability.
        buildConfigField("Boolean", "SYSTEM_PRIVILEGES", "false")
        // Set this parameter to true if you'd like to trust every certificate, for example, self-signed
        // Not recommended for security purposes!
        buildConfigField("Boolean", "TRUST_ANY_CERTIFICATE", "false")
        // A shared secret to sign server config requests and MQTT (Push) messages
        buildConfigField("String", "REQUEST_SIGNATURE", "\"changeme-C3z9vi54\"")
        // Set this parameter to true if the server signature should be checked
        // (additional protection against Man-In-The-Middle attacks)
        buildConfigField("Boolean", "CHECK_SIGNATURE", "false")
        // ANR watchdog flag (for testing purposes only as this watchdog may drain the resources!)
        buildConfigField("Boolean", "ANR_WATCHDOG", "false")
        // If set to true, the server URL will be requested in UI in non-MDM mode even if it is hardcoded in build.gradle
        // See the related "if" statement in MainActivity.java
        buildConfigField("Boolean", "REQUEST_SERVER_URL", "true")
        // Set to true to debug admin receiver via remote logging
        buildConfigField("Boolean", "DEVICE_ADMIN_DEBUG", "false")
        // Set to true to enable kiosk mode even if the app can't draw over other windows
        // This may be required for weak devices where drawing over other windows is disabled by OS
        buildConfigField("Boolean", "ENABLE_KIOSK_WITHOUT_OVERLAYS", "false")
        // Foreground service for MQTT: prevents OS from killing MQTT service on weak devices
        buildConfigField("Boolean", "MQTT_SERVICE_FOREGROUND", "true")
        // Set Headwind MDM to default launcher at early time of the first start
        // to prevent the user from clicking Home and stop initializing Headwind MDM
        buildConfigField("Boolean", "SET_DEFAULT_LAUNCHER_EARLY", "false")
        // Adjust application selection on TV boxes
        buildConfigField("Boolean", "SELECTED_ITEM_BY_CLICK", "false")
        // Adjust application selection on TV boxes
        buildConfigField("Boolean", "DISABLE_ORIENTATION_LOCK", "false")
        // API key for the authorization of privileged library requests
        buildConfigField("String", "LIBRARY_API_KEY", "\"changeme-8gzk321W\"")
        // Use accessibility services to control unwanted apps
        // (this option is banned by Play Protect in some countries!)
        buildConfigField("Boolean", "USE_ACCESSIBILITY", "false")
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            debuggable false
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    packagingOptions {
        exclude 'META-INF/DEPENDENCIES.txt'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/NOTICE.md'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.md'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/notice.txt'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/dependencies.txt'
        exclude 'META-INF/LGPL2.1'
    }

    flavorDimensions "all"

    productFlavors {
        opensource { }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    androidTestImplementation('androidx.test.espresso:espresso-core:3.1.0', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    implementation 'androidx.appcompat:appcompat:1.1.0'
    testImplementation 'junit:junit:4.12'
    implementation 'androidx.recyclerview:recyclerview:1.1.0'
    implementation 'com.google.android.material:material:1.1.0'
    implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.0.0'

    // MQTT messaging
    implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0'

    // Picassomk
    implementation 'com.squareup.picasso:picasso:2.5.2'
    implementation 'com.jakewharton.picasso:picasso2-okhttp3-downloader:1.1.0'

    // Retrofit
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
    implementation project(':flutter')
    // Jackson
    implementation 'com.fasterxml.jackson.core:jackson-core:2.9.4'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.9.4'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.4'

    // Worker
    implementation 'androidx.work:work-runtime:2.9.1'

    implementation('com.journeyapps:zxing-android-embedded:4.1.0') { transitive = false }
    implementation 'com.google.zxing:core:3.3.0'
    implementation group: 'commons-io', name: 'commons-io', version: '2.0.1'

    // JAX-B dependencies for JDK 9+
    implementation "jakarta.xml.bind:jakarta.xml.bind-api:2.3.2"
    implementation "org.glassfish.jaxb:jaxb-runtime:2.3.2"
}
</file>

</files>
</file>

<file path="gradle.properties">
#
# Headwind MDM: Open Source Android MDM Software
# https://h-mdm.com
#
# Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

android.useAndroidX=true
android.enableJetifier=true
android.nonTransitiveRClass=false
android.nonFinalResIds=false
android.enableR8.fullMode=false
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="lint.xml">
<?xml version="1.0" encoding="UTF-8"?>
<lint>
    <issue id="ExpiredTargetSdkVersion" severity="ignore" />
</lint>
</file>

<file path="settings.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include ':app', ':lib'
setBinding(new Binding([gradle: this]))
evaluate(new File(
        settingsDir.parentFile,
        'exs/.android/include_flutter.groovy'
))
</file>

<file path="app/src/main/aidl/com/hmdm/IMdmApi.aidl">
// IMdmApi.aidl
package com.hmdm;

// Declare any non-default types here with import statements

interface IMdmApi {
    /**
     * Get the MDM configuration (non-privileged, no sensitive info)
     */
    Bundle queryConfig();

    /**
     * Send a log message
     */
    void log(long timestamp, int level, String packageId, String message);

    /**
     * Get app preference
     */
    String queryAppPreference(String packageId, String attr);

    /**
     * Set app preference
     */
    boolean setAppPreference(String packageId, String attr, String value);

    /**
     * Send app preferences to server
     */
    void commitAppPreferences(String packageId);

    // Added in library version 1.1.3
    // All new methods should be added at the end of the AIDL file!!!

    /**
     * Get the API version supported by the launcher (1.1.3 = 113)
     */
    int getVersion();

    /**
     * Get the MDM configuration (privileged, including IMEI and serial number)
     */
    Bundle queryPrivilegedConfig(String apiKey);

    /**
     * Set a custom field to send it to the server
     */
    void setCustom(int number, String value);

    // Added in library version 1.1.5
    /**
     * Force the configuration update
     */
    void forceConfigUpdate();
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/LocationTable.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.annotation.SuppressLint;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;

import java.util.LinkedList;
import java.util.List;

public class LocationTable {
    private static final String CREATE_TABLE =
            "CREATE TABLE locations (" +
                    "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
                    "ts INTEGER, " +
                    "lat REAL, " +
                    "lon REAL " +
                    ")";
    private static final String SELECT_LAST_LOCATION =
            "SELECT * FROM locations ORDER BY ts LIMIT ?";
    private static final String INSERT_LOCATIONS =
            "INSERT OR IGNORE INTO locations(ts, lat, lon) " +
            "VALUES (?, ?, ?)";
    private static final String DELETE_FROM_LOCATION =
            "DELETE FROM locations WHERE _id=?";
    private static final String DELETE_OLD_ITEMS =
            "DELETE FROM locations WHERE ts < ?";

    public static class Location {
        private long _id;
        private long ts;
        private double lat;
        private double lon;

        public Location() {}

        public Location(android.location.Location location) {
            this.ts = location.getTime();
            this.lat = location.getLatitude();
            this.lon = location.getLongitude();
        }

        @SuppressLint("Range")
        public Location(Cursor cursor) {
            _id = cursor.getLong(cursor.getColumnIndex("_id"));
            ts = cursor.getLong(cursor.getColumnIndex("ts"));
            lat = cursor.getDouble(cursor.getColumnIndex("lat"));
            lon = cursor.getDouble(cursor.getColumnIndex("lon"));
        }

        public long getId() {
            return _id;
        }

        public void setId(int id) {
            this._id = id;
        }

        public long getTs() {
            return ts;
        }

        public void setTs(long ts) {
            this.ts = ts;
        }

        public double getLat() {
            return lat;
        }

        public void setLat(double lat) {
            this.lat = lat;
        }

        public double getLon() {
            return lon;
        }

        public void setLon(double lon) {
            this.lon = lon;
        }
    }

    public static String getCreateTableSql() {
        return CREATE_TABLE;
    }

    public static void insert(SQLiteDatabase db, Location location) {
        try {
            db.execSQL(INSERT_LOCATIONS, new String[]{
                    Long.toString(location.getTs()),
                    Double.toString(location.getLat()),
                    Double.toString(location.getLon())
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void deleteOldItems(SQLiteDatabase db) {
        long oldTs = System.currentTimeMillis() - 24 * 60 * 60 * 1000L;
        try {
            db.execSQL(DELETE_OLD_ITEMS, new String[]{
                    Long.toString(oldTs)
            });
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    public static void delete(SQLiteDatabase db, List<Location> items) {
        db.beginTransaction();
        try {
            for (Location item : items) {
                db.execSQL(DELETE_FROM_LOCATION, new String[]{
                        Long.toString(item.getId())
                });
            }
            db.setTransactionSuccessful();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            db.endTransaction();
        }
    }

    public static List<Location> select(SQLiteDatabase db, int limit) {
        Cursor cursor = db.rawQuery( SELECT_LAST_LOCATION, new String[] {
                Integer.toString(limit)
        });
        List<Location> result = new LinkedList<>();

        boolean isDataNotEmpty = cursor.moveToFirst();
        while (isDataNotEmpty) {
            Location item = new Location(cursor);
            result.add(item);
            isDataNotEmpty = cursor.moveToNext();
        }
        cursor.close();

        return result;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DetailedInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import android.annotation.SuppressLint;
import android.database.Cursor;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class DetailedInfo {

    @JsonIgnore
    private long _id;

    private long ts;
    private Device device;
    private Wifi wifi;
    private Gps gps;
    private Mobile mobile;
    private Mobile mobile2;

    public DetailedInfo() {
    }

    @SuppressLint("Range")
    public DetailedInfo(Cursor cursor) {
        _id = cursor.getLong(cursor.getColumnIndex("_id"));
        ts = cursor.getLong(cursor.getColumnIndex("ts"));

        device = new Device();
        device.setBatteryLevel(cursor.getInt(cursor.getColumnIndex("deviceBatteryLevel")));
        device.setBatteryCharging(cursor.getString(cursor.getColumnIndex("deviceBatteryCharging")));
        device.setWifi(cursor.getInt(cursor.getColumnIndex("deviceWifi")) != 0);
        device.setGps(cursor.getInt(cursor.getColumnIndex("deviceGps")) != 0);
        device.setIp(cursor.getString(cursor.getColumnIndex("deviceIp")));
        device.setKeyguard(cursor.getInt(cursor.getColumnIndex("deviceKeyguard")) != 0);
        device.setRingVolume(cursor.getInt(cursor.getColumnIndex("deviceRingVolume")));
        device.setMobileData(cursor.getInt(cursor.getColumnIndex("deviceMobileData")) != 0);
        device.setBluetooth(cursor.getInt(cursor.getColumnIndex("deviceBluetooth")) != 0);
        device.setUsbStorage(cursor.getInt(cursor.getColumnIndex("deviceUsbStorage")) != 0);
        device.setMemoryTotal(cursor.getInt(cursor.getColumnIndex("deviceMemoryTotal")));
        device.setMemoryAvailable(cursor.getInt(cursor.getColumnIndex("deviceMemoryAvailable")));

        wifi = new Wifi();
        wifi.setRssi(cursor.getInt(cursor.getColumnIndex("wifiRssi")));
        wifi.setSsid(cursor.getString(cursor.getColumnIndex("wifiSsid")));
        wifi.setSecurity(cursor.getString(cursor.getColumnIndex("wifiSecurity")));
        wifi.setState(cursor.getString(cursor.getColumnIndex("wifiState")));
        wifi.setIp(cursor.getString(cursor.getColumnIndex("wifiIp")));
        wifi.setTx(cursor.getLong(cursor.getColumnIndex("wifiTx")));
        wifi.setRx(cursor.getLong(cursor.getColumnIndex("wifiRx")));

        gps = new Gps();
        gps.setState(cursor.getString(cursor.getColumnIndex("gpsState")));
        gps.setLat(cursor.getDouble(cursor.getColumnIndex("gpsLat")));
        gps.setLon(cursor.getDouble(cursor.getColumnIndex("gpsLon")));
        gps.setAlt(cursor.getDouble(cursor.getColumnIndex("gpsAlt")));
        gps.setSpeed(cursor.getDouble(cursor.getColumnIndex("gpsSpeed")));
        gps.setCourse(cursor.getDouble(cursor.getColumnIndex("gpsCourse")));

        mobile = new Mobile();
        mobile.setRssi(cursor.getInt(cursor.getColumnIndex("mobileRssi")));
        mobile.setCarrier(cursor.getString(cursor.getColumnIndex("mobileCarrier")));
        mobile.setNumber(cursor.getString(cursor.getColumnIndex("mobileNumber")));
        mobile.setImsi(cursor.getString(cursor.getColumnIndex("mobileImsi")));
        mobile.setData(cursor.getInt(cursor.getColumnIndex("mobileData")) != 0);
        mobile.setIp(cursor.getString(cursor.getColumnIndex("mobileIp")));
        mobile.setState(cursor.getString(cursor.getColumnIndex("mobileState")));
        mobile.setSimState(cursor.getString(cursor.getColumnIndex("mobileSimState")));
        mobile.setTx(cursor.getLong(cursor.getColumnIndex("mobileTx")));
        mobile.setRx(cursor.getLong(cursor.getColumnIndex("mobileRx")));

        mobile2 = new Mobile();
        mobile2.setRssi(cursor.getInt(cursor.getColumnIndex("mobile2Rssi")));
        mobile2.setCarrier(cursor.getString(cursor.getColumnIndex("mobile2Carrier")));
        mobile2.setNumber(cursor.getString(cursor.getColumnIndex("mobile2Number")));
        mobile2.setImsi(cursor.getString(cursor.getColumnIndex("mobile2Imsi")));
        mobile2.setData(cursor.getInt(cursor.getColumnIndex("mobile2Data")) != 0);
        mobile2.setIp(cursor.getString(cursor.getColumnIndex("mobile2Ip")));
        mobile2.setState(cursor.getString(cursor.getColumnIndex("mobile2State")));
        mobile2.setSimState(cursor.getString(cursor.getColumnIndex("mobile2SimState")));
        mobile2.setTx(cursor.getLong(cursor.getColumnIndex("mobile2Tx")));
        mobile2.setRx(cursor.getLong(cursor.getColumnIndex("mobile2Rx")));
    }

    public long getId() {
        return _id;
    }

    public void setId(long _id) {
        this._id = _id;
    }

    public long getTs() {
        return ts;
    }

    public void setTs(long ts) {
        this.ts = ts;
    }

    public Device getDevice() {
        return device;
    }

    public void setDevice(Device device) {
        this.device = device;
    }

    public Wifi getWifi() {
        return wifi;
    }

    public void setWifi(Wifi wifi) {
        this.wifi = wifi;
    }

    public Gps getGps() {
        return gps;
    }

    public void setGps(Gps gps) {
        this.gps = gps;
    }

    public Mobile getMobile() {
        return mobile;
    }

    public void setMobile(Mobile mobile) {
        this.mobile = mobile;
    }

    public Mobile getMobile2() {
        return mobile2;
    }

    public void setMobile2(Mobile mobile2) {
        this.mobile2 = mobile2;
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Device {
        private Integer batteryLevel;
        private String batteryCharging;
        private Boolean wifi;
        private Boolean gps;
        private String ip;
        private Boolean keyguard;
        private Integer ringVolume;
        private Boolean mobileData;
        private Boolean bluetooth;
        private Boolean usbStorage;
        private Integer memoryTotal;
        private Integer memoryAvailable;

        public Integer getBatteryLevel() {
            return batteryLevel;
        }

        public void setBatteryLevel(Integer batteryLevel) {
            this.batteryLevel = batteryLevel;
        }

        public String getBatteryCharging() {
            return batteryCharging;
        }

        public void setBatteryCharging(String batteryCharging) {
            this.batteryCharging = batteryCharging;
        }

        public Boolean getWifi() {
            return wifi;
        }

        public void setWifi(Boolean wifi) {
            this.wifi = wifi;
        }

        public Boolean getGps() {
            return gps;
        }

        public void setGps(Boolean gps) {
            this.gps = gps;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public Boolean getKeyguard() {
            return keyguard;
        }

        public void setKeyguard(Boolean keyguard) {
            this.keyguard = keyguard;
        }

        public Integer getRingVolume() {
            return ringVolume;
        }

        public void setRingVolume(Integer ringVolume) {
            this.ringVolume = ringVolume;
        }

        public Boolean getMobileData() {
            return mobileData;
        }

        public void setMobileData(Boolean mobileData) {
            this.mobileData = mobileData;
        }

        public Boolean getBluetooth() {
            return bluetooth;
        }

        public void setBluetooth(Boolean bluetooth) {
            this.bluetooth = bluetooth;
        }

        public Boolean getUsbStorage() {
            return usbStorage;
        }

        public void setUsbStorage(Boolean usbStorage) {
            this.usbStorage = usbStorage;
        }

        public Integer getMemoryTotal() {
            return memoryTotal;
        }

        public void setMemoryTotal(Integer memoryTotal) {
            this.memoryTotal = memoryTotal;
        }

        public Integer getMemoryAvailable() {
            return memoryAvailable;
        }

        public void setMemoryAvailable(Integer memoryAvailable) {
            this.memoryAvailable = memoryAvailable;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Wifi {
        private Integer rssi;
        private String ssid;
        private String security;
        private String state;
        private String ip;
        private Long tx;
        private Long rx;

        public Integer getRssi() {
            return rssi;
        }

        public void setRssi(Integer rssi) {
            this.rssi = rssi;
        }

        public String getSsid() {
            return ssid;
        }

        public void setSsid(String ssid) {
            this.ssid = ssid;
        }

        public String getSecurity() {
            return security;
        }

        public void setSecurity(String security) {
            this.security = security;
        }

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public Long getTx() {
            return tx;
        }

        public void setTx(Long tx) {
            this.tx = tx;
        }

        public Long getRx() {
            return rx;
        }

        public void setRx(Long rx) {
            this.rx = rx;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Gps {
        private String state;
        private String provider;
        private Double lat;
        private Double lon;
        private Double alt;
        private Double speed;
        private Double course;

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getProvider() {
            return provider;
        }

        public void setProvider(String provider) {
            this.provider = provider;
        }

        public Double getLat() {
            return lat;
        }

        public void setLat(Double lat) {
            this.lat = lat;
        }

        public Double getLon() {
            return lon;
        }

        public void setLon(Double lon) {
            this.lon = lon;
        }

        public Double getAlt() {
            return alt;
        }

        public void setAlt(Double alt) {
            this.alt = alt;
        }

        public Double getSpeed() {
            return speed;
        }

        public void setSpeed(Double speed) {
            this.speed = speed;
        }

        public Double getCourse() {
            return course;
        }

        public void setCourse(Double course) {
            this.course = course;
        }
    }

    @JsonIgnoreProperties( ignoreUnknown = true )
    public static class Mobile {
        private Integer rssi;
        private String carrier;
        private String number;
        private String imsi;
        private Boolean data;
        private String ip;
        private String state;
        private String simState;
        private Long tx;
        private Long rx;

        public Integer getRssi() {
            return rssi;
        }

        public void setRssi(Integer rssi) {
            this.rssi = rssi;
        }

        public String getCarrier() {
            return carrier;
        }

        public void setCarrier(String carrier) {
            this.carrier = carrier;
        }

        public String getNumber() {
            return number;
        }

        public void setNumber(String number) {
            this.number = number;
        }

        public String getImsi() {
            return imsi;
        }

        public void setImsi(String imsi) {
            this.imsi = imsi;
        }

        public Boolean getData() {
            return data;
        }

        public void setData(Boolean data) {
            this.data = data;
        }

        public String getIp() {
            return ip;
        }

        public void setIp(String ip) {
            this.ip = ip;
        }

        public String getState() {
            return state;
        }

        public void setState(String state) {
            this.state = state;
        }

        public String getSimState() {
            return simState;
        }

        public void setSimState(String simState) {
            this.simState = simState;
        }

        public Long getTx() {
            return tx;
        }

        public void setTx(Long tx) {
            this.tx = tx;
        }

        public Long getRx() {
            return rx;
        }

        public void setRx(Long rx) {
            this.rx = rx;
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/RemoteFile.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class RemoteFile {
    @JsonIgnore
    private long _id;

    private String url;
    private String path;
    private long lastUpdate;
    private String checksum;
    private boolean remove;
    private String description;
    private boolean varContent;

    public RemoteFile() {}

    public RemoteFile(RemoteFile remoteFile) {
        _id = remoteFile._id;
        lastUpdate = remoteFile.lastUpdate;
        url = remoteFile.url;
        checksum = remoteFile.checksum;
        remove = remoteFile.remove;
        path = remoteFile.path;
        description = remoteFile.description;
        varContent = remoteFile.varContent;
    }

    @JsonIgnore
    public long getId() {
        return _id;
    }

    @JsonIgnore
    public void setId(long _id) {
        this._id = _id;
    }

    public long getLastUpdate() {
        return lastUpdate;
    }

    public void setLastUpdate(long lastUpdate) {
        this.lastUpdate = lastUpdate;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getChecksum() {
        return checksum;
    }

    public void setChecksum(String checksum) {
        this.checksum = checksum;
    }

    public boolean isRemove() {
        return remove;
    }

    public void setRemove(boolean remove) {
        this.remove = remove;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public boolean isVarContent() {
        return varContent;
    }

    public void setVarContent(boolean varContent) {
        this.varContent = varContent;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AdminModeRequestActivity.java">
package com.hmdm.launcher.ui;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Intent;
import android.os.Bundle;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;

import com.hmdm.launcher.R;
import com.hmdm.launcher.util.LegacyUtils;

/**
 * There is a weird bug: MainActivity cannot open intent ACTION_ADD_DEVICE_ADMIN
 * because it is declared as "singleInstance" (???).
 * To work around this issue, I created a simple proxy activity which does the same
 */
public class AdminModeRequestActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(this);
        Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, adminComponentName);
        try {
            startActivityForResult(intent, 1);
        } catch (/*ActivityNotFound*/Exception e) {
            Toast.makeText(this, getString(R.string.admin_not_supported), Toast.LENGTH_LONG).show();
            finish();
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        setResult(resultCode);
        finish();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BottomAppListAdapter.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.view.LayoutInflater;

public class BottomAppListAdapter extends BaseAppListAdapter {
    private LayoutInflater layoutInflater;

    public BottomAppListAdapter(Activity parentActivity, OnAppChooseListener appChooseListener, SwitchAdapterListener switchAdapterListener) {
        super(parentActivity, appChooseListener, switchAdapterListener);
        items = AppShortcutManager.getInstance().getInstalledApps(parentActivity, true);
        initShortcuts();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/ErrorDetailsActivity.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityErrorDetailsBinding;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class ErrorDetailsActivity extends AppCompatActivity {
    private ActivityErrorDetailsBinding binding;

    public static final String MESSAGE = "MESSAGE";
    public static final String RESET_ENABLED = "RESET_ENABLED";

    public static void display(Activity parent, String message, boolean resetEnabled) {
        Intent intent = new Intent(parent, ErrorDetailsActivity.class);
        intent.putExtra(MESSAGE, message);
        intent.putExtra(RESET_ENABLED, resetEnabled);
        parent.startActivity(intent);
    }

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);
        binding = DataBindingUtil.setContentView(this, R.layout.activity_error_details);

        Intent intent = getIntent();
        boolean resetEnabled = intent.getBooleanExtra(RESET_ENABLED, false);
        binding.resetButton.setVisibility(resetEnabled ? View.VISIBLE : View.GONE);

        String message = intent.getStringExtra(MESSAGE);
        binding.editMessage.setText(message);
    }

    public void resetClicked(View view) {
        // Factory reset!!!
        if (!Utils.factoryReset(this)) {
            RemoteLogger.log(this, Const.LOG_WARN, "Device reset failed");
        }
        finish();
    }

    public void closeClicked(View view) {
        finish();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MainAppListAdapter.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.app.Activity;

/**
 * Created by Ivan Lozenko on 21.02.2017.
 */

public class MainAppListAdapter extends BaseAppListAdapter {

    public MainAppListAdapter(Activity parentActivity, OnAppChooseListener appChooseListener, SwitchAdapterListener switchAdapterListener) {
        super(parentActivity, appChooseListener, switchAdapterListener);
        items = AppShortcutManager.getInstance().getInstalledApps(parentActivity, false);
        initShortcuts();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/XapkUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.Context;
import android.content.pm.PackageInstaller;
import android.os.Build;
import android.util.Log;

import com.hmdm.launcher.Const;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class XapkUtils {
    public static List<File> extract(Context context, File xapk) {
        // Here we presume that xapk file name ends with .xapk
        try {
            String extractDir = xapk.getName().substring(0, xapk.getName().length() - 5);
            File extractDirFile = new File(context.getExternalFilesDir(null), extractDir);
            if (extractDirFile.isDirectory()) {
                FileUtils.deleteDirectory(extractDirFile);
            } else if (extractDirFile.exists()) {
                extractDirFile.delete();
            }
            extractDirFile.mkdirs();

            List<File> result = new LinkedList<File>();

            ZipFile zipFile = new ZipFile(xapk);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();

            while(entries.hasMoreElements()) {
                ZipEntry entry = entries.nextElement();
                if (entry.getName().endsWith(".apk")) {
                    InputStream inputStream = zipFile.getInputStream(entry);
                    File resultFile = new File(extractDirFile, entry.getName());
                    FileOutputStream outputStream = new FileOutputStream(resultFile);
                    IOUtils.copy(inputStream, outputStream);
                    inputStream.close();
                    outputStream.close();
                    result.add(resultFile);
                }

            }
            zipFile.close();
            return result;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void install(Context context, List<File> files, String packageName, InstallUtils.InstallErrorHandler errorHandler) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        if (files == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Failed to unpack XAPK for " + packageName + " - ignoring installation");
            if (errorHandler != null) {
                errorHandler.onInstallError(null);
            }
            return;
        }
        long totalSize = 0;
        for (File file : files) {
            totalSize += file.length();
        }

        try {
            Log.i(Const.LOG_TAG, "Installing XAPK " + packageName);
            PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
            PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(
                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);
            if (packageName != null) {
                params.setAppPackageName(packageName);
            }
            params.setSize(totalSize);
            int sessionId = packageInstaller.createSession(params);

            for (File file : files) {
                addFileToSession(sessionId, file, packageInstaller);
            }

            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            session.commit(InstallUtils.createIntentSender(context, sessionId, packageName));
            session.close();
            Log.i(Const.LOG_TAG, "Installation session committed");

        } catch (Exception e) {
            if (errorHandler != null) {
                errorHandler.onInstallError(e.getMessage());
            }
        }
    }

    private static void addFileToSession(int sessionId, File file, PackageInstaller packageInstaller) throws IOException {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        FileInputStream in = new FileInputStream(file);
        // set params
        PackageInstaller.Session session = packageInstaller.openSession(sessionId);
        OutputStream out = session.openWrite(file.getName(), 0, file.length());
        byte[] buffer = new byte[65536];
        int c;
        while ((c = in.read(buffer)) != -1) {
            out.write(buffer, 0, c);
        }
        session.fsync(out);
        in.close();
        out.close();
        session.close();
    }

}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttAndroidClient.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *   
 *   Ian Craggs - Per subscription message handlers bug 466579
 *   Ian Craggs - ack control (bug 472172)
 *   
 */
package org.eclipse.paho.android.service;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.util.SparseArray;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;

import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttAsyncClient;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttCallback;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;
import org.eclipse.paho.client.mqttv3.MqttToken;

import java.io.IOException;
import java.io.InputStream;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;

/**
 * Enables an android application to communicate with an MQTT server using non-blocking methods.
 * <p>
 * Implementation of the MQTT asynchronous client interface {@link IMqttAsyncClient} , using the MQTT
 * android service to actually interface with MQTT server. It provides android applications a simple programming interface to all features of the MQTT version 3.1
 * specification including:
 * </p>
 * <ul>
 * <li>connect
 * <li>publish
 * <li>subscribe
 * <li>unsubscribe
 * <li>disconnect
 * </ul>
 */
public class MqttAndroidClient extends BroadcastReceiver implements
		IMqttAsyncClient {

	/**
	 * 
	 * The Acknowledgment mode for messages received from {@link MqttCallback#messageArrived(String, MqttMessage)}
	 *
	 */
	public enum Ack {
		/**
		 * As soon as the {@link MqttCallback#messageArrived(String, MqttMessage)} returns,
		 * the message has been acknowledged as received .
		 */
		AUTO_ACK,
		/**
		 * When {@link MqttCallback#messageArrived(String, MqttMessage)} returns, the message
		 * will not be acknowledged as received, the application will have to make an acknowledgment call
		 * to {@link MqttAndroidClient} using {@link MqttAndroidClient#acknowledgeMessage(String)}
		 */
		MANUAL_ACK
	}

	public static final String SERVICE_NAME = "org.eclipse.paho.android.service.MqttService";

	public static final String EXTRA_START_AT_BOOT = "START_AT_BOOT";
	public static final String EXTRA_DOMAIN = "DOMAIN";
	public static final String EXTRA_KEEPALIVE_TIME = "KEEPALIVE_TIME";
	public static final String EXTRA_PUSH_OPTIONS = "PUSH_OPTIONS";
	public static final String EXTRA_DEVICE_ID = "DEVICE_ID";

	private static final int BIND_SERVICE_FLAG = 0;

	private static final ExecutorService pool = Executors.newCachedThreadPool();

	/**
	 * ServiceConnection to process when we bind to our service
	 */
	private final class MyServiceConnection implements ServiceConnection {

		@Override
		public void onServiceConnected(ComponentName name, IBinder binder) {
			mqttService = ((MqttServiceBinder) binder).getService();
			bindedService = true;
			// now that we have the service available, we can actually
			// connect...
			doConnect();
		}

		@Override
		public void onServiceDisconnected(ComponentName name) {
			mqttService = null;
		}
	}

	// Listener for when the service is connected or disconnected
	private final MyServiceConnection serviceConnection = new MyServiceConnection();

	// The Android Service which will process our mqtt calls
	private MqttService mqttService;

	// An identifier for the underlying client connection, which we can pass to
	// the service
	private String clientHandle;

	private Context myContext;

	// We hold the various tokens in a collection and pass identifiers for them
	// to the service
	private final SparseArray<IMqttToken> tokenMap = new SparseArray<>();
	private int tokenNumber = 0;

	// Connection data
	private final String serverURI;
	private final String clientId;
	private MqttClientPersistence persistence = null;
	private MqttConnectOptions connectOptions;
	private IMqttToken connectToken;

	// The MqttCallback provided by the application
	private MqttCallback callback;
	private MqttTraceHandler traceCallback;

	// Default message listener (called if any messages are delivered before calling subscribe()
	private IMqttMessageListener defaultMessageListener;

	//The acknowledgment that a message has been processed by the application
	private final Ack messageAck;
	private boolean traceEnabled = false;
	
	private volatile boolean receiverRegistered = false;
	private volatile boolean bindedService = false;

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate with an MQTT server on android
	 * 
	 * @param context 
	 *            object used to pass context to the callback. 
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 */
	public MqttAndroidClient(Context context, String serverURI,
			String clientId) {
		this(context, serverURI, clientId, null, Ack.AUTO_ACK);
	}

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param ctx
	 *            Application's context
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param ackType
	 *            how the application wishes to acknowledge a message has been
	 *            processed
	 */
	public MqttAndroidClient(Context ctx, String serverURI, String clientId, Ack ackType) {
		this(ctx, serverURI, clientId, null, ackType);
	}

	/**
	 * Constructor - create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param ctx
	 *            Application's context
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param persistence
	 *            The object to use to store persisted data
	 */
	public MqttAndroidClient(Context ctx, String serverURI, String clientId, MqttClientPersistence persistence) {
		this(ctx, serverURI, clientId, persistence, Ack.AUTO_ACK);
	}

	/**
	 * Constructor- create an MqttAndroidClient that can be used to communicate
	 * with an MQTT server on android
	 * 
	 * @param context
	 *            used to pass context to the callback.
	 * @param serverURI
	 *            specifies the protocol, host name and port to be used to
	 *            connect to an MQTT server
	 * @param clientId
	 *            specifies the name by which this connection should be
	 *            identified to the server
	 * @param persistence
	 *            the persistence class to use to store in-flight message. If
	 *            null then the default persistence mechanism is used
	 * @param ackType
	 *            how the application wishes to acknowledge a message has been
	 *            processed.
	 */
	public MqttAndroidClient(Context context, String serverURI,
			String clientId, MqttClientPersistence persistence, Ack ackType) {
		myContext = context;
		this.serverURI = serverURI;
		this.clientId = clientId;
		this.persistence = persistence;
		messageAck = ackType;
	}

	 /**
	 * Determines if this client is currently connected to the server.
	 *
	 * @return <code>true</code> if connected, <code>false</code> otherwise.
	 */
	@Override
	public boolean isConnected() {

		return clientHandle != null && mqttService != null && mqttService.isConnected(clientHandle);
	}

	/**
	 * Returns the client ID used by this client.
	 * <p>
	 * All clients connected to the same server or server farm must have a
	 * unique ID.
	 * </p>
	 * 
	 * @return the client ID used by this client.
	 */
	@Override
	public String getClientId() {
		return clientId;
	}


	/**
	 * Sets the default message listener
	 * <p>
	 * Default message listener is called if messages are arrived
	 * before subscribe() is called
	 * </p>
	 * @param defaultMessageListener
	 *            default message listener or null if no listener required.
	 *
	 */
	public void setDefaultMessageListener(IMqttMessageListener defaultMessageListener) {
		this.defaultMessageListener = defaultMessageListener;
	}

	/**
	 * Returns the URI address of the server used by this client.
	 * <p>
	 * The format of the returned String is the same as that used on the
	 * constructor.
	 * </p>
	 * 
	 * @return the server's address, as a URI String.
	 */
	@Override
	public String getServerURI() {
		return serverURI;
	}

	/**
	 * Close the client. Releases all resource associated with the client. After
	 * the client has been closed it cannot be reused. For instance attempts to
	 * connect will fail.
	 *
	 */
	@Override
	public void close() {
		if(mqttService != null){
			if (clientHandle == null) {
				clientHandle = mqttService.getClient(serverURI, clientId, myContext.getApplicationInfo().packageName,persistence,defaultMessageListener);
			}
			mqttService.close(clientHandle);
		}
	}
	
	/**
	 * Connects to an MQTT server using the default options.
	 * <p>
	 * The default options are specified in {@link MqttConnectOptions} class.
	 * </p>
	 * 
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to the callback methods if a callback is
	 *         set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect() throws MqttException {
		return connect(null, null);
	}

	
	/**
	 * Connects to an MQTT server using the provided connect options.
	 * <p>
	 * The connection will be established using the options specified in the
	 * {@link MqttConnectOptions} parameter.
	 * </p>
	 * 
	 * @param options
	 *            a set of connection parameters that override the defaults.
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect(MqttConnectOptions options) throws MqttException {
		return connect(options, null, null);
	}

	/**
	 * Connects to an MQTT server using the default options.
	 * <p>
	 * The default options are specified in {@link MqttConnectOptions} class.
	 * </p>
	 * 
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the connect
	 *            completes. Use null if not required.
	 * @throws MqttException
	 *             for any connected problems
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @see #connect(MqttConnectOptions, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken connect(Object userContext, IMqttActionListener callback)
			throws MqttException {
		return connect(new MqttConnectOptions(), userContext, callback);
	}

	/**
	 * Connects to an MQTT server using the specified options.
	 * <p>
	 * The server to connect to is specified on the constructor. It is
	 * recommended to call {@link #setCallback(MqttCallback)} prior to
	 * connecting in order that messages destined for the client can be accepted
	 * as soon as the client is connected.
	 * </p>
	 *
	 * <p>
	 * The method returns control before the connect completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 *
	 * 
	 * @param options
	 *            a set of connection parameters that override the defaults.
	 * @param userContext
	 *            optional object for used to pass context to the callback. Use
	 *            null if not required.
	 * @param callback
	 *            optional listener that will be notified when the connect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the connect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for any connected problems, including communication errors
	 */

	@Override
	public IMqttToken connect(MqttConnectOptions options, Object userContext,
			IMqttActionListener callback) throws MqttException {

		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);

		connectOptions = options;
		connectToken = token;

		/*
		 * The actual connection depends on the service, which we start and bind
		 * to here, but which we can't actually use until the serviceConnection
		 * onServiceConnected() method has run (asynchronously), so the
		 * connection itself takes place in the onServiceConnected() method
		 */
		if (mqttService == null) { // First time - must bind to the service
			Intent serviceStartIntent = new Intent();
			serviceStartIntent.setClassName(myContext, SERVICE_NAME);
			Object service = BuildConfig.MQTT_SERVICE_FOREGROUND && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
					myContext.startForegroundService(serviceStartIntent) :
					myContext.startService(serviceStartIntent);
			if (service == null) {
				IMqttActionListener listener = token.getActionCallback();
				if (listener != null) {
					listener.onFailure(token, new RuntimeException(
							"cannot start service " + SERVICE_NAME));
				}
			}

			// We bind with BIND_SERVICE_FLAG (0), leaving us the manage the lifecycle
			// until the last time it is stopped by a call to stopService()
			myContext.bindService(serviceStartIntent, serviceConnection,
					Context.BIND_AUTO_CREATE);

			if (!receiverRegistered) registerReceiver(this);
		}
		else {
			pool.execute(new Runnable() {

				@Override
				public void run() {
					doConnect();
					
					//Register receiver to show shoulder tap.
					if (!receiverRegistered) registerReceiver(MqttAndroidClient.this);
				}

			});
		}

		return token;
	}

	private void registerReceiver(BroadcastReceiver receiver) {
		IntentFilter filter = new IntentFilter();
				filter.addAction(MqttServiceConstants.CALLBACK_TO_ACTIVITY);
				LocalBroadcastManager.getInstance(myContext).registerReceiver(receiver, filter);
				receiverRegistered = true;
	}

	/**
	 * Actually do the mqtt connect operation
	 */
	private void doConnect() {
		if (clientHandle == null) {
			clientHandle = mqttService.getClient(serverURI, clientId,myContext.getApplicationInfo().packageName,
					persistence, defaultMessageListener);
		}
		mqttService.setTraceEnabled(traceEnabled);
		mqttService.setTraceCallbackId(clientHandle);
		
		String activityToken = storeToken(connectToken);
		try {
			mqttService.connect(clientHandle, connectOptions, null,
					activityToken);
		}
		catch (MqttException e) {
			IMqttActionListener listener = connectToken.getActionCallback();
			if (listener != null) {
				listener.onFailure(connectToken, e);
			}
		}
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of 30 seconds
	 * for work to quiesce before disconnecting. This method must not be called
	 * from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @return token used to track and wait for disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect() throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, null,
				null);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, null, activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of the
	 * specified quiesce time for work to complete before disconnecting. This
	 * method must not be called from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @param quiesceTimeout
	 *            the amount of time in milliseconds to allow for existing work
	 *            to finish before disconnecting. A value of zero or less means
	 *            the client will not quiesce.
	 * @return token used to track and wait for disconnect to complete. The
	 *         token will be passed to the callback methods if a callback is
	 *         set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect(long quiesceTimeout) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, null,
				null);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, quiesceTimeout, null,
				activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * An attempt is made to quiesce the client allowing outstanding work to
	 * complete before disconnecting. It will wait for a maximum of 30 seconds
	 * for work to quiesce before disconnecting. This method must not be called
	 * from inside {@link MqttCallback} methods.
	 * </p>
	 * 
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the disconnect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 * @see #disconnect(long, Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken disconnect(Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, null, activityToken);
		return token;
	}

	/**
	 * Disconnects from the server.
	 * <p>
	 * The client will wait for {@link MqttCallback} methods to complete. It
	 * will then wait for up to the quiesce timeout to allow for work which has
	 * already been initiated to complete. For instance when a QoS 2 message has
	 * started flowing to the server but the QoS 2 flow has not completed.It
	 * prevents new messages being accepted and does not send any messages that
	 * have been accepted but not yet started delivery across the network to the
	 * server. When work has completed or after the quiesce timeout, the client
	 * will disconnect from the server. If the cleanSession flag was set to
	 * false and next time it is also set to false in the connection, the
	 * messages made in QoS 1 or 2 which were not previously delivered will be
	 * delivered this time.
	 * </p>
	 * <p>
	 * This method must not be called from inside {@link MqttCallback} methods.
	 * </p>
	 * <p>
	 * The method returns control before the disconnect completes. Completion
	 * can be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link IMqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener}</li>
	 * </ul>
	 * 
	 * @param quiesceTimeout
	 *            the amount of time in milliseconds to allow for existing work
	 *            to finish before disconnecting. A value of zero or less means
	 *            the client will not quiesce.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when the disconnect
	 *            completes. Use null if not required.
	 * @return token used to track and wait for the disconnect to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttException
	 *             for problems encountered while disconnecting
	 */
	@Override
	public IMqttToken disconnect(long quiesceTimeout, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.disconnect(clientHandle, quiesceTimeout, null,
				activityToken);
		return token;
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * A convenience method, which will create a new {@link MqttMessage} object
	 * with a byte array payload and the specified QoS, and then publish it.
	 * </p>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param payload
	 *            the byte array to use as the payload
	 * @param qos
	 *            the Quality of Service to deliver the message at. Valid values
	 *            are 0, 1 or 2.
	 * @param retained
	 *            whether or not this message should be retained by the server.
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance, too many messages are being processed.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained) throws MqttException, MqttPersistenceException {
		return publish(topic, payload, qos, retained, null, null);
	}

	/**
	 * Publishes a message to a topic on the server. Takes an
	 * {@link MqttMessage} message and delivers it to the server at the
	 * requested quality of service.
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param message
	 *            to deliver to the server
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance client not connected.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, MqttMessage message)
			throws MqttException, MqttPersistenceException {
		return publish(topic, message, null, null);
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * A convenience method, which will create a new {@link MqttMessage} object
	 * with a byte array payload, the specified QoS and retained, then publish it.
	 * </p>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param payload
	 *            the byte array to use as the payload
	 * @param qos
	 *            the Quality of Service to deliver the message at. Valid values
	 *            are 0, 1 or 2.
	 * @param retained
	 *            whether or not this message should be retained by the server.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when message delivery
	 *            has completed to the requested quality of service
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to any callback that has been set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance client not connected.
	 * @see #publish(String, MqttMessage, Object, IMqttActionListener)
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, byte[] payload, int qos,
			boolean retained, Object userContext, IMqttActionListener callback)
			throws MqttException, MqttPersistenceException {

		MqttMessage message = new MqttMessage(payload);
		message.setQos(qos);
		message.setRetained(retained);
		MqttDeliveryTokenAndroid token = new MqttDeliveryTokenAndroid(
				this, userContext, callback, message);
		String activityToken = storeToken(token);
		IMqttDeliveryToken internalToken = mqttService.publish(clientHandle,
				topic, payload, qos, retained, null, activityToken);
		token.setDelegate(internalToken);
		return token;
	}

	/**
	 * Publishes a message to a topic on the server.
	 * <p>
	 * Once this method has returned cleanly, the message has been accepted for
	 * publication by the client and will be delivered on a background thread.
	 * In the event the connection fails or the client stops, Messages will be
	 * delivered to the requested quality of service once the connection is
	 * re-established to the server on condition that:
     * </p>
	 * <ul>
	 * <li>The connection is re-established with the same clientID
	 * <li>The original connection was made with (@link
	 * MqttConnectOptions#setCleanSession(boolean)} set to false
	 * <li>The connection is re-established with (@link
	 * MqttConnectOptions#setCleanSession(boolean)} set to false
	 * <li>Depending when the failure occurs QoS 0 messages may not be
	 * delivered.
	 * </ul>
	 * 
	 * <p>
	 * When building an application, the design of the topic tree should take
	 * into account the following principles of topic name syntax and semantics:
	 * </p>
	 * 
	 * <ul>
	 * <li>A topic must be at least one character long.</li>
	 * <li>Topic names are case sensitive. For example, <em>ACCOUNTS</em> and
	 * <em>Accounts</em> are two different topics.</li>
	 * <li>Topic names can include the space character. For example,
	 * <em>Accounts
	 * 	payable</em> is a valid topic.</li>
	 * <li>A leading "/" creates a distinct topic. For example,
	 * <em>/finance</em> is different from <em>finance</em>. <em>/finance</em>
	 * matches "+/+" and "/+", but not "+".</li>
	 * <li>Do not include the null character (Unicode <em>\x0000</em>) in any topic.</li>
	 * </ul>
	 * 
	 * <p>
	 * The following principles apply to the construction and content of a topic
	 * tree:
	 * </p>
	 * 
	 * <ul>
	 * <li>The length is limited to 64k but within that there are no limits to
	 * the number of levels in a topic tree.</li>
	 * <li>There can be any number of root nodes; that is, there can be any
	 * number of topic trees.</li>
	 * </ul>
	 * <p>
	 * The method returns control before the publish completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Setting an {@link IMqttAsyncClient#setCallback(MqttCallback)} where
	 * the {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)} method will
	 * be called.</li>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            to deliver the message to, for example "finance/stock/ibm".
	 * @param message
	 *            to deliver to the server
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when message delivery
	 *            has completed to the requested quality of service
	 * @return token used to track and wait for the publish to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttPersistenceException
	 *             when a problem occurs storing the message
	 * @throws IllegalArgumentException
	 *             if value of QoS is not 0, 1 or 2.
	 * @throws MqttException
	 *             for other errors encountered while publishing the message.
	 *             For instance, client not connected.
	 * @see MqttMessage
	 */
	@Override
	public IMqttDeliveryToken publish(String topic, MqttMessage message,
			Object userContext, IMqttActionListener callback)
			throws MqttException, MqttPersistenceException {
		MqttDeliveryTokenAndroid token = new MqttDeliveryTokenAndroid(
				this, userContext, callback, message);
		String activityToken = storeToken(token);
		IMqttDeliveryToken internalToken = mqttService.publish(clientHandle,
				topic, message, null, activityToken);
		token.setDelegate(internalToken);
		return token;
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 * 
	 * @param topic
	 *            the topic to subscribe to, which can include wildcards.
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttSecurityException
	 *             for security related problems
	 * @throws MqttException
	 *             for non security related problems
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String topic, int qos) throws MqttException,
			MqttSecurityException {
		return subscribe(topic, qos, null, null);
	}

	/**
	 * Subscribe to multiple topics, each topic may include wildcards.
	 * 
	 * <p>
	 * Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.
	 * </p>
	 * 
	 * @param topic
	 *            one or more topics to subscribe to, which can include
	 *            wildcards
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @return token used to track and wait for the subscription to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttSecurityException
	 *             for security related problems
	 * @throws MqttException
	 *             for non security related problems
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String[] topic, int[] qos)
			throws MqttException, MqttSecurityException {
		return subscribe(topic, qos, null, null);
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 * 
	 * @param topic
	 *            the topic to subscribe to, which can include wildcards.
	 * @param qos
	 *            the maximum quality of service at which to subscribe. Messages
	 *            published at a lower quality of service will be received at
	 *            the published QoS. Messages published at a higher quality of
	 *            service will be received using the QoS specified on the
	 *            subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when subscribe has
	 *            completed
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error when registering the subscription.
	 * 
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken subscribe(String topic, int qos, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback, new String[]{topic});
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topic, qos, null, activityToken);
		return token;
	}

	/**
	 * Subscribes to multiple topics, each topic may include wildcards.
	 * <p>
	 * Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.
	 * </p>
	 * <p>
	 * The {@link #setCallback(MqttCallback)} method should be called before
	 * this method, otherwise any received messages will be discarded.
	 * </p>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to true,
	 * when connecting to the server, the subscription remains in place until
	 * either:
     * </p>
	 * <ul>
	 * <li>The client disconnects</li>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
     * </ul>
	 * <p>
	 * If (@link MqttConnectOptions#setCleanSession(boolean)} was set to false,
	 * when connecting to the server, the subscription remains in place
	 * until either:
     * </p>
	 * <ul>
	 * <li>An unsubscribe method is called to unsubscribe the topic</li>
	 * <li>The next time the client connects with cleanSession set to true
	 * </ul>
	 * <p>With cleanSession set to false the MQTT server will store messages
	 * on behalf of the client when the client is not connected. The next time
	 * the client connects with the <b>same client ID</b> the server will
	 * deliver the stored messages to the client.
     * </p>
	 * 
	 * <p>
	 * The "topic filter" string is used when subscription may contain special
	 * characters, which allows you to subscribe to multiple topics at once.
	 * <dl>
	 * <dt>Topic level separator</dt>
	 * <dd>The forward slash (/) is used to separate each level within a topic
	 * tree and provide a hierarchical structure to the topic space. The use of
	 * the topic level separator is significant when the two wildcard characters
	 * are encountered in topics specified by subscribers.</dd>
	 * 
	 * <dt>Multi-level wildcard</dt>
	 * <dd>
	 * <p>
	 * The number sign (#) is a wildcard character that matches any number of
	 * levels within a topic. For example, if you subscribe to <span><span
	 * class="filepath">finance/stock/ibm/#</span></span>, you receive messages
	 * on these topics:
     * </p>
     * <ul>
     *     <li><pre>finance/stock/ibm</pre></li>
     *     <li><pre>finance/stock/ibm/closingprice</pre></li>
     *     <li><pre>finance/stock/ibm/currentprice</pre></li>
     * </ul>
	 *
	 * <p>
	 * The multi-level wildcard can represent zero or more levels. Therefore,
	 * <em>finance/#</em> can also match the singular <em>finance</em>, where
	 * <em>#</em> represents zero levels. The topic level separator is
	 * meaningless in this context, because there are no levels to separate.
	 * </p>
	 * 
	 * <p>
	 * The <span>multi-level</span> wildcard can be specified only on its own or
	 * next to the topic level separator character. Therefore, <em>#</em> and
	 * <em>finance/#</em> are both valid, but <em>finance#</em> is not valid.
	 * <span>The multi-level wildcard must be the last character used within the
	 * topic tree. For example, <em>finance/#</em> is valid but
	 * <em>finance/#/closingprice</em> is not valid.</span>
	 * </p>
	 * </dd>
	 * 
	 * <dt>Single-level wildcard</dt>
	 * <dd>
	 * <p>
	 * The plus sign (+) is a wildcard character that matches only one topic
	 * level. For example, <em>finance/stock/+</em> matches
	 * <em>finance/stock/ibm</em> and <em>finance/stock/xyz</em>, but not
	 * <em>finance/stock/ibm/closingprice</em>. Also, because the single-level
	 * wildcard matches only a single level, <em>finance/+</em> does not match
	 * <em>finance</em>.
	 * </p>
	 * 
	 * <p>
	 * Use the single-level wildcard at any level in the topic tree, and in
	 * conjunction with the multilevel wildcard. Specify the single-level
	 * wildcard next to the topic level separator, except when it is specified
	 * on its own. Therefore, <em>+</em> and <em>finance/+</em> are both valid,
	 * but <em>finance+</em> is not valid. <span>The single-level wildcard can
	 * be used at the end of the topic tree or within the topic tree. For
	 * example, <em>finance/+</em> and <em>finance/+/ibm</em> are both
	 * valid.</span>
	 * </p>
	 * </dd>
	 * </dl>
	 * <p>
	 * The method returns control before the subscribe completes. Completion can
	 * be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the supplied token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            one or more topics to subscribe to, which can include
	 *            wildcards
	 * @param qos
	 *            the maximum quality of service to subscribe each topic
	 *            at.Messages published at a lower quality of service will be
	 *            received at the published QoS. Messages published at a higher
	 *            quality of service will be received using the QoS specified on
	 *            the subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when subscribe has
	 *            completed
	 * @return token used to track and wait for the subscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error registering the subscription.
	 * @throws IllegalArgumentException
	 *             if the two supplied arrays are not the same size.
	 */
	@Override
	public IMqttToken subscribe(String[] topic, int[] qos, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback, topic);
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topic, qos, null, activityToken);
		return token;
	}
	
	/**
	 * Subscribe to a topic, which may include wildcards.
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param userContext optional object used to pass context to the callback. Use
	 * null if not required.
	 * @param callback optional listener that will be notified when subscribe
	 * has completed
	 * @param messageListener a callback to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String topicFilter, int qos, Object userContext, IMqttActionListener callback, IMqttMessageListener messageListener) throws MqttException {

		return subscribe(new String[] {topicFilter}, new int[] {qos}, userContext, callback, new IMqttMessageListener[] {messageListener});
	}

	/**
	 * Subscribe to a topic, which may include wildcards.
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilter the topic to subscribe to, which can include wildcards.
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param messageListener a callback to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String topicFilter, int qos, IMqttMessageListener messageListener) throws MqttException {
		
		return subscribe(topicFilter, qos, null, null, messageListener);
	}

	
	/**
	 * Subscribe to multiple topics, each of which may include wildcards.
	 *
	 * <p>Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.</p>
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilters one or more topics to subscribe to, which can include wildcards
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param messageListeners an array of callbacks to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String[] topicFilters, int[] qos, IMqttMessageListener[] messageListeners) throws MqttException {
		
		return subscribe(topicFilters, qos, null, null, messageListeners);
	}


	/**
	 * Subscribe to multiple topics, each of which may include wildcards.
	 *
	 * <p>Provides an optimized way to subscribe to multiple topics compared to
	 * subscribing to each one individually.</p>
	 *
	 * @see #subscribe(String[], int[], Object, IMqttActionListener)
	 *
	 * @param topicFilters one or more topics to subscribe to, which can include wildcards
	 * @param qos the maximum quality of service at which to subscribe. Messages
	 * published at a lower quality of service will be received at the published
	 * QoS.  Messages published at a higher quality of service will be received using
	 * the QoS specified on the subscribe.
	 * @param userContext optional object used to pass context to the callback. Use
	 * null if not required.
	 * @param callback optional listener that will be notified when subscribe
	 * has completed
	 * @param messageListeners an array of callbacks to handle incoming messages
	 * @return token used to track and wait for the subscribe to complete. The token
	 * will be passed to callback methods if set.
	 * @throws MqttException if there was an error registering the subscription.
	 */
	public IMqttToken subscribe(String[] topicFilters, int[] qos, Object userContext, IMqttActionListener callback, IMqttMessageListener[] messageListeners) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext, callback, topicFilters);
		String activityToken = storeToken(token);
		mqttService.subscribe(clientHandle, topicFilters, qos, null, activityToken, messageListeners);

		return null;
	}


	/**
	 * Requests the server unsubscribe the client from a topic.
	 * 
	 * @param topic
	 *            the topic to unsubscribe from. It must match a topic specified
	 *            on an earlier subscribe.
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String topic) throws MqttException {
		return unsubscribe(topic, null, null);
	}

	/**
	 * Requests the server to unsubscribe the client from one or more topics.
	 * 
	 * @param topic
	 *            one or more topics to unsubscribe from. Each topic must match
	 *            one specified on an earlier subscription.
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String[] topic) throws MqttException {
		return unsubscribe(topic, null, null);
	}

	/**
	 * Requests the server to unsubscribe the client from a topics.
	 * 
	 * @param topic
	 *            the topic to unsubscribe from. It must match a topic specified
	 *            on an earlier subscribe.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when unsubscribe has
	 *            completed
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 * 
	 * @see #unsubscribe(String[], Object, IMqttActionListener)
	 */
	@Override
	public IMqttToken unsubscribe(String topic, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.unsubscribe(clientHandle, topic, null, activityToken);
		return token;
	}

	/**
	 * Requests the server to unsubscribe the client from one or more topics.
	 * <p>
	 * Unsubcribing is the opposite of subscribing. When the server receives the
	 * unsubscribe request it looks to see if it can find a matching
	 * subscription for the client and then removes it. After this point the
	 * server will send no more messages to the client for this subscription.
	 * </p>
	 * <p>
	 * The topic(s) specified on the unsubscribe must match the topic(s)
	 * specified in the original subscribe request for the unsubscribe to
	 * succeed
	 * </p>
	 * <p>
	 * The method returns control before the unsubscribe completes. Completion
	 * can be tracked by:
     * </p>
	 * <ul>
	 * <li>Waiting on the returned token {@link MqttToken#waitForCompletion()}
	 * or</li>
	 * <li>Passing in a callback {@link IMqttActionListener} to this method</li>
	 * </ul>
	 * 
	 * @param topic
	 *            one or more topics to unsubscribe from. Each topic must match
	 *            one specified on an earlier subscription.
	 * @param userContext
	 *            optional object used to pass context to the callback. Use null
	 *            if not required.
	 * @param callback
	 *            optional listener that will be notified when unsubscribe has
	 *            completed
	 * @return token used to track and wait for the unsubscribe to complete. The
	 *         token will be passed to callback methods if set.
	 * @throws MqttException
	 *             if there was an error unregistering the subscription.
	 */
	@Override
	public IMqttToken unsubscribe(String[] topic, Object userContext,
			IMqttActionListener callback) throws MqttException {
		IMqttToken token = new MqttTokenAndroid(this, userContext,
				callback);
		String activityToken = storeToken(token);
		mqttService.unsubscribe(clientHandle, topic, null, activityToken);
		return token;
	}

	/**
	 * Returns the delivery tokens for any outstanding publish operations.
	 * <p>
	 * If a client has been restarted and there are messages that were in the
	 * process of being delivered when the client stopped, this method returns a
	 * token for each in-flight message to enable the delivery to be tracked.
	 * Alternately the {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)}
	 * callback can be used to track the delivery of outstanding messages.
	 * </p>
	 * <p>
	 * If a client connects with cleanSession true then there will be no
	 * delivery tokens as the cleanSession option deletes all earlier state. For
	 * state to be remembered the client must connect with cleanSession set to
	 * false
	 * </P>
	 * 
	 * @return zero or more delivery tokens
	 */
	@Override
	public IMqttDeliveryToken[] getPendingDeliveryTokens() {
		return mqttService.getPendingDeliveryTokens(clientHandle);
	}

	/**
	 * Sets a callback listener to use for events that happen asynchronously.
	 * <p>
	 * There are a number of events that the listener will be notified about.
	 * These include:
     * </p>
	 * <ul>
	 * <li>A new message has arrived and is ready to be processed</li>
	 * <li>The connection to the server has been lost</li>
	 * <li>Delivery of a message to the server has completed</li>
	 * </ul>
	 * <p>
	 * Other events that track the progress of an individual operation such as
	 * connect and subscribe can be tracked using the {@link MqttToken} returned
	 * from each non-blocking method or using setting a
	 * {@link IMqttActionListener} on the non-blocking method.
	 * <p>
	 * 
	 * @param callback
	 *            which will be invoked for certain asynchronous events
	 * 
	 * @see MqttCallback
	 */
	@Override
	public void setCallback(MqttCallback callback) {
		this.callback = callback;

	}
	
	/**
	 * identify the callback to be invoked when making tracing calls back into
	 * the Activity
	 * 
	 * @param traceCallback handler
	 */
	public void setTraceCallback(MqttTraceHandler traceCallback) {
		this.traceCallback = traceCallback;
	 // mqttService.setTraceCallbackId(traceCallbackId);
	}

	/**
	 * turn tracing on and off
	 * 
	 * @param traceEnabled
	 *            set <code>true</code> to enable trace, otherwise, set
	 *            <code>false</code> to disable trace
	 * 
	 */
	public void setTraceEnabled(boolean traceEnabled) {
	this.traceEnabled = traceEnabled;
	if (mqttService !=null)
			mqttService.setTraceEnabled(traceEnabled);
	}
	
	/**
	 * <p>
	 * Process incoming Intent objects representing the results of operations
	 * and asynchronous activities such as message received
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This is only a public method because the Android
	 * APIs require such.<br>
	 * This method should not be explicitly invoked.
	 * </p>
	 */
	@Override
	public void onReceive(Context context, Intent intent) {
		Bundle data = intent.getExtras();

		String handleFromIntent = data
				.getString(MqttServiceConstants.CALLBACK_CLIENT_HANDLE);

		if ((handleFromIntent == null)
				|| (!handleFromIntent.equals(clientHandle))) {
			return;
		}

		String action = data.getString(MqttServiceConstants.CALLBACK_ACTION);

		if (MqttServiceConstants.CONNECT_ACTION.equals(action)) {
			connectAction(data);
		}
		else if (MqttServiceConstants.CONNECT_EXTENDED_ACTION.equals(action)){
			connectExtendedAction(data);
		}
		else if (MqttServiceConstants.MESSAGE_ARRIVED_ACTION.equals(action)) {
			messageArrivedAction(data);
		}
		else if (MqttServiceConstants.SUBSCRIBE_ACTION.equals(action)) {
			subscribeAction(data);
		}
		else if (MqttServiceConstants.UNSUBSCRIBE_ACTION.equals(action)) {
			unSubscribeAction(data);
		}
		else if (MqttServiceConstants.SEND_ACTION.equals(action)) {
			sendAction(data);
		}
		else if (MqttServiceConstants.MESSAGE_DELIVERED_ACTION.equals(action)) {
			messageDeliveredAction(data);
		}
		else if (MqttServiceConstants.ON_CONNECTION_LOST_ACTION
				.equals(action)) {
			connectionLostAction(data);
		}
		else if (MqttServiceConstants.DISCONNECT_ACTION.equals(action)) {
			disconnected(data);
		}
		else if (MqttServiceConstants.TRACE_ACTION.equals(action)) {
			traceAction(data);
		}else{
			mqttService.traceError(MqttService.TAG, "Callback action doesn't exist.");	
		}

	}

	/**
	 * Acknowledges a message received on the
	 * {@link MqttCallback#messageArrived(String, MqttMessage)}
	 * 
	 * @param messageId
	 *            the messageId received from the MqttMessage (To access this
	 *            field you need to cast {@link MqttMessage} to
	 *            {@link ParcelableMqttMessage})
	 * @return whether or not the message was successfully acknowledged
	 */
	public boolean acknowledgeMessage(String messageId) {
		if (messageAck == Ack.MANUAL_ACK) {
			Status status = mqttService.acknowledgeMessageArrival(clientHandle, messageId);
			return status == Status.OK;
		}
		return false;

	}
	
	public void messageArrivedComplete(int messageId, int qos) throws MqttException {
		throw new UnsupportedOperationException();	
	}
	
	public void setManualAcks(boolean manualAcks) {
		throw new UnsupportedOperationException();	
	}

	/**
	 * Process the results of a connection
	 * 
	 * @param data
	 */
	private void connectAction(Bundle data) {
		IMqttToken token = connectToken;
		removeMqttToken(data);
		
		simpleAction(token, data);
	}



	/**
	 * Process a notification that we have disconnected
	 * 
	 * @param data
	 */
	private void disconnected(Bundle data) {
		clientHandle = null; // avoid reuse!
		IMqttToken token = removeMqttToken(data);
		if (token != null) {
			((MqttTokenAndroid) token).notifyComplete();
		}
		if (callback != null) {
			callback.connectionLost(null);
		}
	}

	/**
	 * Process a Connection Lost notification
	 * 
	 * @param data
	 */
	private void connectionLostAction(Bundle data) {
		if (callback != null) {
			Exception reason = (Exception) data
					.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
			callback.connectionLost(reason);
		}
	}

	private void connectExtendedAction(Bundle data){
		// This is called differently from a normal connect

		if(callback instanceof MqttCallbackExtended){
			boolean reconnect = data.getBoolean(MqttServiceConstants.CALLBACK_RECONNECT, false);
			String serverURI = data.getString(MqttServiceConstants.CALLBACK_SERVER_URI);
			((MqttCallbackExtended) callback).connectComplete(reconnect, serverURI);
		}

	}

	/**
	 * Common processing for many notifications
	 * 
	 * @param token
	 *            the token associated with the action being undertake
	 * @param data
	 *            the result data
	 */
	private void simpleAction(IMqttToken token, Bundle data) {
		if (token != null) {
			Status status = (Status) data
					.getSerializable(MqttServiceConstants.CALLBACK_STATUS);
			if (status == Status.OK) {
				((MqttTokenAndroid) token).notifyComplete();
			}
			else {
				Exception exceptionThrown = (Exception) data.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
				((MqttTokenAndroid) token).notifyFailure(exceptionThrown);
			}
		} else {
			mqttService.traceError(MqttService.TAG, "simpleAction : token is null");	
		}
	}

	/**
	 * Process notification of a publish(send) operation
	 * 
	 * @param data
	 */
	private void sendAction(Bundle data) {
		IMqttToken token = getMqttToken(data); // get, don't remove - will
		// remove on delivery
		simpleAction(token, data);
	}

	/**
	 * Process notification of a subscribe operation
	 * 
	 * @param data
	 */
	private void subscribeAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		simpleAction(token, data);
	}

	/**
	 * Process notification of an unsubscribe operation
	 * 
	 * @param data
	 */
	private void unSubscribeAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		simpleAction(token, data);
	}

	/**
	 * Process notification of a published message having been delivered
	 * 
	 * @param data
	 */
	private void messageDeliveredAction(Bundle data) {
		IMqttToken token = removeMqttToken(data);
		if (token != null) {
			if (callback != null) {
				Status status = (Status) data
						.getSerializable(MqttServiceConstants.CALLBACK_STATUS);
				if (status == Status.OK && token instanceof IMqttDeliveryToken) {
					callback.deliveryComplete((IMqttDeliveryToken) token);
				}
			}
		}
	}

	/**
	 * Process notification of a message's arrival
	 * 
	 * @param data
	 */
	private void messageArrivedAction(Bundle data) {
		if (callback != null) {
			String messageId = data
					.getString(MqttServiceConstants.CALLBACK_MESSAGE_ID);
			String destinationName = data
					.getString(MqttServiceConstants.CALLBACK_DESTINATION_NAME);

			ParcelableMqttMessage message = data
					.getParcelable(MqttServiceConstants.CALLBACK_MESSAGE_PARCEL);
			try {
				if (messageAck == Ack.AUTO_ACK) {
					callback.messageArrived(destinationName, message);
					mqttService.acknowledgeMessageArrival(clientHandle, messageId);
				}
				else {
					message.messageId = messageId;
					callback.messageArrived(destinationName, message);
				}

				// let the service discard the saved message details
			}
			catch (Exception e) {
				// Swallow the exception
			}
		}
	}
	
	/**
	 * Process trace action - pass trace data back to the callback
	 * 
	 * @param data
	 */
	private void traceAction(Bundle data) {

		if (traceCallback != null) {
			String severity = data.getString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY);
			String message =  data.getString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE);
			String tag = data.getString(MqttServiceConstants.CALLBACK_TRACE_TAG);
			if (MqttServiceConstants.TRACE_DEBUG.equals(severity)) 
				traceCallback.traceDebug(tag, message);
			else if (MqttServiceConstants.TRACE_ERROR.equals(severity)) 
				traceCallback.traceError(tag, message);
			else
			{
				Exception e = (Exception) data.getSerializable(MqttServiceConstants.CALLBACK_EXCEPTION);
				traceCallback.traceException(tag, message, e);
			}
		}
	}
	
	/**
	 * @param token
	 *            identifying an operation
	 * @return an identifier for the token which can be passed to the Android
	 *         Service
	 */
	private synchronized String storeToken(IMqttToken token) {
		tokenMap.put(tokenNumber, token);
		return Integer.toString(tokenNumber++);
	}

	/**
	 * Get a token identified by a string, and remove it from our map
	 * 
	 * @param data
	 * @return the token
	 */
	private synchronized IMqttToken removeMqttToken(Bundle data) {
		
		String activityToken = data.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
		if (activityToken!=null){
			int tokenNumber = Integer.parseInt(activityToken);
			IMqttToken token = tokenMap.get(tokenNumber);
			tokenMap.delete(tokenNumber);
			return token;
		}
		return null;
	}

	/**
	 * Get a token identified by a string, and remove it from our map
	 * 
	 * @param data
	 * @return the token
	 */
	private synchronized IMqttToken getMqttToken(Bundle data) {
		String activityToken = data
				.getString(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
		return tokenMap.get(Integer.parseInt(activityToken));
	}

	/**
	 * Sets the DisconnectedBufferOptions for this client
	 * @param bufferOpts the DisconnectedBufferOptions
	 */
	public void setBufferOpts(DisconnectedBufferOptions bufferOpts) {
		mqttService.setBufferOpts(clientHandle, bufferOpts);
	}

	public int getBufferedMessageCount(){
		return mqttService.getBufferedMessageCount(clientHandle);
	}

	public MqttMessage getBufferedMessage(int bufferIndex){
		return mqttService.getBufferedMessage(clientHandle, bufferIndex);
	}

	public void deleteBufferedMessage(int bufferIndex){
		mqttService.deleteBufferedMessage(clientHandle, bufferIndex);
	}
	
	/**
	 * Get the SSLSocketFactory using SSL key store and password
	 * <p>
	 * A convenience method, which will help user to create a SSLSocketFactory
	 * object
	 * </p>
	 * 
	 * @param keyStore
	 *            the SSL key store which is generated by some SSL key tool,
	 *            such as keytool in Java JDK
	 * @param password
	 *            the password of the key store which is set when the key store
	 *            is generated
	 * @return SSLSocketFactory used to connect to the server with SSL
	 *         authentication
	 * @throws MqttSecurityException
	 *             if there was any error when getting the SSLSocketFactory
	 */
	public SSLSocketFactory getSSLSocketFactory (InputStream keyStore, String password) throws MqttSecurityException {
	 try{
		 SSLContext ctx = null;
		 SSLSocketFactory sslSockFactory=null;
		 KeyStore ts;
		 ts = KeyStore.getInstance("BKS");			
		 ts.load(keyStore, password.toCharArray());
		 TrustManagerFactory tmf = TrustManagerFactory.getInstance("X509");
		 tmf.init(ts);
		 TrustManager[] tm = tmf.getTrustManagers();
		 ctx = SSLContext.getInstance("TLSv1");
		 ctx.init(null, tm, null);
		 
		 sslSockFactory=ctx.getSocketFactory();
		 return sslSockFactory;
		 
		} catch (KeyStoreException | CertificateException | IOException | NoSuchAlgorithmException | KeyManagementException e) {
			throw new MqttSecurityException(e);
		}
	}

	@Override
	public void disconnectForcibly() throws MqttException {
		throw new UnsupportedOperationException();
	}
	
	@Override
	public void disconnectForcibly(long disconnectTimeout) throws MqttException {
		throw new UnsupportedOperationException();
	}
	
	@Override
	public void disconnectForcibly(long quiesceTimeout, long disconnectTimeout)
			throws MqttException {
		throw new UnsupportedOperationException();	
	}
	
	/**
	 * Unregister receiver which receives intent from MqttService avoids
	 * IntentReceiver leaks.
	 */
	public void unregisterResources(){
		if(myContext != null && receiverRegistered){
			synchronized (MqttAndroidClient.this) {
				LocalBroadcastManager.getInstance(myContext).unregisterReceiver(this);
				receiverRegistered = false;
			}
			if(bindedService){
				try{
					myContext.unbindService(serviceConnection);
					bindedService = false;
				}catch(IllegalArgumentException e){
					//Ignore unbind issue.
				}
			}
		}
	}
	
	/**
	 * Register receiver to receiver intent from MqttService. Call this method
	 * when activity is hidden and become to show again.
	 * 
	 * @param context
	 *            - Current activity context.
	 */
	public void registerResources(Context context){
		if(context != null){
			this.myContext = context;
			if(!receiverRegistered){
				registerReceiver(this);
			}
		}
	}
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/PingDeathDetector.java">
package org.eclipse.paho.android.service;

import android.content.Context;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

public class PingDeathDetector {
    private static PingDeathDetector instance;

    private long lastPingTimestamp = 0;

    private PingDeathDetector() {
    }

    public static PingDeathDetector getInstance() {
        if (instance == null) {
            instance = new PingDeathDetector();
        }
        return instance;
    }

    public void registerPing() {
        lastPingTimestamp = System.currentTimeMillis();
    }

    public boolean detectPingDeath(Context context) {
        Log.d(Const.LOG_TAG, "checkPingDeath(): last connect " + lastPingTimestamp + ", current time " + System.currentTimeMillis());
        boolean pingDeath = lastPingTimestamp != 0 && lastPingTimestamp < System.currentTimeMillis() - 1800000;
        if (pingDeath) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "PingDeathDetector: lastPingTimestamp=" + lastPingTimestamp +
                    ", now=" + System.currentTimeMillis());
        }
        return pingDeath;
    }
}
</file>

<file path="app/src/main/res/layout/activity_admin.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout>

    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:app="http://schemas.android.com/apk/res-auto"
        android:id="@+id/activity_app_list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        tools:context="com.hmdm.launcher.ui.AdminActivity"
        android:gravity="center_horizontal">

        <androidx.appcompat.widget.Toolbar
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            app:title="@string/admin_title"
            app:navigationIcon="@drawable/ic_arrow_back_white_24dp"
            android:id="@+id/toolbar"/>

        <ScrollView
            android:layout_width="match_parent"
            android:layout_height="match_parent">

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"
                >

        <TextView
            android:id="@+id/deviceId"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textColor="@color/white"
            android:textSize="20dp"
            android:gravity="center_horizontal"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            />

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_allow_settings"
            android:onClick="allowSettings"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_clear_restrictions"
            android:onClick="clearRestrictions"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_change_device_id"
            android:onClick="changeDeviceId"/>

        <Button
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_change_server_url"
            android:onClick="changeServerUrl"/>

        <Button
            android:visibility="gone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_refresh"
            android:onClick="updateConfig"/>

        <Button
            android:id="@+id/systemLauncherButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_exit"
            android:onClick="exitToSystemLauncher"/>

        <Button
            android:id="@+id/resetPermissionsButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_reset_permissions"
            android:onClick="resetPermissions"/>

        <Button
            android:id="@+id/resetNetworkButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/admin_reset_network"
            android:onClick="resetNetworkPolicy"/>

        <Button
            android:id="@+id/rebootButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginBottom="@dimen/activity_vertical_margin"
            android:layout_marginLeft="@dimen/activity_horizontal_margin"
            android:layout_marginRight="@dimen/activity_horizontal_margin"
            android:text="@string/reboot"
            android:onClick="reboot"/>

            </LinearLayout>
        </ScrollView>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/activity_error_details.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
    </data>

    <LinearLayout
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.ErrorDetailsActivity">

        <EditText
            android:id="@+id/editMessage"
            android:layout_width="match_parent"
            android:layout_height="0px"
            android:layout_weight="1"
            android:editable="false"
            android:inputType="none"
            android:textIsSelectable="true"
            android:layout_margin="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"/>

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:gravity="center_vertical|center_horizontal"
                android:layout_margin="@dimen/activity_horizontal_margin"
                android:orientation="horizontal">

                <Button
                    android:id="@+id/resetButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/main_activity_reset"
                    android:layout_margin="@dimen/activity_vertical_margin"
                    android:background="@color/wizardPrimary"
                    android:textColor="@color/white"
                    android:onClick="resetClicked"
                    android:paddingLeft="@dimen/activity_horizontal_margin"
                    android:paddingRight="@dimen/activity_horizontal_margin"
                    ></Button>

                <Button
                    android:id="@+id/closeButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@string/close"
                    android:layout_margin="@dimen/activity_vertical_margin"
                    android:background="@color/wizardPrimary"
                    android:textColor="@color/white"
                    android:onClick="closeClicked"
                    android:paddingLeft="@dimen/activity_horizontal_margin"
                    android:paddingRight="@dimen/activity_horizontal_margin"
                    ></Button>

            </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/layout_application_not_allowed.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/colorPrimaryDark">

    <LinearLayout
        android:focusable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:gravity="center"
        android:padding="@dimen/activity_horizontal_margin"
        android:layout_centerInParent="true">

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="@string/access_to_app_denied"
            android:id="@+id/message"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:layout_margin="@dimen/activity_vertical_margin"
            android:textSize="@dimen/title_text_size"
            android:textStyle="bold"
            android:textColor="@color/white"
            android:id="@+id/package_id"/>

        <TextView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:gravity="center"
            android:text="@string/access_to_app_denied_2"
            android:id="@+id/message2"/>

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin">

            <Button
                android:layout_width="@dimen/block_window_button_width"
                android:layout_height="wrap_content"
                android:id="@+id/layout_application_not_allowed_continue"
                android:textSize="@dimen/button_text_size"
                android:text="@string/dialog_app_not_allowed_close"/>

            <Button
                android:layout_width="@dimen/block_window_button_width"
                android:layout_height="wrap_content"
                android:id="@+id/layout_application_not_allowed_admin"
                android:textSize="@dimen/button_text_size"
                android:text="@string/dialog_app_not_allowed_admin"
                android:layout_marginRight="@dimen/activity_horizontal_margin"/>

        </LinearLayout>

    </LinearLayout>

</RelativeLayout>
</file>

<file path="app/src/main/res/values/styles.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.NoActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="SetupWizardTheme" parent="Theme.AppCompat.Light.NoActionBar">
        <item name="colorPrimary">@color/wizardPrimary</item>
        <item name="colorPrimaryDark">@color/wizardPrimaryDark</item>
        <item name="colorAccent">@color/wizardAccent</item>
    </style>

</resources>
</file>

<file path="app/src/main/res/values-it/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Amministratore</string>
    <string name="install_error">Errore durante l\'installazione</string>
    <string name="file_create_error">Errore durante la creazione del file</string>
    <string name="dialog_enter_device_id_error">Questo ID non è registrato su %s. Ottieni l\'ID dalla scheda \"Dispositivi\" del pannello di controllo.</string>
    <string name="dialog_enter_device_id_qrcode">Codice QR</string>
    <string name="dialog_enter_device_id_variants">Varianti</string>
    <string name="dialog_enter_device_id_save">Salva</string>
    <string name="dialog_enter_device_id_exit">Esci</string>
    <string name="dialog_enter_device_id_title">Inserisci l\'ID dispositivo in %s</string>
    <string name="main_start_preparations">Preparazione all\'avvio</string>
    <string name="main_downloading_configuration">Aggiornamento del file di configurazione</string>
    <string name="main_downloading_content">Aggiornamento dei dati</string>
    <string name="main_update_applications">Installazione e aggiornamento delle applicazioni</string>
    <string name="dialog_root_message">Hai bisogno di accesso ROOT</string>
    <string name="main_application_start">Avvio applicazione</string>
    <string name="main_app_installing">Installazione applicazione</string>
    <string name="main_app_downloading">Download applicazione</string>
    <string name="main_app_downloading_error">Impossibile scaricare il pacchetto</string>
    <string name="main_app_removing">Disinstallazione applicazione</string>
    <string name="main_file_downloading">Download file</string>
    <string name="main_file_downloading_error">Impossibile scaricare il file</string>
    <string name="main_activity_repeat">Riprova</string>
    <string name="main_activity_reset">Reimposta</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Annulla</string> <string name="main_activity_details">Dettagli</string>
    <string name="select_system_launcher">Seleziona %s come launcher predefinito e seleziona \'Sempre\':</string>
    <string name="dialog_network_error_title">Errore di connessione a %s. Controlla la connessione Internet e riprova.</string>
    <string name="main_activity_update_config">Richiesta file di configurazione dal server</string>
    <string name="main_activity_applications_update">Aggiornamento applicazioni</string>
    <string name="dialog_overlay_settings_title">Consenti all\'app di sovrapporre altre finestre.\n\nQuesta opzione aiuta a bloccare le app indesiderate e consente lo sblocco di emergenza della modalità chiosco.\n\nTocca \"Continua\" per aprire le impostazioni. Trova la voce \"%s\", concedi l\'autorizzazione, quindi tocca \"Indietro\".</string>
    <string name="dialog_manage_storage_title">Consenti all\'app di gestire l\'archiviazione.\n\nQuesta opzione consente a Headwind MDM di gestire i file sul tuo dispositivo.</string>
    <string name="dialog_history_settings_title">Consenti all\'app di accedere ai dati di utilizzo.\n\nQuesta opzione consente il controllo di app e impostazioni.\n\nQuesta opzione potrebbe causare un consumo più rapido della batteria. Per risparmiare batteria, salta questa opzione (usa invece i servizi di accessibilità o la modalità chiosco).\n\nTocca \"Continua\" per aprire le impostazioni. Trova la voce \"%s\", concedi l\'autorizzazione, quindi tocca \"Indietro\".</string>
    <string name="dialog_history_settings_continue">Continua</string>
    <string name="dialog_history_settings_skip">Salta</string>
    <string name="dialog_unknown_sources_title">Consenti l\'installazione da fonti sconosciute. Ora si aprirà un foglio delle impostazioni. Trova \"Origini sconosciute\", consenti l\'installazione e fai clic su \"Indietro\".</string>
    <string name="dialog_unknown_sources_continue">Continua</string>
    <string name="dialog_miui_permissions_title">MIUI richiede la configurazione manuale delle autorizzazioni personalizzate. Ora si aprirà la finestra delle autorizzazioni app. Tocca \"Altre autorizzazioni\", consenti \"Visualizza finestre pop-up durante l\'esecuzione in background\" e fai clic su \"Indietro\".</string>
    <string name="dialog_miui_developer_title">MIUI richiede la configurazione manuale del tuo dispositivo. Nella schermata informativa, TOCCA 7 VOLTE SU \"NUMERO BUILD\". Ciò abiliterà le impostazioni sviluppatore.</string>
    <string name="dialog_miui_optimization_title">MIUI richiede la configurazione manuale del tuo dispositivo. Ora si aprirà la finestra delle impostazioni sviluppatore. Scorri la schermata verso il basso e deseleziona \"Ottimizzazione MIUI\".</string>
    <string name="dialog_administrator_mode_message">Consenti all\'app di funzionare in modalità amministratore dispositivo. Si aprirà ora un foglio Impostazioni. Seleziona \"Amministratori dispositivo\", trova la voce \"%s\", attiva l\'amministratore e tocca \"Indietro\".</string>
    <string name="dialog_administrator_mode_continue">Continua</string>
    <string name="dialog_administrator_mode_skip">Salta</string>
    <string name="accessibility_service_description">Monitoraggio app attivo tramite l\'applicazione MDM</string>
    <string name="dialog_accessibility_service_message">Consenti all\'app di utilizzare i servizi di accessibilità. Si aprirà ora un foglio Impostazioni. Trova la voce \"%s\", consenti di utilizzare i servizi di accessibilità e tocca \"Indietro\".</string>
    <string name="dialog_accessibility_service_continue">Continua</string>
    <string name="dialog_accessibility_service_skip">Salta</string>
    <string name="access_to_app_denied">Il pacchetto non è consentito:</string>
    <string name="access_to_app_denied_2">Chiedi all\'amministratore di abilitare questo pacchetto nella configurazione.\n\nFai clic sul pulsante \'Chiudi\' o Home per procedere.</string>
    <string name="package_id_copied">L\'ID del pacchetto viene copiato negli appunti</string>
    <string name="dialog_app_not_allowed_close">Chiudi</string>
    <string name="dialog_app_not_allowed_admin">Amministratore</string>
    <string name="device_id">ID dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numero di serie</string>
    <string name="phone_number">Numero di telefono</string>
    <string name="launcher_version">Versione del launcher</string>
    <string name="close">Chiudi</string>
    <string name="admin_change_device_id">Cambia ID dispositivo</string>
    <string name="admin_change_server_url">Cambia URL server</string>
    <string name="admin_allow_settings">Apri impostazioni</string>
    <string name="settings_allowed">Puoi modificare le impostazioni per 3 minuti.</string>
    <string name="admin_clear_restrictions">Cancella restrizioni</string>
    <string name="permissive_mode_enabled">Puoi eseguire tutte le app per 3 minuti.</string>
    <string name="admin_refresh">Aggiorna configurazione</string>
    <string name="admin_exit">Esci al launcher di sistema</string>
    <string name="admin_reset_permissions">Controlla autorizzazioni</string>
    <string name="admin_reset_network">Reimposta policy di rete</string>
    <string name="admin_reset_network_hint">Le policy di rete sono state cancellate. Ora puoi abilitare la rete e ricaricare la configurazione.</string>
    <string name="reboot">Riavvia il dispositivo</string>
    <string name="reboot_failed">Diritti insufficienti per riavviare il dispositivo.</string>
    <string name="message_turn_on_gps">Si aprirà la schermata delle impostazioni. Attiva la posizione GPS in questa schermata e fai clic su Indietro.</string>
    <string name="message_turn_off_gps">Si aprirà la schermata delle impostazioni. DISATTIVARE la posizione GPS in questa schermata e fai clic su Indietro.</string>
    <string name="message_turn_on_mobile_data">I dati mobili sono disabilitati! Apri la barra di stato e attiva i dati mobili.</string>
    <string name="message_turn_off_mobile_data">I dati mobili sono abilitati. Apri la barra di stato e DISATTIVARE i dati mobili.</string>
    <string name="message_set_password">La qualità della tua password non è sufficientemente buona. Si aprirà la schermata delle impostazioni. Cambia la password e fai clic su Indietro.</string>
    <string name="switch_off_blockings">Disattivazione delle restrizioni...</string>
    <string name="kiosk_mode_requires_overlays">Modalità chiosco disabilitata: nessuna autorizzazione a disegnare su altre finestre. Consenti a %s di disegnare su altre finestre.</string>
    <string name="enter_admin_password">Inserisci la password amministratore</string>
    <string name="wrong_password">Password errata</string>
    <string name="dialog_enter_password_login">Accedi</string>
    <string name="dialog_enter_password_cancel">Annulla</string>
    <string name="internal_error">L\'app ha riscontrato un errore interno. Riavvia il dispositivo e riprova l\'azione.</string>
    <string name="empty_configuration">La configurazione non è impostata, riprova a ottenere dal server!</string>
    <string name="permissions_reset_hint">Chiudi il pannello di amministrazione per controllare e richiedere le autorizzazioni.</string>
    <string name="dialog_enter_server_error">Inserisci un URL del server valido.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Inserisci l\'URL del server</string>
    <string name="critical_server_failure">Esci a causa di un errore del server! Risolvi il problema e riavvia %s, oppure rimuovilo completamente e reinstallalo.</string>
    <string name="dialog_permission_title">L\'app richiede le autorizzazioni per essere eseguita. Concedi le autorizzazioni richieste.</string>
    <string name="main_activity_exit">Esci</string>
    <string name="browser_not_found">Impossibile aprire la pagina Web perché il browser non è stato trovato. Aggiungi un\'app browser alla configurazione del dispositivo.</string>
    <string name="invalid_web_link">Impossibile aprire il collegamento Web perché non è ben formato. Contatta l\'amministratore per i dettagli.</string>

    <string name="activity_not_found">Impossibile eseguire l\'azione %s perché l\'attività non è stata trovata.</string>

    <string name="location_service_text">La posizione del dispositivo è monitorata</string>

    <string name="qrcode_contents_error">Contenuto del codice QR non valido. Genera il codice QR di provisioning nel pannello Web %s.</string>

    <string name="device_locked">Questo dispositivo (%s) è stato bloccato dall\'amministratore.</string>

    <string name="fault_loop_detected">Oops, il launcher ha riscontrato un errore irreversibile! Contatta l\'amministratore di sistema.</string>

    <string name="mqtt_service_text">Le notifiche push sono attive</string>

    <string name="background_location">%s richiede l\'autorizzazione per la posizione in background. Fai clic su \'Continua\' per aprire le autorizzazioni, fai clic su \'Posizione\' e consenti di determinare sempre la posizione.</string>
    <string name="location_disable">Disabilita posizione</string>
    <string name="background_location_continue">Continua</string>
    <string name="initializing_mdm">Inizializzazione dell\'applicazione di gestione dei dispositivi mobili...</string>
    <string name="dialog_server_error_title">Il server MDM %s ha restituito una risposta non valida. Contatta l\'amministratore.</string>
    <string name="mdm_choice_message">Questo dispositivo sarà completamente gestito dalla tua organizzazione. I tuoi dati non saranno privati e potranno essere cancellati o esaminati dal tuo amministratore IT in qualsiasi momento.</string>
    <string name="work_profile_message">Questo dispositivo otterrà un profilo di lavoro gestito appartenente alla tua organizzazione. Il profilo di lavoro è separato dal tuo profilo privato e puoi passare da un profilo all\'altro in qualsiasi momento.</string>
    <string name="overlays_not_supported">Purtroppo le sovrapposizioni non sono supportate dal tuo dispositivo.</string>
    <string name="admin_not_supported">Il tuo dispositivo non ha un\'opzione di amministratore dispositivo. Fai clic su Salta per continuare.</string>
    <string name="manage_storage_not_supported">Il tuo dispositivo non ha alcuna opzione per gestire la memoria esterna.</string>
</resources>
</file>

<file path="app/src/main/res/values-tr/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Yönetici</string>
	<string name="install_error">Yükleme hatası</string>
	<string name="file_create_error">Dosya oluşturma hatası</string>
	<string name="dialog_enter_device_id_error">Bu kimlik %s adresinde kayıtlı değil. Kontrol panelinin \"Cihazlar\" sekmesinden kimliği alın.</string>
	<string name="dialog_enter_device_id_qrcode">QR kodu</string>
	<string name="dialog_enter_device_id_variants">Varyantlar</string>
	<string name="dialog_enter_device_id_save">Kaydet</string>
	<string name="dialog_enter_device_id_exit">Çıkış</string>
	<string name="dialog_enter_device_id_title">%s adresindeki cihaz kimliğini girin</string>
	<string name="main_start_preparations">Başlatmaya hazırlanıyor</string>
	<string name="main_downloading_configuration">Yapılandırma dosyası güncelleniyor</string>
	<string name="main_downloading_content">Veriler güncelleniyor</string>
	<string name="main_update_applications">Uygulamalar yükleniyor ve güncelleniyor</string>
	<string name="dialog_root_message">ROOT erişimine ihtiyacınız var</string>
	<string name="main_application_start">Uygulama başlatılıyor</string>
	<string name="main_app_installing">Uygulama yükleniyor</string>
	<string name="main_app_downloading">Uygulama indiriliyor</string>
	<string name="main_app_downloading_error">Paket indirilemedi</string>
	<string name="main_app_removing">Uygulama kaldırılıyor</string>
	<string name="main_file_downloading">Dosya indiriliyor</string>
	<string name="main_file_downloading_error">Dosya indirilemedi</string>
	<string name="main_activity_repeat">Tekrar dene</string>
	<string name="main_activity_reset">Sıfırla</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">İptal</string>
	<string name="main_activity_details">Ayrıntılar</string>
	<string name="select_system_launcher">Varsayılan başlatıcı olarak %s\'yi seçin ve \'Her Zaman\'ı işaretleyin:</string>
	<string name="dialog_network_error_title">%s\'ye bağlanırken hata oluştu. Lütfen İnternet bağlantısını kontrol edin ve tekrar deneyin.</string>
	<string name="main_activity_update_config">Sunucudan yapılandırma dosyası isteniyor</string>
	<string name="main_activity_applications_update">Uygulamalar güncelleniyor</string>
	<string name="dialog_overlay_settings_title">Lütfen uygulamanın diğer pencerelerin üzerine çizim yapmasına izin verin.\n\nBu seçenek istenmeyen uygulamaların engellenmesine yardımcı olur ve kiosk modunun acil olarak kilidini açmayı sağlar.\n\nAyarları açmak için \"Devam\" öğesine dokunun. \"%s\" öğesini bulun, izni verin ve ardından \"Geri\" öğesine dokunun.</string>
	<string name="dialog_manage_storage_title">Lütfen uygulamanın depolama alanını yönetmesine izin verin.\n\nBu seçenek Headwind MDM\'nin cihazınızdaki dosyaları yönetmesine olanak tanır.</string>
	<string name="dialog_history_settings_title">Lütfen uygulamanın kullanım verilerine erişmesine izin verin.\n\nBu seçenek uygulamaların ve ayarların kontrolünü sağlar.\n\nBu seçenek pilin daha hızlı bitmesine neden olabilir. Pil tasarrufu için bu seçeneği atlayın (bunun yerine erişilebilirlik hizmetlerini veya kiosk modunu kullanın).\n\nAyarları açmak için \"Devam\" öğesine dokunun. \"%s\" öğesini bulun, izni verin ve ardından \"Geri\" öğesine dokunun.</string>
	<string name="dialog_history_settings_continue">Devam</string>
	<string name="dialog_history_settings_skip">Atla</string>
	<string name="dialog_unknown_sources_title">Lütfen bilinmeyen kaynaklardan yüklemeye izin verin. Şimdi bir ayarlar sayfası açılacak. \"Bilinmeyen kaynaklar\" öğesini bulun, yüklemeye izin verin ve \"Geri\" öğesine tıklayın.</string>
	<string name="dialog_unknown_sources_continue">Devam</string>
	<string name="dialog_miui_permissions_title">MIUI, özel izinlerin manuel olarak ayarlanmasını gerektirir. Uygulama izinleri penceresi şimdi açılacak. \"Diğer izinler\"e dokunun, \"Arka planda çalışırken açılır pencereleri görüntüle\"ye izin verin ve \"Geri\"ye tıklayın.</string>
	<string name="dialog_miui_developer_title">MIUI cihazınızın manuel kurulumunu gerektirir. Bilgi ekranında, \"DERLEME NUMARASI\"NA 7 KEZ DOKUNUN. Bu, geliştirici ayarlarını etkinleştirecektir.</string>
	<string name="dialog_miui_optimization_title">MIUI cihazınızın manuel kurulumunu gerektirir. Geliştirici ayarları penceresi şimdi açılacaktır. Ekranı aşağı kaydırın ve \"MIUI optimizasyonu\"nun işaretini kaldırın.</string>
	<string name="dialog_administrator_mode_message">Lütfen uygulamanın cihaz yöneticisi modunda çalışmasına izin verin. Şimdi bir Ayarlar sayfası açılacaktır. \"Cihaz yöneticileri\"ni seçin, \"%s\" öğesini bulun, yöneticiyi etkinleştirin ve \"Geri\"ye dokunun.</string>
	<string name="dialog_administrator_mode_continue">Devam</string>
	<string name="dialog_administrator_mode_skip">Atla</string>
	<string name="accessibility_service_description">MDM uygulaması tarafından etkin uygulama izleme</string>
	<string name="dialog_accessibility_service_message">Lütfen uygulamanın erişilebilirlik hizmetlerini kullanmasına izin verin. Şimdi bir Ayarlar sayfası açılacaktır. \"%s\" öğesini bulun, erişilebilirlik hizmetlerini kullanmaya izin verin ve \"Geri\" öğesine dokunun.</string>
	<string name="dialog_accessibility_service_continue">Devam</string>
	<string name="dialog_accessibility_service_skip">Atla</string>
	<string name="access_to_app_denied">Pakete izin verilmiyor:</string>
	<string name="access_to_app_denied_2">Lütfen yöneticinizden yapılandırmada bu paketi etkinleştirmesini isteyin.\n\nDevam etmek için \'Kapat\' veya Ana Sayfa düğmesine tıklayın.</string>
	<string name="package_id_copied">Paket kimliği panoya kopyalandı</string>
	<string name="dialog_app_not_allowed_close">Kapat</string>
	<string name="dialog_app_not_allowed_admin">Yönetici</string>
	<string name="device_id">Cihaz Kimlik</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">Seri numarası</string>
	<string name="phone_number">Telefon numarası</string>
	<string name="launcher_version">Başlatıcı sürümü</string>
	<string name="close">Kapat</string>
	<string name="admin_change_device_id">Cihaz kimliğini değiştir</string>
	<string name="admin_change_server_url">Sunucu URL\'sini değiştir</string>
	<string name="admin_allow_settings">Ayarları aç</string>
	<string name="settings_allowed">Ayarları 3 dakika boyunca değiştirmenize izin verilir.</string>
	<string name="admin_clear_restrictions">Kısıtlamaları temizle</string>
	<string name="permissive_mode_enabled">Tüm uygulamaları 3 dakika boyunca çalıştırmanıza izin verilir.</string>
	<string name="admin_refresh">Yapılandırmayı güncelle</string>
	<string name="admin_exit">Sistem başlatıcısından çık</string>
	<string name="admin_reset_permissions">İzinleri kontrol et</string>
	<string name="admin_reset_network">Ağ politikasını sıfırla</string>
	<string name="admin_reset_network_hint">Ağ politikaları temizlendi. Artık ağı etkinleştirebilir ve yapılandırmayı yeniden yükleyebilirsiniz.</string>
	<string name="reboot">Cihazı yeniden başlat</string>
	<string name="reboot_failed">Cihazı yeniden başlatmak için yeterli hak yok.</string>
	<string name="message_turn_on_gps">Ayarlar ekranı açılacaktır. Lütfen bu ekranda GPS konumunu açın ve Geri\'ye tıklayın.</string>
	<string name="message_turn_off_gps">Ayarlar ekranı açılacaktır. Lütfen bu ekranda GPS konumunu KAPATIN ve Geri\'ye tıklayın.</string>
	<string name="message_turn_on_mobile_data">Mobil veri devre dışı! Lütfen durum çubuğunu açın ve mobil veriyi açın.</string>
	<string name="message_turn_off_mobile_data">Mobil veri etkin. Lütfen durum çubuğunu açın ve mobil veriyi KAPATIN.</string>
	<string name="message_set_password">Şifrenizin kalitesi yeterince iyi değil. Ayarlar ekranı açılacaktır. Lütfen şifreyi değiştirin ve Geri\'ye tıklayın.</string>
	<string name="switch_off_blockings">Kısıtlamalar kapatılıyor...</string>
	<string name="kiosk_mode_requires_overlays">Kiosk modu devre dışı bırakıldı: diğer pencerelerin üzerine çizim yapma izni yok. Lütfen %s\'nin diğer pencerelerin üzerine çizim yapmasına izin verin.</string>
	<string name="enter_admin_password">Yönetici şifresini girin</string>
	<string name="wrong_password">Yanlış şifre</string>
	<string name="dialog_enter_password_login">Giriş yap</string>
	<string name="dialog_enter_password_cancel">İptal</string>
	<string name="internal_error">Uygulama dahili bir hatayla karşılaştı. Lütfen cihazı yeniden başlatın ve işlemi tekrar deneyin.</string>
	<string name="empty_configuration">Yapılandırma ayarlanmadı, sunucudan almaya tekrar çalışılıyor!</string>
	<string name="permissions_reset_hint">İzinleri kontrol etmek ve talep etmek için yönetici panelini kapatın.</string>
	<string name="dialog_enter_server_error">Lütfen geçerli bir sunucu URL\'si girin.</string>
	<string name="dialog_enter_server_ok">Tamam</string>
	<string name="dialog_enter_server_title">Lütfen sunucu URL\'sini girin</string>
	<string name="critical_server_failure">Sunucu hatası nedeniyle çıkın! Lütfen sorunu düzeltin ve %s uygulamasını yeniden başlatın veya tamamen kaldırıp yeniden yükleyin.</string>
	<string name="dialog_permission_title">Uygulamanın çalışması için izinlere ihtiyaç var. Lütfen istenen izinleri verin.</string>
	<string name="main_activity_exit">Çıkış</string>
	<string name="browser_not_found">Tarayıcı bulunamadığından web sayfası açılamıyor. Lütfen cihaz yapılandırmasına bir tarayıcı uygulaması ekleyin.</string>
	<string name="invalid_web_link">Web bağlantısı düzgün biçimlendirilmediği için açılamıyor. Lütfen ayrıntılar için yöneticinizle iletişime geçin.</string>
	<string name="activity_not_found">Etkinlik bulunamadığından %s eylemi gerçekleştirilemiyor.</string>
	<string name="location_service_text">Cihaz konumu izleniyor</string>
	<string name="qrcode_contents_error">Geçersiz QR kodu içerikleri. Lütfen %s web panelinde sağlama QR kodunu oluşturun.</string>
	<string name="device_locked">Bu cihaz (%s) yönetici tarafından kilitlendi.</string>
	<string name="fault_loop_detected">Oops, başlatıcıda kurtarılamaz bir hata oluştu! Lütfen sistem yöneticinizle iletişime geçin.</string>
	<string name="mqtt_service_text">Anında bildirimler etkin</string>
	<string name="background_location">%s, arka plan konum iznini gerektirir. İzinleri açmak için \'Devam\'a tıklayın, \'Konum\'a tıklayın ve konumun her zaman belirlenmesine izin verin.</string>
	<string name="location_disable">Konumu devre dışı bırak</string>
	<string name="background_location_continue">Devam</string>
	<string name="initializing_mdm">Mobil cihaz yönetim uygulaması başlatılıyor...</string>
	<string name="dialog_server_error_title">MDM sunucusu %s geçersiz bir yanıt döndürdü. Lütfen yöneticinizle iletişime geçin.</string>
	<string name="mdm_choice_message">Bu cihaz kuruluşunuz tarafından tamamen yönetilecektir. Verileriniz özel olmayacak ve istediğiniz zaman BT yöneticiniz tarafından silinebilir veya incelenebilir.</string>
	<string name="work_profile_message">Bu cihaz kuruluşunuza ait yönetilen bir çalışma profili alacaktır. Çalışma profili özel profilinizden ayrılmıştır ve istediğiniz zaman profiller arasında geçiş yapabilirsiniz.</string>
	<string name="overlays_not_supported">Ne yazık ki cihazınız kaplamaları desteklemiyor.</string>
	<string name="admin_not_supported">Cihazınızda cihaz yöneticisi seçeneği yok. Devam etmek için Atla\'ya tıklayın.</string>
	<string name="manage_storage_not_supported">Cihazınızda harici depolamayı yönetme seçeneği bulunmuyor.</string>
</resources>
</file>

<file path="app/src/main/res/xml/network_security_config.xml">
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config cleartextTrafficPermitted="true">
        <trust-anchors>
            <certificates src="system"/>
            <certificates src="user"/>
        </trust-anchors>
    </base-config>
</network-security-config>
</file>

<file path="lib/src/main/aidl/com/hmdm/IMdmApi.aidl">
// IMdmApi.aidl
package com.hmdm;

// Declare any non-default types here with import statements

interface IMdmApi {
    /**
     * Get the MDM configuration (non-privileged, no sensitive info)
     */
    Bundle queryConfig();

    /**
     * Send a log message
     */
    void log(long timestamp, int level, String packageId, String message);

    /**
     * Get app preference
     */
    String queryAppPreference(String packageId, String attr);

    /**
     * Set app preference
     */
    boolean setAppPreference(String packageId, String attr, String value);

    /**
     * Send app preferences to server
     */
    void commitAppPreferences(String packageId);

    // Added in library version 1.1.3
    // All new methods should be added at the end of the AIDL file!!!

    /**
     * Get the API version supported by the launcher (1.1.3 = 113)
     */
    int getVersion();

    /**
     * Get the MDM configuration (privileged, including IMEI and serial number)
     */
    Bundle queryPrivilegedConfig(String apiKey);

    /**
     * Set a custom field to send it to the server
     */
    void setCustom(int number, String value);

    // Added in library version 1.1.5
    /**
     * Force the configuration update
     */
    void forceConfigUpdate();
}
</file>

<file path="lib/src/main/java/com/hmdm/Const.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

class Const {
    static final String SERVICE_ACTION = "com.hmdm.action.Connect";
    static final String PACKAGE = "com.hmdm.launcher";
    static final String LEGACY_PACKAGE = "ru.headwind.kiosk";
    static final String ADMIN_RECEIVER_CLASS = "com.hmdm.launcher.AdminReceiver";

    public static final String INTENT_PUSH_NOTIFICATION_PREFIX = "com.hmdm.push.";
    public static final String INTENT_PUSH_NOTIFICATION_EXTRA = "com.hmdm.PUSH_DATA";

    public static final String LOG_TAG ="HeadwindMDMAPI";

    public static final String NOTIFICATION_CONFIG_UPDATED = "com.hmdm.push.configUpdated";

    public static final int HMDM_RECONNECT_DELAY_FIRST = 5000;
    public static final int HMDM_RECONNECT_DELAY_NEXT = 60000;
}
</file>

<file path="lib/src/main/java/com/hmdm/MDMError.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

public class MDMError {
    public int code;
    public MDMError() {
        code = 0;
    }
    public MDMError(int code) {
        this.code = code;
    }

    public static String getMessage(int code) {
        switch (code) {
            case NO_ERROR:
                return "";
            case ERROR_NO_MDM:
                return "Headwind MDM not installed";
            case ERROR_INTERNAL:
                return "Internal Headwind MDM error";
            case ERROR_GENERAL:
                return "General error";
            case ERROR_DISCONNECTED:
                return "MDM service not connected";
            case ERROR_INVALID_PARAMETER:
                return "Invalid parameter";
            case ERROR_VERSION:
                return "Please update Headwind MDM launcher";
            case ERROR_KEY_NOT_MATCH:
                return "API key is not correct";
            case ERROR_NOT_CONFIGURED:
                return "Mobile agent is not configured";
            default:
                return "Unknown error";
        }
    }

    public String getMessage() {
        return getMessage(code);
    }

    public static final int NO_ERROR = 0;
    public static final int ERROR_NO_MDM = 1;           // Headwind MDM not installed
    public static final int ERROR_INTERNAL = 2;         // Launcher internal error
    public static final int ERROR_GENERAL = 3;          // Library error
    public static final int ERROR_DISCONNECTED = 4;     // Service disconnected
    public static final int ERROR_INVALID_PARAMETER = 5;
    public static final int ERROR_VERSION = 6;          // Launcher needs to update
    public static final int ERROR_KEY_NOT_MATCH = 7;    // API key does not match
    public static final int ERROR_NOT_CONFIGURED = 8;  // Headwind MDM is not configured
}
</file>

<file path="build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
        maven {
            url 'https://maven.google.com/'
            name 'Google'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
        google()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="README.md">
# Headwind MDM: free and open-source MDM launcher

A Powerful Open Source Platform to Manage your Enterprise Android Devices

[<img src="https://fdroid.gitlab.io/artwork/badge/get-it-on.png"
     alt="Get it on F-Droid"
     height="80">](https://f-droid.org/packages/com.hmdm.launcher/)

## Starting work

Open the project directory in Android Studio (use default settings).

## Debugging on the device

1. Connect the device by USB
2. Click "Run 'App'" icon in Android Studio
3. After successful run, add device owner rights to the app (optional).

    Run in the console
   
    `adb shell`

    Run the command in the adb console
   
    `dpm set-device-owner com.hmdm.launcher/.AdminReceiver`

## Building the APK

Build the APK after you successfully build the app.

1. Setup the keys for signing the app
2. Select Build - Generate signed Bundle / APK
3. Select the place you'd like to save APK

## Building the library

1. Select the 'lib' item in the project tree
2. Select Build - Make Module 'lib'
3. Find the library in the 'lib/build/outputs/aar' directory

## Building the project in the command line

1. Install the Gradle plugin v5.1.1 (Linux only)
2. Install Android Studio or download the standalone Android SDK
3. Create the file local.properties and store the SDK location in this file:

sdk.dir=/path/to/sdk

4. Run the command

gradlew build

5. Find the resulting APK in the app/build/outputs/apk/release/ directory.
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/CertInstaller.java">
package com.hmdm.launcher.helper;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.Build;
import android.util.Log;

import androidx.annotation.RequiresApi;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.util.LegacyUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

import java.io.IOException;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.Enumeration;
import java.util.LinkedList;
import java.util.List;

public class CertInstaller {
    static class CertEntry {
        public String path;
        public String cert;
        public CertEntry() {}
        public CertEntry(String path, String cert) {
            this.path = path;
            this.cert = cert;
        }
    }

    public static List<CertEntry> getCertificatesFromAssets(Context context) {
        String[] names = context.getResources().getStringArray(R.array.certificates);
        if (names == null) {
            return null;
        }
        List<CertEntry> result = new LinkedList<>();
        for (String name : names) {
            try {
                String cert = Utils.loadStreamAsString(new InputStreamReader(context.getAssets().open(name)));
                if (cert != null) {
                    result.add(new CertEntry(name, cert));
                } else {
                    Log.e(Const.LOG_TAG, "Failed to read certificate " + name);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return result;
    }

    public static List<CertEntry> getCertificatesFromFiles(Context context, String paths) {
        String[] names = paths.split("[;:,]");
        if (names == null) {
            return null;
        }
        List<CertEntry> result = new LinkedList<>();
        for (String name : names) {
            String adjustedName = name;
            if (!adjustedName.startsWith("/storage/emulated/0/")) {
                if (!adjustedName.startsWith("/")) {
                    adjustedName = "/" + adjustedName;
                }
                adjustedName = "/storage/emulated/0" + adjustedName;
            }
            try {
                String cert = Utils.loadFileAsString(adjustedName);
                if (cert != null) {
                    result.add(new CertEntry(adjustedName, cert));
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to read certificate " + adjustedName);
                }
            } catch (IOException e) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to read certificate " + adjustedName + ": " + e.getMessage());
                e.printStackTrace();
            }
        }
        return result;
    }

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static boolean installCertificate(Context context, String cert, String path, boolean remoteLog) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            boolean res = dpm.installCaCert(adminComponentName, cert.getBytes());
            if (remoteLog) {
                if (res) {
                    RemoteLogger.log(context, Const.LOG_INFO, "Certificate installed: " + path);
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to install certificate " + path);
                }
            } else {
                if (res) {
                    Log.d(Const.LOG_TAG, "Certificate installed: " + path);
                } else {
                    Log.w(Const.LOG_TAG, "Failed to install certificate: " + path);
                }
            }
            return res;
        } catch (Exception e) {
            if (remoteLog) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to install certificate " + path + ": " + e.getMessage());
            } else {
                Log.w(Const.LOG_TAG, "Failed to install certificate " + path + ": " + e.getMessage());
            }
            e.printStackTrace();
            return false;
        }
    }

    public static void installCertificatesFromAssets(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        List<CertEntry> certs = getCertificatesFromAssets(context);
        if (certs == null || certs.size() == 0) {
            return;
        }
        for (CertEntry cert : certs) {
            // Do not log installation of certificates from assets
            // because the remote logger is not yet initialized
            installCertificate(context, cert.cert, cert.path, false);
        }
    }

    public static void installCertificatesFromFiles(Context context, String paths) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        List<CertEntry> certs = getCertificatesFromFiles(context, paths);
        if (certs == null || certs.size() == 0) {
            return;
        }
        for (CertEntry cert : certs) {
            installCertificate(context, cert.cert, cert.path, true);
        }
    }

    public static List<String> getInstalledCerts() {
        try {
            List<String> result = new LinkedList<>();
            KeyStore ks = KeyStore.getInstance("AndroidCAStore");

            if (ks != null) {
                ks.load(null, null);
                Enumeration<String> aliases = ks.aliases();

                while (aliases.hasMoreElements()) {
                    String alias = aliases.nextElement();
                    java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);
                    result.add(cert.getIssuerDN().getName());
                }

                return result;
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (java.security.cert.CertificateException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/MigrationHelper.java">
package com.hmdm.launcher.helper;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.ServerConfigResponse;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.server.ServerUrl;

import java.net.MalformedURLException;

import retrofit2.Response;

public class MigrationHelper {

    public interface CompletionHandler {
        public void onSuccess();
        public void onError(String cause);
    }

    private ServerUrl serverUrl;

    public MigrationHelper(String url) throws MalformedURLException {
        serverUrl = new ServerUrl(url);
    }

    public String getBaseUrl() {
        return serverUrl.baseUrl;
    }

    public String getServerProject() {
        return serverUrl.serverProject;
    }

    public boolean needMigrating(Context context) {
        return !serverUrl.baseUrl.equalsIgnoreCase(SettingsHelper.getInstance(context).getBaseUrl()) ||
               !serverUrl.serverProject.equalsIgnoreCase(SettingsHelper.getInstance(context).getServerProject());
    }

    // Before migration, test that URL is working well
    public void tryNewServer(final Context context, final CompletionHandler completionHandler) {
        new AsyncTask<Void, Void, String>() {
            @Override
            protected String doInBackground(Void... voids) {
                final ServerService newServer;
                try {
                    newServer = ServerServiceKeeper.createServerService(serverUrl.baseUrl);
                } catch (Exception e) {
                    return e.getMessage();
                }

                Response<ServerConfigResponse> response = null;
                SettingsHelper settingsHelper = SettingsHelper.getInstance(context);

                String deviceId = settingsHelper.getDeviceId();
                String signature = "";
                try {
                    signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + deviceId);
                } catch (Exception e) {
                }

                try {
                    response = newServer.getServerConfig(serverUrl.serverProject, deviceId, signature, Build.CPU_ABI).execute();
                } catch (Exception e) {
                    e.printStackTrace();
                }

                if (response == null) {
                    return "Network error";
                }

                if (!response.isSuccessful()) {
                    return "Bad server response: " + response.message();
                }

                if (!Const.STATUS_OK.equals(response.body().getStatus())) {
                    return "Bad server status: " + response.body().getStatus();
                }

                if (response.body().getData() == null) {
                    return "Failed to parse server response";
                }

                // We get something JSON-like, let's conclude the request has been successful!
                return null;
            }

            @Override
            protected void onPostExecute(String error) {
                if (error == null) {
                    completionHandler.onSuccess();
                } else {
                    completionHandler.onError(error);
                }
            }
        }.execute();
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AppShortcutManager.java">
package com.hmdm.launcher.ui;

import android.content.Context;
import android.content.pm.ApplicationInfo;

import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.util.AppInfo;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AppShortcutManager {

    private static AppShortcutManager instance;

    public static AppShortcutManager getInstance() {
        if (instance == null) {
            instance = new AppShortcutManager();
        }
        return instance;
    }

    public int getInstalledAppCount(Context context, boolean bottom) {
        Map<String, Application> requiredPackages = new HashMap();
        Map<String, Application> requiredLinks = new HashMap();
        getConfiguredApps(context, bottom, requiredPackages, requiredLinks);
        List<ApplicationInfo> packs = context.getPackageManager().getInstalledApplications(0);
        if (packs == null) {
            return requiredLinks.size();
        }
        // Calculate applications
        int packageCount = 0;
        for(int i = 0; i < packs.size(); i++) {
            ApplicationInfo p = packs.get(i);
            if (context.getPackageManager().getLaunchIntentForPackage(p.packageName) != null &&
                    requiredPackages.containsKey(p.packageName)) {
                packageCount++;
            }
        }
        return requiredLinks.size() + packageCount;
    }

    public List<AppInfo> getInstalledApps(Context context, boolean bottom) {
        Map<String, Application> requiredPackages = new HashMap();
        Map<String, Application> requiredLinks = new HashMap();
        getConfiguredApps(context, bottom, requiredPackages, requiredLinks);

        List<AppInfo> appInfos = new ArrayList<>();
        List<ApplicationInfo> packs = context.getPackageManager().getInstalledApplications(0);
        if (packs == null) {
            return new ArrayList<AppInfo>();
        }
        // First we display app icons
        for(int i = 0; i < packs.size(); i++) {
            ApplicationInfo p = packs.get(i);
            if ( context.getPackageManager().getLaunchIntentForPackage(p.packageName) != null &&
                    requiredPackages.containsKey( p.packageName ) ) {
                Application app = requiredPackages.get(p.packageName);
                AppInfo newInfo = new AppInfo();
                newInfo.type = AppInfo.TYPE_APP;
                newInfo.keyCode = app.getKeyCode();
                newInfo.name = app.getIconText() != null ? app.getIconText() : p.loadLabel(context.getPackageManager()).toString();
                newInfo.packageName = p.packageName;
                newInfo.iconUrl = app.getIcon();
                newInfo.screenOrder = app.getScreenOrder();
                newInfo.longTap = app.isLongTap() ? 1 : 0;
                appInfos.add(newInfo);
            }
        }

        // Then we display weblinks
        for (Map.Entry<String, Application> entry : requiredLinks.entrySet()) {
            AppInfo newInfo = new AppInfo();
            newInfo.type = entry.getValue().getType().equals(Application.TYPE_INTENT) ? AppInfo.TYPE_INTENT : AppInfo.TYPE_WEB;
            newInfo.keyCode = entry.getValue().getKeyCode();
            newInfo.name = entry.getValue().getIconText();
            newInfo.url = entry.getValue().getUrl();
            newInfo.iconUrl = entry.getValue().getIcon();
            newInfo.screenOrder = entry.getValue().getScreenOrder();
            newInfo.useKiosk = entry.getValue().isUseKiosk() ? 1 : 0;
            newInfo.intent = entry.getValue().getIntent();
            appInfos.add(newInfo);
        }

        // Apply manually set order
        Collections.sort(appInfos, new AppInfosComparator());

        return appInfos;
    }

    private void getConfiguredApps(Context context, boolean bottom, Map<String, Application> requiredPackages, Map<String, Application> requiredLinks) {
        SettingsHelper config = SettingsHelper.getInstance( context );
        if ( config.getConfig() != null ) {
            List< Application > applications = SettingsHelper.getInstance( context ).getConfig().getApplications();
            for ( Application application : applications ) {
                if (application.isShowIcon() && !application.isRemove() && (bottom == application.isBottom())) {
                    if (application.getType() == null || application.getType().equals(Application.TYPE_APP)) {
                        requiredPackages.put(application.getPkg(), application);
                    } else if (application.getType().equals(Application.TYPE_WEB)) {
                        requiredLinks.put(application.getUrl(), application);
                    } else if (application.getType().equals(Application.TYPE_INTENT)) {
                        requiredLinks.put(application.getIntent(), application);
                    }
                }
            }
        }
    }

    public class AppInfosComparator implements Comparator<AppInfo> {
        @Override
        public int compare(AppInfo o1, AppInfo o2) {
            if (o1.screenOrder == null) {
                if (o2.screenOrder == null) {
                    return 0;
                }
                return 1;
            }
            if (o2.screenOrder == null) {
                return -1;
            }
            return Integer.compare(o1.screenOrder, o2.screenOrder);
        }
    }

}
</file>

<file path="app/src/main/res/layout/activity_mdm_choice.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
    </data>

    <RelativeLayout 
        android:id="@+id/activity_initial_setup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.InitialSetupActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:gravity="center"
            android:orientation="vertical"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingBottom="@dimen/activity_vertical_margin">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:gravity="center"
                android:text="@string/mdm_choice_message"
                android:textAppearance="?android:textAppearanceMedium" />

            <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/dialog_administrator_mode_continue"
                android:layout_marginTop="@dimen/activity_vertical_margin"
                android:background="@color/wizardPrimary"
                android:textColor="@color/white"
                android:onClick="continueSetup"
                android:paddingLeft="@dimen/activity_horizontal_margin"
                android:paddingRight="@dimen/activity_horizontal_margin"
                ></Button>

        </LinearLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_device_id.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
    </data>

    <LinearLayout
          android:focusable="true"
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/deviceIdError"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/dialog_enter_device_id_error"/>

        <TextView
            android:id="@+id/deviceIdErrorDetails"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:textColor="@color/colorAccent"
            bind:boolToVisible="@{error}"
            android:text="@string/main_activity_details"
            android:onClick="showErrorDetails"/>

        <TextView
            android:id="@+id/deviceIdPrompt"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:gravity="center_horizontal"
            android:layout_height="wrap_content"
            bind:boolToVisible="@{!error}"
            android:text="@string/dialog_enter_device_id_title"/>

        <AutoCompleteTextView
            android:focusable="true"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/device_id"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_horizontal"
            >
            <Button
                android:id="@+id/showDeviceIdQrCode"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_qrcode"
                android:onClick="showDeviceIdQrCode"/>
            <Button
                android:id="@+id/showDeviceIdVariants"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_variants"
                android:onClick="showDeviceIdVariants"/>
            <Button
                android:id="@+id/saveDeviceId"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_save"
                android:onClick="saveDeviceId"/>
            <Button
                android:id="@+id/exitDeviceId"
                bind:boolToVisible="@{error}"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:textSize="@dimen/button_text_size_small"
                android:text="@string/dialog_enter_device_id_exit"
                android:onClick="exitDeviceId"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_enter_server.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">

    <data>
        <variable name="error" type="Boolean"/>
        <variable name="server" type="String"/>
    </data>

    <LinearLayout
          android:focusable="true"
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{error}"
            android:text="@string/dialog_enter_server_error"/>

        <TextView
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            bind:boolToVisible="@{!error}"
            android:text="@string/dialog_enter_server_title"/>

        <EditText
            android:focusable="true"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:id="@+id/server_url"
            android:hint="@string/dialog_enter_server_hint"
            android:text="@{server}"
            android:layout_marginTop="@dimen/activity_vertical_margin"
            android:layout_marginBottom="@dimen/activity_vertical_margin"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_horizontal"
        >

        <Button
            android:id="@+id/showDeviceIdQrCode"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:textSize="@dimen/button_text_size_small"
            android:text="@string/dialog_enter_device_id_qrcode"
            android:onClick="showDeviceIdQrCode"/>

            <Button
                android:id="@+id/saveServerUrl"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/dialog_enter_server_ok"
                android:onClick="saveServerUrl"/>
    </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/layout/dialog_network_error.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools">

    <LinearLayout
          android:orientation="vertical"
          android:layout_width="wrap_content"
          android:layout_height="match_parent"
          android:gravity="center"
          android:paddingTop="@dimen/activity_vertical_margin"
          android:paddingBottom="@dimen/activity_vertical_margin"
          android:paddingLeft="@dimen/activity_horizontal_margin"
          android:paddingRight="@dimen/activity_horizontal_margin"
          tools:context="com.hmdm.launcher.ui.MainActivity">

        <TextView
            android:id="@+id/title"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/dialog_network_error_title"/>

        <TextView
            android:id="@+id/details"
            android:layout_width="@dimen/dialog_enter_device_id_width"
            android:layout_height="wrap_content"
            android:gravity="center_horizontal"
            android:text="@string/main_activity_details"
            android:textColor="@color/colorAccent"
            android:layout_marginBottom="@dimen/activity_vertical_margin"
            android:onClick="networkErrorDetailsClicked"
            />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:gravity="center_vertical|center_horizontal"
            android:layout_marginTop="@dimen/activity_horizontal_margin"
            android:orientation="horizontal">

            <Button
                android:id="@+id/repeatButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_repeat"
                android:onClick="networkErrorRepeatClicked"/>

            <Button
                android:id="@+id/resetButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_reset"
                android:onClick="networkErrorResetClicked"/>

            <Button
                android:id="@+id/wifiButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_wifi"
                android:onClick="networkErrorWifiClicked"/>

            <Button
                android:id="@+id/cancelButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="@string/main_activity_cancel"
                android:onClick="networkErrorCancelClicked"/>

        </LinearLayout>

    </LinearLayout>

</layout>
</file>

<file path="app/src/main/res/values/colors.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <color name="colorPrimary">#607D8B</color>
    <color name="colorPrimaryDark">#000000</color>
    <color name="colorAccent">#87d3e1</color>
    <color name="white">#ffffff</color>
    <color name="defaultBackground">#303030</color>

    <color name="wizardPrimaryDark">#ff254FAE</color>
    <color name="wizardPrimary">#ff3367d6</color>
    <color name="wizardAccent">#ff3367d6</color>

    <color name="statusBarLight">#aaffffff</color>
    <color name="statusBarDark">#aa000000</color>
</resources>
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
#Thu Sep 18 17:23:18 AST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="lib/src/main/java/com/hmdm/MDMService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

public class MDMService {
    // MDM configuration attributes
    public static final String KEY_SERVER_HOST = "SERVER_HOST";
    public static final String KEY_SECONDARY_SERVER_HOST = "SECONDARY_SERVER_HOST";
    public static final String KEY_SERVER_PATH = "SERVER_PATH";
    public static final String KEY_DEVICE_ID = "DEVICE_ID";
    public static final String KEY_CUSTOM_1 = "CUSTOM_1";
    public static final String KEY_CUSTOM_2 = "CUSTOM_2";
    public static final String KEY_CUSTOM_3 = "CUSTOM_3";
    public static final String KEY_IMEI = "IMEI";
    public static final String KEY_SERIAL = "SERIAL";
    public static final String KEY_IS_MANAGED = "IS_MANAGED";
    public static final String KEY_IS_KIOSK = "IS_KIOSK";
    public static final String KEY_ERROR = "ERROR";

    public static final int INITIAL_VERSION = 112;

    private Context context;
    private IMdmApi mdmApi;
    private RemoteServiceConnection serviceConnection;

    private static MDMService instance;

    public interface ResultHandler {
        void onMDMConnected();
        void onMDMDisconnected();
    }

    public static MDMService getInstance() {
        if (instance == null) {
            instance = new MDMService();
        }
        return instance;
    }

    /**
     * Connect to the MDM service
     * @param handler
     * @return true on success and false if no Headwind MDM installed
     */
    public boolean connect(Context context, ResultHandler handler) {
        this.context = context;
        serviceConnection = new RemoteServiceConnection(handler);

        // First we try up-to-date package
        Intent i = new Intent(Const.SERVICE_ACTION);
        i.setPackage(Const.PACKAGE);
        boolean ret = context.bindService(i, serviceConnection, Context.BIND_AUTO_CREATE);
        if (!ret) {
            android.util.Log.i("MDMService", "Failed to bind service: intent " + i.getAction() + ", package " + i.getPackage());
            // Try legacy package
            i.setPackage(Const.LEGACY_PACKAGE);
            ret = context.bindService(i, serviceConnection, Context.BIND_AUTO_CREATE);
        }
        if (!ret) {
            android.util.Log.i("MDMService", "Failed to bind legacy service: intent " + i.getAction() + ", package " + i.getPackage());
        }

        return ret;
    }

    class RemoteServiceConnection implements ServiceConnection {

        ResultHandler handler;

        public RemoteServiceConnection(ResultHandler handler) {
            super();
            this.handler = handler;
        }

        public void onServiceConnected(ComponentName name, IBinder boundService) {
            mdmApi = IMdmApi.Stub.asInterface((IBinder) boundService);
            if (handler != null) {
                handler.onMDMConnected();
            }
        }

        public void onServiceDisconnected(ComponentName name) {
            mdmApi = null;
            if (handler != null) {
                handler.onMDMDisconnected();
            }
        }
    }

    /**
     * Get version
     */
    public int getVersion() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            return mdmApi.getVersion();
        } catch (RemoteException e) {
            // No getVersion() method prior to 1.1.3, so return 0 by default
            return 0;
        }
    }

    /**
     * Request the configuration update by the app
     * This method forces the application update even if the background update is scheduled
     * Reason: this method may be called manually from a kiosk app
     */
    public void forceConfigUpdate() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            mdmApi.forceConfigUpdate();
        } catch (RemoteException e) {
            // No forceConfigUpdate() method prior to 1.1.5
        }
    }

    /**
     * Query configuration
     */
    public Bundle queryConfig() throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        try {
            return mdmApi.queryConfig();
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Query configuration (including privileged fields)
     */
    public Bundle queryConfig(String apiKey) throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        if (getVersion() <= INITIAL_VERSION) {
            throw new MDMException(MDMError.ERROR_VERSION);
        }

        try {
            Bundle config = mdmApi.queryPrivilegedConfig(apiKey);
            String error = config.getString(KEY_ERROR);
            if (error != null) {
                if (error.equals("KEY_NOT_MATCH")) {
                    throw new MDMException(MDMError.ERROR_KEY_NOT_MATCH);
                } else {
                    throw new MDMException(MDMError.ERROR_INTERNAL);
                }
            }
            return config;
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Set a custom field to send its value to the server
     */
    public void setCustom(int number, String value) throws MDMException {
        if (mdmApi == null) {
            throw new MDMException(MDMError.ERROR_DISCONNECTED);
        }

        if (getVersion() <= INITIAL_VERSION) {
            throw new MDMException(MDMError.ERROR_VERSION);
        }

        try {
            mdmApi.setCustom(number, value);
        } catch (RemoteException e) {
            throw new MDMException(MDMError.ERROR_INTERNAL);
        }
    }

    /**
     * Usage:
     * Log.v (etc)
     */
    public static class Log {
        public static final int ERROR = 1;
        public static final int WARN = 2;
        public static final int INFO = 3;
        public static final int DEBUG = 4;
        public static final int VERBOSE = 5;

        public static void log(int level, String tag, String message) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Remote logger not initialized!");
                return;
            }
            try {
                String finalMessage = tag != null ? tag + " " + message : message;
                instance.mdmApi.log(System.currentTimeMillis(), level, instance.context.getPackageName(), finalMessage);
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to send a log to Headwind MDM!");
                e.printStackTrace();
            }
        }

        public static void v(String tag, String message) {
            android.util.Log.v(tag, message);
            log(VERBOSE, tag, message);
        }

        public static void d(String tag, String message) {
            android.util.Log.d(tag, message);
            log(DEBUG, tag, message);
        }

        public static void i(String tag, String message) {
            android.util.Log.i(tag, message);
            log(INFO, tag, message);
        }

        public static void w(String tag, String message) {
            android.util.Log.w(tag, message);
            log(WARN, tag, message);
        }

        public static void e(String tag, String message) {
            android.util.Log.e(tag, message);
            log(ERROR, tag, message);
        }
    }

    public static class Preferences {

        public static String get(String attr, String defValue) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
                return defValue;
            }
            try {
                String result = instance.mdmApi.queryAppPreference(instance.context.getPackageName(), attr);
                if (result == null) {
                    return defValue;
                }
                return result;
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to get Headwind MDM app preference " + attr);
                e.printStackTrace();
            }
            return defValue;
        }

        public static boolean set(String attr, String value) {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
            }
            try {
                return instance.mdmApi.setAppPreference(instance.context.getPackageName(), attr, value);
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to set Headwind MDM app preference " + attr + "=" + value);
                e.printStackTrace();
            }
            return false;
        }

        public static void apply() {
            if (instance == null || instance.mdmApi == null || instance.context == null) {
                // Not initialized, just return
                android.util.Log.w(Const.LOG_TAG, "Connection to Headwind MDM not initialized!");
                return;
            }
            try {
                instance.mdmApi.commitAppPreferences(instance.context.getPackageName());
            } catch (Exception e) {
                android.util.Log.w(Const.LOG_TAG, "Remote exception while trying to apply Headwind MDM app preferences!");
                e.printStackTrace();
            }
        }
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/db/DatabaseHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.db;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DatabaseHelper extends SQLiteOpenHelper {
    // Next version should be 10 and versions must be increased by 10
    // to enable custom database changes
    private static final int DATABASE_VERSION = 10;
    private static final String DATABASE_NAME = "hmdm.launcher.sqlite";

    private static DatabaseHelper sInstance;

    private DatabaseHelper( Context context ) {
        super( context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    public static synchronized DatabaseHelper instance(Context context) {
        if (sInstance == null) {
            sInstance = new DatabaseHelper(context.getApplicationContext());
        }
        return sInstance;
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.beginTransaction();
        try {
            db.execSQL(LogTable.getCreateTableSql());
            db.execSQL(LogConfigTable.getCreateTableSql());
            db.execSQL(InfoHistoryTable.getCreateTableSql());
            db.execSQL(RemoteFileTable.getCreateTableSql());
            db.execSQL(LocationTable.getCreateTableSql());
            db.execSQL(DownloadTable.getCreateTableSql());
            db.setTransactionSuccessful();
        }
        catch ( Exception e ) {
            e.printStackTrace();
        }
        finally {
            db.endTransaction();
        }
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.beginTransaction();
        try {
            if (oldVersion < 2 && newVersion >= 2) {
                db.execSQL(InfoHistoryTable.getCreateTableSql());
            }
            if (oldVersion < 3 && newVersion >= 3) {
                db.execSQL(RemoteFileTable.getCreateTableSql());
            }
            if (oldVersion < 4 && newVersion >= 4) {
                db.execSQL(InfoHistoryTable.getAlterTableAddMemoryTotalSql());
                db.execSQL(InfoHistoryTable.getAlterTableAddMemoryAvailableSql());
            }
            if (oldVersion < 5 && newVersion >= 5) {
                db.execSQL(LocationTable.getCreateTableSql());
            }
            if (oldVersion < 10 && newVersion >= 10) {
                db.execSQL(DownloadTable.getCreateTableSql());
            }
            db.setTransactionSuccessful();
        } catch ( Exception e ) {
            e.printStackTrace();
        }
        finally {
            db.endTransaction();
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/DeviceInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;

import java.util.LinkedList;
import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
@JsonInclude(JsonInclude.Include.NON_NULL)
public class DeviceInfo {

    private String model;
    private List<Integer> permissions = new LinkedList();
    private List<Application> applications = new LinkedList();
    private List<RemoteFile> files = new LinkedList();
    private String deviceId;
    private String phone;
    private String imei;
    private boolean mdmMode;
    private boolean kioskMode;
    private int batteryLevel;
    private String batteryCharging;
    private String androidVersion;
    private Boolean factoryReset;
    private Location location;
    private String launcherType;
    private String launcherPackage;
    private boolean defaultLauncher;
    private String iccid;
    private String imsi;
    private String phone2;
    private String imei2;
    private String iccid2;
    private String imsi2;
    private String cpu;
    private String serial;

    // These fields are reserved for custom builds of Headwind MDM
    private String custom1;
    private String custom2;
    private String custom3;

    public static class Location {
        private long ts;
        private double lat;
        private double lon;

        public long getTs() {
            return ts;
        }

        public void setTs(long ts) {
            this.ts = ts;
        }

        public double getLat() {
            return lat;
        }

        public void setLat(double lat) {
            this.lat = lat;
        }

        public double getLon() {
            return lon;
        }

        public void setLon(double lon) {
            this.lon = lon;
        }
    }

    public DeviceInfo() {}

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public List<Integer> getPermissions() {
        return permissions;
    }

    public void setPermissions(List<Integer> permissions) {
        this.permissions = permissions;
    }

    public List<Application> getApplications() {
        return applications;
    }

    public void setApplications(List<Application> applications) {
        this.applications = applications;
    }

    public List<RemoteFile> getFiles() {
        return files;
    }

    public void setFiles(List<RemoteFile> files) {
        this.files = files;
    }

    public String getDeviceId() {
        return deviceId;
    }

    public void setDeviceId( String deviceId ) {
        this.deviceId = deviceId;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getImei() {
        return imei;
    }

    public void setImei(String imei) {
        this.imei = imei;
    }

    public boolean isMdmMode() {
        return mdmMode;
    }

    public void setMdmMode(boolean mdmMode) {
        this.mdmMode = mdmMode;
    }

    public boolean isKioskMode() {
        return kioskMode;
    }

    public void setKioskMode(boolean kioskMode) {
        this.kioskMode = kioskMode;
    }

    public int getBatteryLevel() {
        return batteryLevel;
    }

    public void setBatteryLevel(int batteryLevel) {
        this.batteryLevel = batteryLevel;
    }

    public String isBatteryCharging() {
        return batteryCharging;
    }

    public void setBatteryCharging(String batteryCharging) {
        this.batteryCharging = batteryCharging;
    }

    public String getAndroidVersion() {
        return androidVersion;
    }

    public void setAndroidVersion(String androidVersion) {
        this.androidVersion = androidVersion;
    }

    public Boolean getFactoryReset() {
        return factoryReset;
    }

    public void setFactoryReset(Boolean factoryReset) {
        this.factoryReset = factoryReset;
    }

    public Location getLocation() {
        return location;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    public String getLauncherType() {
        return launcherType;
    }

    public void setLauncherType(String launcherType) {
        this.launcherType = launcherType;
    }

    public String getLauncherPackage() {
        return launcherPackage;
    }

    public void setLauncherPackage(String launcherPackage) {
        this.launcherPackage = launcherPackage;
    }

    public boolean isDefaultLauncher() {
        return defaultLauncher;
    }

    public void setDefaultLauncher(boolean defaultLauncher) {
        this.defaultLauncher = defaultLauncher;
    }

    public String getIccid() {
        return iccid;
    }

    public void setIccid(String iccid) {
        this.iccid = iccid;
    }

    public String getImsi() {
        return imsi;
    }

    public void setImsi(String imsi) {
        this.imsi = imsi;
    }

    public String getPhone2() {
        return phone2;
    }

    public void setPhone2(String phone2) {
        this.phone2 = phone2;
    }

    public String getImei2() {
        return imei2;
    }

    public void setImei2(String imei2) {
        this.imei2 = imei2;
    }

    public String getIccid2() {
        return iccid2;
    }

    public void setIccid2(String iccid2) {
        this.iccid2 = iccid2;
    }

    public String getImsi2() {
        return imsi2;
    }

    public void setImsi2(String imsi2) {
        this.imsi2 = imsi2;
    }

    public String getCpu() {
        return cpu;
    }

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    public String getCustom1() {
        return custom1;
    }

    public void setCustom1(String custom1) {
        this.custom1 = custom1;
    }

    public String getCustom2() {
        return custom2;
    }

    public void setCustom2(String custom2) {
        this.custom2 = custom2;
    }

    public String getCustom3() {
        return custom3;
    }

    public void setCustom3(String custom3) {
        this.custom3 = custom3;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerServiceKeeper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.server;

import android.content.Context;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;

import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import retrofit2.Retrofit;
import retrofit2.converter.jackson.JacksonConverterFactory;

public class ServerServiceKeeper {

    private static ServerService serverServiceInstance;
    private static ServerService secondaryServerServiceInstance;

    // This is called after changing the server URL
    public static void resetServices() {
        serverServiceInstance = null;
        secondaryServerServiceInstance = null;
    }

    public static ServerService getServerServiceInstance(Context context) {
        if ( serverServiceInstance == null ) {
            try {
                serverServiceInstance = createServerService(SettingsHelper.getInstance(context).getBaseUrl());
            } catch (Exception e) {
                // "Invalid URL" exception. We must not be here but in the case we are here,
                // avoid crash loop by replacing the URL to the default one
                serverServiceInstance = createServerService(BuildConfig.BASE_URL);
            }
        }

        return serverServiceInstance;
    }

    public static ServerService getSecondaryServerServiceInstance(Context context) {
        if ( secondaryServerServiceInstance == null ) {
            try {
                secondaryServerServiceInstance = createServerService(SettingsHelper.getInstance(context).getSecondaryBaseUrl());
            } catch (Exception e) {
                // Here we can go if the secondary base URL is invalid
                // In this case, just return a copy of the primary instance
                secondaryServerServiceInstance = getServerServiceInstance(context);
            }
        }

        return secondaryServerServiceInstance;
    }

    // Made public for downloading from third party servers
    public static ServerService createServerService(String baseUrl) {
        return createBuilder(baseUrl, Const.CONNECTION_TIMEOUT).build().create(ServerService.class);
    }

    // For long polling, read timeout should be adjustable
    public static ServerService createServerService(String baseUrl, long readTimeout) {
        return createBuilder(baseUrl, readTimeout).build().create(ServerService.class);
    }

    private static Retrofit.Builder createBuilder(String baseUrl, long readTimeout) {
        Retrofit.Builder builder = new Retrofit.Builder();

        if (BuildConfig.TRUST_ANY_CERTIFICATE) {
            builder.client(UnsafeOkHttpClient.getUnsafeOkHttpClient());
        } else {
            OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder().
                    connectTimeout(Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS).
                    readTimeout(readTimeout, TimeUnit.MILLISECONDS).
                    writeTimeout(Const.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);
            builder.client(clientBuilder.build());
        }

        builder.baseUrl( baseUrl )
                .addConverterFactory( JacksonConverterFactory.create( new ObjectMapper()) );

        return builder;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/PushLongPollingService.java">
package com.hmdm.launcher.service;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.IBinder;
import android.util.Log;

import androidx.core.app.NotificationCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.PushNotificationProcessor;

import org.eclipse.paho.android.service.MqttService;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;

import retrofit2.Response;

public class PushLongPollingService extends Service {

    private boolean enabled = true;
    private boolean threadActive = false;
    private Thread pollingThread;
    // If we get an exception, we have to delay, otherwise there would be a looping
    private final long DELAY_AFTER_EXCEPTION_MS = 60000;
    // Delay between polling requests to avoid looping if the server would respond instantly
    private final long DELAY_AFTER_REQUEST_MS = 5000;
    public static String CHANNEL_ID = MqttService.class.getName();
    // A flag preventing multiple notifications for the foreground service
    boolean started = false;
    // Notification ID for the foreground service
    private static final int NOTIFICATION_ID = 113;
    private ServerService serverService;
    private ServerService secondaryServerService;

    private final BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            if (intent != null && intent.getAction() != null &&
                    intent.getAction().equals(Const.ACTION_SERVICE_STOP)) {
                enabled = false;
                stopSelf();
            }
        }
    };

    @Override
    public void onDestroy() {
        LocalBroadcastManager.getInstance( this ).unregisterReceiver(receiver);
        Log.i(Const.LOG_TAG, "PushLongPollingService: service stopped");
        started = false;
        super.onDestroy();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
        enabled = true;

        if (BuildConfig.MQTT_SERVICE_FOREGROUND && !started) {
            startAsForeground();
            started = true;
        }

        Log.i(Const.LOG_TAG, "PushLongPolling: service started. ");

        IntentFilter intentFilter = new IntentFilter(Const.ACTION_SERVICE_STOP);
        LocalBroadcastManager.getInstance( this ).registerReceiver( receiver, intentFilter );

        if (!threadActive) {
            pollingThread = new Thread(pollingRunnable);
            pollingThread.start();
        }

        return Service.START_STICKY;
    }

    private Runnable pollingRunnable = () -> {
        Context context = PushLongPollingService.this;
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (serverService == null) {
            serverService = ServerServiceKeeper.createServerService(settingsHelper.getBaseUrl(), Const.LONG_POLLING_READ_TIMEOUT);
        }
        if (secondaryServerService == null) {
            secondaryServerService = ServerServiceKeeper.createServerService(settingsHelper.getSecondaryBaseUrl(), Const.LONG_POLLING_READ_TIMEOUT);
        }

        // Calculate request signature
        String encodedDeviceId = settingsHelper.getDeviceId();
        try {
            encodedDeviceId = URLEncoder.encode(encodedDeviceId, "utf8");
        } catch (UnsupportedEncodingException e) {
        }
        String path = settingsHelper.getServerProject() + "/rest/notification/polling/" + encodedDeviceId;
        String signature = null;
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + path);
        } catch (Exception e) {
        }

        threadActive = true;
        while (enabled) {
            Response<PushResponse> response = null;

            RemoteLogger.log(context, Const.LOG_VERBOSE, "Push long polling inquiry");
            try {
                // This is the long operation
                response = serverService.
                        queryPushLongPolling(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
            } catch (Exception e) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications from "
                        + settingsHelper.getBaseUrl() + " : " + e.getMessage());
                e.printStackTrace();
            }

            try {
                if (response == null) {
                    response = secondaryServerService.
                            queryPushLongPolling(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
                }

                if ( response.isSuccessful() ) {
                    if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                        Map<String, PushMessage> filteredMessages = new HashMap<String, PushMessage>();
                        for (PushMessage message : response.body().getData()) {
                            // Filter out multiple configuration update requests
                            if (!message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED) ||
                                    !filteredMessages.containsKey(PushMessage.TYPE_CONFIG_UPDATED)) {
                                filteredMessages.put(message.getMessageType(), message);
                            }
                        }
                        for (Map.Entry<String, PushMessage> entry : filteredMessages.entrySet()) {
                            PushNotificationProcessor.process(entry.getValue(), context);
                        }
                    }
                } else if (response.code() >= 400 && response.code() < 500) {
                    // Response code 500 is fine (Timeout), so here we log only 4xx requests (403 Forbidden in particular)
                    RemoteLogger.log(context, Const.LOG_WARN, "Wrong response while querying push notifications from "
                            + settingsHelper.getSecondaryBaseUrl() + " : HTTP status " + response.code());
                    try {
                        // On exception, we need to wait to avoid looping
                        Thread.sleep(DELAY_AFTER_EXCEPTION_MS);
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                }
                // Avoid looping by adding some pause
                Thread.sleep(DELAY_AFTER_REQUEST_MS);

            } catch ( Exception e ) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications from "
                        + settingsHelper.getSecondaryBaseUrl() + " : " + e.getMessage());
                e.printStackTrace();
                try {
                    // On exception, we need to wait to avoid looping
                    Thread.sleep(DELAY_AFTER_EXCEPTION_MS);
                } catch (InterruptedException e1) {
                    e1.printStackTrace();
                }
            }
        }
        threadActive = false;
    };


    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText(getString(R.string.mqtt_service_text))
                .setSmallIcon(R.drawable.ic_mqtt_service).build();

        Utils.startStableForegroundService(this, NOTIFICATION_ID, notification);
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/AdminReceiver.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;
import static android.content.Context.MODE_PRIVATE;

import android.app.admin.DeviceAdminReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.PersistableBundle;

import androidx.annotation.RequiresApi;

import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.util.PreferenceLogger;

/**
 * Created by Ivan Lozenko on 21.02.2017.
 */

public class AdminReceiver extends DeviceAdminReceiver {

    @Override
    public void onEnabled(Context context, Intent intent) {
        // We come here after both successful provisioning and manual activation of the device owner
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        PreferenceLogger.log(preferences, "Administrator enabled");
        preferences.edit().putInt(Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_ON).commit();
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        PreferenceLogger.log(preferences, "Profile provisioning complete");

        if ( Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP ) {
            // This function is never called on Android versions less than 5 (in fact, less than 7)
            return;
        }

        PersistableBundle bundle = intent.getParcelableExtra(EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        updateSettings(context, bundle);
    }

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static void updateSettings(Context context, PersistableBundle bundle) {
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        try {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());
            String deviceId = null;
            PreferenceLogger.log(preferences, "Bundle != null: " + (bundle != null));
            if (bundle != null) {
                deviceId = bundle.getString(Const.QR_DEVICE_ID_ATTR, null);
                if (deviceId == null) {
                    // Also let's try legacy attribute
                    deviceId = bundle.getString(Const.QR_LEGACY_DEVICE_ID_ATTR, null);
                }
                if (deviceId == null) {
                    String deviceIdUse = bundle.getString(Const.QR_DEVICE_ID_USE_ATTR, null);
                    if (deviceIdUse != null) {
                        PreferenceLogger.log(preferences, "deviceIdUse: " + deviceIdUse);
                        // Save for further automatic choice of the device ID
                        settingsHelper.setDeviceIdUse(deviceIdUse);
                    }
                }
            }
            if (deviceId != null) {
                // Device ID is delivered in the QR code!
                // Added: "android.app.extra.PROVISIONING_ADMIN_EXTRAS_BUNDLE": {"com.hmdm.DEVICE_ID": "(device id)"}
                PreferenceLogger.log(preferences, "DeviceID: " + deviceId);
                settingsHelper.setDeviceId(deviceId);
            }

            String baseUrl = null;
            String secondaryBaseUrl = null;
            String serverProject = null;
            DeviceEnrollOptions createOptions = new DeviceEnrollOptions();
            if (bundle != null) {
                baseUrl = bundle.getString(Const.QR_BASE_URL_ATTR, null);
                secondaryBaseUrl = bundle.getString(Const.QR_SECONDARY_BASE_URL_ATTR, null);
                serverProject = bundle.getString(Const.QR_SERVER_PROJECT_ATTR, null);
                createOptions.setCustomer(bundle.getString(Const.QR_CUSTOMER_ATTR, null));
                createOptions.setConfiguration(bundle.getString(Const.QR_CONFIG_ATTR, null));
                createOptions.setGroups(bundle.getString(Const.QR_GROUP_ATTR, null));
                if (baseUrl != null) {
                    PreferenceLogger.log(preferences, "BaseURL: " + baseUrl);
                    settingsHelper.setBaseUrl(baseUrl);
                    // If we don't set the secondary base URL, it will point to app.h-mdm.com by default which is wrong
                    if (secondaryBaseUrl == null) {
                        secondaryBaseUrl = baseUrl;
                    }
                }
                if (secondaryBaseUrl != null) {
                    PreferenceLogger.log(preferences, "SecondaryBaseURL: " + secondaryBaseUrl);
                    settingsHelper.setSecondaryBaseUrl(secondaryBaseUrl);
                }
                if (serverProject != null) {
                    PreferenceLogger.log(preferences, "ServerPath: " + serverProject);
                    settingsHelper.setServerProject(serverProject);
                }
                if (createOptions.getCustomer() != null) {
                    PreferenceLogger.log(preferences, "Customer: " + createOptions.getCustomer());
                    settingsHelper.setEnrollOptionCustomer(createOptions.getCustomer());
                }
                if (createOptions.getConfiguration() != null) {
                    PreferenceLogger.log(preferences, "Configuration: " + createOptions.getConfiguration());
                    settingsHelper.setEnrollOptionConfigName(createOptions.getConfiguration());
                }
                if (createOptions.getGroups() != null) {
                    PreferenceLogger.log(preferences, "Groups: " + bundle.getString(Const.QR_GROUP_ATTR));
                    settingsHelper.setEnrollOptionGroup(createOptions.getGroupSet());
                }
                settingsHelper.setQrProvisioning(true);
            }
        } catch (Exception e) {
            // Ignored
            e.printStackTrace();
            PreferenceLogger.printStackTrace(preferences, e);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/Initializer.java">
package com.hmdm.launcher.helper;

import static android.content.Context.MODE_PRIVATE;

import android.bluetooth.BluetoothAdapter;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.pro.service.CheckForegroundAppAccessibilityService;
import com.hmdm.launcher.pro.service.CheckForegroundApplicationService;
import com.hmdm.launcher.pro.worker.DetailedInfoWorker;
import com.hmdm.launcher.service.PushLongPollingService;
import com.hmdm.launcher.service.StatusControlService;
import com.hmdm.launcher.task.SendDeviceInfoTask;
import com.hmdm.launcher.util.ConnectionWaiter;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.PushNotificationWorker;
import com.hmdm.launcher.worker.ScheduledAppUpdateWorker;
import com.hmdm.launcher.worker.SendDeviceInfoWorker;

import org.eclipse.paho.android.service.MqttAndroidClient;

import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

// Shared initialization code which should run either by MainActivity (in foreground mode)
// or by InitialSetupActivity (in background mode)
public class Initializer {
    private static ExecutorService executor = Executors.newSingleThreadExecutor();
    private static Handler uiHandler = new Handler(Looper.getMainLooper());

    public static void init(Context context, Runnable completion) {
        // Background work
        executor.execute(() -> {
            // Crashlytics is not included in the open-source version
            ProUtils.initCrashlytics(context);

            if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                InstallUtils.initUnsafeTrustManager();
            }

            Utils.lockSafeBoot(context);
            Utils.initPasswordReset(context);

            RemoteLogger.log(context, Const.LOG_INFO, "MDM Launcher " + BuildConfig.VERSION_NAME + "-" + Utils.getLauncherVariant() + " started");

            InstallUtils.clearTempFiles(context);

            // Install the certificates (repeat the action from InitialSetupActivity because
            // the customer may wish to install new certificates without re-enrolling the device
            CertInstaller.installCertificatesFromAssets(context);

            ConnectionWaiter.waitForConnect(context, () -> {
                DetailedInfoWorker.schedule(context);
                if (BuildConfig.ENABLE_PUSH) {
                    PushNotificationWorker.schedule(context);
                }
                ScheduledAppUpdateWorker.schedule(context);

                // Run completion in the UI thread
                uiHandler.post(completion);
            });
        });
    }

    public static void startServicesAndLoadConfig(Context context) {
        // Start Push service
        String pushOptions = null;
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            pushOptions = settingsHelper.getConfig().getPushOptions();
            Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
            if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
                keepaliveTime = newKeepaliveTime;
            }
        }
        if (BuildConfig.MQTT_SERVICE_FOREGROUND && BuildConfig.ENABLE_PUSH && pushOptions != null) {
            if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
                try {
                    URL url = new URL(settingsHelper.getBaseUrl());
                    // Broadcast receivers are not allowed to bind to services
                    // Therefore we start a service, and it binds to itself using
                    // PushNotificationMqttWrapper.getInstance().connect()
                    Intent serviceStartIntent = new Intent();
                    serviceStartIntent.setClassName(context, MqttAndroidClient.SERVICE_NAME);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_START_AT_BOOT, true);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_DOMAIN, url.getHost());
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_KEEPALIVE_TIME, keepaliveTime);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_PUSH_OPTIONS, pushOptions);
                    serviceStartIntent.putExtra(MqttAndroidClient.EXTRA_DEVICE_ID, settingsHelper.getDeviceId());
                    Object service = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                            context.startForegroundService(serviceStartIntent) :
                            context.startService(serviceStartIntent);
                    Log.i(Const.LOG_TAG, "Starting Push service from BootReceiver");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            } else if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_POLLING)) {
                try {
                    Intent serviceStartIntent = new Intent(context, PushLongPollingService.class);
                    serviceStartIntent.putExtra(Const.EXTRA_ENABLED, true);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceStartIntent);
                    } else {
                        context.startService(serviceStartIntent);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }

        // Start required services here instead of MainActivity (because it's not running)
        // Notice: some devices do not allow starting background services from boot receiver
        // java.lang.IllegalStateException
        // Not allowed to start service Intent { cmp=com.hmdm.launcher/.service.StatusControlService }: app is in background
        // Let's just ignore these exceptions for now
        SharedPreferences preferences = context.getApplicationContext().getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        // Foreground apps checks are not available in a free version: services are the stubs
        if (preferences.getInt(Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            try {
                context.startService(new Intent(context, CheckForegroundApplicationService.class));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        if (BuildConfig.USE_ACCESSIBILITY &&
            preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            try {
                context.startService(new Intent(context, CheckForegroundAppAccessibilityService.class));
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        try {
            context.startService(new Intent(context, StatusControlService.class));
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Send pending logs to server
        RemoteLogger.sendLogsToServer(context);

        final ConfigUpdater.UINotifier uiNotifier = new ConfigUpdater.UINotifier() {
            @Override
            public void onConfigUpdateStart() {
            }

            @Override
            public void onConfigUpdateServerError(String errorText) {
            }

            @Override
            public void onConfigUpdateNetworkError(String errorText) {
            }

            @Override
            public void onConfigLoaded() {
            }

            @Override
            public void onPoliciesUpdated() {
            }

            @Override
            public void onFileDownloading(RemoteFile remoteFile) {
            }

            @Override
            public void onDownloadProgress(int progress, long total, long current) {
            }

            @Override
            public void onFileDownloadError(RemoteFile remoteFile) {
            }

            @Override
            public void onFileInstallError(RemoteFile remoteFile) {
            }

            @Override
            public void onAppUpdateStart() {
            }

            @Override
            public void onAppRemoving(Application application) {
            }

            @Override
            public void onAppDownloading(Application application) {
            }

            @Override
            public void onAppInstalling(Application application) {
            }

            @Override
            public void onAppDownloadError(Application application) {
            }

            @Override
            public void onAppInstallError(String packageName) {
            }

            @Override
            public void onAppInstallComplete(String packageName) {
            }

            @Override
            public void onConfigUpdateComplete() {
                // In background mode, we need to send the information to the server once update is complete
                SendDeviceInfoTask sendDeviceInfoTask = new SendDeviceInfoTask(context);
                DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
                sendDeviceInfoTask.execute(deviceInfo);
                SendDeviceInfoWorker.scheduleDeviceInfoSending(context);
            }

            @Override
            public void onAllAppInstallComplete() {
            }
        };
        ConfigUpdater.forceConfigUpdate(context, uiNotifier, false);
    }

    // Used by InitialSetupActivity
    public static void applyEarlyNonInteractivePolicies(Context context, ServerConfig config) {
        if (config.getSystemUpdateType() != null &&
                config.getSystemUpdateType() != ServerConfig.SYSTEM_UPDATE_DEFAULT &&
                Utils.isDeviceOwner(context)) {
            Utils.setSystemUpdatePolicy(context, config.getSystemUpdateType(), config.getSystemUpdateFrom(), config.getSystemUpdateTo());
        }

        if (config.getBluetooth() != null) {
            try {
                BluetoothAdapter bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
                if (bluetoothAdapter != null) {
                    boolean enabled = bluetoothAdapter.isEnabled();
                    if (config.getBluetooth() && !enabled) {
                        bluetoothAdapter.enable();
                    } else if (!config.getBluetooth() && enabled) {
                        bluetoothAdapter.disable();
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        if (config.getTimeZone() != null) {
            Utils.setTimeZone(config.getTimeZone(), context);
        }

        if (config.getUsbStorage() != null) {
            Utils.lockUsbStorage(config.getUsbStorage(), context);
        }

        // Null value is processed here, it means unlock brightness
        Utils.setBrightnessPolicy(config.getAutoBrightness(), config.getBrightness(), context);

        if (config.getManageTimeout() != null) {
            Utils.setScreenTimeoutPolicy(config.getManageTimeout(), config.getTimeout(), context);
        }

        if (config.getManageVolume() != null && config.getManageVolume() && config.getVolume() != null) {
            Utils.lockVolume(false, context);
            if (!Utils.setVolume(config.getVolume(), context)) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to set the device volume");
            }
        }

        if (config.getLockVolume() != null) {
            Utils.lockVolume(config.getLockVolume(), context);
        }

        Utils.disableScreenshots(config.isDisableScreenshots(), context);
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MdmChoiceSetupActivity.java">
package com.hmdm.launcher.ui;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_MODE;

import android.app.Dialog;
import android.app.admin.DevicePolicyManager;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.os.PersistableBundle;
import android.provider.Settings;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.widget.ArrayAdapter;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.AdminReceiver;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityMdmChoiceBinding;
import com.hmdm.launcher.databinding.DialogEnterDeviceIdBinding;
import com.hmdm.launcher.helper.SettingsHelper;

import java.util.ArrayList;
import java.util.List;

public class MdmChoiceSetupActivity extends AppCompatActivity {
    private ActivityMdmChoiceBinding binding;

    protected Dialog enterDeviceIdDialog;
    protected DialogEnterDeviceIdBinding enterDeviceIdDialogBinding;

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);

        Log.d(Const.LOG_TAG, "Launching the provisioning mode choice activity");

        binding = DataBindingUtil.setContentView(this, R.layout.activity_mdm_choice);

        Intent intent = getIntent();
        PersistableBundle bundle = intent.getParcelableExtra(DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            if (bundle != null && bundle.getString(Const.QR_OPEN_WIFI_ATTR) != null) {
                try {
                    startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
                } catch (Exception e) {
                    e.printStackTrace();
                    Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
                }
            }
            AdminReceiver.updateSettings(this, bundle);
        }

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        if (settingsHelper.getDeviceId() == null || settingsHelper.getDeviceId().length() == 0) {
            Log.d(Const.LOG_TAG, "Device ID is empty");
            String deviceIdUse = settingsHelper.getDeviceIdUse();
            String deviceId;
            Log.d(Const.LOG_TAG, "Device ID choice: " + deviceIdUse);
            if (BuildConfig.DEVICE_ID_CHOICE.equals("imei") || "imei".equals(deviceIdUse)) {
                // These extras could not be set so we should retry setting these values in InitialSetupActivity!
                deviceId = intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_IMEI);
            } else if (BuildConfig.DEVICE_ID_CHOICE.equals("serial") || "serial".equals(deviceIdUse)) {
                deviceId = intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_SERIAL_NUMBER);
            } else {
                displayEnterDeviceIdDialog(intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_IMEI),
                        intent.getStringExtra(DevicePolicyManager.EXTRA_PROVISIONING_SERIAL_NUMBER));
                return;
            }
            settingsHelper.setDeviceId(deviceId);
        }
    }

    @Override
    public void onBackPressed() {
        setResult(RESULT_CANCELED);
        super.onBackPressed();
    }

    public void continueSetup(View view) {
        final Intent intent = new Intent();
        intent.putExtra(EXTRA_PROVISIONING_MODE, DevicePolicyManager.PROVISIONING_MODE_FULLY_MANAGED_DEVICE);
        setResult(RESULT_OK, intent);
        finish();
    }

    protected void displayEnterDeviceIdDialog(String imei, String serial) {
        enterDeviceIdDialog = new Dialog(this);
        enterDeviceIdDialogBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_device_id,
                null,
                false);
        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        String serverUrl = settingsHelper.getBaseUrl();
        String serverPath = settingsHelper.getServerProject();
        if (serverPath.length() > 0) {
            serverUrl += "/" + serverPath;
        }
        enterDeviceIdDialogBinding.deviceIdPrompt.setText(getString(R.string.dialog_enter_device_id_title, serverUrl));
        enterDeviceIdDialogBinding.deviceIdError.setText(getString(R.string.dialog_enter_device_id_error, serverUrl));
        enterDeviceIdDialogBinding.setError(false);
        enterDeviceIdDialog.setCancelable(false);
        enterDeviceIdDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        // Suggest variants to choose the device ID: IMEI or serial
        List<String> variantsList = new ArrayList<>();
        if (imei != null) {
            variantsList.add(imei);
        }
        if (serial != null && !serial.equals(Build.UNKNOWN)) {
            variantsList.add(serial);
        }
        if (variantsList.size() > 0) {
            String[] variantsArray = variantsList.toArray(new String[variantsList.size()]);
            enterDeviceIdDialogBinding.deviceId.setThreshold(0);
            enterDeviceIdDialogBinding.deviceId.setAdapter(new ArrayAdapter<String>(this,
                    android.R.layout.select_dialog_item, variantsArray));
        } else {
            enterDeviceIdDialogBinding.showDeviceIdVariants.setVisibility(View.GONE);
        }

        enterDeviceIdDialogBinding.showDeviceIdQrCode.setVisibility(View.GONE);

        enterDeviceIdDialog.setContentView( enterDeviceIdDialogBinding.getRoot() );
        enterDeviceIdDialog.show();
    }

    public void saveDeviceId( View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString().trim();
        if ("".equals(deviceId)) {
            return;
        } else {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
            settingsHelper.setDeviceId( deviceId );
            if (enterDeviceIdDialog != null) {
                enterDeviceIdDialog.dismiss();
            }
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/AppInfo.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.os.Parcel;
import android.os.Parcelable;

public class AppInfo implements Parcelable {
    public static final int TYPE_APP = 0;
    public static final int TYPE_WEB = 1;
    public static final int TYPE_INTENT = 2;

    public int type;
    public Integer keyCode;
    public CharSequence name;
    public String packageName;
    public String url;
    public String iconUrl;
    public Integer screenOrder;
    public int useKiosk;
    public int longTap;
    public String intent;

    public AppInfo(){}

    protected AppInfo(Parcel in) {
        type = in.readInt();
        keyCode = (Integer)in.readSerializable();
        name = in.readString();
        packageName = in.readString();
        url = in.readString();
        iconUrl = in.readString();
        screenOrder = (Integer)in.readSerializable();
        useKiosk = in.readInt();
        longTap = in.readInt();
        intent = in.readString();
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(type);
        dest.writeSerializable(keyCode);
        dest.writeString(name != null ? name.toString() : null);
        dest.writeString(packageName);
        dest.writeString(url);
        dest.writeString(iconUrl);
        dest.writeSerializable(screenOrder);
        dest.writeInt(useKiosk);
        dest.writeInt(longTap);
        dest.writeString(intent);
    }

    @Override
    public int describeContents() {
        return 0;
    }

    public static final Creator<AppInfo> CREATOR = new Creator<AppInfo>() {
        @Override
        public AppInfo createFromParcel(Parcel in) {
            return new AppInfo(in);
        }

        @Override
        public AppInfo[] newArray(int size) {
            return new AppInfo[size];
        }
    };
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/PluginApiService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.service;

import android.app.Service;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.util.Log;

import androidx.annotation.Nullable;

import com.hmdm.IMdmApi;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class PluginApiService extends Service {
    // Data keys
    public static final String KEY_SERVER_HOST = "SERVER_HOST";
    public static final String KEY_SECONDARY_SERVER_HOST = "SECONDARY_SERVER_HOST";
    public static final String KEY_SERVER_PATH = "SERVER_PATH";
    public static final String KEY_DEVICE_ID = "DEVICE_ID";
    public static final String KEY_CUSTOM_1 = "CUSTOM_1";
    public static final String KEY_CUSTOM_2 = "CUSTOM_2";
    public static final String KEY_CUSTOM_3 = "CUSTOM_3";
    public static final String KEY_IMEI = "IMEI";
    public static final String KEY_SERIAL = "SERIAL";
    public static final String KEY_IS_MANAGED = "IS_MANAGED";
    public static final String KEY_IS_KIOSK = "IS_KIOSK";
    public static final String KEY_ERROR = "ERROR";

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    private final IMdmApi.Stub mBinder = new IMdmApi.Stub() {

        @Override
        public int getVersion() {
            // 1.1.7
            return 117;
        }

        @Override
        public Bundle queryConfig() {
            return queryPrivilegedConfig(null);
        }

        @Override
        public Bundle queryPrivilegedConfig(String apiKey) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return null;
            } else {
                Bundle bundle = new Bundle();
                bundle.putString(KEY_SERVER_HOST, settingsHelper.getBaseUrl());
                bundle.putString(KEY_SECONDARY_SERVER_HOST, settingsHelper.getSecondaryBaseUrl());
                bundle.putString(KEY_SERVER_PATH, settingsHelper.getServerProject());
                bundle.putString(KEY_DEVICE_ID, settingsHelper.getDeviceId());
                bundle.putBoolean(KEY_IS_MANAGED, Utils.isDeviceOwner(PluginApiService.this));
                bundle.putBoolean(KEY_IS_KIOSK, ProUtils.isKioskModeRunning(PluginApiService.this));
                if (settingsHelper.getConfig().getCustom1() != null) {
                    bundle.putString(KEY_CUSTOM_1, settingsHelper.getConfig().getCustom1());
                }
                if (settingsHelper.getConfig().getCustom2() != null) {
                    bundle.putString(KEY_CUSTOM_2, settingsHelper.getConfig().getCustom2());
                }
                if (settingsHelper.getConfig().getCustom3() != null) {
                    bundle.putString(KEY_CUSTOM_3, settingsHelper.getConfig().getCustom3());
                }
                if (apiKey != null) {
                    if (apiKey.equals(BuildConfig.LIBRARY_API_KEY)) {
                        // IMEI and serial are set only to authorized requests
                        bundle.putString(KEY_IMEI, DeviceInfoProvider.getImei(PluginApiService.this));
                        bundle.putString(KEY_SERIAL, DeviceInfoProvider.getSerialNumber());
                    } else {
                        bundle.putString(KEY_ERROR, "KEY_NOT_MATCH");
                    }
                }

                return bundle;
            }
        }

        @Override
        public void log(long timestamp, int level, String packageId, String message) {
            Log.i(Const.LOG_TAG, "Got a log item from " + packageId);
            RemoteLogItem item = new RemoteLogItem();
            item.setTimestamp(timestamp);
            item.setLogLevel(level);
            item.setPackageId(packageId);
            item.setMessage(message);
            RemoteLogger.postLog(PluginApiService.this, item);
        }

        @Override
        public String queryAppPreference(String packageId, String attr) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return null;
            }
            return settingsHelper.getAppPreference(packageId, attr);
        }

        @Override
        public boolean setAppPreference(String packageId, String attr, String value) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return false;
            }
            return settingsHelper.setAppPreference(packageId, attr, value);
        }

        @Override
        public void commitAppPreferences(String packageId) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return;
            }
            settingsHelper.commitAppPreferences(packageId);
        }

        @Override
        public void setCustom(int number, String value) {
            SettingsHelper settingsHelper = SettingsHelper.getInstance(PluginApiService.this);
            if ( settingsHelper.getConfig() == null ) {
                // This shouldn't happen!
                return;
            }
            switch (number) {
                case 1:
                    settingsHelper.getConfig().setCustom1(value);
                    settingsHelper.setUserCustom1(value);
                    break;
                case 2:
                    settingsHelper.getConfig().setCustom2(value);
                    settingsHelper.setUserCustom2(value);
                    break;
                case 3:
                    settingsHelper.getConfig().setCustom3(value);
                    settingsHelper.setUserCustom3(value);
                    break;
            }
        }

        @Override
        public void forceConfigUpdate() {
            // userInteraction is set to true so the applications are also updated unrelated from the app update schedule
            ConfigUpdater.forceConfigUpdate(PluginApiService.this, null, true);
        }
    };
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/PushNotificationWorker.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;

import androidx.annotation.NonNull;
import androidx.work.ExistingPeriodicWorkPolicy;
import androidx.work.PeriodicWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;

import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import retrofit2.Response;

public class PushNotificationWorker extends Worker {

    // Minimal interval is 15 minutes as per docs
    public static final int FIRE_PERIOD_MINS = 15;

    // Interval to update configuration to avoid losing device due to push failure
    public static final long CONFIG_UPDATE_INTERVAL = 3600000l;

    private static final String WORK_TAG_PERIODIC = "com.hmdm.launcher.WORK_TAG_PUSH_PERIODIC";

    public static void schedule(Context context) {
        RemoteLogger.log(context, Const.LOG_DEBUG, "Push notifications enqueued: " + FIRE_PERIOD_MINS + " mins");
        PeriodicWorkRequest queryRequest =
                new PeriodicWorkRequest.Builder(PushNotificationWorker.class, FIRE_PERIOD_MINS, TimeUnit.MINUTES)
                        .addTag(Const.WORK_TAG_COMMON)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniquePeriodicWork(WORK_TAG_PERIODIC, ExistingPeriodicWorkPolicy.REPLACE, queryRequest);
    }

    private Context context;
    private SettingsHelper settingsHelper;

    public PushNotificationWorker(
            @NonNull final Context context,
            @NonNull WorkerParameters params) {
        super(context, params);
        this.context = context;
        settingsHelper = SettingsHelper.getInstance(context);
    }

    @Override
    // This is running in a background thread by WorkManager
    public Result doWork() {
        if (settingsHelper == null || settingsHelper.getConfig() == null) {
            return Result.failure();
        }

        String pushOptions = settingsHelper.getConfig().getPushOptions();

        if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER) ||
                pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
            // Note: MQTT client is automatically reconnected if connection is broken during launcher running,
            // and re-initializing it may cause looped errors
            // In particular, MQTT client is reconnected after turning Wi-Fi off and back on.
            // Re-connection of MQTT client at Headwind MDM startup is implemented in MainActivity
            // So by now, just request configuration update some times per day to avoid "device lost" issues
            return doMqttWork();
        } else {
            // PUSH_OPTIONS_POLLING by default
            //return doPollingWork();
            // Long polling is done in a related service
            // This is just a reserve task to prevent devices from being lost just in case
            return doLongPollingWork();
        }
    }

    // Query server for incoming messages each 15 minutes
    private Result doPollingWork() {
        ServerService serverService = ServerServiceKeeper.getServerServiceInstance(context);
        ServerService secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        Response<PushResponse> response = null;

        // Calculate request signature
        String encodedDeviceId = settingsHelper.getDeviceId();
        try {
            encodedDeviceId = URLEncoder.encode(encodedDeviceId, "utf8");
        } catch (UnsupportedEncodingException e) {
        }
        String path = settingsHelper.getServerProject() + "/rest/notifications/device/" + encodedDeviceId;
        String signature = null;
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + path);
        } catch (Exception e) {
        }

        RemoteLogger.log(context, Const.LOG_DEBUG, "Querying push notifications");
        try {
            response = serverService.
                    queryPushNotifications(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Failed to query push notifications: " + e.getMessage());
            e.printStackTrace();
        }

        try {
            if (response == null) {
                response = secondaryServerService.
                        queryPushNotifications(settingsHelper.getServerProject(), settingsHelper.getDeviceId(), signature).execute();
            }

            if ( response.isSuccessful() ) {
                if ( Const.STATUS_OK.equals( response.body().getStatus() ) && response.body().getData() != null ) {
                    Map<String, PushMessage> filteredMessages = new HashMap<String, PushMessage>();
                    for (PushMessage message : response.body().getData()) {
                        // Filter out multiple configuration update requests
                        if (!message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED) ||
                                !filteredMessages.containsKey(PushMessage.TYPE_CONFIG_UPDATED)) {
                            filteredMessages.put(message.getMessageType(), message);
                        }
                    }
                    for (Map.Entry<String, PushMessage> entry : filteredMessages.entrySet()) {
                        PushNotificationProcessor.process(entry.getValue(), context);
                    }
                    return Result.success();
                } else {
                    return Result.failure();
                }
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }

        return Result.failure();
    }

    // Periodic configuration update requests
    private Result doLongPollingWork() {
        return forceConfigUpdateWork();
    }

    // Periodic configuration update requests
    private Result doMqttWork() {

        if (PushNotificationMqttWrapper.getInstance().checkPingDeath(context)) {
            RemoteLogger.log(context, Const.LOG_INFO, "MQTT ping death detected, reconnecting!");
            mqttReconnect();
        }

        return forceConfigUpdateWork();
    }

    private Result forceConfigUpdateWork() {
        long lastConfigUpdateTimestamp = settingsHelper.getConfigUpdateTimestamp();
        long now = System.currentTimeMillis();
        if (lastConfigUpdateTimestamp == 0) {
            settingsHelper.setConfigUpdateTimestamp(now);
            return Result.success();
        }
        if (lastConfigUpdateTimestamp + CONFIG_UPDATE_INTERVAL > now) {
            return Result.success();
        }
        RemoteLogger.log(context, Const.LOG_DEBUG, "Forcing configuration update");
        settingsHelper.setConfigUpdateTimestamp(now);
        ConfigUpdater.forceConfigUpdate(context);
        return Result.success();
    }

    // We assume we're running in the background!
    // https://stackoverflow.com/questions/57552955/is-possible-backgroundworker-dowork-in-main-thread
    private void mqttReconnect() {
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        String pushOptions = settingsHelper.getConfig().getPushOptions();
        Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
        if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
            keepaliveTime = newKeepaliveTime;
        }
        try {
            PushNotificationMqttWrapper.getInstance().disconnect(context);
            Thread.sleep(5000);
            URL url = new URL(settingsHelper.getBaseUrl());
            PushNotificationMqttWrapper.getInstance().connect(context, url.getHost(), BuildConfig.MQTT_PORT,
                    pushOptions, keepaliveTime, settingsHelper.getDeviceId(), null, null);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Reconnection failure: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/AlarmPingSender.java">
/*******************************************************************************
 * Copyright (c) 2014 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution. 
 *
 * The Eclipse Public License is available at 
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at 
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Build;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.util.RemoteLogger;

import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttPingSender;
import org.eclipse.paho.client.mqttv3.internal.ClientComms;

/**
 * Default ping sender implementation on Android. It is based on AlarmManager.
 *
 * <p>This class implements the {@link MqttPingSender} pinger interface
 * allowing applications to send ping packet to server every keep alive interval.
 * </p>
 *
 * @see MqttPingSender
 */
class AlarmPingSender implements MqttPingSender {
	// Identifier for Intents, log messages, etc..
	private static final String TAG = "MqttAlarmPingSender";

	// TODO: Add log.
	private ClientComms comms;
	private MqttService service;
	private BroadcastReceiver alarmReceiver;
	private AlarmPingSender that;
	private PendingIntent pendingIntent;
	private volatile boolean hasStarted = false;

	public AlarmPingSender(MqttService service) {
		if (service == null) {
			throw new IllegalArgumentException(
					"Neither service nor client can be null.");
		}
		this.service = service;
		that = this;
	}

	@Override
	public void init(ClientComms comms) {
		this.comms = comms;
		this.alarmReceiver = new AlarmReceiver();
	}

	@Override
	public void start() {
		String action = MqttServiceConstants.PING_SENDER
				+ comms.getClient().getClientId();
		Log.d(TAG, "Register alarmreceiver to MqttService"+ action);
		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
			service.registerReceiver(alarmReceiver, new IntentFilter(action), Context.RECEIVER_EXPORTED);
		} else {
			service.registerReceiver(alarmReceiver, new IntentFilter(action));
		}

		pendingIntent = PendingIntent.getBroadcast(service, 0, new Intent(
				action), PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE);

		schedule(comms.getKeepAlive());
		hasStarted = true;
	}

	@Override
	public void stop() {

		Log.d(TAG, "Unregister alarmreceiver to MqttService"+comms.getClient().getClientId());
		if(hasStarted){
			if(pendingIntent != null){
				// Cancel Alarm.
				AlarmManager alarmManager = (AlarmManager) service.getSystemService(Service.ALARM_SERVICE);
				alarmManager.cancel(pendingIntent);
			}

			hasStarted = false;
			try{
				service.unregisterReceiver(alarmReceiver);
			}catch(IllegalArgumentException e){
				//Ignore unregister errors.			
			}
		}
	}

	@Override
	public void schedule(long delayInMilliseconds) {
			long nextAlarmInMilliseconds = System.currentTimeMillis()
				+ delayInMilliseconds;
		Log.d(TAG, "Schedule next alarm at " + nextAlarmInMilliseconds);
		AlarmManager alarmManager = (AlarmManager) service
				.getSystemService(Service.ALARM_SERVICE);

        if(Build.VERSION.SDK_INT >= 23){
			// In SDK 23 and above, dosing will prevent setExact, setExactAndAllowWhileIdle will force
			// the device to run this task whilst dosing.
			Log.d(TAG, "Alarm schedule using setExactAndAllowWhileIdle, next: " + delayInMilliseconds);
			if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S || alarmManager.canScheduleExactAlarms()) {
				alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
						pendingIntent);
			} else {
				Log.w(TAG, "Failed to alarm schedule: no permission!");
			}
		} else if (Build.VERSION.SDK_INT >= 19) {
			Log.d(TAG, "Alarm schedule using setExact, delay: " + delayInMilliseconds);
			alarmManager.setExact(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
					pendingIntent);
		} else {
			alarmManager.set(AlarmManager.RTC_WAKEUP, nextAlarmInMilliseconds,
					pendingIntent);
		}
	}

	/*
	 * This class sends PingReq packet to MQTT broker
	 */
	class AlarmReceiver extends BroadcastReceiver {
		private WakeLock wakelock;
		private final String wakeLockTag = MqttServiceConstants.PING_WAKELOCK
				+ that.comms.getClient().getClientId();

		@Override
        @SuppressLint("Wakelock")
		public void onReceive(final Context context, Intent intent) {
			// According to the docs, "Alarm Manager holds a CPU wake lock as
			// long as the alarm receiver's onReceive() method is executing.
			// This guarantees that the phone will not sleep until you have
			// finished handling the broadcast.", but this class still get
			// a wake lock to wait for ping finished.

			Log.d(TAG, "Sending Ping at:" + System.currentTimeMillis());

			PowerManager pm = (PowerManager) service
					.getSystemService(Service.POWER_SERVICE);
			wakelock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, wakeLockTag);
			wakelock.acquire();

			RemoteLogger.log(context, Const.LOG_VERBOSE, "Sending MQTT Ping at:" + System.currentTimeMillis());
			PingDeathDetector.getInstance().registerPing();

			// Assign new callback to token to execute code after PingResq
			// arrives. Get another wakelock even receiver already has one,
			// release it until ping response returns.
			IMqttToken token = comms.checkForActivity(new IMqttActionListener() {

				@Override
				public void onSuccess(IMqttToken asyncActionToken) {
					RemoteLogger.log(context, Const.LOG_VERBOSE, "Ping success");
					Log.d(TAG, "Success. Release lock(" + wakeLockTag + "):"
							+ System.currentTimeMillis());
					//Release wakelock when it is done.
					wakelock.release();
				}

				@Override
				public void onFailure(IMqttToken asyncActionToken,
									  Throwable exception) {
					RemoteLogger.log(context, Const.LOG_INFO, "MQTT ping failure");
					Log.d(TAG, "Failure. Release lock(" + wakeLockTag + "):"
							+ System.currentTimeMillis());
					//Release wakelock when it is done.
					wakelock.release();
				}
			});


			if (token == null && wakelock.isHeld()) {
				RemoteLogger.log(context, Const.LOG_VERBOSE, "WakeLock released");
				wakelock.release();
			}
		}
	}
}
</file>

<file path="app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<layout xmlns:android="http://schemas.android.com/apk/res/android"
        xmlns:tools="http://schemas.android.com/tools"
        xmlns:bind="http://schemas.android.com/apk/res-auto">
    <data>
        <variable name="message" type="String"/>
        <variable name="downloading" type="Boolean"/>
        <variable name="showContent" type="Boolean"/>
        <variable name="fileLength" type="Long"/>
        <variable name="downloadedLength" type="Long"/>
    </data>
    
    <RelativeLayout 
        android:id="@+id/activity_main"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:context="com.hmdm.launcher.ui.MainActivity">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:paddingBottom="@dimen/activity_vertical_margin"
            android:paddingLeft="@dimen/activity_horizontal_margin"
            android:paddingRight="@dimen/activity_horizontal_margin"
            android:paddingTop="@dimen/activity_vertical_margin"
            android:orientation="vertical"
            android:layout_centerInParent="true"
            android:gravity="center">

            <ProgressBar
                android:id="@+id/loading"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"/>

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{message}"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:gravity="center"/>

            <ProgressBar
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="@dimen/activity_vertical_margin"
                android:id="@+id/progress"
                android:max="100"
                style="?android:attr/progressBarStyleHorizontal"
                bind:boolToVisible="@{downloading}"/>

            <LinearLayout
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:orientation="horizontal"
                android:layout_marginTop="10dp"
                bind:boolToVisible="@{downloading}">

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@{String.valueOf(downloadedLength)}"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="/"/>

                <TextView
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="@{String.valueOf(fileLength)}"/>

            </LinearLayout>

        </LinearLayout>

        <RelativeLayout
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            bind:boolToVisible="@{showContent}"
            android:id="@+id/activity_main_content_wrapper">

            <ImageView
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:scaleType="centerCrop"
                android:id="@+id/activity_main_background"/>


            <LinearLayout
                android:id="@+id/status_header"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="horizontal">
                <TextView
                    android:id="@+id/clock"
                    android:layout_width="@dimen/status_bar_side_width"
                    android:layout_height="wrap_content"
                    android:layout_marginLeft="5dp"
                    android:textSize="@dimen/title_text_size"
                    />
                <TextView
                    android:layout_width="0dp"
                    android:layout_height="wrap_content"
                    android:layout_weight="1"
                    android:id="@+id/activity_main_title"
                    android:gravity="center"
                    android:textSize="@dimen/title_text_size"
                    />
                <com.hmdm.launcher.ui.custom.BatteryStateView
                    android:id="@+id/battery_state"
                    android:layout_width="@dimen/status_bar_side_width"
                    android:layout_height="wrap_content"
                    android:layout_marginRight="5dp"/>
                <Button
                    android:id="@+id/openFlutterButton"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="Flutter" />
            </LinearLayout>

            <androidx.recyclerview.widget.RecyclerView
                android:id="@+id/activity_main_content"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_above="@+id/activity_bottom_layout"
                android:layout_below="@+id/status_header" />

            <RelativeLayout
                android:id="@+id/activity_bottom_layout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_alignParentBottom="true"
                >

                <androidx.recyclerview.widget.RecyclerView
                    android:layout_centerHorizontal="true"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:id="@+id/activity_bottom_line"/>

            </RelativeLayout>

        </RelativeLayout>

    </RelativeLayout>

</layout>
</file>

<file path="app/src/main/res/values-cs/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrátor</string>
    <string name="install_error">Chyba instalace</string>
    <string name="file_create_error">Chyba při vytváření souboru</string>
    <string name="dialog_enter_device_id_error">ID není registrováno na %s. Získejte ID ze záložky \"Zařízení\" admin panelu.</string>
    <string name="dialog_enter_device_id_qrcode">QR kód</string>
    <string name="dialog_enter_device_id_variants">Varianty</string>
    <string name="dialog_enter_device_id_save">Uložit</string>
    <string name="dialog_enter_device_id_exit">Ukončit</string>
    <string name="dialog_enter_device_id_title">Vložte ID zařízení na %s</string>
    <string name="main_start_preparations">Příprava spuštění</string>
    <string name="main_downloading_configuration">Aktualizace konfiguračního souboru</string>
    <string name="main_downloading_content">Aktualizace dat</string>
    <string name="main_update_applications">Instalace a aktualizace aplikací</string>
    <string name="dialog_root_message">Potřebujete ROOT přístup</string>
    <string name="main_application_start">Aplikace se zapíná</string>
    <string name="main_app_installing">Aplikace se instaluje</string>
    <string name="main_app_downloading">Aplikace se stahuje</string>
    <string name="main_app_downloading_error">Aplikace se nepodařila stáhnout</string>
    <string name="main_app_removing">Aplikace se odebírá</string>
    <string name="main_file_downloading">Soubor se stahuje</string>
    <string name="main_file_downloading_error">Soubor se nepodařilo stáhnout</string>
    <string name="main_activity_repeat">Zkusit znovu</string>
    <string name="main_activity_reset">Reset</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Ukončit</string>
    <string name="main_activity_details">Podrobnosti</string>
    <string name="select_system_launcher">Vyberte %s jako hlavní launcher a klepněte na \'Vždy\':</string>
    <string name="dialog_network_error_title">Chyba připojení k %s. Zkontrolujte připojení k internetu a zkuste znovu.</string>
    <string name="main_activity_update_config">Získávám konfigurační soubor ze serveru</string>
    <string name="main_activity_applications_update">Aktualizace aplikací</string>
    <string name="dialog_overlay_settings_title">Prosím povolte aplikaci vykreslování přes ostatní okna.\n\nToto nastavení pomáhá lépe blokovat nežádoucí aplikace a umožní nouzové odemykání kiosku.\n\nVyberte \"Pokračovat\" pro otevření nastavení. Vyberte položku \"%s\" a povolte oprávnění, poté se vraťte.</string>
    <string name="dialog_manage_storage_title">Povolte aplikaci spravovat úložiště.\n\nTato možnost umožňuje Headwind MDM spravovat soubory ve vašem zařízení.</string>
    <string name="dialog_history_settings_title">Prosím povolte aplikaci přístup k diagnostickým datům.\n\nToto nastavení pomáhá k ovládání nastavení a aplikací.\n\nToto nastavení může způsobit rychlejší vybití baterie. Pokud chcete šetřit baterii, toto nastavení přeskočte (použijte kiosk nebo nastavení přístupnosti).\n\nVyberte \"Pokračovat\" pro otevření nastavení. Vyberte položku \"%s\" a povolte oprávnění, poté se vraťte.</string>
    <string name="dialog_history_settings_continue">Pokračovat</string>
    <string name="dialog_history_settings_skip">Přeskočit</string>
    <string name="dialog_unknown_sources_title">Prosím povolte instalaci z neznámých zdrojů. Bude otevřeno nastavení. Vyberte \"Neznámé zdroje\" a povolte instalaci, poté se vraťte.</string>
    <string name="dialog_unknown_sources_continue">Pokračovat</string>
    <string name="dialog_miui_permissions_title">MIUI vyžaduje ruční nastavení vlastních oprávnění. Oprávnění aplikace se nyní otevřou. Vyberte \"Ostatní oprávnění\" a povolte \"Zobrazovat vyskakovací okna při běhu v pozadí\", poté se vraťte.</string>
    <string name="dialog_miui_developer_title">MIUI vyžaduje ruční nastavení vašeho zařízení. Na stavové obrazovce 7x poklepejte na \"Číslo sestavení\". Toto povolí možnosti vývojáře.</string>
    <string name="dialog_miui_optimization_title">MIUI vyžaduje ruční nastavení vašeho zařízení. Nastavení vývojáře se nyní otevře. Najděte položku \"MIUI optimization\" a vypněte ji.</string>
    <string name="dialog_administrator_mode_message">Prosím povolte aplikaci možnost běhu jako administrátor zařízení. Bude otevřeno nastavení. Vyberte \"Administrátoři zařízeni\" a aktivujte administrátora pro \"%s\", poté se vraťte.</string>
    <string name="dialog_administrator_mode_continue">Pokračovat</string>
    <string name="dialog_administrator_mode_skip">Přeskočit</string>
    <string name="accessibility_service_description">Aktivní monitorování aplikací přes MDM</string>
    <string name="dialog_accessibility_service_message">Prosím povolte aplikaci oprávnění ke službám přístupnosti. Bude otevřeno nastavení. Najděte \"%s\" a povolte přístup, poté se vraťte.</string>
    <string name="dialog_accessibility_service_continue">Pokračovat</string>
    <string name="dialog_accessibility_service_skip">Přeskočit</string>
    <string name="access_to_app_denied">Balíček není povolen:</string>
    <string name="access_to_app_denied_2">Požádejte svého administrátora, aby tento balíček povolil v konfiguraci.\n\nPokračujte kliknutím na tlačítko \'Zavřít\' nebo Domů.</string>
    <string name="package_id_copied">ID balíčku se zkopíruje do schránky</string>
    <string name="dialog_app_not_allowed_close">Zavřít</string>
    <string name="dialog_app_not_allowed_admin">Administrátor</string>
    <string name="device_id">ID zařízení</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Sériové číslo</string>
    <string name="phone_number">Telefonní číslo</string>
    <string name="launcher_version">Verze launcheru</string>
    <string name="close">Zavřít</string>
    <string name="admin_change_device_id">Změnit ID zařízení</string>
    <string name="admin_change_server_url">Změnit adresu serveru</string>
    <string name="admin_allow_settings">Otevřít nastavení</string>
    <string name="settings_allowed">Máte povoleno 3 minuty měnit nastavení.</string>
    <string name="admin_clear_restrictions">Smazat omezení</string>
    <string name="permissive_mode_enabled">Máte povoleno 3 minuty spouštět všechny aplikace.</string>
    <string name="admin_refresh">Aktualizovat konfiguraci</string>
    <string name="admin_exit">Odejít do systémového launcheru</string>
    <string name="admin_reset_permissions">Zkontrolovat oprávnění</string>
    <string name="admin_reset_network">Resetovat nastavení sítě</string>
    <string name="admin_reset_network_hint">Nastavení sítě bylo resetováno. Nyní můžete znovu připojit síť a aktualizovat konfiguraci</string>
    <string name="reboot">Restartovat zařízení</string>
    <string name="reboot_failed">Nedostatečná oprávnění pro restartování zařízení.</string>
    <string name="message_turn_on_gps">Nyní se otevře nastavení. Prosím zapněte lokalizaci přes GPS.</string>
    <string name="message_turn_off_gps">Nyní se otevře nastavení. Prosím vypněte lokalizaci přes GPS.</string>
    <string name="message_turn_on_mobile_data">Mobilní data jsou vypnuta. Zapněte je prosím ve stavové liště</string>
    <string name="message_turn_off_mobile_data">Mobilní data jsou zapnuta. Vypněte je prosím ve stavové liště.</string>
    <string name="message_set_password">Vaše heslo nesplňuje požadavky. Nyní se otevře nastavení. Prosím změnte si heslo.</string>
    <string name="switch_off_blockings">Vypínám omezení...</string>
    <string name="kiosk_mode_requires_overlays">Režim kiosk vypnut: chybí oprávnění pro vykreslování přes aplikace. Prosím povolte oprávnění pro %s.</string>
    <string name="enter_admin_password">Zadejte administrátorské heslo</string>
    <string name="wrong_password">Špatné heslo</string>
    <string name="dialog_enter_password_login">Přihlásit se</string>
    <string name="dialog_enter_password_cancel">Zavřít</string>
    <string name="internal_error">Aplikace zaznamenala vnitřní chybu. Prosím restartujte zařízení a zkuste znovu.</string>
    <string name="empty_configuration">Prázdná konfigurace! Pokouším se stáhnout konfiguraci ze serveru.</string>
    <string name="permissions_reset_hint">Zavřete panel administrátora pro kontrolu a nastavení oprávnění.</string>
    <string name="dialog_enter_server_error">Prosím zadejte platnou URL serveru.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Prosím zadejte adres URL serveru</string>
    <string name="critical_server_failure">Ukončeno - Chyba serveru! Prosím opravta chybu a restartujte %s, nebo kompletně reinstalujte.</string>
    <string name="dialog_permission_title">Tato aplikace vyžaduje oprávnění k jejímu běhu. Prosím aktivujte je.</string>
    <string name="main_activity_exit">Ukončit</string>
    <string name="browser_not_found">Webová stránka nelze otevřít, protože nebyl nalezen prohlížeč. Prosím přidejte aplikaci prohlížeče do konfigurace zařízení.</string>
    <string name="invalid_web_link">Webový odkaz nelze otevřít, protože má špatný formát. Prosím kontaktujte vašeho administrátora.</string>
    <string name="activity_not_found">Nelze provést akci %s, protože aktivita nebyla nalezena.</string>
    <string name="location_service_text">Poloha zařízení je sledována</string>
    <string name="qrcode_contents_error">Neplatný obsah QR kódu. Prosím vygenerujte QR kód znovu ve webové administraci %s.</string>
    <string name="device_locked">Toto zařízení (%s) bylo zamknuto administrátorem.</string>
    <string name="fault_loop_detected">Launcher se dostal do neobnovitelného stavu! Prosím kontaktujte vašeho administrátora.</string>
    <string name="mqtt_service_text">Push notifikace jsou zapnuté</string>
    <string name="background_location">%s vyžaduje oprávnění sledování polohy na pozadí. Vyberte \'Pokračovat\' pro otevření nastavení. Vyberte \'Poloha\' a možnost sledování polohy kdykoliv.</string>
    <string name="location_disable">Zakázat polohu</string>
    <string name="background_location_continue">Pokračovat</string>
    <string name="initializing_mdm">Připravuji aplikaci pro správu zařízení...</string>
    <string name="dialog_server_error_title">MDM server %s vrátil neplatnou odpověď. Prosím kontaktujte administrátora.</string>
    <string name="mdm_choice_message">Toto zažízení bude plně řízeno vaší organizací. Vaše data nejsou soukromá a mohou být kdykoliv smazána, nebo zobrazena vaším administrátotem.</string>
    <string name="work_profile_message">Na tomto zařízení se vytvoří pracovní profil, který patří vaší organizaci. Pracovní profil je oddělen od vašeho soukromého a lze mezi nimi kdykoliv přepínat.</string>
    <string name="overlays_not_supported">Překreslování obrazovku bohužel není podporováno na vašem zařízení.</string>
    <string name="admin_not_supported">Vaše zařízení nemá možnost vytvoření administrátora zařízení. Vyberte přeskočit pro pokračování.</string>
    <string name="manage_storage_not_supported">Vaše zařízení nemá možnost spravovat externí úložiště.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/Application.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties( ignoreUnknown = true )
public class Application {

    public static final String TYPE_APP = "app";
    public static final String TYPE_WEB = "web";
    public static final String TYPE_INTENT = "intent";

    private String type;
    private String name;
    private String pkg;
    private String version;
    private Integer code;
    private String url;
    private boolean useKiosk;
    private boolean showIcon;
    private boolean remove;
    private boolean runAfterInstall;
    private boolean runAtBoot;
    private boolean skipVersion;
    private String iconText;
    private String icon;
    private Integer screenOrder;
    private Integer keyCode;
    private boolean bottom;
    private boolean longTap;
    private String intent;

    public Application() {}

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPkg() {
        return pkg;
    }

    public void setPkg(String pkg) {
        this.pkg = pkg;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public boolean isUseKiosk() {
        return useKiosk;
    }

    public void setUseKiosk(boolean useKiosk) {
        this.useKiosk = useKiosk;
    }

    public boolean isShowIcon() {
        return showIcon;
    }

    public void setShowIcon(boolean showIcon) {
        this.showIcon = showIcon;
    }

    public boolean isRemove() {
        return remove;
    }

    public void setRemove(boolean remove) {
        this.remove = remove;
    }

    public boolean isRunAfterInstall() {
        return runAfterInstall;
    }

    public void setRunAfterInstall(boolean runAfterInstall) {
        this.runAfterInstall = runAfterInstall;
    }

    public boolean isRunAtBoot() {
        return runAtBoot;
    }

    public void setRunAtBoot(boolean runAtBoot) {
        this.runAtBoot = runAtBoot;
    }

    public boolean isSkipVersion() {
        return skipVersion;
    }

    public void setSkipVersion(boolean skipVersion) {
        this.skipVersion = skipVersion;
    }

    public String getIconText() {
        return iconText;
    }

    public void setIconText(String iconText) {
        this.iconText = iconText;
    }

    public String getIcon() {
        return icon;
    }

    public void setIcon(String icon) {
        this.icon = icon;
    }

    public Integer getScreenOrder() {
        return screenOrder;
    }

    public void setScreenOrder(Integer screenOrder) {
        this.screenOrder = screenOrder;
    }

    public Integer getKeyCode() {
        return keyCode;
    }

    public void setKeyCode(Integer keyCode) {
        this.keyCode = keyCode;
    }

    public boolean isBottom() {
        return bottom;
    }

    public void setBottom(boolean bottom) {
        this.bottom = bottom;
    }

    public boolean isLongTap() {
        return longTap;
    }

    public void setLongTap(boolean longTap) {
        this.longTap = longTap;
    }

    public String getIntent() {
        return intent;
    }

    public void setIntent(String intent) {
        this.intent = intent;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/pro/ProUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.pro;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.location.Location;
import android.view.View;

import com.hmdm.launcher.R;
import com.hmdm.launcher.json.ServerConfig;

import java.util.Calendar;

/**
 * These functions are available in Pro-version only
 * In a free version, the class contains stubs
 */
public class ProUtils {

    public static boolean isPro() {
        return false;
    }

    public static boolean kioskModeRequired(Context context) {
        return false;
    }

    public static void initCrashlytics(Context context) {
        // Stub
    }

    public static void sendExceptionToCrashlytics(Throwable e) {
        // Stub
    }

    // Start the service checking if the foreground app is allowed to the user (by usage statistics)
    public static boolean checkAccessibilityService(Context context) {
        // Stub
        return true;
    }

    // Pro-version
    public static boolean checkUsageStatistics(Context context) {
        // Stub
        return true;
    }

    // Add a transparent view on top of the status bar which prevents user interaction with the status bar
    public static View preventStatusBarExpansion(Activity activity) {
        // Stub
        return null;
    }

    // Add a transparent view on top of a swipeable area at the right (opens app list on Samsung tablets)
    public static View preventApplicationsList(Activity activity) {
        // Stub
        return null;
    }

    public static View createKioskUnlockButton(Activity activity) {
        // Stub
        return null;
    }

    public static boolean isKioskAppInstalled(Context context) {
        // Stub
        return false;
    }

    public static boolean isKioskModeRunning(Context context) {
        // Stub
        return false;
    }

    public static Intent getKioskAppIntent(String kioskApp, Activity activity) {
        // Stub
        return null;
    }

    // Start COSU kiosk mode
    public static boolean startCosuKioskMode(String kioskApp, Activity activity, boolean enableSettings) {
        // Stub
        return false;
    }

    // Set/update kiosk mode options (lock tack features)
    public static void updateKioskOptions(Activity activity) {
        // Stub
    }

    // Update app list in the kiosk mode
    public static void updateKioskAllowedApps(String kioskApp, Activity activity, boolean enableSettings) {
        // Stub
    }

    public static void unlockKiosk(Activity activity) {
        // Stub
    }

    public static void processConfig(Context context, ServerConfig config) {
        // Stub
    }

    public static void processLocation(Context context, Location location, String provider) {
        // Stub    
    }

    public static String getAppName(Context context) {
        return context.getString(R.string.app_name);
    }

    public static String getCopyright(Context context) {
        return "(c) " + Calendar.getInstance().get(Calendar.YEAR) + " " + context.getString(R.string.vendor);
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/service/LocationService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.service;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ServiceInfo;
import android.location.GnssStatus;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.RemoteLogger;

public class LocationService extends Service {
    private LocationManager locationManager;

    private static final int NOTIFICATION_ID = 112;
    public static String CHANNEL_ID = LocationService.class.getName();

    public static final String ACTION_UPDATE_GPS = "gps";
    public static final String ACTION_UPDATE_NETWORK = "network";
    public static final String ACTION_STOP = "stop";

    boolean updateViaGps = false;
    boolean started = false;

    private static final int LOCATION_UPDATE_INTERVAL = 60000;

    // Use different location listeners for GPS and Network
    // Not sure what happens if we share the same listener for both providers
    private LocationListener gpsLocationListener = new LocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            // Do nothing here: we use getLastKnownLocation() to determine the location!
            //Toast.makeText(LocationService.this, "Location updated from GPS", Toast.LENGTH_SHORT).show();
            RemoteLogger.log(LocationService.this, Const.LOG_VERBOSE, "GPS location update: lat="
                    + location.getLatitude() + ", lon=" + location.getLongitude());
            ProUtils.processLocation(LocationService.this, location, LocationManager.GPS_PROVIDER);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        @Override
        public void onProviderEnabled(String provider) {
        }

        @Override
        public void onProviderDisabled(String provider) {
        }
    };
    private LocationListener networkLocationListener = new LocationListener() {
        @Override
        public void onLocationChanged(Location location) {
            // Do nothing here: we use getLastKnownLocation() to determine the location!
            //Toast.makeText(LocationService.this, "Location updated from Network", Toast.LENGTH_SHORT).show();
            RemoteLogger.log(LocationService.this, Const.LOG_VERBOSE, "Network location update: lat="
                    + location.getLatitude() + ", lon=" + location.getLongitude());
            ProUtils.processLocation(LocationService.this, location, LocationManager.NETWORK_PROVIDER);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
        }

        @Override
        public void onProviderEnabled(String provider) {
        }

        @Override
        public void onProviderDisabled(String provider) {
        }
    };

    private Handler handler = new Handler();
    private GnssStatus.Callback gnssStatusCallback = null;

    @Override
    public void onCreate() {
        super.onCreate();
        locationManager = (LocationManager)this.getSystemService(LOCATION_SERVICE);

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            gnssStatusCallback = new GnssStatus.Callback() {
                @Override
                public void onSatelliteStatusChanged(@NonNull GnssStatus status) {
                    super.onSatelliteStatusChanged(status);
                    try {
                        Log.d(Const.LOG_TAG, "Satellite status changed, count: " + status.getSatelliteCount());
                        SettingsHelper.getInstance(LocationService.this.getApplicationContext()).setSatelliteCount(status.getSatelliteCount());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            };
        }
    }

    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText( getString( R.string.location_service_text ) )
                .setSmallIcon( R.drawable.ic_location_service ).build();

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            startForeground(NOTIFICATION_ID, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
        } else {
            startForeground(NOTIFICATION_ID, notification);
        }
    }

    private boolean requestLocationUpdates() {
        if (updateViaGps && (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) !=
                PackageManager.PERMISSION_GRANTED || !locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER))) {
            updateViaGps = false;
        }
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION) !=
                PackageManager.PERMISSION_GRANTED) {
            // No permission, so give up!
            return false;
        }

        boolean gpsEnabled = locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER);
        boolean networkEnabled = locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER);
        boolean passiveEnabled = locationManager.isProviderEnabled(LocationManager.PASSIVE_PROVIDER);
        RemoteLogger.log(this, Const.LOG_VERBOSE,
                "Request location updates. gps=" + gpsEnabled + ", network=" + networkEnabled + ", passive=" + passiveEnabled);

        locationManager.removeUpdates(networkLocationListener);
        locationManager.removeUpdates(gpsLocationListener);
        try {
            locationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, LOCATION_UPDATE_INTERVAL, 0, networkLocationListener);
            if (updateViaGps) {
                locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, LOCATION_UPDATE_INTERVAL, 0, gpsLocationListener);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                    locationManager.registerGnssStatusCallback(gnssStatusCallback, handler);
                }
            }
        } catch (Exception e) {
            // Provider may not exist, so process it friendly
            e.printStackTrace();
            return false;
        }

        return true;
    }


    @Override
    public void onDestroy() {
        locationManager.removeUpdates(networkLocationListener);
        locationManager.removeUpdates(gpsLocationListener);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            locationManager.unregisterGnssStatusCallback(gnssStatusCallback);
        }
        started = false;

        super.onDestroy();
    }


    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent inputIntent, int flags, int startId) {
        boolean legacyGpsFlag = updateViaGps;
        if (inputIntent != null && inputIntent.getAction() != null) {
            if (inputIntent.getAction().equals(ACTION_STOP)) {
                // Stop service
                started = false;
                stopForeground(true);
                stopSelf();
                return Service.START_NOT_STICKY;
            } else if (inputIntent.getAction().equals(ACTION_UPDATE_GPS)) {
                updateViaGps = true;
            } else {
                updateViaGps = false;
            }
        } else {
            updateViaGps = false;
        }
        if (!started || legacyGpsFlag != updateViaGps) {
            if (!requestLocationUpdates()) {
                // No permissions!
                started = false;
                stopForeground(true);
                stopSelf();
                return Service.START_NOT_STICKY;
            }
        }
        if (!started) {
            startAsForeground();
            started = true;
        }
        return START_STICKY;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/AdminActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.Build;
import android.os.Bundle;
import android.os.UserManager;
import android.util.Log;
import android.view.View;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityAdminBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.LegacyUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class AdminActivity extends BaseActivity {

    private static final String KEY_APP_INFO = "info";
    private SettingsHelper settingsHelper;

    @Nullable
    public static AppInfo getAppInfo(Intent intent){
        if (intent == null){
            return null;
        }
        return intent.getParcelableExtra(KEY_APP_INFO);
    }

    ActivityAdminBinding binding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_admin);
        binding.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
        binding.toolbar.setTitle(ProUtils.getAppName(this));
        binding.toolbar.setSubtitle(ProUtils.getCopyright(this));

        // If QR code doesn't contain "android.app.extra.PROVISIONING_LEAVE_ALL_SYSTEM_APPS_ENABLED":true
        // the system launcher is turned off, so it's not possible to exit and we must hide the exit button
        // Currently the QR code contains this parameter, so the button is always visible
        //binding.systemLauncherButton.setVisibility(Utils.isDeviceOwner(this) ? View.GONE : View.VISIBLE);

        if ( Build.VERSION.SDK_INT <= Build.VERSION_CODES.M ) {
            binding.rebootButton.setVisibility(View.GONE);
        }

        settingsHelper = SettingsHelper.getInstance( this );
        binding.deviceId.setText(settingsHelper.getDeviceId());
        binding.deviceId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                createAndShowInfoDialog();
            }
        });
    }

    @Override
    protected void onPause() {
        super.onPause();

        if (progressDialog != null) {
            progressDialog.dismiss();
            progressDialog = null;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        if (progressDialog != null) {
            progressDialog.dismiss();
            progressDialog = null;
        }
    }

    public void changeDeviceId(View view) {
        dismissDialog(enterDeviceIdDialog);
        createAndShowEnterDeviceIdDialog(false, settingsHelper.getDeviceId());
    }

    public void changeServerUrl(View view) {
        dismissDialog(enterServerDialog);
        createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
    }

    public void allowSettings(View view) {
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_ENABLE_SETTINGS ) );
        Toast.makeText(this, R.string.settings_allowed, Toast.LENGTH_LONG).show();
        startActivity(new Intent(android.provider.Settings.ACTION_SETTINGS));
        //finish();
    }

    public void clearRestrictions(View view) {
        String restrictions =
                UserManager.DISALLOW_SAFE_BOOT + "," +
                UserManager.DISALLOW_USB_FILE_TRANSFER + "," +
                UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA + "," +
                UserManager.DISALLOW_CONFIG_BRIGHTNESS + "," +
                UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT + "," +
                UserManager.DISALLOW_ADJUST_VOLUME;
        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            restrictions = "," + settingsHelper.getConfig().getRestrictions();
        }
        Utils.unlockUserRestrictions(this, restrictions);
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_PERMISSIVE_MODE ) );
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_STOP_CONTROL ) );
        Toast.makeText(this, R.string.permissive_mode_enabled, Toast.LENGTH_LONG).show();
        //finish();
    }
    @Override
    protected void updateSettingsFromQr(String qrcode) {
        super.updateSettingsFromQr(qrcode);
        dismissDialog(enterServerDialog);
        dismissDialog(enterDeviceIdDialog);
        binding.deviceId.setText(settingsHelper.getDeviceId());
    }

    public void saveServerUrl(View view ) {
        if (saveServerUrlBase()) {
            ServerServiceKeeper.resetServices();
            String pushOptions = null;
            if (settingsHelper != null && settingsHelper.getConfig() != null) {
                pushOptions = settingsHelper.getConfig().getPushOptions();
            }
            if (BuildConfig.ENABLE_PUSH && pushOptions != null && (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM))) {
                PushNotificationMqttWrapper.getInstance().disconnect(this);
            }
            updateConfig(view);
        }
    }

    public void saveDeviceId(View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString();
        if ( "".equals( deviceId ) ) {
            return;
        } else {
            settingsHelper.setDeviceId( deviceId );
            enterDeviceIdDialogBinding.setError( false );

            dismissDialog(enterDeviceIdDialog);

            Log.i(Const.LOG_TAG, "saveDeviceId(): calling updateConfig()");
            updateConfig(view);
        }
    }

    public void updateConfig( View view ) {
        LocalBroadcastManager.getInstance( this ).
                sendBroadcast( new Intent( Const.ACTION_UPDATE_CONFIGURATION ) );
        finish();
    }

    public void resetPermissions(View view) {
        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        SharedPreferences preferences = getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE );
        SharedPreferences.Editor editor = preferences.edit();
        editor.remove(Const.PREFERENCES_UNKNOWN_SOURCES);
        editor.remove(Const.PREFERENCES_ADMINISTRATOR);
        editor.remove(Const.PREFERENCES_ACCESSIBILITY_SERVICE);
        editor.remove(Const.PREFERENCES_OVERLAY);
        editor.remove(Const.PREFERENCES_USAGE_STATISTICS);
        editor.remove(Const.PREFERENCES_DEVICE_OWNER);
        editor.remove(Const.PREFERENCES_MIUI_PERMISSIONS);
        editor.remove(Const.PREFERENCES_MIUI_OPTIMIZATION);
        editor.remove(Const.PREFERENCES_DEVICE_OWNER);
        editor.commit();
        RemoteLogger.log(this, Const.LOG_INFO, "Reset saved permissions state, will be refreshed at next start");
        Toast.makeText(this, R.string.permissions_reset_hint, Toast.LENGTH_LONG).show();
    }


    public void resetNetworkPolicy(View view) {
        ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            config.setWifi(null);
            config.setMobileData(null);
            settingsHelper.updateConfig(config);
        }
        RemoteLogger.log(this, Const.LOG_INFO, "Network policies are cleared");
        Toast.makeText(this, R.string.admin_reset_network_hint, Toast.LENGTH_LONG).show();
    }

    public void reboot(View view) {
        if ( Build.VERSION.SDK_INT > Build.VERSION_CODES.M ) {
            ComponentName deviceAdmin = LegacyUtils.getAdminComponentName(this);
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
            try {
                devicePolicyManager.reboot(deviceAdmin);
            } catch (Exception e) {
                Toast.makeText(this, R.string.reboot_failed, Toast.LENGTH_LONG).show();
            }
        }
    }
}
</file>

<file path="app/src/main/java/org/eclipse/paho/android/service/MqttService.java">
/*******************************************************************************
 * Copyright (c) 1999, 2016 IBM Corp.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Eclipse Distribution License v1.0 which accompany this distribution.
 *
 * The Eclipse Public License is available at
 *    http://www.eclipse.org/legal/epl-v10.html
 * and the Eclipse Distribution License is available at
 *   http://www.eclipse.org/org/documents/edl-v10.php.
 *
 * Contributors:
 *   James Sutton - isOnline Null Pointer (bug 473775)
 */
package org.eclipse.paho.android.service;

import android.annotation.SuppressLint;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.Build;
import android.os.Bundle;
import android.os.IBinder;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;

import androidx.core.app.NotificationCompat;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.Utils;

import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.MqttClientPersistence;
import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.eclipse.paho.client.mqttv3.MqttPersistenceException;
import org.eclipse.paho.client.mqttv3.MqttSecurityException;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * <p>
 * The android service which interfaces with an MQTT client implementation
 * </p>
 * <p>
 * The main API of MqttService is intended to pretty much mirror the
 * IMqttAsyncClient with appropriate adjustments for the Android environment.<br>
 * These adjustments usually consist of adding two parameters to each method :-
 * </p>
 * <ul>
 * <li>invocationContext - a string passed from the application to identify the
 * context of the operation (mainly included for support of the javascript API
 * implementation)</li>
 * <li>activityToken - a string passed from the Activity to relate back to a
 * callback method or other context-specific data</li>
 * </ul>
 * <p>
 * To support multiple client connections, the bulk of the MQTT work is
 * delegated to MqttConnection objects. These are identified by "client
 * handle" strings, which is how the Activity, and the higher-level APIs refer
 * to them.
 * </p>
 * <p>
 * Activities using this service are expected to start it and bind to it using
 * the BIND_AUTO_CREATE flag. The life cycle of this service is based on this
 * approach.
 * </p>
 * <p>
 * Operations are highly asynchronous - in most cases results are returned to
 * the Activity by broadcasting one (or occasionally more) appropriate Intents,
 * which the Activity is expected to register a listener for.<br>
 * The Intents have an Action of
 * {@link MqttServiceConstants#CALLBACK_TO_ACTIVITY
 * MqttServiceConstants.CALLBACK_TO_ACTIVITY} which allows the Activity to
 * register a listener with an appropriate IntentFilter.<br>
 * Further data is provided by "Extra Data" in the Intent, as follows :-
 * </p>
 * <table border="1" summary="">
 * <tr>
 * <th align="left">Name</th>
 * <th align="left">Data Type</th>
 * <th align="left">Value</th>
 * <th align="left">Operations used for</th>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_CLIENT_HANDLE
 * MqttServiceConstants.CALLBACK_CLIENT_HANDLE}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The clientHandle identifying the client which
 * initiated this operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">{@link MqttServiceConstants#CALLBACK_STATUS
 * MqttServiceConstants.CALLBACK_STATUS}</td>
 * <td align="left" valign="top">Serializable</td>
 * <td align="left" valign="top">An {@link Status} value indicating success or
 * otherwise of the operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ACTIVITY_TOKEN
 * MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">the activityToken passed into the operation</td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_INVOCATION_CONTEXT
 * MqttServiceConstants.CALLBACK_INVOCATION_CONTEXT}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">the invocationContext passed into the operation
 * </td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">{@link MqttServiceConstants#CALLBACK_ACTION
 * MqttServiceConstants.CALLBACK_ACTION}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">one of
 * <table summary="">
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#SEND_ACTION
 * MqttServiceConstants.SEND_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#UNSUBSCRIBE_ACTION
 * MqttServiceConstants.UNSUBSCRIBE_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#SUBSCRIBE_ACTION
 * MqttServiceConstants.SUBSCRIBE_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#DISCONNECT_ACTION
 * MqttServiceConstants.DISCONNECT_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top"> {@link MqttServiceConstants#CONNECT_ACTION
 * MqttServiceConstants.CONNECT_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#MESSAGE_ARRIVED_ACTION
 * MqttServiceConstants.MESSAGE_ARRIVED_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#MESSAGE_DELIVERED_ACTION
 * MqttServiceConstants.MESSAGE_DELIVERED_ACTION}</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#ON_CONNECTION_LOST_ACTION
 * MqttServiceConstants.ON_CONNECTION_LOST_ACTION}</td>
 * </tr>
 * </table>
 * </td>
 * <td align="left" valign="top">All operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ERROR_MESSAGE
 * MqttServiceConstants.CALLBACK_ERROR_MESSAGE}
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">A suitable error message (taken from the
 * relevant exception where possible)</td>
 * <td align="left" valign="top">All failing operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_ERROR_NUMBER
 * MqttServiceConstants.CALLBACK_ERROR_NUMBER}
 * <td align="left" valign="top">int</td>
 * <td align="left" valign="top">A suitable error code (taken from the relevant
 * exception where possible)</td>
 * <td align="left" valign="top">All failing operations</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_EXCEPTION_STACK
 * MqttServiceConstants.CALLBACK_EXCEPTION_STACK}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The stacktrace of the failing call</td>
 * <td align="left" valign="top">The Connection Lost event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_MESSAGE_ID
 * MqttServiceConstants.CALLBACK_MESSAGE_ID}</td>
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The identifier for the message in the message
 * store, used by the Activity to acknowledge the arrival of the message, so
 * that the service may remove it from the store</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_DESTINATION_NAME
 * MqttServiceConstants.CALLBACK_DESTINATION_NAME}
 * <td align="left" valign="top">String</td>
 * <td align="left" valign="top">The topic on which the message was received</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * <tr>
 * <td align="left" valign="top">
 * {@link MqttServiceConstants#CALLBACK_MESSAGE_PARCEL
 * MqttServiceConstants.CALLBACK_MESSAGE_PARCEL}</td>
 * <td align="left" valign="top">Parcelable</td>
 * <td align="left" valign="top">The new message encapsulated in Android
 * Parcelable format as a {@link ParcelableMqttMessage}</td>
 * <td align="left" valign="top">The Message Arrived event</td>
 * </tr>
 * </table>
 */
@SuppressLint("Registered")
public class MqttService extends Service implements MqttTraceHandler {

	// Identifier for Intents, log messages, etc..
	static final String TAG = "MqttService";

	// callback id for making trace callbacks to the Activity
	// needs to be set by the activity as appropriate
	private String traceCallbackId;
	// state of tracing
	private boolean traceEnabled = false;

	// somewhere to persist received messages until we're sure
	// that they've reached the application
	MessageStore messageStore;

	// An intent receiver to deal with changes in network connectivity
	private NetworkConnectionIntentReceiver networkConnectionMonitor;

	// A flag preventing multiple notifications for the foreground service
    boolean started = false;

    // Notification ID for the foreground service
    private static final int NOTIFICATION_ID = 113;

    // Channel ID for the foreground service
    public static String CHANNEL_ID = MqttService.class.getName();

    //a receiver to recognise when the user changes the "background data" preference
  // and a flag to track that preference
  // Only really relevant below android version ICE_CREAM_SANDWICH - see
  // android docs
  private BackgroundDataPreferenceReceiver backgroundDataPreferenceMonitor;
  private volatile boolean backgroundDataEnabled = true;

  // a way to pass ourself back to the activity
  private MqttServiceBinder mqttServiceBinder;

	// mapping from client handle strings to actual client connections.
	private Map<String/* clientHandle */, MqttConnection/* client */> connections = new ConcurrentHashMap<>();

  public MqttService() {
    super();
  }

  /**
   * pass data back to the Activity, by building a suitable Intent object and
   * broadcasting it
   *
   * @param clientHandle
   *            source of the data
   * @param status
   *            OK or Error
   * @param dataBundle
   *            the data to be passed
   */
  void callbackToActivity(String clientHandle, Status status,
      Bundle dataBundle) {
    // Don't call traceDebug, as it will try to callbackToActivity leading
    // to recursion.
    Intent callbackIntent = new Intent(
        MqttServiceConstants.CALLBACK_TO_ACTIVITY);
    if (clientHandle != null) {
      callbackIntent.putExtra(
          MqttServiceConstants.CALLBACK_CLIENT_HANDLE, clientHandle);
    }
    callbackIntent.putExtra(MqttServiceConstants.CALLBACK_STATUS, status);
    if (dataBundle != null) {
      callbackIntent.putExtras(dataBundle);
    }
    LocalBroadcastManager.getInstance(this).sendBroadcast(callbackIntent);
  }

  // The major API implementation follows :-

  /**
   * Get an MqttConnection object to represent a connection to a server
   *
   * @param serverURI specifies the protocol, host name and port to be used to connect to an MQTT server
   * @param clientId specifies the name by which this connection should be identified to the server
   * @param contextId specifies the app conext info to make a difference between apps
   * @param persistence specifies the persistence layer to be used with this client
   * @param defaultMessageListener speficies the default message listener called if messages arrived before subscription
   * @return a string to be used by the Activity as a "handle" for this
   *         MqttConnection
   */
  public String getClient(String serverURI, String clientId, String contextId, MqttClientPersistence persistence,
                          IMqttMessageListener defaultMessageListener) {
    String clientHandle = serverURI + ":" + clientId+":"+contextId;
    if (!connections.containsKey(clientHandle)) {
      MqttConnection client = new MqttConnection(this, serverURI,
          clientId, persistence, clientHandle, defaultMessageListener);
      connections.put(clientHandle, client);
    }
    return clientHandle;
  }

  /**
   * Connect to the MQTT server specified by a particular client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param connectOptions
   *            the MQTT connection options to be used
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttSecurityException thrown if there is a security exception
   * @throws MqttException thrown for all other MqttExceptions
   */
  public void connect(String clientHandle, MqttConnectOptions connectOptions,
      String invocationContext, String activityToken)
      throws MqttSecurityException, MqttException {
	  	MqttConnection client = getConnection(clientHandle);
	  	client.connect(connectOptions, null, activityToken);

  }

  /**
   * Request all clients to reconnect if appropriate
   */
  void reconnect() {
	traceDebug(TAG, "Reconnect to server, client size=" + connections.size());
	for (MqttConnection client : connections.values()) {
			traceDebug("Reconnect Client:",
					client.getClientId() + '/' + client.getServerURI());
		if(this.isOnline() && !client.isConnected()){
			client.reconnect();
		}
	}
  }

  /**
   * Close connection from a particular client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   */
  public void close(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    client.close();
  }

  /**
   * Disconnect from the server
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void disconnect(String clientHandle, String invocationContext,
      String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.disconnect(invocationContext, activityToken);
    connections.remove(clientHandle);


    // the activity has finished using us, so we can stop the service
    // the activities are bound with BIND_AUTO_CREATE, so the service will
    // remain around until the last activity disconnects
    stopSelf();
  }

  /**
   * Disconnect from the server
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param quiesceTimeout
   *            in milliseconds
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void disconnect(String clientHandle, long quiesceTimeout,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.disconnect(quiesceTimeout, invocationContext, activityToken);
    connections.remove(clientHandle);

    // the activity has finished using us, so we can stop the service
    // the activities are bound with BIND_AUTO_CREATE, so the service will
    // remain around until the last activity disconnects
    stopSelf();
  }

  /**
   * Get the status of a specific client
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @return true if the specified client is connected to an MQTT server
   */
  public boolean isConnected(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    return client.isConnected();
  }

  /**
   * Publish a message to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            the topic to which to publish
   * @param payload
   *            the content of the message to publish
   * @param qos
   *            the quality of service requested
   * @param retained
   *            whether the MQTT server should retain this message
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttPersistenceException when a problem occurs storing the message
   * @throws MqttException if there was an error publishing the message
   * @return token for tracking the operation
   */
  public IMqttDeliveryToken publish(String clientHandle, String topic,
      byte[] payload, int qos, boolean retained,
      String invocationContext, String activityToken)
      throws MqttPersistenceException, MqttException {
    MqttConnection client = getConnection(clientHandle);
    return client.publish(topic, payload, qos, retained, invocationContext,
        activityToken);
  }

  /**
   * Publish a message to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            the topic to which to publish
   * @param message
   *            the message to publish
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @throws MqttPersistenceException when a problem occurs storing the message
   * @throws MqttException if there was an error publishing the message
   * @return token for tracking the operation
   */
  public IMqttDeliveryToken publish(String clientHandle, String topic,
      MqttMessage message, String invocationContext, String activityToken)
      throws MqttPersistenceException, MqttException {
    MqttConnection client = getConnection(clientHandle);
    return client.publish(topic, message, invocationContext, activityToken);
  }

  /**
   * Subscribe to a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            a possibly wildcarded topic name
   * @param qos
   *            requested quality of service for the topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void subscribe(String clientHandle, String topic, int qos,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topic, qos, invocationContext, activityToken);
  }

  /**
   * Subscribe to one or more topics
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topic
   *            a list of possibly wildcarded topic names
   * @param qos
   *            requested quality of service for each topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void subscribe(String clientHandle, String[] topic, int[] qos,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topic, qos, invocationContext, activityToken);
  }

  /**
   * Subscribe using topic filters
   *
   * @param clientHandle
   *            identifies the MqttConnection to use
   * @param topicFilters
   *            a list of possibly wildcarded topicfilters
   * @param qos
   *            requested quality of service for each topic
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   * @param messageListeners a callback to handle incoming messages
   */
  public void subscribe(String clientHandle, String[] topicFilters, int[] qos, String invocationContext, String activityToken, IMqttMessageListener[] messageListeners){
    MqttConnection client = getConnection(clientHandle);
    client.subscribe(topicFilters, qos, invocationContext, activityToken, messageListeners);
  }

  /**
   * Unsubscribe from a topic
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @param topic
   *            a possibly wildcarded topic name
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void unsubscribe(String clientHandle, final String topic,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.unsubscribe(topic, invocationContext, activityToken);
  }

  /**
   * Unsubscribe from one or more topics
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @param topic
   *            a list of possibly wildcarded topic names
   * @param invocationContext
   *            arbitrary data to be passed back to the application
   * @param activityToken
   *            arbitrary identifier to be passed back to the Activity
   */
  public void unsubscribe(String clientHandle, final String[] topic,
      String invocationContext, String activityToken) {
    MqttConnection client = getConnection(clientHandle);
    client.unsubscribe(topic, invocationContext, activityToken);
  }

  /**
   * Get tokens for all outstanding deliveries for a client
   *
   * @param clientHandle
   *            identifies the MqttConnection
   * @return an array (possibly empty) of tokens
   */
  public IMqttDeliveryToken[] getPendingDeliveryTokens(String clientHandle) {
    MqttConnection client = getConnection(clientHandle);
    return client.getPendingDeliveryTokens();
  }

  /**
   * Get the MqttConnection identified by this client handle
   *
   * @param clientHandle identifies the MqttConnection
   * @return the MqttConnection identified by this handle
   */
  private MqttConnection getConnection(String clientHandle) {
    MqttConnection client = connections.get(clientHandle);
    if (client == null) {
      throw new IllegalArgumentException("Invalid ClientHandle");
    }
    return client;
  }

  /**
   * Called by the Activity when a message has been passed back to the
   * application
   *
   * @param clientHandle identifier for the client which received the message
   * @param id identifier for the MQTT message
   * @return {@link Status}
   */
  public Status acknowledgeMessageArrival(String clientHandle, String id) {
    if (messageStore.discardArrived(clientHandle, id)) {
      return Status.OK;
    }
    else {
      return Status.ERROR;
    }
  }

  // Extend Service

  /**
   * @see android.app.Service#onCreate()
   */
  @Override
  public void onCreate() {
    super.onCreate();

    // create a binder that will let the Activity UI send
    // commands to the Service
    mqttServiceBinder = new MqttServiceBinder(this);

    // create somewhere to buffer received messages until
    // we know that they have been passed to the application
    messageStore = new DatabaseMessageStore(this, this);
	}



	/**
	 * @see android.app.Service#onDestroy()
	 */
	@Override
	public void onDestroy() {
		// disconnect immediately
		for (MqttConnection client : connections.values()) {
			client.disconnect(null, null);
		}

    // clear down
    if (mqttServiceBinder != null) {
      mqttServiceBinder = null;
    }

		unregisterBroadcastReceivers();

		if (this.messageStore !=null )
			this.messageStore.close();

		super.onDestroy();
	}

  /**
   * @see android.app.Service#onBind(Intent)
   */
  @Override
  public IBinder onBind(Intent intent) {
    // What we pass back to the Activity on binding -
    // a reference to ourself, and the activityToken
    // we were given when started
    String activityToken = intent
        .getStringExtra(MqttServiceConstants.CALLBACK_ACTIVITY_TOKEN);
    mqttServiceBinder.setActivityToken(activityToken);
    return mqttServiceBinder;
  }

  /**
   * @see android.app.Service#onStartCommand(Intent,int,int)
   */
  @Override
  public int onStartCommand(final Intent intent, int flags, final int startId) {
    // run till explicitly stopped, restart when
    // process restarted
	registerBroadcastReceivers();

	if (BuildConfig.MQTT_SERVICE_FOREGROUND && !started) {
        startAsForeground();
        started = true;
    }

      SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
      if (intent != null && intent.getBooleanExtra(MqttAndroidClient.EXTRA_START_AT_BOOT, false)) {
          try {
              String domain = intent.getStringExtra(MqttAndroidClient.EXTRA_DOMAIN);
              String pushType = intent.getStringExtra(MqttAndroidClient.EXTRA_PUSH_OPTIONS);
              int keepaliveTime = intent.getIntExtra(MqttAndroidClient.EXTRA_KEEPALIVE_TIME, Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC);
              String deviceId = intent.getStringExtra(MqttAndroidClient.EXTRA_DEVICE_ID);

              PushNotificationMqttWrapper.getInstance().connect(this,
                      domain, BuildConfig.MQTT_PORT, pushType, keepaliveTime, deviceId,
                      null,null);
          } catch (Exception e) {
              e.printStackTrace();
          }
      }

    return START_STICKY;
  }

    @SuppressLint("WrongConstant")
    private void startAsForeground() {
        NotificationCompat.Builder builder;

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, "Notification Channel", NotificationManager.IMPORTANCE_DEFAULT);
            NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            notificationManager.createNotificationChannel(channel);
            builder = new NotificationCompat.Builder(this, CHANNEL_ID);
        } else {
            builder = new NotificationCompat.Builder( this );
        }
        Notification notification = builder
                .setContentTitle(ProUtils.getAppName(this))
                .setTicker(ProUtils.getAppName(this))
                .setContentText(getString(R.string.mqtt_service_text))
                .setSmallIcon(R.drawable.ic_mqtt_service).build();

        Utils.startStableForegroundService(this, NOTIFICATION_ID, notification);
    }


    /**
   * Identify the callbackId to be passed when making tracing calls back into
   * the Activity
   *
   * @param traceCallbackId identifier to the callback into the Activity
   */
  public void setTraceCallbackId(String traceCallbackId) {
    this.traceCallbackId = traceCallbackId;
  }

  /**
   * Turn tracing on and off
   *
   * @param traceEnabled set <code>true</code> to turn on tracing, <code>false</code> to turn off tracing
   */
  public void setTraceEnabled(boolean traceEnabled) {
    this.traceEnabled = traceEnabled;
  }

  /**
   * Check whether trace is on or off.
   *
   * @return the state of trace
   */
  public boolean isTraceEnabled(){
	  return this.traceEnabled;
  }

  /**
   * Trace debugging information
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   */
  @Override
  public void traceDebug(String tag, String message) {
    traceCallback(MqttServiceConstants.TRACE_DEBUG, tag, message);
  }

  /**
   * Trace error information
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   */
  @Override
  public void traceError(String tag, String message) {
    traceCallback(MqttServiceConstants.TRACE_ERROR, tag, message);
  }

  private void traceCallback(String severity, String tag, String message) {
    if ((traceCallbackId != null) && (traceEnabled)) {
      Bundle dataBundle = new Bundle();
      dataBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.TRACE_ACTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY, severity);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_TAG, tag);
      //dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_ID, traceCallbackId);
      dataBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE, message);
      callbackToActivity(traceCallbackId, Status.ERROR, dataBundle);
    }
  }

  /**
   * trace exceptions
   *
   * @param tag
   *            identifier for the source of the trace
   * @param message
   *            the text to be traced
   * @param e
   *            the exception
   */
  @Override
  public void traceException(String tag, String message, Exception e) {
    if (traceCallbackId != null) {
      Bundle dataBundle = new Bundle();
      dataBundle.putString(MqttServiceConstants.CALLBACK_ACTION, MqttServiceConstants.TRACE_ACTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_SEVERITY, MqttServiceConstants.TRACE_EXCEPTION);
      dataBundle.putString(MqttServiceConstants.CALLBACK_ERROR_MESSAGE,  message);
      dataBundle.putSerializable(MqttServiceConstants.CALLBACK_EXCEPTION, e); //TODO: Check
      dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_TAG, tag);
      //dataBundle.putString(MqttServiceConstants.CALLBACK_TRACE_ID, traceCallbackId);
      callbackToActivity(traceCallbackId, Status.ERROR, dataBundle);
    }
  }

  @SuppressWarnings("deprecation")
  private void registerBroadcastReceivers() {
		if (networkConnectionMonitor == null) {
			networkConnectionMonitor = new NetworkConnectionIntentReceiver();
			registerReceiver(networkConnectionMonitor, new IntentFilter(
					ConnectivityManager.CONNECTIVITY_ACTION));
		}

		if (Build.VERSION.SDK_INT < 14 /**Build.VERSION_CODES.ICE_CREAM_SANDWICH**/) {
			// Support the old system for background data preferences
			ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
			backgroundDataEnabled = cm.getBackgroundDataSetting();
			if (backgroundDataPreferenceMonitor == null) {
				backgroundDataPreferenceMonitor = new BackgroundDataPreferenceReceiver();
				registerReceiver(
						backgroundDataPreferenceMonitor,
						new IntentFilter(
								ConnectivityManager.ACTION_BACKGROUND_DATA_SETTING_CHANGED));
			}
		}
  }

  private void unregisterBroadcastReceivers(){
  	if(networkConnectionMonitor != null){
  		unregisterReceiver(networkConnectionMonitor);
  		networkConnectionMonitor = null;
  	}

  	if (Build.VERSION.SDK_INT < 14 /**Build.VERSION_CODES.ICE_CREAM_SANDWICH**/) {
  		if(backgroundDataPreferenceMonitor != null){
  			unregisterReceiver(backgroundDataPreferenceMonitor);
  		}
		}
  }

  /*
   * Called in response to a change in network connection - after losing a
   * connection to the server, this allows us to wait until we have a usable
   * data connection again
   */
  private class NetworkConnectionIntentReceiver extends BroadcastReceiver {

		@Override
        @SuppressLint("Wakelock")
		public void onReceive(Context context, Intent intent) {
			traceDebug(TAG, "Internal network status receive.");
			// we protect against the phone switching off
			// by requesting a wake lock - we request the minimum possible wake
			// lock - just enough to keep the CPU running until we've finished
			PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);
			WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "org.eclipse.paho:mqtt");
			wl.acquire();
			traceDebug(TAG,"Reconnect for Network recovery.");
			if (isOnline()) {
				traceDebug(TAG,"Online,reconnect.");
				// we have an internet connection - have another try at
				// connecting
				reconnect();
			} else {
				notifyClientsOffline();
			}

			wl.release();
		}
  }

	/**
	 * @return whether the android service can be regarded as online
	 */
	public boolean isOnline() {
		ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
		NetworkInfo networkInfo = cm.getActiveNetworkInfo();
      //noinspection RedundantIfStatement
      if (networkInfo != null
              && networkInfo.isAvailable()
              && networkInfo.isConnected()
              && backgroundDataEnabled) {
			return true;
		}

		return false;
	}

	/**
	 * Notify clients we're offline
	 */
    private void notifyClientsOffline() {
		for (MqttConnection connection : connections.values()) {
			connection.offline();
		}
	}

	/**
	 * Detect changes of the Allow Background Data setting - only used below
	 * ICE_CREAM_SANDWICH
	 */
	private class BackgroundDataPreferenceReceiver extends BroadcastReceiver {

		@SuppressWarnings("deprecation")
		@Override
		public void onReceive(Context context, Intent intent) {
			ConnectivityManager cm = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE);
			traceDebug(TAG,"Reconnect since BroadcastReceiver.");
			if (cm.getBackgroundDataSetting()) {
				if (!backgroundDataEnabled) {
					backgroundDataEnabled = true;
					// we have the Internet connection - have another try at
					// connecting
					reconnect();
				}
			} else {
				backgroundDataEnabled = false;
				notifyClientsOffline();
			}
		}
	}

  /**
   * Sets the DisconnectedBufferOptions for this client
   * @param clientHandle identifier for the client
   * @param bufferOpts the DisconnectedBufferOptions for this client
   */
  public void setBufferOpts(String clientHandle, DisconnectedBufferOptions bufferOpts) {
    MqttConnection client = getConnection(clientHandle);
    client.setBufferOpts(bufferOpts);
  }

  public int getBufferedMessageCount(String clientHandle){
    MqttConnection client = getConnection(clientHandle);
    return client.getBufferedMessageCount();
  }

  public MqttMessage getBufferedMessage(String clientHandle, int bufferIndex){
    MqttConnection client = getConnection(clientHandle);
    return client.getBufferedMessage(bufferIndex);
  }

  public void deleteBufferedMessage(String clientHandle, int bufferIndex){
    MqttConnection client = getConnection(clientHandle);
    client.deleteBufferedMessage(bufferIndex);
  }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/server/ServerService.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.server;


import com.hmdm.launcher.db.LocationTable;
import com.hmdm.launcher.json.DetailedInfo;
import com.hmdm.launcher.json.DetailedInfoConfigResponse;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.PushResponse;
import com.hmdm.launcher.json.RemoteLogConfigResponse;
import com.hmdm.launcher.json.RemoteLogItem;
import com.hmdm.launcher.json.ServerConfigResponse;

import java.util.List;

import okhttp3.ResponseBody;
import retrofit2.Call;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.POST;
import retrofit2.http.PUT;
import retrofit2.http.Path;

public interface ServerService {

    static final String REQUEST_SIGNATURE_HEADER = "X-Request-Signature";
    static final String CPU_ARCH_HEADER = "X-CPU-Arch";

    @POST("{project}/rest/public/sync/configuration/{number}")
    Call<ResponseBody> enrollAndGetServerConfigRaw(@Path("project") String project,
                                                   @Path("number") String number,
                                                   @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                                   @Header(CPU_ARCH_HEADER) String cpuArch,
                                                   @Body DeviceEnrollOptions createOptions);

    @GET("{project}/rest/public/sync/configuration/{number}")
    Call<ResponseBody> getServerConfigRaw(@Path("project") String project,
                                          @Path("number") String number,
                                          @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                          @Header(CPU_ARCH_HEADER) String cpuArch);

    @POST("{project}/rest/public/sync/configuration/{number}")
    Call<ServerConfigResponse> enrollAndGetServerConfig(@Path("project") String project,
                                                        @Path("number") String number,
                                                        @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                                        @Header(CPU_ARCH_HEADER) String cpuArch,
                                                        @Body DeviceEnrollOptions createOptions);

    @GET("{project}/rest/public/sync/configuration/{number}")
    Call<ServerConfigResponse> getServerConfig(@Path("project") String project,
                                               @Path("number") String number,
                                               @Header(REQUEST_SIGNATURE_HEADER) String signature,
                                               @Header(CPU_ARCH_HEADER) String cpuArch);

    @POST("{project}/rest/public/sync/info")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendDevice(@Path("project") String project, @Body DeviceInfo deviceInfo);

    @GET("{project}/rest/notifications/device/{number}")
    Call<PushResponse> queryPushNotifications(@Path("project") String project,
                                              @Path("number") String number,
                                              @Header(REQUEST_SIGNATURE_HEADER) String signature);

    @GET("{project}/rest/notification/polling/{number}")
    Call<PushResponse> queryPushLongPolling(@Path("project") String project,
                                            @Path("number") String number,
                                            @Header(REQUEST_SIGNATURE_HEADER) String signature);

    @GET( "{project}/rest/plugins/devicelog/log/rules/{number}" )
    Call<RemoteLogConfigResponse> getRemoteLogConfig(@Path("project") String project, @Path("number") String number);

    @POST("{project}/rest/plugins/devicelog/log/list/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendLogs(@Path("project") String project, @Path("number") String number, @Body List<RemoteLogItem> logItems);

    @PUT("{project}/rest/plugins/deviceinfo/deviceinfo/public/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendDetailedInfo(@Path("project") String project, @Path("number") String number, @Body List<DetailedInfo> infoItems);

    @PUT("{project}/rest/plugins/devicelocations/public/update/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> sendLocations(@Path("project") String project, @Path("number") String number, @Body List<LocationTable.Location> locationItems);

    @GET( "{project}/rest/plugins/deviceinfo/deviceinfo-plugin-settings/device/{number}" )
    Call<DetailedInfoConfigResponse> getDetailedInfoConfig(@Path("project") String project, @Path("number") String number);

    @POST("{project}/rest/plugins/devicereset/public/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmDeviceReset(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

    @POST("{project}/rest/plugins/devicereset/public/reboot/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmReboot(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

    @POST("{project}/rest/plugins/devicereset/public/password/{number}")
    @Headers("Content-Type: application/json")
    Call<ResponseBody> confirmPasswordReset(@Path("project") String project, @Path("number") String number, @Body DeviceInfo deviceInfo);

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/PushNotificationMqttWrapper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.work.Data;
import androidx.work.ExistingWorkPolicy;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkManager;
import androidx.work.Worker;
import androidx.work.WorkerParameters;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.json.PushMessageJson;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.worker.PushNotificationProcessor;

import org.eclipse.paho.android.service.MqttAndroidClient;
import org.eclipse.paho.android.service.MqttAndroidConnectOptions;
import org.eclipse.paho.android.service.PingDeathDetector;
import org.eclipse.paho.client.mqttv3.IMqttActionListener;
import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
import org.eclipse.paho.client.mqttv3.IMqttMessageListener;
import org.eclipse.paho.client.mqttv3.IMqttToken;
import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
import org.eclipse.paho.client.mqttv3.MqttException;
import org.eclipse.paho.client.mqttv3.MqttMessage;
import org.json.JSONObject;

import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class PushNotificationMqttWrapper {
    private static PushNotificationMqttWrapper instance;

    private MqttAndroidClient client;
    private Handler handler = new Handler(Looper.getMainLooper());
    private Handler connectHangupMonitorHandler = new Handler(Looper.getMainLooper());
    private BroadcastReceiver debugReceiver;
    private Context context;
    private boolean needProcessConnectExtended;

    private static final String WORKER_TAG_MQTT_RECONNECT = "com.hmdm.launcher.WORK_TAG_MQTT_RECONNECT";
    private static final int MQTT_RECONNECT_INTERVAL_SEC = 900;

    // If more than 20 connections per minute, we are stopping:
    // this is a sign that two devices with the same ID are registered
    private List<Long> connectionLoopProtectionArray = new LinkedList<>();
    private static final int CONNECTION_LOOP_PROTECTION_TIME_MS = 60000;
    private static final int CONNECTION_LOOP_CRITICAL_COUNT = 15;

    private PushNotificationMqttWrapper() {
    }

    public static PushNotificationMqttWrapper getInstance() {
        if (instance == null) {
            instance = new PushNotificationMqttWrapper();
        }
        return instance;
    }

    public void connect(final Context context, String host, int port, String pushType, int keepaliveTime,
                        final String deviceId, final Runnable onSuccess, final Runnable onFailure) {
        this.context = context;
        cancelReconnectionAfterFailure(context);
        if (client != null && client.isConnected()) {
            if (onSuccess != null) {
                handler.post(onSuccess);
            }
            return;
        }
        MqttAndroidConnectOptions connectOptions = new MqttAndroidConnectOptions();
        connectOptions.setAutomaticReconnect(true);
        connectOptions.setKeepAliveInterval(keepaliveTime);
        connectOptions.setCleanSession(false);
        if (pushType.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)) {
            connectOptions.setPingType(MqttAndroidConnectOptions.PING_WORKER);
            // For worker, keepalive time cannot be less than 15 minutes
            connectOptions.setKeepAliveInterval(Const.DEFAULT_PUSH_WORKER_KEEPALIVE_TIME_SEC);
        } else {
            connectOptions.setPingType(MqttAndroidConnectOptions.PING_ALARM);
            connectOptions.setKeepAliveInterval(keepaliveTime);
        }
        connectOptions.setUserName("hmdm");
        connectOptions.setPassword(CryptoHelper.getSHA1String("hmdm" + BuildConfig.REQUEST_SIGNATURE).toCharArray());
        String serverUri = "tcp://" + host + ":" + port;

        if (client != null) {
            // Here we go after reconnection.
            // Previous client is disconnected and in "Failure" state, but it listens for broadcasts
            // We need to clean it up before registering a new client
            client.unregisterResources();
        }

        client = new MqttAndroidClient(context, serverUri, deviceId);
        client.setTraceEnabled(true);
        client.setDefaultMessageListener(mqttMessageListener);
        setupDebugging(context);

        // We need to re-subscribe after reconnection. This is required because server may be not persistent
        // so after the server restart all subscription info is lost
        client.setCallback(new MqttCallbackExtended() {

            @Override
            public void connectionLost(Throwable cause) {
            }

            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
            }

            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
            }

            @Override
            public void connectComplete(boolean reconnect, String serverURI) {
                if (reconnect || needProcessConnectExtended) {
                    RemoteLogger.log(context, Const.LOG_VERBOSE, "Reconnect complete");
                    if (checkConnectionLoop()) {
                        subscribe(context, deviceId, null, null);
                    } else {
                        RemoteLogger.log(context, Const.LOG_ERROR, "Reconnection loop detected! You have multiple devices with ID=" + deviceId + "! MQTT service stopped.");
                        disconnect(context);
                    }
                }
            }
        });

        try {
            needProcessConnectExtended = false;

            // If connection hangs up, consider it as failure and continue the flow
            connectHangupMonitorHandler.postDelayed(() -> {
                RemoteLogger.log(context, Const.LOG_WARN, "MQTT connection timeout, disconnecting");
                try {
                    client.disconnect();
                } catch (Exception e) {
                    e.printStackTrace();
                }
                scheduleReconnectionAfterFailure(context, host, port, pushType, keepaliveTime, deviceId);
                if (onFailure != null) {
                    handler.post(onFailure);
                }
            }, 30000);

            client.connect(connectOptions, null, new IMqttActionListener() {
                @Override
                public void onSuccess(IMqttToken asyncActionToken) {
                    // We believe that if connect is successful, subscribe() won't hang up
                    connectHangupMonitorHandler.removeCallbacksAndMessages(null);
                    subscribe(context, deviceId, onSuccess, onFailure);
                }

                @Override
                public void onFailure(IMqttToken asyncActionToken, Throwable e) {
                    e.printStackTrace();
                    connectHangupMonitorHandler.removeCallbacksAndMessages(null);
                    RemoteLogger.log(context, Const.LOG_WARN, "MQTT connection failure");
                    scheduleReconnectionAfterFailure(context, host, port, pushType, keepaliveTime, deviceId);
                    // We fail here but Mqtt client tries to reconnect and we need to subscribe
                    // after connection succeeds. This is done in the extended callback client.
                    // The flag needProcessConnectExtended prevents duplicate subscribe after
                    // successful connection
                    needProcessConnectExtended = true;
                    if (onFailure != null) {
                        handler.post(onFailure);
                    }
                }
            });


        } catch (MqttException e) {
            e.printStackTrace();
            if (onFailure != null) {
                handler.post(onFailure);
            }
        }
    }

    private boolean checkConnectionLoop() {
        Long now = System.currentTimeMillis();
        // Remove old items
        for (int n = 0; n < connectionLoopProtectionArray.size(); n++) {
            if (connectionLoopProtectionArray.get(n) < now - CONNECTION_LOOP_PROTECTION_TIME_MS) {
                connectionLoopProtectionArray.remove(n);
                n--;
            }
        }
        connectionLoopProtectionArray.add(now);
        return connectionLoopProtectionArray.size() <= CONNECTION_LOOP_CRITICAL_COUNT;
    }

    private IMqttMessageListener mqttMessageListener = new IMqttMessageListener() {
        @Override
        public void messageArrived(String topic, final MqttMessage message) throws Exception {
            handler.post(new Runnable() {
                @Override
                public void run() {
                    try {
                        JSONObject obj = new JSONObject(new String(message.getPayload()));
                        String messageType = obj.getString("messageType");
                        PushMessageJson msg = new PushMessageJson(messageType, obj.optJSONObject("payload"));
                        PushNotificationProcessor.process(msg, context);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            });

        }
    };

    private void subscribe(final Context context, final String deviceId, final Runnable onSuccess, final Runnable onFailure) {
        try {
            // Topic is deviceId
            client.subscribe(deviceId, 2, mqttMessageListener);
            if (onSuccess != null) {
                RemoteLogger.log(context, Const.LOG_DEBUG, "MQTT connection established");
                handler.post(onSuccess);
            }
        } catch (Exception e) {
            e.printStackTrace();
            RemoteLogger.log(context, Const.LOG_DEBUG, "Exception while subscribing: " + e.getMessage());
            if (onFailure != null) {
                handler.post(onFailure);
            }
        }
    }

    private void setupDebugging(Context context) {
        if (debugReceiver == null) {
            debugReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String errorMessage = intent.getStringExtra("MqttService.errorMessage");
                    if (errorMessage != null) {
                        Log.d(Const.LOG_TAG, intent.getStringExtra("MqttService.traceTag") + " " + errorMessage);
                    }
                }
            };
            LocalBroadcastManager.getInstance(context).registerReceiver(debugReceiver, new IntentFilter("MqttService.callbackToActivity.v0"));
        }
    }

    public void disconnect(Context context) {
        try {
            cancelReconnectionAfterFailure(context);
            RemoteLogger.log(context, Const.LOG_DEBUG, "MQTT client disconnected by user request");
            client.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
        client = null;
        LocalBroadcastManager.getInstance(context).unregisterReceiver(debugReceiver);
        debugReceiver = null;
    }

    private void cancelReconnectionAfterFailure(Context context) {
        WorkManager.getInstance(context.getApplicationContext()).cancelUniqueWork(WORKER_TAG_MQTT_RECONNECT);
    }

    private void scheduleReconnectionAfterFailure(Context context, String host, int port,
                                                  String pushType, int keepaliveTime, final String deviceId) {
        RemoteLogger.log(context, Const.LOG_INFO, "Scheduling MQTT reconnection in " + MQTT_RECONNECT_INTERVAL_SEC + " sec");
        Data data = new Data.Builder()
                .putString("host", host)
                .putInt("port", port)
                .putString("pushType", pushType)
                .putInt("keepalive", keepaliveTime)
                .putString("deviceId", deviceId)
                .build();
        OneTimeWorkRequest queryRequest =
                new OneTimeWorkRequest.Builder(PushNotificationMqttWrapper.ReconnectAfterFailureWorker.class)
                        .addTag(Const.WORK_TAG_COMMON)
                        .setInitialDelay(MQTT_RECONNECT_INTERVAL_SEC, TimeUnit.SECONDS)
                        .setInputData(data)
                        .build();
        WorkManager.getInstance(context.getApplicationContext()).enqueueUniqueWork(WORKER_TAG_MQTT_RECONNECT,
                ExistingWorkPolicy.REPLACE, queryRequest);
    }

    public static class ReconnectAfterFailureWorker extends Worker {

        private Context context;

        public ReconnectAfterFailureWorker(
                @NonNull final Context context,
                @NonNull WorkerParameters params) {
            super(context, params);
            this.context = context;
        }

        @NonNull
        @Override
        public Result doWork() {
            Data data = getInputData();
            PushNotificationMqttWrapper.getInstance().connect(context, data.getString("host"),
                    data.getInt("port", 0), data.getString("pushType"),
                    data.getInt("keepalive", Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC),
                    data.getString("deviceId"), null, null);
            return Result.success();
        }
    }

    public boolean checkPingDeath(Context context) {
        // If not connected, ping is not working so we return false
        return client != null && client.isConnected() && PingDeathDetector.getInstance().detectPingDeath(context);
    }

}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/SystemUtils.java">
package com.hmdm.launcher.util;

import android.annotation.TargetApi;
import android.app.AppOpsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Build;
import android.provider.Settings;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.SettingsHelper;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Method;

/**
 * These utils are used only in the 'system' flavor
 * when Headwind MDM is installed as a system app and
 * signed by OS keys
 */
public class SystemUtils {

    /**
     * This command requires system privileges: MANAGE_DEVICE_ADMINS, MANAGE_PROFILE_AND_DEVICE_OWNERS
     * The MANAGE_PROFILE_AND_DEVICE_OWNERS is only provided to system apps!
     *
     * Also, there's the following restriction in the DevicePolicyManagerService.java:
     * The device owner can only be set before the setup phase of the primary user has completed,
     * except for adb command if no accounts or additional users are present on the device.
     *
     * So it looks like Headwind MDM can never declare itself as a device owner,
     * except when it is running from inside a setup wizard (or declares itself as a setup wizard!)
     * To become a setup wizard, Headwind MDM should be preinstalled in the system, and
     * handle the following intent: android.intent.action.DEVICE_INITIALIZATION_WIZARD
     *
     * @param context
     * @return
     */
    public static boolean becomeDeviceOwnerByCommand(Context context) {
        String command = "dpm set-device-owner " + context.getPackageName() + "/.AdminReceiver";
        String result = executeShellCommand(command, false);
        RemoteLogger.log(context, Const.LOG_INFO, "DPM command output: " + result);
        return result.startsWith("Active admin component set");
    }

    public static String executeShellCommand(String command, boolean useShell) {
        StringBuffer output = new StringBuffer();

        Process p;
        try {
            if (useShell) {
                String[] cmdArray = {"sh", "-c", command};
                p = Runtime.getRuntime().exec(cmdArray);
            } else {
                p = Runtime.getRuntime().exec(command);
            }
            p.waitFor();
            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));

            String line = "";
            while ((line = reader.readLine()) != null) {
                output.append(line + "\n");
            }

            if (output.toString().trim().equalsIgnoreCase("")) {
                // No output, try to read an error!
                BufferedReader errorReader = new BufferedReader(new InputStreamReader(p.getErrorStream()));
                while ((line = errorReader.readLine()) != null) {
                    output.append(line + "\n");
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        String response = output.toString();
        return response;
    }

    public static boolean autoSetDeviceId(Context context) {
        String deviceIdUse = SettingsHelper.getInstance(context).getDeviceIdUse();
        String deviceId = null;
        Log.d(Const.LOG_TAG, "Device ID choice: " + deviceIdUse);
        if (BuildConfig.DEVICE_ID_CHOICE.equals("imei") || "imei".equals(deviceIdUse)) {
            deviceId = DeviceInfoProvider.getImei(context);
        } else if (BuildConfig.DEVICE_ID_CHOICE.equals("serial") || "serial".equals(deviceIdUse)) {
            deviceId = DeviceInfoProvider.getSerialNumber();
            if (deviceId.equals(Build.UNKNOWN)) {
                deviceId = null;
            }
        } else if (BuildConfig.DEVICE_ID_CHOICE.equals("mac")) {
            deviceId = DeviceInfoProvider.getMacAddress();
        }

        if (deviceId == null || deviceId.length() == 0) {
            return false;
        }

        return SettingsHelper.getInstance(context.getApplicationContext()).setDeviceId(deviceId);
    }

    public static boolean becomeDeviceOwnerByXmlFile(Context context) {
        ComponentName cn = LegacyUtils.getAdminComponentName(context);

        final String deviceOwnerFileName = "/data/system/device_owner_2.xml";
        final String deviceOwnerFileContent = "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n" +
                "<root>\n" +
                "<device-owner package=\"" + cn.getPackageName() + "\" name=\"\" " +
                "component=\"" + cn.getPackageName() + "/" + cn.getClassName() + "\" userRestrictionsMigrated=\"true\" canAccessDeviceIds=\"true\" />\n" +
                "<device-owner-context userId=\"0\" />\n" +
                "</root>";

        final String devicePoliciesFileName = "/data/system/device_policies.xml";
        final String devicePoliciesFileContent = "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>\n" +
                "<policies setup-complete=\"true\" provisioning-state=\"3\">\n" +
                "<admin name=\"" + cn.getPackageName() + "/" + cn.getClassName() + "\">\n" +
                "<policies flags=\"17\" />\n" +
                "<strong-auth-unlock-timeout value=\"0\" />\n" +
                "<user-restrictions no_add_managed_profile=\"true\" />\n" +
                "<default-enabled-user-restrictions>\n" +
                "<restriction value=\"no_add_managed_profile\" />\n" +
                "</default-enabled-user-restrictions>\n" +
                "<cross-profile-calendar-packages />\n" +
                "</admin>\n" +
                "<password-validity value=\"true\" />\n" +
                "<lock-task-features value=\"16\" />\n" +
                "</policies>";

        if (!Utils.writeStringToFile(deviceOwnerFileName, deviceOwnerFileContent, false)) {
            Log.e(Const.LOG_TAG, "Could not create device owner file " + deviceOwnerFileName);
            return false;
        }

        // Now when we succeeded to create the device owner file, let's update device policies file
        if (!Utils.writeStringToFile(devicePoliciesFileName, devicePoliciesFileContent, true)) {
            Log.e(Const.LOG_TAG, "Could not update device policies file " + devicePoliciesFileName);
            return false;
        }
        return true;
    }

    // https://stackoverflow.com/questions/10061154/how-to-programmatically-enable-disable-accessibility-service-in-android
    public static void autoSetAccessibilityPermission(Context context, String packageName, String className) {
        Settings.Secure.putString(context.getContentResolver(),
                Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, packageName + "/" + className);
        Settings.Secure.putString(context.getContentResolver(),
                Settings.Secure.ACCESSIBILITY_ENABLED, "1");
    }

    static final int OP_WRITE_SETTINGS = 23;
    static final int OP_SYSTEM_ALERT_WINDOW = 24;
    static final int OP_GET_USAGE_STATS = 43;
    static final int OP_MANAGE_EXTERNAL_STORAGE = 92;

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetOverlayPermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_SYSTEM_ALERT_WINDOW, "Overlay");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetUsageStatsPermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_GET_USAGE_STATS, "Usage history");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetStoragePermission(Context context, String packageName) {
        return autoSetPermission(context, packageName, OP_MANAGE_EXTERNAL_STORAGE, "Manage storage");
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public static boolean autoSetPermission(Context context, String packageName, int permission, String permText) {
        PackageManager packageManager = context.getPackageManager();
        int uid = 0;
        try {
            ApplicationInfo applicationInfo = packageManager.getApplicationInfo(packageName, 0);
            uid = applicationInfo.uid;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return false;
        }

        AppOpsManager appOpsManager = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);

        // src/com/android/settings/applications/DrawOverlayDetails.java
        // See method: void setCanDrawOverlay(boolean newState)
        try {
            Class clazz = AppOpsManager.class;
            Method method = clazz.getDeclaredMethod("setMode", int.class, int.class, String.class, int.class);
            method.invoke(appOpsManager, permission, uid, packageName, AppOpsManager.MODE_ALLOWED);
            Log.d(Const.LOG_TAG, permText + " permission granted to " + packageName);
            return true;
        } catch (Exception e) {
            Log.e(Const.LOG_TAG, Log.getStackTraceString(e));
            return false;
        }
    }
}
</file>

<file path="app/src/main/res/values-ja/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">管理者</string>
    <string name="install_error">インストールエラー</string>
    <string name="file_create_error">ファイル作成エラー</string>
    <string name="dialog_enter_device_id_error">このIDは %s に登録されていません。コントロールパネルの\"端末\" タブからIDを取得して下さい。</string>
    <string name="dialog_enter_device_id_qrcode">QRコード</string>
    <string name="dialog_enter_device_id_variants">バリアント</string>
    <string name="dialog_enter_device_id_save">保存</string>
    <string name="dialog_enter_device_id_exit">終了</string>
    <string name="dialog_enter_device_id_title">%s にデバイスIDを入力してください</string>
    <string name="main_start_preparations">起動中</string>
    <string name="main_downloading_configuration">設定ファイルを更新中</string>
    <string name="main_downloading_content">データ更新中</string>
    <string name="main_update_applications">アプリケーションのインストールと更新</string>
    <string name="dialog_root_message">ROOT権限が必要です</string>
    <string name="main_application_start">アプリケーションを開始</string>
    <string name="main_app_installing">アプリケーションをインストール</string>
    <string name="main_app_downloading">アプリケーションをダウンロードしています</string>
    <string name="main_app_downloading_error">パッケージのダウンロードに失敗しました</string>
    <string name="main_app_removing">アプリケーションをアンインストールしています</string>
    <string name="main_file_downloading">ファイルをダウンロードしています</string>
    <string name="main_file_downloading_error">ファイルのダウンロードに失敗しました</string>
    <string name="main_activity_repeat">再試行</string>
    <string name="main_activity_reset">リセット</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">キャンセル</string>
    <string name="main_activity_details">詳細</string>
    <string name="select_system_launcher">%s をデフォルトのランチャーとして選択し、\'常に\' にチェックを入れます:</string>
    <string name="dialog_network_error_title">%s への接続エラー。インターネット接続を確認して、再試行してください。</string>
    <string name="main_activity_update_config">サーバーから設定ファイルをリクエストしています</string>
    <string name="main_activity_applications_update">アプリケーションの更新</string>
    <string name="dialog_overlay_settings_title">アプリが他のウィンドウの上に描画できるようにしてください。\n\nこのオプションは、不要なアプリをより効果的にブロックし、キオスクモードの緊急ロック解除を可能にします。\n\n\"続行\" をタップして設定を開きますシート。 \"%s\" アイテムを見つけて許可を与え、\"戻る\" をタップしてください。</string>
    <string name="dialog_manage_storage_title">アプリにストレージの管理を許可してください。\n\nこのオプションにより、Headwind MDM はデバイス上のファイルを管理できるようになります。</string>
    <string name="dialog_history_settings_title">アプリが使用状況データにアクセスできるようにしてください。\n\nこのオプションにより、アプリと設定の制御が可能になります。\n\nこのオプションにより、バッテリーの消耗が早くなる可能性があります。バッテリーを節約するには、このオプションをスキップしてください (代わりにアクセシビリティサービスまたはキオスクモードを使用してください)。\n\n \"続行\" をタップして設定シートを開きます。 \"%s\" アイテムを見つけて権限を与え、\"戻る\" をタップしてください。</string>
    <string name="dialog_history_settings_continue">続ける</string>
    <string name="dialog_history_settings_skip">スキップ</string>
    <string name="dialog_unknown_sources_title">提供元不明のインストールを許可してください。設定シートが開きます。 \"不明なソース\" を見つけて、インストールを許可し、\"戻る\" をクリックします。</string>
    <string name="dialog_unknown_sources_continue">続ける</string>
    <string name="dialog_miui_permissions_title">MIUIではカスタム権限を手動で設定する必要があります。アプリの権限ウィンドウが開きます。 \"その他の権限\" をタップし、\"バックグラウンドでの実行中にポップアップウィンドウを表示する\" を許可して、\"戻る\" をクリックします。</string>
    <string name="dialog_miui_developer_title">MIUIでは、デバイスを手動でセットアップする必要があります。情報画面で、「ビルド番号」を 7 回タップします。これにより、開発者設定が有効になります。</string>
    <string name="dialog_miui_optimization_title">MIUIでは、デバイスを手動でセットアップする必要があります。開発者設定ウィンドウが開きます。画面を下にスクロールし、\"MIUI最適化\" のチェックを外します。</string>
    <string name="dialog_administrator_mode_message">アプリがデバイス管理者モードで動作することを許可してください。設定シートが開きます。 \"デバイス管理者\" を選択し、\"%s\" アイテムを見つけ、管理者を有効にして、\"戻る\" をタップします。</string>
    <string name="dialog_administrator_mode_continue">続ける</string>
    <string name="dialog_administrator_mode_skip">スキップ</string>
    <string name="accessibility_service_description">MDMアプリケーションによるアクティブなアプリの監視</string>
    <string name="dialog_accessibility_service_message">アプリがアクセシビリティサービスを使用できるようにしてください。設定シートが開きます。 \"%s\" アイテムを見つけて、ユーザー補助サービスの使用を許可し、\"戻る\" をタップしてください。</string>
    <string name="dialog_accessibility_service_continue">続ける</string>
    <string name="dialog_accessibility_service_skip">スキップ</string>
    <string name="access_to_app_denied">パッケージは許可されていません:</string>
    <string name="access_to_app_denied_2">構成でこのパッケージを有効にするよう管理者に依頼してください。\n\n「閉じる」または「ホーム」ボタンをクリックして続行してください。</string>
    <string name="package_id_copied">パッケージIDがクリップボードにコピーされます</string>
    <string name="dialog_app_not_allowed_close">閉じる</string>
    <string name="dialog_app_not_allowed_admin">管理者</string>
    <string name="device_id">デバイスID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">シリアル番号</string>
    <string name="phone_number">電話番号</string>
    <string name="launcher_version">ランチャーのバージョン</string>
    <string name="close">閉じる</string>
    <string name="admin_change_device_id">デバイスIDを変更</string>
    <string name="admin_change_server_url">サーバーのURLを変更</string>
    <string name="admin_allow_settings">設定を開く</string>
    <string name="settings_allowed">3 分以内で設定を変更できます。</string>
    <string name="admin_clear_restrictions">制限を解除</string>
    <string name="permissive_mode_enabled">すべてのアプリを 3 分以内で実行できます。</string>
    <string name="admin_refresh">設定を更新</string>
    <string name="admin_exit">システムランチャーに戻る</string>
    <string name="admin_reset_permissions">権限を確認</string>
    <string name="admin_reset_network">ネットワークポリシーをリセット</string>
    <string name="admin_reset_network_hint">ネットワークポリシーがクリアされました。これで、ネットワークを有効にして構成をリロードできます。</string>
    <string name="reboot">デバイスを再起動</string>
    <string name="reboot_failed">デバイスを再起動するための権限がありません.</string>
    <string name="message_turn_on_gps">設定画面が開きます。この画面でGPS位置情報をオンにして、[戻る] をクリックしてください。</string>
    <string name="message_turn_off_gps">設定画面が開きます。この画面でGPS位置情報をオフにして、[戻る] をクリックしてください。</string>
    <string name="message_turn_on_mobile_data">モバイルデータが無効になっています!ステータスバーを開いてモバイルデータをオンにしてください。</string>
    <string name="message_turn_off_mobile_data">モバイルデータが有効になっています。ステータスバーを開いてモバイルデータをオフにしてください。</string>
    <string name="message_set_password">パスワードの強度が十分ではありません。設定画面よりパスワードを変更し [戻る] をクリックしてください。</string>
    <string name="switch_off_blockings">制限をオフにしています...</string>
    <string name="kiosk_mode_requires_overlays">キオスクモードが無効です: 他のウィンドウの上に描画する権限がありません。 %s が他のウィンドウの上に描画できるようにしてください。</string>
    <string name="enter_admin_password">管理者パスワードを入力してください</string>
    <string name="wrong_password">パスワードが違います</string>
    <string name="dialog_enter_password_login">ログイン</string>
    <string name="dialog_enter_password_cancel">キャンセル</string>
    <string name="internal_error">アプリで内部エラーが発生しました。デバイスを再起動の上、再試行してください。</string>
    <string name="empty_configuration">設定がありません。サーバーからの取得を再試行しています!</string>
    <string name="permissions_reset_hint">管理パネルを閉じ、権限を確認してください。</string>
    <string name="dialog_enter_server_error">有効なサーバーURLを入力してください。</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">サーバーのURLを入力してください</string>
    <string name="critical_server_failure">サーバー障害のため終了します。障害修復後に %s を再起動するか、完全に削除して再インストールしてください。</string>
    <string name="dialog_permission_title">アプリを実行するには権限が必要です。必要な権限を付与してください。</string>
    <string name="main_activity_exit">終了</string>
    <string name="browser_not_found">ブラウザを見つけられないため、ウェブページを開くことができません。デバイス構成にブラウザーアプリを追加してください。</string>
    <string name="invalid_web_link">リンクの形式が正しくないため、開くことができません。詳細は、管理者にお問い合わせください。</string>
    <string name="activity_not_found">アクティビティが見つからないため、アクション %s を実行できません。</string>
    <string name="location_service_text">デバイスの位置情報は監視されています</string>
    <string name="qrcode_contents_error">QRコードの内容が無効です。 %s WebパネルでプロビジョニングQRコードを生成してください。</string>
    <string name="device_locked">このデバイス (%s) は管理者によってロックされています.</string>
    <string name="fault_loop_detected">ランチャーに回復不能なエラーが発生しました。システム管理者に連絡してください。</string>
    <string name="mqtt_service_text">プッシュ通知が有効です</string>
    <string name="background_location">%s にはバックグラウンドでの位置情報の許可が必要です。 \'続行\' をクリックしてアクセス許可を開き、 \'Location\' をクリックして位置情報を許可してください。</string>
    <string name="location_disable">位置情報を無効にする</string>
    <string name="background_location_continue">続ける</string>
    <string name="initializing_mdm">モバイルデバイス管理アプリケーションを初期化しています...</string>
    <string name="dialog_server_error_title">MDMサーバー %s が無効な応答を返しました。管理者に連絡してください。</string>
    <string name="mdm_choice_message">このデバイスは組織によって完全に管理されます。データは秘匿されず、管理者がいつでも消去または確認することができます。</string>
    <string name="work_profile_message">このデバイスは、組織に属する管理対象の仕事用プロファイルを取得します。 仕事用プロファイルはプライベート プロファイルから分離されており、いつでもプロファイルを切り替えることができます。</string>
    <string name="overlays_not_supported">お使いのデバイスではオーバーレイがサポートされていません.</string>
    <string name="admin_not_supported">お使いのデバイスにはデバイス管理者オプションがありません。続けるには [スキップ] をクリックして下さい。</string>
    <string name="manage_storage_not_supported">デバイスには外部ストレージを管理するオプションがありません。</string>
</resources>
</file>

<file path="app/src/main/res/values-pl-rPL/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrator</string>
    <string name="install_error">Błąd instalacji</string>
    <string name="file_create_error">Błąd podczas tworzenia pliku</string>
    <string name="dialog_enter_device_id_error">Wprowadzony ID nie został zarejestrowany na %s. Wprowadź poprawny ID widoczny w zakładce \"Devices\".</string>
    <string name="dialog_enter_device_id_qrcode">Kod QR</string>
    <string name="dialog_enter_device_id_variants">Warianty</string>
    <string name="dialog_enter_device_id_save">Zapisz</string>
    <string name="dialog_enter_device_id_exit">Wyjdź</string>
    <string name="dialog_enter_device_id_title">Wprowadź ID urządzenia z %s</string>
    <string name="main_start_preparations">Przygotowywanie do uruchomienia</string>
    <string name="main_downloading_configuration">Aktualizacja pliku konfiguracyjnego</string>
    <string name="main_downloading_content">Aktualizacja danych</string>
    <string name="main_update_applications">Instalowanie i aktualizowanie aplikacji</string>
    <string name="dialog_root_message">Potrzebujesz uprawnień ROOT</string>
    <string name="main_application_start">Uruchamianie aplikacji</string>
    <string name="main_app_installing">Instalowanie aplikacji</string>
    <string name="main_app_downloading">Pobieranie aplikacji</string>
    <string name="main_app_downloading_error">Niepowodzenie pobierania paczki</string>
    <string name="main_app_removing">Odinstalowywanie aplikacji</string>
    <string name="main_file_downloading">Pobieranie pliku</string>
    <string name="main_file_downloading_error">Niepowodzenie pobierania pliku</string>
    <string name="main_activity_repeat">Ponów</string>
    <string name="main_activity_reset">Resetuj</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Anuluj</string>
    <string name="main_activity_details">Szczegóły</string>
    <string name="select_system_launcher">Wybierz %s jako domyślny launcher i zaznacz \"Zawsze\":</string>
    <string name="dialog_network_error_title">Błąd połączenia z serwerem %s. Sprawdź połączenie sieciowe i spróbuj ponownie.</string>
    <string name="main_activity_update_config">Żądanie pliku konfiguracyjnego z serwera</string>
    <string name="main_activity_applications_update">Aktualizowanie aplikacji</string>
    <string name="dialog_overlay_settings_title">Zezwól tej aplikacji na wyświetlanie nad innymi aplikacjami.\n\nTo ustawienie pomaga lepiej blokować niechciane aplikacje i włącza awaryjną deaktywację trybu kiosk.\n\nNaciśnij \"Kontynuuj\", aby otworzyć ekran ustawień. Znajdź element \"%s\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_manage_storage_title">Zezwól aplikacji na zarządzanie pamięcią masową.\n\nTa opcja umożliwia Headwind MDM zarządzanie plikami na Twoim urządzeniu.</string>
    <string name="dialog_history_settings_title">Zezwol tej aplikacji na dostęp do danych o zużyciu.\n\nTo ustawienie włącza kontrolę aplikacji i ustawień.\n\nMoże powodować zwiększone zużycie baterii. Aby ją oszczędzać, pomiń to ustawienie i użyj ułatwień dostępu lub trybu kiosk.\n\nNaciśnij \"Kontynuuj\", aby otworzyć ekran ustawień. Znajdź element \"%s\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_history_settings_continue">Kontynuuj</string>
    <string name="dialog_history_settings_skip">Pomiń</string>
    <string name="dialog_unknown_sources_title">Zezwól na instalację aplikacji z nieznanych źródeł. Otworzy się ekran ustawień. Znajdź \"Nieznane źródła\", udziel uprawnień i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_unknown_sources_continue">Kontynuuj</string>
    <string name="dialog_miui_permissions_title">MIUI wymaga ręcznej konfiguracji uprawnień. Otworzy się ekran uprawnień aplikacji. Kliknij \"Inne uprawnienia\", zezwól \"Wyświetlaj ekrany pop-up podczas działania w tle\" i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_miui_developer_title">MIUI wymaga ręcznej konfiguracji twojego urządzenia. Na ekranie informacji o urządzeniu, KLIKNIJ 7 RAZY \"WERSJA KOMPILACJI\". Uaktywni to opcje programistyczne.</string>
    <string name="dialog_miui_optimization_title">MIUI wymaga ręcznej konfiguracji twojego urządzenia. Otworzy się ekran opcji programisty. Znajdź opcję \"Optymalizacje MIUI\" i ją odznacz.</string>
    <string name="dialog_administrator_mode_message">Zezwól tej aplikacji na działanie w trybie administratora urządzenia. Otworzy się ekran ustawień, wybierz \"Administratorzy urządzenia\", znajdź element \"%s\", aktywuj administratora i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_administrator_mode_continue">Kontynuuj</string>
    <string name="dialog_administrator_mode_skip">Pomiń</string>
    <string name="accessibility_service_description">Aktywne monitorowanie aplikacji przez aplikację MDM</string>
    <string name="dialog_accessibility_service_message">Zezwól aplikacji na korzystanie z usług ułatwień dostępu. Otworzy się teraz ekran ustawień. Znajdź element \"%s\", zezwól na korzystanie z usług ułatwień dostępu i naciśnij przycisk \"Wstecz\".</string>
    <string name="dialog_accessibility_service_continue">Kontynuuj</string>
    <string name="dialog_accessibility_service_skip">Pomiń</string>
    <string name="access_to_app_denied">Pakiet nie jest dozwolony:</string>
    <string name="access_to_app_denied_2">Poproś administratora o włączenie tego pakietu w konfiguracji.\n\nKliknij przycisk \'Zamknij\' lub przycisk Strona główna, aby kontynuować.</string>
    <string name="package_id_copied">Identyfikator pakietu zostanie skopiowany do schowka</string>
    <string name="dialog_app_not_allowed_close">Zamknij</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">ID urządzenia</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numer seryjny</string>
    <string name="phone_number">Numer telefonu</string>
    <string name="launcher_version">Wersja launchera</string>
    <string name="close">Zamknij</string>
    <string name="admin_change_device_id">Zmień ID urządzenia</string>
    <string name="admin_change_server_url">Zmień URL serwera</string>
    <string name="admin_allow_settings">Otwórz ustawienia</string>
    <string name="settings_allowed">Możesz modyfikować ustawienia przez 3 minuty.</string>
    <string name="admin_clear_restrictions">Wyłącz ograniczenia</string>
    <string name="permissive_mode_enabled">Możesz uruchamiać wszystkie aplikacje przez 3 minuty.</string>
    <string name="admin_refresh">Aktualizuj konfigurację</string>
    <string name="admin_exit">Wyjdź do systemowego launchera</string>
    <string name="admin_reset_permissions">Sprawdź uprawnienia</string>
    <string name="admin_reset_network">Resetuj polityki sieciowe</string>
    <string name="admin_reset_network_hint">Polityki sieciowe zostały zresetowane. Możesz włączyć sieć i przeładować konfigurację.</string>
    <string name="reboot">Uruchom ponownie urządzenie</string>
    <string name="reboot_failed">Niewystarczające uprawnienia do ponownego uruchomienia urządzenia.</string>
    <string name="message_turn_on_gps">Otworzy się ekran ustawień. Włącz lokalizację i naciśnij przycisk \"Wstecz\".</string>
    <string name="message_turn_off_gps">Otworzy się ekran ustawień. WYŁĄCZ lokalizację i naciśnij przycisk \"Wstecz\".</string>
    <string name="message_turn_on_mobile_data">Dane komórkowe są wyłączone. Otwórz pasek statusu i włącz dane komórkowe.</string>
    <string name="message_turn_off_mobile_data">Dane komórkowe są wyłączone. Otwórz pasek statusu i WYŁĄCZ dane komórkowe.</string>
    <string name="message_set_password">Wprowadzone hasło nie spełnia wymagań. Otworzy się ekran ustawień. Zmień hasło i naciśnij \"Wstecz\".</string>
    <string name="switch_off_blockings">Wyłączanie ograniczeń…</string>
    <string name="kiosk_mode_requires_overlays">Tryb kiosku wyłączony: brak uprawnień do wyświetlania nad innymi aplikacjami. Zezwól %s na wyświetlanie nad innymi aplikacjami.</string>
    <string name="enter_admin_password">Wprowadź hasło administratora</string>
    <string name="wrong_password">Wprowadzono nieprawidłowe hasło</string>
    <string name="dialog_enter_password_login">Zaloguj</string>
    <string name="dialog_enter_password_cancel">Anuluj</string>
    <string name="internal_error">Aplikacja napotkała błąd wewnętrzny. Uruchom ponownie urządzenie i spróbuj ponownie wykonać tą operację.</string>
    <string name="empty_configuration">Konfiguracja nie jest ustawiona, ponawianie próby pobrania jej z serwera!</string>
    <string name="permissions_reset_hint">Zamknij panel administracyjny, aby sprawdzić i poprosić o uprawnienia.</string>
    <string name="dialog_enter_server_error">Wprowadź poprawny adres serwera.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Wprowadź adres serwera</string>
    <string name="critical_server_failure">Napotkano na błąd serwera. Napraw problem i uruchom ponownie %s lub zainstaluj go na nowo.</string>
    <string name="dialog_permission_title">Aplikacja wymaga uprawnień do działania. Proszę udzielić żądanych uprawnień.</string>
    <string name="main_activity_exit">Wyjdź</string>
    <string name="browser_not_found">Nie można otworzyć strony internetowej, ponieważ nie znaleziono przeglądarki. Dodaj aplikację przeglądarki do konfiguracji urządzenia.</string>
    <string name="invalid_web_link">Nie można otworzyć wskazanego linku, ponieważ jest nieprawidłowy. Aby uzyskać szczegółowe informacje, skontaktuj się z administratorem.</string>
    <string name="activity_not_found">Nie można wykonać akcji %s, ponieważ nie znaleziono działania.</string>
    <string name="location_service_text">Lokalizacja tego urządzenia jest monitorowana</string>
    <string name="qrcode_contents_error">Kod QR ma nieprawidłową zawartość. Wygeneruj kod QR w panelu administratora na %s.</string>
    <string name="device_locked">To urządzenie (%s) zostało zablokowane przez administratora.</string>
    <string name="fault_loop_detected">Launcher napotkał na nienaprawialną usterkę! Skontaktuj się z administratorem systemu.</string>
    <string name="mqtt_service_text">Powiadomienia push są aktywne</string>
    <string name="background_location">%s wymaga pozwolenia na dostęp do lokalizacji w tle. Kliknij \"Kontynuuj\", aby otworzyć ekran uprawnień, kliknij \"Lokalizacja\" i zawsze zezwalaj na określenie lokalizacji.</string>
    <string name="location_disable">Wyłącz lokalizację</string>
    <string name="background_location_continue">Kontynuuj</string>
    <string name="initializing_mdm">Inicjowanie aplikacji do zarządzania urządzeniem…</string>
    <string name="dialog_server_error_title">Serwer MDM %s zwrócił nieprawidłową odpowiedź. Skontaktuj się z administratorem.</string>
    <string name="mdm_choice_message">To urządzenie będzie w pełni zarządzane przez Twoją organizację. Twoje dane nie będą prywatne i w każdej chwili mogą zostać usunięte lub przejrzane przez administratora IT.</string>
    <string name="work_profile_message">To urządzenie otrzyma zarządzany profil służbowy należący do Twojej organizacji. Profil do pracy jest oddzielony od profilu prywatnego i możesz przełączać się między profilami w dowolnym momencie.</string>
    <string name="overlays_not_supported">Niestety twoje urządzenie nie obsługuje nakładek.</string>
    <string name="admin_not_supported">Twoje urządzenie nie wspiera administracji urządzeniem. Kliknij \"Pomiń\", aby kontynuować.</string>
    <string name="manage_storage_not_supported">Twoje urządzenie nie ma możliwości zarządzania pamięcią zewnętrzną.</string>
</resources>
</file>

<file path="lib/src/main/java/com/hmdm/HeadwindMDM.java">
package com.hmdm;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;

import java.net.MalformedURLException;
import java.net.URL;

import dalvik.system.PathClassLoader;

/**
 * Higher level Headwind MDM integration API incapsulating reconnection to the service and configuration update
 */
public class HeadwindMDM {

    public interface EventHandler {
        // This method is called when Headwind MDM is ready to answer
        // Get your app settings in this method using MDMService.Preferences.get()
        void onHeadwindMDMConnected();
        // This is just an informative method which doesn't need any actions
        // It should be followed by Connected() method shortly
        void onHeadwindMDMDisconnected();
        // Notification about the configuration change
        // Refresh your app settings in this method using MDMService.Preferences.get()
        void onHeadwindMDMConfigChanged();
    }

    private static HeadwindMDM instance;

    public static HeadwindMDM getInstance() {
        if (instance == null) {
            instance = new HeadwindMDM();
        }
        return instance;
    }

    private MDMService mdmService;
    private boolean mdmConnected = false;
    private boolean mustRun = false;

    private EventHandler eventHandler;
    private Context context;

    private String serverHost;
    private String secondaryServerHost;
    private String serverPath;
    private String deviceId;
    private String custom1;
    private String custom2;
    private String custom3;
    private boolean isManaged;
    private boolean isKiosk;
    private String imei;
    private String serial;
    private int version;
    private String apiKey;
    private int mdmAgentError = 0;

    private BroadcastReceiver configUpdateReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction().equals(Const.NOTIFICATION_CONFIG_UPDATED) && eventHandler != null) {
                eventHandler.onHeadwindMDMConfigChanged();
            }
        }
    };

    public void setApiKey(String apiKey) {
        this.apiKey = apiKey;
    }

    /**
     * Connect to Headwind MDM service
     * @param context
     * @param eventHandler
     * @return true if Headwind MDM exists, false otherwise
     */
    @SuppressLint("UnspecifiedRegisterReceiverFlag")
    public boolean connect(final Context context, final EventHandler eventHandler) {
        mdmService = MDMService.getInstance();
        this.eventHandler = eventHandler;
        this.context = context;
        this.mdmAgentError = 0;

        boolean wasConnected = mdmConnected;
        if (!mdmService.connect(context, resultHandler)) {
            mdmConnected = false;
            return false;
        }

        if (!wasConnected) {
            // We register the receiver only once
            // so connect() method can be called multiple times

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.registerReceiver(configUpdateReceiver, new IntentFilter(Const.NOTIFICATION_CONFIG_UPDATED), Context.RECEIVER_EXPORTED);
            } else {
                context.registerReceiver(configUpdateReceiver, new IntentFilter(Const.NOTIFICATION_CONFIG_UPDATED));
            }
        }

        mustRun = true;
        return true;
    }

    public boolean isConnected() {
        return mdmConnected;
    }

    public void disconnect(Context context) {
        mustRun = false;
        mdmConnected = false;
        try {
            context.unregisterReceiver(configUpdateReceiver);
        } catch (Exception e) {
            // Ignore exception if receiver was not registered
        }
    }

    public String getServerHost() {
        try {
            URL url = new URL(serverHost);
            return url.getHost();
        } catch (MalformedURLException e) {
            return null;
        }
    }

    public String getSecondaryServerHost() {
        try {
            URL url = new URL(secondaryServerHost);
            return url.getHost();
        } catch (MalformedURLException e) {
            return null;
        }
    }

    public String getServerPath() {
        return serverPath;
    }

    public String getDeviceId() {
        return deviceId;
    }

    public String getServerUrl() {
        if (serverPath != null && !serverPath.equals("")) {
            return serverHost + "/" + serverPath;
        } else {
            return serverHost;
        }
    }

    public String getSecondaryServerUrl() {
        if (!serverPath.equals("")) {
            return serverHost + "/" + serverPath;
        } else {
            return serverHost;
        }
    }

    public String getCustom(int number) {
        switch (number) {
            case 1:
                return custom1;
            case 2:
                return custom2;
            case 3:
                return custom3;
            default:
                return null;
        }
    }

    public boolean isManaged() {
        return isManaged;
    }

    public boolean isKiosk() {
        return isKiosk;
    }

    public String getSerial() {
        return serial;
    }

    public String getImei() {
        return imei;
    }

    public int getVersion() {
        return version;
    }

    public int getMdmAgentError() {
        return mdmAgentError;
    }

    public void forceConfigUpdate() {
        if (mdmConnected) {
            mdmAgentError = 0;
            try {
                mdmService.forceConfigUpdate();
            } catch (MDMException e) {
                mdmAgentError = e.mdmError.code;
                e.printStackTrace();
            }
        }
    }

    public boolean setCustom(int number, String value) {
        if (!mdmConnected) {
            return false;
        }
        try {
            mdmAgentError = 0;
            mdmService.setCustom(number, value);
        } catch (MDMException e) {
            mdmAgentError = e.mdmError.code;
            e.printStackTrace();
            return false;
        }
        return true;
    }

    // Get the admin component for applications using "com.hmdm" shared user ID
    // This component could be used to use DevicePolicyManager in those applications
    public ComponentName getAdminComponent(Context context) {
        // We must use the context of Device Owner
        // Since we're using the same shared user, it should be returned without any security issues
        Context deviceOwnerContext = null;
        try {
            deviceOwnerContext = context.createPackageContext(Const.PACKAGE, 0);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        // Android SDK is not supposed to load classes of another application
        // However since we're using the same shared user ID (so it's the same application underhood),
        // we can use a hack to get the required class
        String apkName = null;
        try {
            apkName = context.getPackageManager().getApplicationInfo(Const.PACKAGE, 0).sourceDir;
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
            return null;
        }

        PathClassLoader pathClassLoader = new dalvik.system.PathClassLoader(
                apkName,
                ClassLoader.getSystemClassLoader());

        Class adminReceiverClass = null;
        try {
            adminReceiverClass = Class.forName(Const.ADMIN_RECEIVER_CLASS, true, pathClassLoader);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return null;
        }

        return new ComponentName(deviceOwnerContext, adminReceiverClass);
    }

    /* Automatic reconnection mechanism */

    public MDMService.ResultHandler resultHandler = new MDMService.ResultHandler() {
        @Override
        public void onMDMConnected() {
            mdmConnected = true;
            mdmAgentError = 0;

            Bundle data = null;
            try {
                version = mdmService.getVersion();
                if (version > MDMService.INITIAL_VERSION && apiKey != null) {
                    data = mdmService.queryConfig(apiKey);
                } else {
                    data = mdmService.queryConfig();
                }

                if (data == null) {
                    throw new MDMException(MDMError.ERROR_NOT_CONFIGURED);
                }

                // NPE can be here! queryConfig() may return null if Headwind MDM
                // is not configured. Not sure how to handle this, though
                serverHost = data.getString(MDMService.KEY_SERVER_HOST);
                secondaryServerHost = data.getString(MDMService.KEY_SECONDARY_SERVER_HOST);
                serverPath = data.getString(MDMService.KEY_SERVER_PATH);
                deviceId = data.getString(MDMService.KEY_DEVICE_ID);
                custom1 = data.getString(MDMService.KEY_CUSTOM_1);
                custom2 = data.getString(MDMService.KEY_CUSTOM_2);
                custom3 = data.getString(MDMService.KEY_CUSTOM_3);
                // null / false values for older launcher API versions or wrong API key
                isManaged = data.getBoolean(MDMService.KEY_IS_MANAGED);
                isKiosk = data.getBoolean(MDMService.KEY_IS_KIOSK);
                imei = data.getString(MDMService.KEY_IMEI);
                serial = data.getString(MDMService.KEY_SERIAL);
            } catch (MDMException e) {
                mdmAgentError = e.mdmError.code;
                e.printStackTrace();
            }

            if (eventHandler != null) {
                eventHandler.onHeadwindMDMConnected();
            }
        }

        @Override
        public void onMDMDisconnected() {
            // This may be raised when Headwind MDM launcher is updated or due to a launcher crash
            mdmConnected = false;
            if (mustRun) {
                if (eventHandler != null) {
                    eventHandler.onHeadwindMDMDisconnected();
                }
                new Handler().postDelayed(new MDMReconnectRunnable(), Const.HMDM_RECONNECT_DELAY_FIRST);
            }
        }
    };

    public class MDMReconnectRunnable implements Runnable {
        @Override
        public void run() {
            if (!mustRun) {
                return;
            }
            if (!mdmService.connect(context, resultHandler)) {
                // Retry in 1 minute
                new Handler().postDelayed(this, Const.HMDM_RECONNECT_DELAY_NEXT);
            }
        }
    }

}
</file>

<file path="lib/build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

apply plugin: 'com.android.library'

android {
    compileSdkVersion 34

    defaultConfig {
        minSdkVersion 14
        targetSdkVersion 34
        versionCode 170
        versionName "1.1.7"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    buildFeatures {
        aidl true
    }
    namespace 'com.hmdm'

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'androidx.appcompat:appcompat:1.0.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.1.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.1.0'
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/receiver/BootReceiver.java">
package com.hmdm.launcher.receiver;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.pro.ProUtils;

public class BootReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(Const.LOG_TAG, "Got the BOOT_RECEIVER broadcast");

        SettingsHelper settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());
        if (!settingsHelper.isBaseUrlSet()) {
            // We're here before initializing after the factory reset! Let's ignore this call
            return;
        }

        long lastAppStartTime = settingsHelper.getAppStartTime();
        long bootTime = System.currentTimeMillis() - android.os.SystemClock.elapsedRealtime();
        Log.d(Const.LOG_TAG, "appStartTime=" + lastAppStartTime + ", bootTime=" + bootTime);
        if (lastAppStartTime < bootTime) {
            Log.i(Const.LOG_TAG, "Headwind MDM wasn't started since boot, start initializing services");
        } else {
            Log.i(Const.LOG_TAG, "Headwind MDM is already started, ignoring BootReceiver");
            return;
        }

        Initializer.init(context, () -> {
            Initializer.startServicesAndLoadConfig(context);

            SettingsHelper.getInstance(context).setMainActivityRunning(false);
            if (ProUtils.kioskModeRequired(context)) {
                Log.i(Const.LOG_TAG, "Kiosk mode required, forcing Headwind MDM to run in the foreground");
                // If kiosk mode is required, then we just simulate clicking Home and starting MainActivity
                Intent homeIntent = new Intent(Intent.ACTION_MAIN);
                homeIntent.addCategory(Intent.CATEGORY_HOME);
                homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(homeIntent);
            }
        });
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/PushMessage.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import org.json.JSONObject;

@JsonIgnoreProperties( ignoreUnknown = true )
public class PushMessage {
    private String messageType;
    private String payload;

    public static final String TYPE_CONFIG_UPDATING = "configUpdating";
    public static final String TYPE_CONFIG_UPDATED = "configUpdated";
    public static final String TYPE_RUN_APP = "runApp";
    public static final String TYPE_UNINSTALL_APP = "uninstallApp";
    public static final String TYPE_DELETE_FILE = "deleteFile";
    public static final String TYPE_PURGE_DIR = "purgeDir";
    public static final String TYPE_DELETE_DIR = "deleteDir";
    public static final String TYPE_PERMISSIVE_MODE = "permissiveMode";
    public static final String TYPE_RUN_COMMAND = "runCommand";
    public static final String TYPE_REBOOT = "reboot";
    public static final String TYPE_EXIT_KIOSK = "exitKiosk";
    public static final String TYPE_CLEAR_DOWNLOADS = "clearDownloadHistory";
    public static final String TYPE_INTENT = "intent";
    public static final String TYPE_GRANT_PERMISSIONS = "grantPermissions";
    public static final String TYPE_ADMIN_PANEL = "adminPanel";

    public String getMessageType() {
        return messageType;
    }

    public void setMessageType( String messageType ) {
        this.messageType = messageType;
    }

    public String getPayload() {
        return payload;
    }

    public void setPayload(String payload) {
        this.payload = payload;
    }

    public JSONObject getPayloadJSON() {
        if (payload != null) {
            try {
                return new JSONObject(payload);
            } catch (Exception e) {
                // Bad payload
            }
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/task/GetServerConfigTask.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.task;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Build;
import android.provider.Settings;
import android.util.Log;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.json.ServerConfigResponse;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.server.ServerService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;

import okhttp3.ResponseBody;
import retrofit2.Response;

public class GetServerConfigTask extends AsyncTask< Void, Integer, Integer > {

    private Context context;
    private SettingsHelper settingsHelper;

    private ServerService serverService;
    private ServerService secondaryServerService;

    private String serverHost;
    private String urlTemplate = "{project}/rest/public/sync/configuration/{number}";
    private String errorText;
    // There are actually three types of errors: network error, HTTP error and application error
    // First two should be treated similarly and reported only in the foreground mode
    // This flag is introduced to distinguish between HTTP and application errors
    private boolean isDeviceNotFound;
    // This is the only application error which requires reporting in the background
    private String notFoundError = "error.notfound.device";

    public GetServerConfigTask( Context context ) {
        this.context = context;
        this.settingsHelper = SettingsHelper.getInstance( context );
    }

    public String getErrorText() {
        return errorText;
    }

    @Override
    protected Integer doInBackground( Void... voids ) {
        DeviceEnrollOptions enrollOptions = null;
        if (settingsHelper.getConfig() == null) {
            // This is a first start, we need to set up additional options to create a device on demand
            // Even if there's no additional options, we call POST method (enroll) rather than GET (getConfig)
            enrollOptions = new DeviceEnrollOptions();
            enrollOptions.setCustomer(settingsHelper.getEnrollOptionCustomer());
            enrollOptions.setConfiguration(settingsHelper.getEnrollOptionConfigName());
            enrollOptions.setGroups(settingsHelper.getEnrollOptionGroup());
        }

        try {
            serverService = ServerServiceKeeper.getServerServiceInstance(context);
            secondaryServerService = ServerServiceKeeper.getSecondaryServerServiceInstance(context);
        } catch (Exception e) {
            errorText = "Exception: " + e.getMessage();
            return Const.TASK_NETWORK_ERROR;
        }

        String deviceId = settingsHelper.getDeviceId();
        String signature = "";
        try {
            signature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + deviceId);
        } catch (Exception e) {
        }

        isDeviceNotFound = false;
        try {
            ServerConfig serverConfig = null;
            if (enrollOptions == null) {
                serverConfig = BuildConfig.CHECK_SIGNATURE ?
                        getServerConfigSecure(deviceId, signature) :
                        getServerConfigPlain(deviceId, signature);
            } else {
                serverConfig = BuildConfig.CHECK_SIGNATURE ?
                        enrollSecure(deviceId, enrollOptions, signature) :
                        enrollPlain(deviceId, enrollOptions, signature);
            }

            if (serverConfig != null) {
                if (serverConfig.getNewNumber() != null) {
                    RemoteLogger.log(context, Const.LOG_INFO, "Device number changed from " + settingsHelper.getDeviceId() + " to " + serverConfig.getNewNumber());
                    settingsHelper.setDeviceId(serverConfig.getNewNumber());
                    serverConfig.setNewNumber(null);
                    try {
                        PushNotificationMqttWrapper.getInstance().disconnect(context);
                    } catch (Exception e) {
                    }
                }

                settingsHelper.updateConfig(serverConfig);

                // Device already created, erase the device creation options
                settingsHelper.setDeviceIdUse(null);
                settingsHelper.setEnrollOptionCustomer(null);
                settingsHelper.setEnrollOptionConfigName(null);
                settingsHelper.setEnrollOptionGroup(null);

                // Prevent from occasional launch in the kiosk mode without any possibility to exit!
                if (ProUtils.kioskModeRequired(context) &&
                        !settingsHelper.getConfig().getMainApp().equals(context.getPackageName()) &&
                        Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
                        !Settings.canDrawOverlays(context) && !BuildConfig.ENABLE_KIOSK_WITHOUT_OVERLAYS) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Kiosk mode disabled: no permission to draw over other windows.");
                        settingsHelper.getConfig().setKioskMode(false);
                        settingsHelper.updateConfig(settingsHelper.getConfig());
                }

                ProUtils.processConfig(context, serverConfig);

                return Const.TASK_SUCCESS;
            } else {
                return isDeviceNotFound ? Const.TASK_ERROR : Const.TASK_NETWORK_ERROR;
            }
        } catch ( Exception e ) {
            e.printStackTrace();
            buildNetworkErrorText(e.getMessage());
        }

        return Const.TASK_NETWORK_ERROR;
    }

    private ServerConfig getServerConfigPlain(String deviceId, String signature) throws Exception {
        Response<ServerConfigResponse> response = null;
        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.getServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.getServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        }

        if (response.isSuccessful() && Const.STATUS_OK.equals(response.body().getStatus()) && response.body().getData() != null) {
            SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
            return response.body().getData();
        } else {
            isDeviceNotFound = response.body() != null && notFoundError.equals(response.body().getMessage());
            buildTaskErrorText(response);
        }
        return null;
    }

    // Check server signature before accepting server response
    // This is an additional protection against Man-In-The-Middle attacks
    private ServerConfig getServerConfigSecure(String deviceId, String signature) throws Exception {
        Response<ResponseBody> response = null;

        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.getServerConfigRaw(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.getServerConfigRaw(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI).execute();
        }

        if (response.isSuccessful()) {
            String serverResponse = response.body().string();

            ServerConfigResponse serverConfigResponse;
            try {
                serverConfigResponse = new ObjectMapper().readValue(serverResponse, ServerConfigResponse.class);
            } catch (Exception e) {
                errorText = "Failed to parse JSON";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check for application errors before checking the signature
            // Because the errors are not signed
            if (!Const.STATUS_OK.equals(serverConfigResponse.getStatus())) {
                isDeviceNotFound = notFoundError.equals(serverConfigResponse.getMessage());
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check response signature
            String serverSignature = response.headers().get(Const.HEADER_RESPONSE_SIGNATURE);
            if (serverSignature == null) {
                errorText = "Missing " + Const.HEADER_RESPONSE_SIGNATURE + " flag, dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // We need to extract data from the response body
            // Here we assume the specific form of response body: {"status":"OK","message":null,"data":{...}}
            final String dataMarker = "\"data\":";
            int pos = serverResponse.indexOf(dataMarker);
            if (pos == -1) {
                errorText = "Wrong server response, missing data";
                Log.e(Const.LOG_TAG, errorText + ": " + serverResponse);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            String serverData = serverResponse.substring(pos + dataMarker.length(), serverResponse.length() - 1);
            String calculatedSignature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + serverData.replaceAll("\\s", ""));
            if (!calculatedSignature.equalsIgnoreCase(serverSignature)) {
                errorText = "Server signature " + serverSignature + " doesn't match calculated signature " + calculatedSignature + ", dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            return new ObjectMapper().readValue(serverData, ServerConfig.class);
        } else {
            buildTaskErrorTextSecure(response, null);
        }
        return null;
    }

    // Apply extra device creation options (need to be used only at first start when config=null!)
    private ServerConfig enrollPlain(String deviceId, DeviceEnrollOptions createOptions,
                                     String signature) throws Exception {
        Response<ServerConfigResponse> response = null;
        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.enrollAndGetServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI, createOptions).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.enrollAndGetServerConfig(settingsHelper.getServerProject(),
                    deviceId, signature, Build.CPU_ABI, createOptions).execute();
        }

        if (response.isSuccessful() && Const.STATUS_OK.equals(response.body().getStatus()) && response.body().getData() != null) {
            SettingsHelper.getInstance(context).setExternalIp(response.headers().get(Const.HEADER_IP_ADDRESS));
            return response.body().getData();
        } else {
            isDeviceNotFound = response.body() != null && notFoundError.equals(response.body().getMessage());
            buildTaskErrorText(response);
        }
        return null;
    }

    // Check server signature before accepting server response
    // This is an additional protection against Man-In-The-Middle attacks
    // Apply extra device creation options (need to be used only at first start when config=null!)
    private ServerConfig enrollSecure(String deviceId,
                                      DeviceEnrollOptions createOptions,
                                      String signature) throws Exception {
        Response<ResponseBody> response = null;

        try {
            serverHost = settingsHelper.getBaseUrl();
            response = serverService.
                    enrollAndGetServerConfigRaw(settingsHelper.getServerProject(),
                            deviceId, signature, Build.CPU_ABI, createOptions).execute();
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (response == null) {
            serverHost = settingsHelper.getSecondaryBaseUrl();
            response = secondaryServerService.
                    enrollAndGetServerConfigRaw(settingsHelper.getServerProject(),
                            deviceId, signature, Build.CPU_ABI, createOptions).execute();
        }

        if (response.isSuccessful()) {
            String serverResponse = response.body().string();

            ServerConfigResponse serverConfigResponse;
            try {
                serverConfigResponse = new ObjectMapper().readValue(serverResponse, ServerConfigResponse.class);
            } catch (Exception e) {
                errorText = "Failed to parse JSON";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check for application errors before checking the signature
            // Because the errors are not signed
            if (!Const.STATUS_OK.equals(serverConfigResponse.getStatus())) {
                isDeviceNotFound = notFoundError.equals(serverConfigResponse.getMessage());
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }

            // Check response signature
            String serverSignature = response.headers().get(Const.HEADER_RESPONSE_SIGNATURE);
            if (serverSignature == null) {
                errorText = "Missing " + Const.HEADER_RESPONSE_SIGNATURE + " flag, dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
            }

            // We need to extract data from the response body
            // Here we assume the specific form of response body: {"status":"OK","message":null,"data":{...}}
            final String dataMarker = "\"data\":";
            int pos = serverResponse.indexOf(dataMarker);
            if (pos == -1) {
                errorText = "Wrong server response, missing data";
                Log.e(Const.LOG_TAG, errorText + ": " + serverResponse);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            String serverData = serverResponse.substring(pos + dataMarker.length(), serverResponse.length() - 1);
            String calculatedSignature = CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + serverData.replaceAll("\\s", ""));
            if (!calculatedSignature.equalsIgnoreCase(serverSignature)) {
                errorText = "Server signature " + serverSignature + " doesn't match calculated signature " + calculatedSignature + ", dropping response";
                Log.e(Const.LOG_TAG, errorText);
                buildTaskErrorTextSecure(response, serverResponse);
                return null;
            }
            return new ObjectMapper().readValue(serverData, ServerConfig.class);
        } else {
            buildTaskErrorTextSecure(response, null);
        }
        return null;
    }

    private void buildTaskErrorText(Response<ServerConfigResponse> response) {
        String message = "HTTP status: " + response.code();
        if (response.isSuccessful()) {
            message += "\n" +
                    "JSON status: " + response.body().getStatus() + "\n" +
                    "JSON message: " + response.body().getMessage();
        }
        buildNetworkErrorText(message);
    }

    private void buildTaskErrorTextSecure(Response<ResponseBody> response, String body) {
        String reason = errorText;
        String message = "HTTP status: " + response.code();
        if (response.isSuccessful()) {
            message += "\n" +
                    "Body: " + body;
        }
        buildNetworkErrorText(message);
        if (reason != null && !reason.equals("")) {
            errorText = reason + "\n\n" + errorText;
        }
    }

    private void buildNetworkErrorText(String message) {
        String url = serverHost + urlTemplate
                .replace("{project}", settingsHelper.getServerProject())
                .replace("{number}", settingsHelper.getDeviceId());

        errorText = url + "\n\n" +
                message;

        String tag = queryTag(message);
        if (tag != null) {
            errorText += "\n\nError tag: " +
                    tag;
        }
    }

    private String queryTag(String message) {
        if (message != null && message.contains("Trust anchor")) {
            return "trust_anchor";
        }
        return null;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/InitialSetupActivity.java">
package com.hmdm.launcher.ui;

import android.app.AlertDialog;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.Settings;
import android.util.Log;
import android.widget.Toast;

import androidx.databinding.DataBindingUtil;

import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityInitialSetupBinding;
import com.hmdm.launcher.helper.CertInstaller;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.Utils;

public class InitialSetupActivity extends BaseActivity implements ConfigUpdater.UINotifier {
    private ActivityInitialSetupBinding binding;
    private ConfigUpdater configUpdater;
    private SettingsHelper settingsHelper;
    private boolean configuring = false;

    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        super.onCreate(savedInstanceState);

        Log.d(Const.LOG_TAG, "Launching the initial setup activity");

        // Here we must already get the Device Owner permissions
        // So install the required certificates
        CertInstaller.installCertificatesFromAssets(this);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_initial_setup);
        binding.setMessage(getString(R.string.initializing_mdm));
        binding.setLoading(true);
    }

    @Override
    protected void onResume() {
        super.onResume();

        settingsHelper = SettingsHelper.getInstance(this);
        settingsHelper.setAppStartTime(System.currentTimeMillis());

        if (!configuring) {
            configuring = true;
            configUpdater = new ConfigUpdater();
            configUpdater.setLoadOnly(true);
            updateConfig();
        }
    }

    private void updateConfig() {
        configUpdater.updateConfig(this, this, true);
    }

    @Override
    public void onConfigUpdateStart() {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateStart");
    }

    @Override
    public void onConfigUpdateServerError(String errorText) {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateServerError");
        displayError(getString(R.string.dialog_server_error_title, concatenateServerUrl(settingsHelper.getBaseUrl(), settingsHelper.getServerProject())), errorText);
    }

    @Override
    public void onConfigUpdateNetworkError(String errorText) {
        Log.d(Const.LOG_TAG, "Initial setup activity: onConfigUpdateNetworkError");
        displayError(getString(R.string.dialog_network_error_title, concatenateServerUrl(settingsHelper.getBaseUrl(), settingsHelper.getServerProject())), errorText);
    }

    @Override
    public void onConfigLoaded() {
        // Set Headwind MDM as the default launcher if required
        final ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            // Device owner should be already granted, so we grant requested permissions early
            boolean deviceOwner = Utils.isDeviceOwner(this);
            Log.d(Const.LOG_TAG, "Device Owner: " + deviceOwner);
            getSharedPreferences( Const.PREFERENCES, MODE_PRIVATE ).edit().putInt(Const.PREFERENCES_DEVICE_OWNER, deviceOwner ?
                    Const.PREFERENCES_ON : Const.PREFERENCES_OFF).commit();
            if (deviceOwner) {
                Utils.autoGrantRequestedPermissions(this, getPackageName(), config.getAppPermissions(), true);
            }

            if (Utils.isDeviceOwner(this) &&
                    (config.getRunDefaultLauncher() == null || !config.getRunDefaultLauncher())) {
                // As per the documentation, setting the default preferred activity should not be done on the main thread
                new AsyncTask<Void, Void, Void>() {
                    @Override
                    protected Void doInBackground(Void... voids) {
                        Utils.setDefaultLauncher(InitialSetupActivity.this);
                        return null;
                    }

                    @Override
                    protected void onPostExecute(Void v) {
                        completeConfig(settingsHelper);
                    }
                }.execute();
                return;
            } else {
                // Headwind MDM works with default system launcher
                // Run services here
                // TODO: permissions required for watchdog services are not yet granted
                // so watchdog services are not being started at this point.
                // Perhaps we need to request these permissions at this step?
                Log.d(Const.LOG_TAG, "Working in background, starting services and installing apps");
                Initializer.init(InitialSetupActivity.this, () -> {
                    Initializer.startServicesAndLoadConfig(InitialSetupActivity.this);
                });
            }
        }
        completeConfig(settingsHelper);
    }

    private void completeConfig(final SettingsHelper settingsHelper) {
        configuring = false;
        if (settingsHelper.getConfig() != null) {
            try {
                Initializer.applyEarlyNonInteractivePolicies(this, settingsHelper.getConfig());
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        settingsHelper.setIntegratedProvisioningFlow(true);

        Log.d(Const.LOG_TAG, "Initial setup activity: setup completed");
        setResult(RESULT_OK);
        finish();
    }

    private void displayError(String message, String detailsText) {
        try {
            new AlertDialog.Builder(this)
                    .setMessage(message)
                    .setNeutralButton(R.string.main_activity_details, (dialogInterface, i) -> details(detailsText))
                    .setNegativeButton(R.string.main_activity_wifi, (dialogInterface, i) -> openWiFiSettings())
                    .setPositiveButton(R.string.main_activity_repeat, (dialogInterface, i) -> updateConfig())
                    .create()
                    .show();
        } catch (/*BadToken*/Exception e) {
            // Fatal Exception: android.view.WindowManager$BadTokenException
            // Unable to add window -- token android.os.BinderProxy@4a95f1c is not valid; is your activity running?
            // Shouldn't we reset the device here to avoid hanging up?
            e.printStackTrace();
        }
    }

    private void details(String detailsText) {
        configuring = false;
        ErrorDetailsActivity.display(this, detailsText, true);
    }

    private void openWiFiSettings() {
        configuring = false;
        try {
            startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
        } catch (Exception e) {
            e.printStackTrace();
            Toast.makeText(this, e.getMessage(), Toast.LENGTH_LONG).show();
        }
    }

    private void abort() {
        // Factory reset!!!
        if (!Utils.factoryReset(this)) {
            RemoteLogger.log(this, Const.LOG_WARN, "Device reset failed");
        }
        setResult(RESULT_CANCELED);
        finish();
    }

    @Override
    public void onPoliciesUpdated() {
        // Not used in early setup
    }

    @Override
    public void onFileDownloading(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onDownloadProgress(int progress, long total, long current) {
        // Not used in early setup
    }

    @Override
    public void onFileDownloadError(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onFileInstallError(RemoteFile remoteFile) {
        // Not used in early setup
    }

    @Override
    public void onAppUpdateStart() {
        // Not used in early setup
    }

    @Override
    public void onAppRemoving(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppDownloading(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppInstalling(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppDownloadError(Application application) {
        // Not used in early setup
    }

    @Override
    public void onAppInstallError(String packageName) {
        // Not used in early setup
    }

    @Override
    public void onAppInstallComplete(String packageName) {
        // Not used in early setup
    }

    @Override
    public void onConfigUpdateComplete() {
        // Not used in early setup
    }

    @Override
    public void onAllAppInstallComplete() {
        // Not used in early setup
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/DeviceInfoProvider.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.annotation.SuppressLint;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.Location;
import android.location.LocationManager;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Environment;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.util.Log;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.pro.ProUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.List;

public class DeviceInfoProvider {
    public static DeviceInfo getDeviceInfo(Context context, boolean queryPermissions, boolean queryApps) {
        DeviceInfo deviceInfo = new DeviceInfo();
        List<Integer> permissions = deviceInfo.getPermissions();
        List<Application> applications = deviceInfo.getApplications();
        List<RemoteFile> files = deviceInfo.getFiles();

        deviceInfo.setModel(Build.MODEL);

        if (queryPermissions) {
            permissions.add(Utils.checkAdminMode(context) ? 1 : 0);
            permissions.add(Utils.canDrawOverlays(context) ? 1 : 0);
            permissions.add(ProUtils.checkUsageStatistics(context) ? 1 : 0);
            permissions.add(!BuildConfig.USE_ACCESSIBILITY || !ProUtils.checkAccessibilityService(context) ? 0 : 1);
        }

        SettingsHelper config = SettingsHelper.getInstance(context);
        if (queryApps) {
            PackageManager packageManager = context.getPackageManager();
            if (config.getConfig() != null) {
                List<Application> requiredApps = SettingsHelper.getInstance(context).getConfig().getApplications();
                for (Application application : requiredApps) {
                    if (application.isRemove()) {
                        continue;
                    }
                    try {
                        PackageInfo packageInfo = packageManager.getPackageInfo(application.getPkg(), 0);

                        Application installedApp = new Application();
                        installedApp.setName(application.getName());
                        installedApp.setPkg(packageInfo.packageName);
                        installedApp.setVersion(packageInfo.versionName);

                        // Verify there's no duplicates (due to different versions in config), otherwise it causes an error on the server
                        boolean appPresents = false;
                        for (Application a : applications) {
                            if (a.getPkg().equalsIgnoreCase(installedApp.getPkg())) {
                                appPresents = true;
                                break;
                            }
                        }
                        if (!appPresents) {
                            applications.add(installedApp);
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        // Application not installed
                    }
                }

                List<RemoteFile> requiredFiles = SettingsHelper.getInstance(context).getConfig().getFiles();
                for (RemoteFile remoteFile : requiredFiles) {
                    File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                    if (file.exists()) {
                        RemoteFile remoteFileDb = RemoteFileTable.selectByPath(DatabaseHelper.instance(context).getReadableDatabase(),
                                remoteFile.getPath());
                        if (remoteFileDb != null) {
                            files.add(remoteFileDb);
                        } else {
                            // How could that happen? The database entry should exist for each file
                            // Let's recalculate the checksum to check if the file matches
                            try {
                                RemoteFile copy = new RemoteFile(remoteFile);
                                copy.setChecksum(CryptoUtils.calculateChecksum(new FileInputStream(file)));
                                files.add(copy);
                            } catch (FileNotFoundException e) {
                            }
                        }
                    }
                }
            }
        }

        deviceInfo.setDeviceId( SettingsHelper.getInstance( context ).getDeviceId() );

        String phone = DeviceInfoProvider.getPhoneNumber(context, 0);
        if (phone == null || phone.equals("")) {
            phone = config.getConfig().getPhone();
        }
        deviceInfo.setPhone(phone);

        String imei = DeviceInfoProvider.getImei(context, 0);
        if (imei == null || imei.equals("")) {
            imei = config.getConfig().getImei();
        }
        deviceInfo.setImei(imei);

        // Battery
        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);

        Intent batteryStatus = Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ?
                context.registerReceiver(null, ifilter, Context.RECEIVER_EXPORTED) :
                context.registerReceiver(null, ifilter);
        int status = batteryStatus.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING ||
                status == BatteryManager.BATTERY_STATUS_FULL) {
            int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            switch (chargePlug) {
                case BatteryManager.BATTERY_PLUGGED_USB:
                    deviceInfo.setBatteryCharging(Const.DEVICE_CHARGING_USB);
                    break;
                case BatteryManager.BATTERY_PLUGGED_AC:
                    deviceInfo.setBatteryCharging(Const.DEVICE_CHARGING_AC);
                    break;
            }
        } else {
            deviceInfo.setBatteryCharging("");
        }

        int level = batteryStatus.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
        int scale = batteryStatus.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
        deviceInfo.setBatteryLevel(level * 100 / scale);

        deviceInfo.setAndroidVersion(Build.VERSION.RELEASE);
        deviceInfo.setLocation(getLocation(context));
        deviceInfo.setMdmMode(Utils.isDeviceOwner(context));
        deviceInfo.setKioskMode(ProUtils.isKioskModeRunning(context));
        deviceInfo.setLauncherType(Utils.getLauncherVariant());
        deviceInfo.setCpu(Build.CPU_ABI);
        deviceInfo.setSerial(getSerialNumber());

        deviceInfo.setImsi(getImsi(context, 0));
        deviceInfo.setIccid(getIccid(context, 0));
        deviceInfo.setImei2(getImei(context, 1));
        deviceInfo.setImsi2(getImsi(context, 1));
        deviceInfo.setPhone2(getPhoneNumber(context, 1));
        deviceInfo.setIccid2(getIccid(context, 1));

        String launcherPackage = Utils.getDefaultLauncher(context);
        deviceInfo.setLauncherPackage(launcherPackage != null ? launcherPackage : "");
        deviceInfo.setDefaultLauncher(context.getPackageName().equals(launcherPackage));

        deviceInfo.setCustom1(config.getUserCustom1());
        deviceInfo.setCustom2(config.getUserCustom2());
        deviceInfo.setCustom3(config.getUserCustom3());

        return deviceInfo;
    }

    @SuppressWarnings({"MissingPermission"})
    public static DeviceInfo.Location getLocation(Context context) {
        try {
            LocationManager locationManager = (LocationManager)context.getSystemService(Context.LOCATION_SERVICE);
            Location lastLocationGps = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
            Location lastLocationNetwork = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);

            if (lastLocationGps != null || lastLocationNetwork != null) {

                DeviceInfo.Location location = new DeviceInfo.Location();

                Location lastLocation;
                if (lastLocationGps == null || (lastLocationGps.getLatitude() == 0 && lastLocationGps.getLongitude() == 0)) {
                    lastLocation = lastLocationNetwork;
                } else if (lastLocationNetwork == null || (lastLocationNetwork.getLatitude() == 0 && lastLocationNetwork.getLongitude() == 0)) {
                    lastLocation = lastLocationGps;
                } else {
                    // Get the latest location as the best one
                    if (lastLocationGps.getTime() >= lastLocationNetwork.getTime()) {
                        lastLocation = lastLocationGps;
                    } else {
                        lastLocation = lastLocationNetwork;
                    }
                }

                if (lastLocation.getLatitude() == 0 && lastLocation.getLongitude() == 0) {
                    return null;
                }

                location.setLat(lastLocation.getLatitude());
                location.setLon(lastLocation.getLongitude());
                location.setTs(lastLocation.getTime());
                return location;
            }
        } catch (Exception e) {
        }
        return null;
    }

    @SuppressLint("MissingPermission")
    public static String getSerialNumber() {
        String serialNumber = null;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            try {
                String s = Build.getSerial();
                Log.d(Const.LOG_TAG, "Serial number: " + s);
                return s;
            } catch (SecurityException e) {
                Log.w(Const.LOG_TAG, "Failed to get serial number from Build.getSerial()");
                e.printStackTrace();
            }
        }
        try {
            Class<?> c = Class.forName("android.os.SystemProperties");
            Method get = c.getMethod("get", String.class);
            serialNumber = (String) get.invoke(c, "ril.serialnumber");
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to get serial number from ril.serialnumber");
            e.printStackTrace();
        }
        if (serialNumber != null && !serialNumber.equals("")) {
            return serialNumber;
        }
        Log.d(Const.LOG_TAG, "Build.SERIAL=" + Build.SERIAL);
        return Build.SERIAL;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getPhoneNumber(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getLine1Number();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getIccid(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getSimSerialNumber();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImsi(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getSubscriberId();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImsi(Context context, int slot) {
        String imsi = null;
        try {
            TelephonyManager telephonyManager = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
            // This method is hidden, use reflection
            // Thanks to https://stackoverflow.com/questions/36902916/subscriptionmanager-to-read-imsi-for-dual-sim-devices-ruuning-android-5-1
            Class c = Class.forName("android.telephony.TelephonyManager");
            Method m = c.getMethod("getSubscriberId", new Class[] {int.class});
            Object o = m.invoke(telephonyManager, new Object[]{slot});
            imsi = (String)o;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return imsi;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getPhoneNumber(Context context, int slot) {
        try {
            Utils.autoGrantPhonePermission(context);
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) {
                if (slot == 0) {
                    return getPhoneNumber(context);
                }
                return null;
            }
            SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
            List<SubscriptionInfo> subscriptionList = subscriptionManager.getActiveSubscriptionInfoList();
            if (subscriptionList == null || slot >= subscriptionList.size()) {
                // No mobile info at all
                return null;
            }
            return subscriptionList.get(slot).getNumber();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getIccid(Context context, int slot) {
        try {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP_MR1) {
                if (slot == 0) {
                    return getPhoneNumber(context);
                }
                return null;
            }
            SubscriptionManager subscriptionManager = SubscriptionManager.from(context);
            List<SubscriptionInfo> subscriptionList = subscriptionManager.getActiveSubscriptionInfoList();
            if (subscriptionList == null || slot >= subscriptionList.size()) {
                // No mobile info at all
                return null;
            }
            return subscriptionList.get(slot).getIccId();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImei(Context context) {
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getDeviceId();
        } catch (Exception e) {
            return null;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    public static String getImei(Context context, int slot) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            if (slot == 0) {
                return getImei(context);
            }
            return null;
        }
        try {
            TelephonyManager tMgr = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            if (tMgr == null) {
                return null;
            }
            return tMgr.getDeviceId(slot);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Get the STB MacAddress
     */
    public static String getMacAddress() {
        try {
            return Utils.loadFileAsString("/sys/class/net/eth0/address")
                    .toUpperCase().substring(0, 17);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BaseAppListAdapter.java">
package com.hmdm.launcher.ui;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.ComponentName;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.GradientDrawable;
import android.net.Uri;
import android.provider.DocumentsContract;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.core.content.FileProvider;
import androidx.recyclerview.widget.RecyclerView;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ItemAppBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.UnsafeOkHttpClient;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.Utils;
import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.NetworkPolicy;
import com.squareup.picasso.Picasso;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import okhttp3.Cache;
import okhttp3.OkHttpClient;

public class BaseAppListAdapter extends RecyclerView.Adapter<BaseAppListAdapter.ViewHolder> {
    protected LayoutInflater layoutInflater;
    protected List<AppInfo> items;
    protected Map<Integer, AppInfo> shortcuts;        // Keycode -> Application, filled in getInstalledApps()
    protected MainAppListAdapter.OnAppChooseListener appChooseListener;
    protected MainAppListAdapter.SwitchAdapterListener switchAdapterListener;
    protected Activity parentActivity;
    protected SettingsHelper settingsHelper;
    protected int spanCount;
    protected int selectedItem = -1;
    protected RecyclerView.LayoutManager layoutManager;
    protected GradientDrawable selectedItemBorder;
    protected boolean focused = true;
    protected boolean dpadUsed = false;

    protected Picasso picasso = null;

    public BaseAppListAdapter(Activity parentActivity, MainAppListAdapter.OnAppChooseListener appChooseListener, MainAppListAdapter.SwitchAdapterListener switchAdapterListener) {
        layoutInflater = LayoutInflater.from(parentActivity);

        this.appChooseListener = appChooseListener;
        this.switchAdapterListener = switchAdapterListener;
        this.parentActivity = parentActivity;
        this.settingsHelper = SettingsHelper.getInstance(parentActivity);

        boolean isDarkBackground = true;
        ServerConfig config = settingsHelper.getConfig();
        if (config != null && config.getBackgroundColor() != null) {
            try {
                isDarkBackground = !Utils.isLightColor(Color.parseColor(config.getBackgroundColor()));
            } catch (Exception e) {
            }
        }
        selectedItemBorder = new GradientDrawable();
        selectedItemBorder.setColor(0); // transparent background
        selectedItemBorder.setStroke(2, isDarkBackground ? 0xa0ffffff : 0xa0000000); // white or black border with some transparency
    }

    protected void initShortcuts() {
        shortcuts = new HashMap<>();
        for (AppInfo item : items) {
            if (item.keyCode != null) {
                shortcuts.put(item.keyCode, item);
            }
        }
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        ViewHolder viewHolder = new ViewHolder(layoutInflater.inflate(R.layout.item_app, parent, false));
        viewHolder.binding.rootLinearLayout.setOnClickListener(onClickListener);
        viewHolder.binding.rootLinearLayout.setOnLongClickListener(onLongClickListener);
        return viewHolder;
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        AppInfo appInfo = items.get(position);
        holder.binding.rootLinearLayout.setTag(appInfo);
        holder.binding.textView.setText(appInfo.name);

        if (settingsHelper.getConfig().getTextColor() != null && !settingsHelper.getConfig().getTextColor().trim().equals("")) {
            try {
                holder.binding.textView.setTextColor(Color.parseColor(settingsHelper.getConfig().getTextColor()));
            } catch (Exception e) {
                // Invalid color
                e.printStackTrace();
            }
        }

        try {
            Integer iconScale = settingsHelper.getConfig().getIconSize();
            if (iconScale == null) {
                iconScale = ServerConfig.DEFAULT_ICON_SIZE;
            }
            int iconSize = parentActivity.getResources().getDimensionPixelOffset(R.dimen.app_icon_size) * iconScale / 100;
            holder.binding.imageView.getLayoutParams().width = iconSize;
            holder.binding.imageView.getLayoutParams().height = iconSize;
            if (appInfo.iconUrl != null) {
                // Load the icon
                if (picasso == null) {
                    Picasso.Builder builder = new Picasso.Builder(parentActivity);
                    if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                        builder.downloader(new OkHttp3Downloader(UnsafeOkHttpClient.getUnsafeOkHttpClient()));
                    } else {
                        // Add signature to all requests to protect against unauthorized API calls
                        // For TRUST_ANY_CERTIFICATE, we won't add signatures because it's unsafe anyway
                        // and is just a workaround to use Headwind MDM on the LAN
                        OkHttpClient clientWithSignature = new OkHttpClient.Builder()
                                .cache(new Cache(new File(parentActivity.getApplication().getCacheDir(), "image_cache"), 1000000L))
                                .addInterceptor(chain -> {
                                    okhttp3.Request.Builder requestBuilder = chain.request().newBuilder();
                                    String signature = InstallUtils.getRequestSignature(chain.request().url().toString());
                                    if (signature != null) {
                                        requestBuilder.addHeader("X-Request-Signature", signature);
                                    }
                                    return chain.proceed(requestBuilder.build());

                                })
                                .build();
                        builder.downloader(new OkHttp3Downloader(clientWithSignature));
                    }
                    builder.listener(new Picasso.Listener() {
                        @Override
                        public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception) {
                            // On fault, get the image from the cache
                            // This is a workaround against a bug in Picasso: it doesn't display cached images by default!
                            picasso.load(appInfo.iconUrl)
                                    .networkPolicy(NetworkPolicy.OFFLINE)
                                    .into(holder.binding.imageView);
                        }
                    });
                    picasso = builder.build();
                }

                picasso.load(appInfo.iconUrl)
                        .into(holder.binding.imageView);
            } else {
                switch (appInfo.type) {
                    case AppInfo.TYPE_APP:
                        holder.binding.imageView.setImageDrawable(parentActivity.getPackageManager().getApplicationIcon(appInfo.packageName));
                        break;
                    case AppInfo.TYPE_WEB:
                        holder.binding.imageView.setImageDrawable(
                                parentActivity.getResources().getDrawable(getDrawableResourceForWebApp(appInfo)));
                        break;
                    case AppInfo.TYPE_INTENT:
                        holder.binding.imageView.setImageDrawable(
                                parentActivity.getResources().getDrawable(getDrawableResourceForIntent(appInfo)));
                        break;
                }
            }

            holder.itemView.setOnFocusChangeListener((v, hasFocus) -> {
                holder.itemView.setBackground(holder.itemView.hasFocus() && dpadUsed ? selectedItemBorder : null);
            });

        } catch (Exception e) {
            // Here we handle PackageManager.NameNotFoundException as well as
            // DeadObjectException (when a device is being turned off)
            e.printStackTrace();
            holder.binding.imageView.setImageResource(R.drawable.ic_android_white_50dp);
        }
    }

    public int getDrawableResourceForWebApp(AppInfo appInfo) {
        if (appInfo.url.startsWith("file://")) {
            if (appInfo.url.endsWith("/")) {
                return R.drawable.localfolder;
            } else {
                return R.drawable.locallink;
            }
        } else {
            return R.drawable.weblink;
        }
    }

    public int getDrawableResourceForIntent(AppInfo appInfo) {
        if (appInfo.intent != null && appInfo.intent.equals("android.intent.action.DIAL")) {
            return R.drawable.dialer;
        } else {
            return R.drawable.settings;
        }
    }

    public static final class ViewHolder extends RecyclerView.ViewHolder{
        ItemAppBinding binding;

        public ViewHolder(View itemView) {
            super(itemView);
            binding = ItemAppBinding.bind(itemView);
        }
    }

    @Override
    public void onAttachedToRecyclerView(final RecyclerView recyclerView) {
        super.onAttachedToRecyclerView(recyclerView);
        layoutManager = recyclerView.getLayoutManager();
    }

    @Override
    public int getItemCount() {
        return items == null ? 0 : items.size();
    }

    public void setSpanCount(int spanCount) {
        this.spanCount = spanCount;
    }

    public void setFocused(boolean focused) {
        selectedItem = focused ? 0 : -1;
        notifyDataSetChanged();
        if (selectedItem == 0 && layoutManager != null) {
            layoutManager.scrollToPosition(selectedItem);
        }
    }

    public interface OnAppChooseListener{
        void onAppChoose(@NonNull AppInfo resolveInfo);
    }

    // Let the parent know that the user wants to switch the adapter
    // Send the direction; if the parent returns true, this means
    // it switched the adapter - unfocus self
    public interface SwitchAdapterListener {
        boolean switchAppListAdapter(BaseAppListAdapter adapter, int direction);
    }

    protected View.OnClickListener onClickListener = v -> {
        if (BuildConfig.SELECTED_ITEM_BY_CLICK && selectedItem >= 0) {
            // Some TV boxes mistakenly generate onClick() for the first item
            // when the OK button is clicked. Here's the workaround
            chooseSelectedItem();
        } else {
            chooseApp((AppInfo) v.getTag());
        }
    };

    protected View.OnLongClickListener onLongClickListener = v -> {
        AppInfo appInfo = (AppInfo) v.getTag();
        if (appInfo.type == AppInfo.TYPE_APP && appInfo.longTap == 1) {
            // Open app settings on long click
            openAppSettings(appInfo);
            return true;
        }
        return false;
    };

    protected void chooseApp(AppInfo appInfo) {
        switch (appInfo.type) {
            case AppInfo.TYPE_APP:
                Intent launchIntent = parentActivity.getPackageManager().getLaunchIntentForPackage(
                        appInfo.packageName);
                if (launchIntent != null) {
                    // These magic flags are found in the source code of the default Android launcher
                    // These flags preserve the app activity stack (otherwise a launch activity appears at the top which is not correct)
                    launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                            Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
                    parentActivity.startActivity(launchIntent);
                }
                break;
            case AppInfo.TYPE_WEB:
                if (appInfo.url != null) {
                    Intent i = new Intent(Intent.ACTION_VIEW);

                    Uri uri = Uri.parse(appInfo.url);
                    String mimeType = null;

                    if (uri.getScheme().equals("file")) {
                        // Avoid FileUriExposedException
                        String path = uri.getPath();
                        File file = new File(path);
                        try {
                            uri = FileProvider.getUriForFile(parentActivity, parentActivity.getApplicationContext().getPackageName() + ".provider", file);
                        } catch (/*IllegalArgument*/Exception e) {
                            Toast.makeText(parentActivity, R.string.invalid_web_link, Toast.LENGTH_LONG).show();
                            break;
                        }
                        if (appInfo.url.endsWith("/")) {
                            // This is the directory, we need to specify the MIME type explicitly
                            mimeType = DocumentsContract.Document.MIME_TYPE_DIR;
                        }
                        i.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                    }

                    Log.d(Const.LOG_TAG, "BaseAppListAdapter: opening web app: " + uri.toString());
                    if (mimeType != null) {
                        i.setDataAndType(uri, mimeType);
                    } else {
                        i.setData(uri);
                    }
                    i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);

                    if (appInfo.useKiosk != 0) {
                        Log.d(Const.LOG_TAG, "Component: " + Const.KIOSK_BROWSER_PACKAGE_NAME + ".MainActivity");
                        i.setComponent(new ComponentName(Const.KIOSK_BROWSER_PACKAGE_NAME, Const.KIOSK_BROWSER_PACKAGE_NAME + ".MainActivity"));
                    }

                    try {
                        parentActivity.startActivity(i);
                    } catch (ActivityNotFoundException e) {
                        Toast.makeText(parentActivity, R.string.browser_not_found, Toast.LENGTH_LONG).show();
                    } catch (Exception e) {
                        Toast.makeText(parentActivity, R.string.invalid_web_link, Toast.LENGTH_LONG).show();
                    }
                }
                break;
            case AppInfo.TYPE_INTENT:
                if (appInfo.intent != null) {
                    try {
                        Intent i = new Intent(appInfo.intent);
                        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
                        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        parentActivity.startActivity(i);
                    } catch (Exception e) {
                        Toast.makeText(parentActivity, parentActivity.getString(R.string.activity_not_found, appInfo.intent), Toast.LENGTH_LONG).show();
                    }
                }
                break;

        }
        if (appChooseListener != null) {
            appChooseListener.onAppChoose(appInfo);
        }
    }

    public boolean onKey(final int keyCode) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_CENTER:
            dpadUsed = true;
        }
        return false;

        // This code (manual browsing of icons) follows by focusing just 1st item
        // (the workaround is provided by BuildConfig.SELECTED_ITEM_BY_CLICK but it won't work well
        // if an item is selected and another is tapped. Also, (info) and (reload) items become
        // unavailable. So just turn on displaying border by focus here (flag dpadUsed).

/*        AppInfo shortcutAppInfo = shortcuts.get(new Integer(keyCode));
        if (shortcutAppInfo != null) {
            chooseApp(shortcutAppInfo);
            return true;
        }
        if (!focused) {
            return false;
        }

        int switchAdapterDirection = -1;
        switch (keyCode) {
            case KeyEvent.KEYCODE_DPAD_RIGHT:
                if (tryMoveSelection(layoutManager, 1)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_RIGHT;
                };
                break;
            case KeyEvent.KEYCODE_DPAD_LEFT:
                if (tryMoveSelection(layoutManager, -1)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_LEFT;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (tryMoveSelection(layoutManager, spanCount)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_DOWN;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_UP:
                if (tryMoveSelection(layoutManager, -spanCount)) {
                    return true;
                } else {
                    switchAdapterDirection = Const.DIRECTION_UP;
                }
                break;
            case KeyEvent.KEYCODE_DPAD_CENTER:
                chooseSelectedItem();
                return true;
        }
        if (switchAdapterListener != null && switchAdapterListener.switchAppListAdapter(this, switchAdapterDirection)) {
            // Adapter switch accepted, unfocus
            setFocused(false);
        }

        return false; */
    }

    private boolean tryMoveSelection(RecyclerView.LayoutManager lm, int offset) {
        int trySelectedItem = selectedItem + offset;

        if (trySelectedItem < 0) {
            trySelectedItem = 0;
        }
        if (trySelectedItem >= getItemCount()) {
            trySelectedItem = getItemCount() - 1;
        }

        if (trySelectedItem != selectedItem) {
            selectedItem = trySelectedItem;
            notifyDataSetChanged();
            if (lm != null) {
                lm.scrollToPosition(trySelectedItem);
            }
            return true;
        }

        return false;
    }

    private void chooseSelectedItem() {
        if (items == null || selectedItem < 0 || selectedItem >= getItemCount()) {
            return;
        }
        chooseApp(items.get(selectedItem));
    }

    private void openAppSettings(AppInfo appInfo) {
        parentActivity.startActivity(new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
                Uri.parse("package:" + appInfo.packageName)));
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/SettingsHelper.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.helper;

import android.content.Context;
import android.content.SharedPreferences;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.ApplicationSetting;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class SettingsHelper {

    private static final String PREFERENCES_ID = ".helpers.PREFERENCES";
    private static final String PREF_KEY_BASE_URL = ".helpers.BASE_URL";
    private static final String PREF_KEY_SECONDARY_BASE_URL = ".helpers.SECONDARY_BASE_URL";
    private static final String PREF_KEY_SERVER_PROJECT = ".helpers.SERVER_PROJECT";
    private static final String PREF_KEY_DEVICE_ID = ".helpers.DEVICE_ID";
    private static final String PREF_KEY_CUSTOMER = ".helpers.CUSTOMER";
    private static final String PREF_KEY_CONFIG_NAME = ".helpers.CONFIG_NAME";
    private static final String PREF_KEY_GROUP = ".helpers.GROUP";
    private static final String PREF_KEY_DEVICE_ID_USE = ".helpers.DEVICE_ID_USE";
    private static final String PREF_KEY_CONFIG = ".helpers.CONFIG";
    private static final String PREF_KEY_IP_ADDRESS = ".helpers.IP_ADDRESS";
    private static final String PREF_QR_PROVISIONING = ".helpers.QR_PROVISIONING";
    private static final String PREF_CFG_UPDATE_TIMESTAMP = ".helpers.CFG_UPDATE_TIMESTAMP";
    private static final String PREF_KEY_ACTIVITY_RUNNING = ".helpers.ACTIVITY_RUNNING";
    private static final String PREF_KEY_RESTORE_LAUNCHER = ".helpers.NEED_LAUNCHER_RESET";
    private static final String PREF_KEY_INTEGRATED_PROVISIONING_FLOW = ".helpers.INTEGRATED_PROVISIONING_FLOW";
    private static final String PREF_KEY_LAST_APP_UPDATE_STATE = ".helpers.LAST_APP_UPDATE_STATE";
    private static final String PREF_KEY_APP_START_TIME = ".helpers.APP_START_TIME";
    private static final String PREF_KEY_SATELLITE_COUNT = ".helpers.APP_SATELLITE_COUNT";
    private static final String PREF_KEY_USER_CUSTOM_1 = ".helpers.USER_CUSTOM_1";
    private static final String PREF_KEY_USER_CUSTOM_2 = ".helpers.USER_CUSTOM_2";
    private static final String PREF_KEY_USER_CUSTOM_3 = ".helpers.USER_CUSTOM_3";
    // This prefix is for the compatibility with a legacy package name
    private static String PACKAGE_NAME;

    private SharedPreferences sharedPreferences;
    private ServerConfig config;
    private ServerConfig oldConfig;
    private Map<String,ApplicationSetting> appSettings = new HashMap<>();
    private Set<String> allowedClasses = new HashSet<>();

    private static SettingsHelper instance;

    public static SettingsHelper getInstance(Context context) {
        if (instance == null) {
            instance = new SettingsHelper(context);
        }

        return instance;
    }

    public SettingsHelper(Context context) {
        PACKAGE_NAME = context.getPackageName();
        sharedPreferences = context.getSharedPreferences(PACKAGE_NAME + PREFERENCES_ID, Context.MODE_PRIVATE );
        initConfig();
    }

    public void refreshConfig(Context context) {
        if (config == null) {
            sharedPreferences = context.getSharedPreferences(PACKAGE_NAME + PREFERENCES_ID, Context.MODE_PRIVATE );
            initConfig();
        }
    }

    private void initConfig() {
        try {
            if ( sharedPreferences.contains(PACKAGE_NAME + PREF_KEY_CONFIG) ) {
                ObjectMapper mapper = new ObjectMapper();
                config = mapper.readValue(
                        sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CONFIG, "" ),
                        ServerConfig.class );
                updateAppSettingsMap(config);
                updateAllowedClassesSet(config);
            }
        } catch ( Exception e ) {
            e.printStackTrace();
        }
    }

    // Warning: this may return false if the launcher has been updated from older version
    public boolean isQrProvisioning() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_QR_PROVISIONING, false);
    }

    public boolean setQrProvisioning(boolean value) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_QR_PROVISIONING, value).commit();
    }

    public boolean isIntegratedProvisioningFlow() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_INTEGRATED_PROVISIONING_FLOW, false);
    }

    public boolean setIntegratedProvisioningFlow(boolean value) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_INTEGRATED_PROVISIONING_FLOW, value).commit();
    }

    public boolean isBaseUrlSet() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_BASE_URL, null ) != null;
    }

    public String getBaseUrl() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_BASE_URL, BuildConfig.BASE_URL );
    }

    public boolean setBaseUrl( String baseUrl ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_BASE_URL, baseUrl ).commit();
    }

    public String getSecondaryBaseUrl() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_SECONDARY_BASE_URL, BuildConfig.SECONDARY_BASE_URL );
    }

    public boolean setSecondaryBaseUrl( String secondaryBaseUrl ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_SECONDARY_BASE_URL, secondaryBaseUrl ).commit();
    }

    public String getServerProject() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_SERVER_PROJECT, BuildConfig.SERVER_PROJECT );
    }

    public boolean setServerProject( String serverProject ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_SERVER_PROJECT, serverProject ).commit();
    }

    public String getDeviceId() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_DEVICE_ID,"" );
    }

    public boolean setDeviceId( String deviceId ) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_DEVICE_ID, deviceId ).commit();
    }

    public String getExternalIp() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_IP_ADDRESS, "" );
    }

    public boolean setExternalIp( String externalIp ) {
        if (externalIp == null) {
            externalIp = "";
        }
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_IP_ADDRESS, externalIp ).commit();
    }

    public boolean isMainActivityRunning() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_ACTIVITY_RUNNING, false );
    }

    public boolean setMainActivityRunning(boolean running) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_ACTIVITY_RUNNING, running ).commit();
    }

    public boolean isRestoreLauncher() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_RESTORE_LAUNCHER, false);
    }

    public boolean setRestoreLauncher(boolean restore) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_RESTORE_LAUNCHER, restore ).commit();
    }

    public long getConfigUpdateTimestamp() {
        return sharedPreferences.getLong(PACKAGE_NAME + PREF_CFG_UPDATE_TIMESTAMP, 0);
    }

    public boolean setConfigUpdateTimestamp(long timestamp) {
        return sharedPreferences.edit().putLong(PACKAGE_NAME + PREF_CFG_UPDATE_TIMESTAMP, timestamp).commit();
    }

    public boolean setEnrollOptionCustomer(String customer) {
        if (customer == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_CUSTOMER).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CUSTOMER, customer ).commit();
        }
    }

    public String getEnrollOptionCustomer() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CUSTOMER, null);
    }

    public boolean setDeviceIdUse(String deviceIdUse) {
        if (deviceIdUse == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE, deviceIdUse ).commit();
        }
    }

    public String getDeviceIdUse() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_DEVICE_ID_USE, null);
    }

    public boolean setLastAppUpdateState(boolean lastAppUpdateState) {
        return sharedPreferences.edit().putBoolean(PACKAGE_NAME + PREF_KEY_LAST_APP_UPDATE_STATE, lastAppUpdateState).commit();
    }

    public boolean getLastAppUpdateState() {
        return sharedPreferences.getBoolean(PACKAGE_NAME + PREF_KEY_LAST_APP_UPDATE_STATE, false);
    }

    public boolean setAppStartTime(long time) {
        return sharedPreferences.edit().putLong(PACKAGE_NAME + PREF_KEY_APP_START_TIME, time).commit();
    }

    public long getAppStartTime() {
        return sharedPreferences.getLong(PACKAGE_NAME + PREF_KEY_APP_START_TIME, 0);
    }


    public boolean setSatelliteCount(int count) {
        return sharedPreferences.edit().putInt(PACKAGE_NAME + PREF_KEY_SATELLITE_COUNT, count).commit();
    }

    public int getSatelliteCount() {
        return sharedPreferences.getInt(PACKAGE_NAME + PREF_KEY_SATELLITE_COUNT, 0);
    }

    public boolean setEnrollOptionConfigName(String configName) {
        if (configName == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_CONFIG_NAME).commit();
        } else {
            return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CONFIG_NAME, configName ).commit();
        }
    }

    public String getEnrollOptionConfigName() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_CONFIG_NAME, null);
    }

    public boolean setEnrollOptionGroup(Set<String> group) {
        if (group == null) {
            return sharedPreferences.edit().remove(PACKAGE_NAME + PREF_KEY_GROUP).commit();
        } else {
            return sharedPreferences.edit().putStringSet(PACKAGE_NAME + PREF_KEY_GROUP, group).commit();
        }
    }

    public Set<String> getEnrollOptionGroup() {
        return sharedPreferences.getStringSet(PACKAGE_NAME + PREF_KEY_GROUP, null);
    }

    public boolean setUserCustom1(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_1, userCustom).commit();
    }

    public String getUserCustom1() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_1, null);
    }

    public boolean setUserCustom2(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_2, userCustom).commit();
    }

    public String getUserCustom2() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_2, null);
    }

    public boolean setUserCustom3(String userCustom) {
        return sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_3, userCustom).commit();
    }

    public String getUserCustom3() {
        return sharedPreferences.getString(PACKAGE_NAME + PREF_KEY_USER_CUSTOM_3, null);
    }

    public void updateConfig( ServerConfig config ) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            sharedPreferences.edit().putString(PACKAGE_NAME + PREF_KEY_CONFIG, objectMapper.writeValueAsString( config ) ).commit();
        } catch ( Exception e ) {
            e.printStackTrace();
            // Do not apply changes when there's an error while writing settings
            return;
        }
        updateAppSettingsMap(config);
        updateAllowedClassesSet(config);
        this.oldConfig = this.config;
        this.config = config;
    }

    public ServerConfig getConfig() {
        return config;
    }

    public void removeRemoteFile(RemoteFile remoteFile) {
        Iterator<RemoteFile> it = config.getFiles().iterator();
        while (it.hasNext()) {
            RemoteFile file = it.next();
            if ( file.getPath().equals( remoteFile.getPath() ) ) {
                it.remove();
                updateConfig(config);
                return;
            }
        }
    }

    public void removeApplication(Application application) {
        Iterator<Application> it = config.getApplications().iterator();
        while (it.hasNext()) {
            Application app = it.next();
            if (app.getPkg().equals(application.getPkg())) {
                it.remove();
                updateConfig(config);
                return;
            }
        }
    }

    public void removeApplicationUrl(Application application) {
        Iterator<Application> it = config.getApplications().iterator();
        while (it.hasNext()) {
            Application app = it.next();
            if (app.getPkg().equals(application.getPkg())) {
                app.setUrl(null);
                updateConfig(config);
                return;
            }
        }
    }

    private void updateAppSettingsMap(ServerConfig config) {
        if (config == null || config.getApplicationSettings() == null) {
            return;
        }
        appSettings.clear();
        for (ApplicationSetting setting : config.getApplicationSettings()) {
            String key = setting.getPackageId() + "." + setting.getName();
            appSettings.put(key, setting);
        }
    }

    private void updateAllowedClassesSet(ServerConfig config) {
        if (config == null || config.getAllowedClasses() == null) {
            return;
        }
        String[] allowedClassesList = config.getAllowedClasses().split(",");
        for (int n = 0; n < allowedClassesList.length; n++) {
            allowedClassesList[n] = allowedClassesList[n].trim();
        }
        // Is it thread-safe? Hopefully yes
        allowedClasses = new HashSet<>(Arrays.asList(allowedClassesList));
    }

    public String getAppPreference(String packageId, String attr) {
        String key = packageId + "." + attr;
        ApplicationSetting setting = appSettings.get(key);
        if (setting == null) {
            return null;
        }
        return setting.getValue();
    }

    public boolean setAppPreference(String packageId, String attr, String value) {
        String key = packageId + "." + attr;
        ApplicationSetting setting = appSettings.get(key);
        if (setting == null) {
            setting = new ApplicationSetting();
            setting.setPackageId(packageId);
            setting.setName(attr);
            setting.setType(1);     // 1 is string (default value)
            setting.setReadOnly(false);
            appSettings.put(key, setting);
        }
        if (setting.isReadOnly()) {
            return false;
        }
        setting.setValue(value);
        setting.setLastUpdate(System.currentTimeMillis());
        return true;
    }

    public void commitAppPreferences(String packageId) {
        // TODO: send new preferences to server
    }

    public Set<String> getAllowedClasses() {
        return allowedClasses;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/worker/PushNotificationProcessor.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.worker;

import android.content.Context;
import android.content.Intent;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Environment;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.DownloadTable;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.Download;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class PushNotificationProcessor {
    public static void process(PushMessage message, Context context) {
        RemoteLogger.log(context, Const.LOG_INFO, "Got Push Message, type " + message.getMessageType());
        if (message.getMessageType().equals(PushMessage.TYPE_CONFIG_UPDATED)) {
            // Update local configuration
            ConfigUpdater.notifyConfigUpdate(context);
            // The configUpdated should be broadcasted after the configuration update is completed
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_RUN_APP)) {
            // Run application
            runApplication(context, message.getPayloadJSON());
            // Do not broadcast this message to other apps
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_UNINSTALL_APP)) {
            // Uninstall application
            AsyncTask.execute(() -> uninstallApplication(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_DELETE_FILE)) {
            // Delete file
            AsyncTask.execute(() -> deleteFile(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_DELETE_DIR)) {
            // Delete directory recursively
            AsyncTask.execute(() -> deleteDir(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_PURGE_DIR)) {
            // Purge directory (delete all files recursively)
            AsyncTask.execute(() -> purgeDir(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_PERMISSIVE_MODE)) {
            // Turn on permissive mode
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_PERMISSIVE_MODE));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_RUN_COMMAND)) {
            // Run a command-line script
            AsyncTask.execute(() -> runCommand(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_REBOOT)) {
            // Reboot a device
            AsyncTask.execute(() -> reboot(context));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_EXIT_KIOSK)) {
            // Temporarily exit kiosk mode
            LocalBroadcastManager.getInstance(context).
                sendBroadcast(new Intent(Const.ACTION_EXIT_KIOSK));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_ADMIN_PANEL)) {
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_ADMIN_PANEL));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_CLEAR_DOWNLOADS)) {
            // Clear download history
            AsyncTask.execute(() -> clearDownloads(context));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_INTENT)) {
            // Run a system intent (like settings or ACTION_VIEW)
            AsyncTask.execute(() -> callIntent(context, message.getPayloadJSON()));
            return;
        } else if (message.getMessageType().equals(PushMessage.TYPE_GRANT_PERMISSIONS)) {
            // Grant permissions to apps
            AsyncTask.execute(() -> grantPermissions(context, message.getPayloadJSON()));
            return;
        }

        // Send broadcast to all plugins
        Intent intent = new Intent(Const.INTENT_PUSH_NOTIFICATION_PREFIX + message.getMessageType());
        JSONObject jsonObject = message.getPayloadJSON();
        if (jsonObject != null) {
            intent.putExtra(Const.INTENT_PUSH_NOTIFICATION_EXTRA, jsonObject.toString());
        }
        context.sendBroadcast(intent);
    }

    private static void runApplication(Context context, JSONObject payload) {
        if (payload == null) {
            return;
        }
        try {
            String pkg = payload.getString("pkg");
            String action = payload.optString("action", null);
            JSONObject extras = payload.optJSONObject("extra");
            String data = payload.optString("data", null);
            Intent launchIntent = context.getPackageManager().getLaunchIntentForPackage(pkg);
            if (launchIntent != null) {
                if (action != null) {
                    launchIntent.setAction(action);
                }
                if (data != null) {
                    try {
                        launchIntent.setData(Uri.parse(data));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (extras != null) {
                    Iterator<String> keys = extras.keys();
                    String key;
                    while (keys.hasNext()) {
                        key = keys.next();
                        Object value = extras.get(key);
                        if (value instanceof String) {
                            launchIntent.putExtra(key, (String) value);
                        } else if (value instanceof Integer) {
                            launchIntent.putExtra(key, ((Integer) value).intValue());
                        } else if (value instanceof Float) {
                            launchIntent.putExtra(key, ((Float) value).floatValue());
                        } else if (value instanceof Boolean) {
                            launchIntent.putExtra(key, ((Boolean) value).booleanValue());
                        }
                    }
                }

                // These magic flags are found in the source code of the default Android launcher
                // These flags preserve the app activity stack (otherwise a launch activity appears at the top which is not correct)
                launchIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
                        Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
                context.startActivity(launchIntent);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void uninstallApplication(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: no package specified");
            return;
        }
        if (!Utils.isDeviceOwner(context)) {
            // Require device owner for non-interactive uninstallation
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: no device owner");
            return;
        }

        try {
            String pkg = payload.getString("pkg");
            InstallUtils.silentUninstallApplication(context, pkg);
            RemoteLogger.log(context, Const.LOG_INFO, "Uninstalled application: " + pkg);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Uninstall request failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void deleteFile(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "File delete failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            file.delete();
            RemoteLogger.log(context, Const.LOG_INFO, "Deleted file: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "File delete failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void deleteRecursive(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory()) {
            File[] childFiles = fileOrDirectory.listFiles();
            for (File child : childFiles) {
                deleteRecursive(child);
            }
        }
        fileOrDirectory.delete();
    }

    private static void deleteDir(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory delete failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            deleteRecursive(file);
            RemoteLogger.log(context, Const.LOG_INFO, "Deleted directory: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory delete failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void purgeDir(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: no path specified");
            return;
        }

        try {
            String path = payload.getString("path");
            File file = new File(Environment.getExternalStorageDirectory(), path);
            if (!file.isDirectory()) {
                RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: not a directory: " + path);
                return;
            }
            String recursive = payload.optString("recursive");
            File[] childFiles = file.listFiles();
            for (File child : childFiles) {
                if (recursive == null || !recursive.equals("1")) {
                    if (!child.isDirectory()) {
                        child.delete();
                    }
                } else {
                    deleteRecursive(child);
                }
            }
            RemoteLogger.log(context, Const.LOG_INFO, "Purged directory: " + path);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Directory purge failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void runCommand(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Command failed: no command specified");
            return;
        }

        try {
            String command = payload.getString("command");
            Log.d(Const.LOG_TAG, "Executing a command: " + command);
            String result = SystemUtils.executeShellCommand(command, true);
            String msg = "Executed a command: " + command;
            if (!result.equals("")) {
                if (result.length() > 200) {
                    result = result.substring(0, 200) + "...";
                }
                msg += " Result: " + result;
            }
            RemoteLogger.log(context, Const.LOG_DEBUG, msg);

        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Command failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void reboot(Context context) {
        RemoteLogger.log(context, Const.LOG_WARN, "Rebooting by a Push message");
        if (Utils.checkAdminMode(context)) {
            if (!Utils.reboot(context)) {
                RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed");
            }
        } else {
            RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed: no permissions");
        }
    }

    private static void clearDownloads(Context context) {
        RemoteLogger.log(context, Const.LOG_WARN, "Clear download history by a Push message");
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        SQLiteDatabase db = dbHelper.getWritableDatabase();
        List<Download> downloads = DownloadTable.selectAll(db);
        for (Download d: downloads) {
            File file = new File(d.getPath());
            try {
                file.delete();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        DownloadTable.deleteAll(db);
    }

    private static void callIntent(Context context, JSONObject payload) {
        if (payload == null) {
            RemoteLogger.log(context, Const.LOG_WARN, "Calling intent failed: no parameters specified");
            return;
        }

        try {
            String action = payload.getString("action");
            Log.d(Const.LOG_TAG, "Calling intent: " + action);
            JSONObject extras = payload.optJSONObject("extra");
            String data = payload.optString("data", null);
            Intent i = new Intent(action);
            if (data != null) {
                try {
                    i.setData(Uri.parse(data));
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            if (extras != null) {
                Iterator<String> keys = extras.keys();
                String key;
                while (keys.hasNext()) {
                    key = keys.next();
                    Object value = extras.get(key);
                    if (value instanceof String) {
                        i.putExtra(key, (String) value);
                    } else if (value instanceof Integer) {
                        i.putExtra(key, ((Integer) value).intValue());
                    } else if (value instanceof Float) {
                        i.putExtra(key, ((Float) value).floatValue());
                    } else if (value instanceof Boolean) {
                        i.putExtra(key, ((Boolean) value).booleanValue());
                    }
                }
            }
            i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
            i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(i);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_WARN, "Calling intent failed: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void grantPermissions(Context context, JSONObject payload) {
        if (!Utils.isDeviceOwner(context) && !BuildConfig.SYSTEM_PRIVILEGES) {
            RemoteLogger.log(context, Const.LOG_WARN, "Can't auto grant permissions: no device owner");
        }

        ServerConfig config = SettingsHelper.getInstance(context).getConfig();
        List<String> apps = null;

        if (payload != null) {
            apps = new LinkedList<>();
            String pkg;
            JSONArray pkgs = payload.optJSONArray("pkg");
            if (pkgs != null) {
                for (int i = 0; i < pkgs.length(); i++) {
                    pkg = pkgs.optString(i);
                    if (pkg != null) {
                        apps.add(pkg);
                    }
                }
            } else {
                pkg = payload.optString("pkg");
                if (pkg != null) {
                    apps.add(pkg);
                }
            }
        } else {
            // By default, grant permissions to all packagee having an URL
            apps = new LinkedList<>();
            List<Application> configApps = config.getApplications();
            for (Application app: configApps) {
                if (Application.TYPE_APP.equals(app.getType()) &&
                    app.getUrl() != null && app.getPkg() != null) {
                    apps.add(app.getPkg());
                }
            }
        }

        for (String app: apps) {
            Utils.autoGrantRequestedPermissions(context, app,
                    config.getAppPermissions(), false);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/Const.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher;

public class Const {

    public static final int TASK_SUCCESS = 0;
    public static final int TASK_ERROR = 1;
    public static final int TASK_NETWORK_ERROR = 2;

    public static final String ACTION_SERVICE_STOP = "SERVICE_STOP";
    public static final String ACTION_SHOW_LAUNCHER = "SHOW_LAUNCHER";
    public static final String ACTION_ENABLE_SETTINGS = "ENABLE_SETTINGS";
    public static final String ACTION_PERMISSIVE_MODE = "PERMISSIVE_MODE";          // Temporary action
    public static final String ACTION_TOGGLE_PERMISSIVE = "TOGGLE_PERMISSIVE";      // Permanent action
    public static final String ACTION_EXIT_KIOSK = "EXIT_KIOSK";
    public static final String ACTION_ADMIN_PANEL = "ADMIN_PANEL";
    public static final String ACTION_STOP_CONTROL = "STOP_CONTROL";
    public static final String ACTION_EXIT = "EXIT";
    public static final String ACTION_HIDE_SCREEN = "HIDE_SCREEN";
    public static final String ACTION_UPDATE_CONFIGURATION = "UPDATE_CONFIGURATION";
    public static final String ACTION_POLICY_VIOLATION = "ACTION_POLICY_VIOLATION";
    public static final String ACTION_ADMIN = "ADMIN";
    public static final String ACTION_INSTALL_COMPLETE = "INSTALL_COMPLETE";
    public static final String ACTION_DISABLE_BLOCK_WINDOW = "DISABLE_BLOCK_WINDOW";

    public static final String EXTRA_ENABLED = "ENABLED";

    public static long CONNECTION_TIMEOUT = 10000;
    public static long LONG_POLLING_READ_TIMEOUT = 300000;
    public static final String STATUS_OK = "OK";
    public static final String ORIENTATION = "ORIENTATION";
    public static final String PACKAGE_NAME = "PACKAGE_NAME";
    public static final String POLICY_VIOLATION_CAUSE = "POLICY_VIOLATION_CAUSE";
    public static final String RESTORED_ACTIVITY = "RESTORED_ACTIVITY";

    public static final int GPS_ON_REQUIRED = 1;
    public static final int GPS_OFF_REQUIRED = 2;
    public static final int MOBILE_DATA_ON_REQUIRED = 3;
    public static final int MOBILE_DATA_OFF_REQUIRED = 4;

    public static final String PREFERENCES = "PREFERENCES";

    public static final int PREFERENCES_ON = 1;
    public static final int PREFERENCES_OFF = 0;

    public static final String PREFERENCES_ADMINISTRATOR = "PREFERENCES_ADMINISTRATOR";
    public static final String PREFERENCES_OVERLAY = "PREFERENCES_OVERLAY";
    public static final String PREFERENCES_USAGE_STATISTICS = "PREFERENCES_USAGE_STATISTICS";
    public static final String PREFERENCES_MANAGE_STORAGE = "PREFERENCES_MANAGE_STORAGE";
    public static final String PREFERENCES_ACCESSIBILITY_SERVICE = "PREFERENCES_ACCESSIBILITY_SERVICE";
    public static final String PREFERENCES_DEVICE_OWNER = "PREFERENCES_DEVICE_OWNER";
    public static final String PREFERENCES_UNKNOWN_SOURCES = "PREFERENCES_UNKNOWN_SOURCES";
    public static final String PREFERENCES_DISABLE_LOCATION = "PREFERENCES_DISABLE_LOCATION";
    public static final String PREFERENCES_MIUI_PERMISSIONS = "PREFERENCES_MIUI_PERMISSIONS";
    public static final String PREFERENCES_MIUI_DEVELOPER = "PREFERENCES_MIUI_DEVELOPER";
    public static final String PREFERENCES_MIUI_OPTIMIZATION = "PREFERENCES_MIUI_OPTIMIZATION";
    public static final String PREFERENCES_LOG_STRING = "PREFERENCES_LOG_STRING";
    public static final String PREFERENCES_DATA_TOKEN = "PREFERENCES_DATA_TOKEN";

    public static final int MIUI_PERMISSIONS = 0;
    public static final int MIUI_DEVELOPER = 1;
    public static final int MIUI_OPTIMIZATION = 2;

    public static final String LOG_TAG = "HeadwindMDM";

    public static final int SETTINGS_UNBLOCK_TIME = 180000;
    public static final int PERMISSIVE_MODE_TIME = 180000;

    public static final String LAUNCHER_RESTARTER_PACKAGE_ID = "com.hmdm.emuilauncherrestarter";
    public static final String LAUNCHER_RESTARTER_OLD_VERSION = "oldVersion";
    public static final String LAUNCHER_RESTARTER_STOP = "stop";

    public static final String SETTINGS_PACKAGE_NAME = "com.android.settings";
    public static final String GSF_PACKAGE_NAME = "com.google.android.gsf";
    public static final String SYSTEM_UI_PACKAGE_NAME = "com.android.systemui";
    public static final String KIOSK_BROWSER_PACKAGE_NAME = "com.hmdm.kiosk";
    public static final String APUPPET_PACKAGE_NAME = "com.hmdm.control";
    public static final String APUPPET_SERVICE_CLASS_NAME = "com.hmdm.control.GestureDispatchService";

    public static final String QR_BASE_URL_ATTR = "com.hmdm.BASE_URL";
    public static final String QR_SECONDARY_BASE_URL_ATTR = "com.hmdm.SECONDARY_BASE_URL";
    public static final String QR_SERVER_PROJECT_ATTR = "com.hmdm.SERVER_PROJECT";
    public static final String QR_DEVICE_ID_ATTR = "com.hmdm.DEVICE_ID";
    public static final String QR_LEGACY_DEVICE_ID_ATTR = "ru.headwind.kiosk.DEVICE_ID";
    public static final String QR_DEVICE_ID_USE_ATTR = "com.hmdm.DEVICE_ID_USE";
    public static final String QR_CUSTOMER_ATTR = "com.hmdm.CUSTOMER";
    public static final String QR_CONFIG_ATTR = "com.hmdm.CONFIG";
    public static final String QR_GROUP_ATTR = "com.hmdm.GROUP";
    public static final String QR_OPEN_WIFI_ATTR = "com.hmdm.OPEN_WIFI";
    public static final String QR_WORK_PROFILE_ATTR = "com.hmdm.WORK_PROFILE";

    public static final int KIOSK_UNLOCK_CLICK_COUNT = 4;

    public static final String INTENT_PUSH_NOTIFICATION_PREFIX = "com.hmdm.push.";
    public static final String INTENT_PUSH_NOTIFICATION_EXTRA = "com.hmdm.PUSH_DATA";

    public static final String WORK_TAG_COMMON = "com.hmdm.launcher";

    public static final String DEVICE_CHARGING_USB = "usb";
    public static final String DEVICE_CHARGING_AC = "ac";

    public static final String WIFI_STATE_FAILED = "failed";
    public static final String WIFI_STATE_INACTIVE = "inactive";
    public static final String WIFI_STATE_SCANNING = "scanning";
    public static final String WIFI_STATE_DISCONNECTED = "disconnected";
    public static final String WIFI_STATE_CONNECTING = "connecting";
    public static final String WIFI_STATE_CONNECTED = "connected";

    public static final String GPS_STATE_INACTIVE = "inactive";
    public static final String GPS_STATE_LOST = "lost";
    public static final String GPS_STATE_ACTIVE = "active";

    public static final String MOBILE_STATE_INACTIVE = "inactive";
    public static final String MOBILE_STATE_DISCONNECTED = "disconnected";
    public static final String MOBILE_STATE_CONNECTED = "connected";

    public static final String MOBILE_SIMSTATE_UNKNOWN = "unknown";
    public static final String MOBILE_SIMSTATE_ABSENT = "absent";
    public static final String MOBILE_SIMSTATE_PIN_REQUIRED = "pinRequired";
    public static final String MOBILE_SIMSTATE_PUK_REQUIRED = "pukRequired";
    public static final String MOBILE_SIMSTATE_LOCKED = "locked";
    public static final String MOBILE_SIMSTATE_READY = "ready";
    public static final String MOBILE_SIMSTATE_NOT_READY = "notReady";
    public static final String MOBILE_SIMSTATE_DISABLED = "disabled";
    public static final String MOBILE_SIMSTATE_ERROR = "error";
    public static final String MOBILE_SIMSTATE_RESTRICTED = "restricted";

    public static final int LOG_ERROR = 1;
    public static final int LOG_WARN = 2;
    public static final int LOG_INFO = 3;
    public static final int LOG_DEBUG = 4;
    public static final int LOG_VERBOSE = 5;

    public static final String PASSWORD_QUALITY_PRESENT = "present";
    public static final String PASSWORD_QUALITY_EASY = "easy";
    public static final String PASSWORD_QUALITY_MODERATE = "moderate";
    public static final String PASSWORD_QUALITY_STRONG = "strong";

    public static final String HEADER_IP_ADDRESS = "X-IP-Address";
    public static final String HEADER_RESPONSE_SIGNATURE = "X-Response-Signature";

    public static final int SCREEN_ORIENTATION_PORTRAIT = 1;
    public static final int SCREEN_ORIENTATION_LANDSCAPE = 2;

    public static final int DIRECTION_LEFT = 0;
    public static final int DIRECTION_RIGHT = 1;
    public static final int DIRECTION_UP = 2;
    public static final int DIRECTION_DOWN = 3;

    public static final int DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC = 300;
    public static final int DEFAULT_PUSH_WORKER_KEEPALIVE_TIME_SEC = 900;
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/BaseActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.annotation.SuppressLint;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Handler;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.view.inputmethod.InputMethodManager;
import android.widget.ArrayAdapter;
import android.widget.Toast;

import androidx.appcompat.app.AppCompatActivity;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.google.zxing.integration.android.IntentIntegrator;
import com.google.zxing.integration.android.IntentResult;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.DialogDeviceInfoBinding;
import com.hmdm.launcher.databinding.DialogEnterDeviceIdBinding;
import com.hmdm.launcher.databinding.DialogEnterServerBinding;
import com.hmdm.launcher.databinding.DialogNetworkErrorBinding;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.DeviceEnrollOptions;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.server.ServerUrl;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.Utils;

import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

import okhttp3.HttpUrl;

public class BaseActivity extends AppCompatActivity {

    protected ProgressDialog progressDialog;

    protected Dialog enterServerDialog;
    protected DialogEnterServerBinding dialogEnterServerBinding;

    protected Dialog enterDeviceIdDialog;
    protected DialogEnterDeviceIdBinding enterDeviceIdDialogBinding;

    protected Dialog networkErrorDialog;
    protected DialogNetworkErrorBinding dialogNetworkErrorBinding;
    protected String networkErrorDetails;

    protected Dialog deviceInfoDialog;
    protected DialogDeviceInfoBinding dialogDeviceInfoBinding;

    protected void dismissDialog(Dialog dialog) {
        if (dialog != null) {
            try {
                dialog.dismiss();
            } catch (Exception ignored) {
            }
        }
    }

    protected void createAndShowEnterDeviceIdDialog( boolean error, String deviceId ) {
        dismissDialog(enterDeviceIdDialog);
        enterDeviceIdDialog = new Dialog( this );
        enterDeviceIdDialogBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_device_id,
                null,
                false );
        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        String serverUrl = settingsHelper.getBaseUrl();
        String serverPath = settingsHelper.getServerProject();
        if (serverPath.length() > 0) {
            serverUrl += "/" + serverPath;
        }
        enterDeviceIdDialogBinding.deviceIdPrompt.setText(getString(R.string.dialog_enter_device_id_title, serverUrl));
        enterDeviceIdDialogBinding.deviceIdError.setText(getString(R.string.dialog_enter_device_id_error, serverUrl));
        enterDeviceIdDialogBinding.setError( error );
        enterDeviceIdDialog.setCancelable( false );
        enterDeviceIdDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        if (deviceId != null) {
            enterDeviceIdDialogBinding.deviceId.setText(deviceId);
        }

        // Suggest IMEI as ID is an option which could be turned on in the build settings
        // Don't use this by default because the device ID must not be bound to IMEI:
        // if it's bound to IMEI, it becomes difficult to replace the device
        List<String> variantsList = new ArrayList<>();
        if (!BuildConfig.DEVICE_ID_CHOICE.equals("user")) {
            Utils.autoGrantPhonePermission(this);
            String imei = DeviceInfoProvider.getImei(this);
            if (imei != null) {
                variantsList.add(imei);
            }
            String serial = DeviceInfoProvider.getSerialNumber();
            if (serial != null && !serial.equals(Build.UNKNOWN)) {
                variantsList.add(serial);
            }
        }
        if (variantsList.size() > 0) {
            String[] variantsArray = variantsList.toArray(new String[variantsList.size()]);
            enterDeviceIdDialogBinding.deviceId.setThreshold(0);
            enterDeviceIdDialogBinding.deviceId.setAdapter(new ArrayAdapter<String>(this,
                    android.R.layout.select_dialog_item, variantsArray));
        } else {
            enterDeviceIdDialogBinding.showDeviceIdVariants.setVisibility(View.GONE);
        }

        enterDeviceIdDialogBinding.showDeviceIdQrCode.setVisibility(View.VISIBLE);

        enterDeviceIdDialog.setContentView( enterDeviceIdDialogBinding.getRoot() );
        enterDeviceIdDialog.setOnShowListener(dialog -> {
            enterDeviceIdDialogBinding.deviceId.requestFocus();
        });
        enterDeviceIdDialogBinding.deviceId.setOnFocusChangeListener((view, hasFocus) -> {
            if (hasFocus) {
                InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
            }
        });
        enterDeviceIdDialog.show();
    }

    public void showDeviceIdVariants(View view) {
        enterDeviceIdDialogBinding.deviceId.showDropDown();
    }

    public void showDeviceIdQrCode(View view) {
        IntentIntegrator integrator = new IntentIntegrator(this);
        integrator.setOrientationLocked(false);
        integrator.initiateScan();
    }

    public void showErrorDetails(View view) {
        ErrorDetailsActivity.display(this, networkErrorDetails, false);
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        try {
            IntentResult result = IntentIntegrator.parseActivityResult(requestCode, resultCode, data);
            if (result != null) {
                if (result.getContents() != null) {
                    updateSettingsFromQr(result.getContents());
                }
            } else {
                Log.d(Const.LOG_TAG, "Failed to parse QR code!");
                super.onActivityResult(requestCode, resultCode, data);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    protected void updateSettingsFromQr(String qrcode) {
        try {
            Log.d(Const.LOG_TAG, "Get initial settings from the QR code");
            SettingsHelper settingsHelper = SettingsHelper.getInstance(getApplicationContext());
            JSONObject qr = new JSONObject(qrcode);
            JSONObject extras = qr.getJSONObject(DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);

            String deviceId = extras.optString(Const.QR_DEVICE_ID_ATTR, null);
            if (deviceId == null) {
                // Also let's try legacy attribute
                deviceId = extras.optString(Const.QR_LEGACY_DEVICE_ID_ATTR, null);
            }
            if (deviceId != null) {
                Log.d(Const.LOG_TAG, "Device ID: " + deviceId);
                settingsHelper.setDeviceId(deviceId);
            } else {
                Log.d(Const.LOG_TAG, "Device ID is null");
                String deviceIdUse = extras.optString(Const.QR_DEVICE_ID_USE_ATTR, null);
                if (deviceIdUse != null) {
                    Log.d(Const.LOG_TAG, "Device ID use: " + deviceIdUse);
                    // Save for further automatic choice of the device ID
                    settingsHelper.setDeviceIdUse(deviceIdUse);
                }
            }

            String baseUrl = extras.optString(Const.QR_BASE_URL_ATTR, null);
            String secondaryBaseUrl = extras.optString(Const.QR_SECONDARY_BASE_URL_ATTR, null);
            if (baseUrl != null) {
                Log.d(Const.LOG_TAG, "Base URL: " + baseUrl);
                settingsHelper.setBaseUrl(baseUrl);
                // If we don't set the secondary base URL, it will point to app.h-mdm.com by default which is wrong
                if (secondaryBaseUrl == null) {
                    secondaryBaseUrl = baseUrl;
                }
            }
            if (secondaryBaseUrl != null) {
                Log.d(Const.LOG_TAG, "Secondary base URL: " + baseUrl);
                settingsHelper.setSecondaryBaseUrl(secondaryBaseUrl);
            }

            String serverProject = extras.optString(Const.QR_SERVER_PROJECT_ATTR, null);
            if (serverProject != null) {
                Log.d(Const.LOG_TAG, "Project path: " + serverProject);
                settingsHelper.setServerProject(serverProject);
            }

            DeviceEnrollOptions createOptions = new DeviceEnrollOptions();
            createOptions.setCustomer(extras.optString(Const.QR_CUSTOMER_ATTR, null));
            createOptions.setConfiguration(extras.optString(Const.QR_CONFIG_ATTR, null));
            createOptions.setGroups(extras.optString(Const.QR_GROUP_ATTR, null));
            if (createOptions.getCustomer() != null) {
                Log.d(Const.LOG_TAG, "Customer: " + createOptions.getCustomer());
                settingsHelper.setEnrollOptionCustomer(createOptions.getCustomer());
            }
            if (createOptions.getConfiguration() != null) {
                Log.d(Const.LOG_TAG, "Configuration: " + createOptions.getConfiguration());
                settingsHelper.setEnrollOptionConfigName(createOptions.getConfiguration());
            }
            if (createOptions.getGroups() != null) {
                settingsHelper.setEnrollOptionGroup(createOptions.getGroupSet());
            }

        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Invalid QR code contents, got an exception!");
            e.printStackTrace();
            Toast.makeText(this, getString(R.string.qrcode_contents_error,
                    getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
        }
    }

    public void exitDeviceId(View view) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            finishAffinity();
        }
        System.exit(0);
    }

    protected String concatenateServerUrl(String serverName, String serverPath) {
        String serverUrl = serverName;
        if (serverPath != null && serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        return serverUrl;
    }

    protected void createAndShowNetworkErrorDialog(String serverName,
                                                   String serverPath,
                                                   String errorDetails,
                                                   boolean showResetButton,
                                                   boolean showWifiButton) {
        dismissDialog(networkErrorDialog);
        networkErrorDialog = new Dialog( this );
        dialogNetworkErrorBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_network_error,
                null,
                false );
        networkErrorDialog.setCancelable( false );
        networkErrorDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        networkErrorDetails = errorDetails;

        String serverUrl = serverName;
        if (serverPath != null && serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        dialogNetworkErrorBinding.title.setText(getString(R.string.dialog_network_error_title, serverUrl));

        dialogNetworkErrorBinding.resetButton.setVisibility(showResetButton ? View.VISIBLE : View.GONE);
        dialogNetworkErrorBinding.wifiButton.setVisibility(showWifiButton ? View.VISIBLE : View.GONE);

        networkErrorDialog.setContentView( dialogNetworkErrorBinding.getRoot() );
        try {
            networkErrorDialog.show();
        } catch (Exception e) {
            // Unable to add window -- token is not valid; is your activity running?
            e.printStackTrace();
        }
    }


    protected void createAndShowServerDialog(boolean error, String serverName, String serverPath) {
        dismissDialog(enterServerDialog);
        enterServerDialog = new Dialog( this );
        dialogEnterServerBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_server,
                null,
                false );
        dialogEnterServerBinding.setError(error);
        enterServerDialog.setCancelable(false);
        enterServerDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        String serverUrl = serverName;
        if (serverPath.length() > 0) {
            serverUrl += "/";
            serverUrl += serverPath;
        }
        dialogEnterServerBinding.setServer(serverUrl);

        enterServerDialog.setContentView( dialogEnterServerBinding.getRoot() );
        enterServerDialog.setOnShowListener(dialog -> {
            dialogEnterServerBinding.serverUrl.requestFocus();
        });
        dialogEnterServerBinding.serverUrl.setOnFocusChangeListener((view, hasFocus) -> {
            if (hasFocus) {
                InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
            }
        });
        enterServerDialog.show();
    }

    public boolean saveServerUrlBase() {
        String serverUrl = dialogEnterServerBinding.serverUrl.getText().toString();
        if ( "".equals( serverUrl ) ) {
            dialogEnterServerBinding.setError(true);
            return false;
        } else {
            ServerUrl url = null;
            try {
                url = new ServerUrl(serverUrl);

                // Retrofit uses HttpUrl!
                HttpUrl httpUrl = HttpUrl.parse(serverUrl);
                if (httpUrl == null) {
                    // Malformed URL
                    dialogEnterServerBinding.setError(true);
                    return false;
                }
            } catch (Exception e) {
                // Malformed URL
                dialogEnterServerBinding.setError(true);
                return false;
            }

            SettingsHelper settingsHelper = SettingsHelper.getInstance( this );
            settingsHelper.setBaseUrl(url.baseUrl);
            settingsHelper.setSecondaryBaseUrl(url.baseUrl);
            settingsHelper.setServerProject(url.serverProject);
            dialogEnterServerBinding.setError( false );

            dismissDialog(enterServerDialog);

            Log.i(Const.LOG_TAG, "saveServerUrl(): calling updateConfig()");
            return true;
        }
    }

    @SuppressLint( { "MissingPermission" } )
    protected void createAndShowInfoDialog() {
        dismissDialog(deviceInfoDialog);
        deviceInfoDialog = new Dialog( this );
        dialogDeviceInfoBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_device_info,
                null,
                false );
        deviceInfoDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        deviceInfoDialog.setCancelable( false );

        deviceInfoDialog.setContentView( dialogDeviceInfoBinding.getRoot() );

        dialogDeviceInfoBinding.setSerialNumber(DeviceInfoProvider.getSerialNumber());

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);

        String phone = DeviceInfoProvider.getPhoneNumber(this);
        if (phone == null || phone.equals("")) {
            phone = settingsHelper.getConfig() != null ? settingsHelper.getConfig().getPhone() : "";
        }
        dialogDeviceInfoBinding.setPhone(phone);

        String imei = DeviceInfoProvider.getImei(this);
        if (imei == null || imei.equals("")) {
            imei = settingsHelper.getConfig() != null ? settingsHelper.getConfig().getImei() : "";
        }
        dialogDeviceInfoBinding.setImei(imei);

        dialogDeviceInfoBinding.setDeviceId(SettingsHelper.getInstance(this).getDeviceId());
        dialogDeviceInfoBinding.setVersion(BuildConfig.VERSION_NAME + "-" + Utils.getLauncherVariant());

        String serverPath = SettingsHelper.getInstance(this).getServerProject();
        if (serverPath.length() > 0) {
            serverPath = "/" + serverPath;
        }
        dialogDeviceInfoBinding.setServerUrl(SettingsHelper.getInstance(this).getBaseUrl() + serverPath);

        deviceInfoDialog.show();
    }

    public void closeDeviceInfoDialog( View view ) {
        dismissDialog(deviceInfoDialog);
    }


    public void exitToSystemLauncher( View view ) {
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_SERVICE_STOP ) );
        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_EXIT ) );

        // One second delay is required to avoid race between opening a forbidden activity and stopping the locked mode
        progressDialog = new ProgressDialog(this);
        progressDialog.setCancelable(false);
        progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
        progressDialog.setMessage(getString(R.string.switch_off_blockings));
        progressDialog.show();

        SettingsHelper settingsHelper = SettingsHelper.getInstance(this);
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            ServerConfig config = settingsHelper.getConfig();
            if (config.getRestrictions() != null && !config.getRestrictions().trim().equals("")) {
                Utils.releaseUserRestrictions(this, config.getRestrictions());
            }
        }

        new Handler().postDelayed(new Runnable() {
            @Override
            public void run() {
                if (progressDialog != null) {
                    progressDialog.dismiss();
                    progressDialog = null;
                }

                openLauncherChoiceDialog();
            }
        }, 1000);
    }

    protected void openLauncherChoiceDialog() {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        startActivity(Intent.createChooser(intent, getString(R.string.select_system_launcher, getString(R.string.white_app_name))));
    }

}
</file>

<file path="app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!-- -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:sharedUserId="com.hmdm">

    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="29"/>
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<!-- This permission is dangerous and causes blocking by Play Protect in some countries.
     In fact, this permission is currently never used by Headwind MDM.
 -->
<!--    <uses-permission android:name="android.permission.READ_SMS"/>-->
    <uses-permission android:name="android.permission.READ_PHONE_NUMBERS"/>
    <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE"
        tools:ignore="ProtectedPermissions"/>

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>


    <uses-permission android:name="android.permission.GET_TASKS"/>
    <uses-permission android:name="android.permission.PACKAGE_USAGE_STATS"
                     tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.INJECT_EVENTS"
        tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES"/>
    <uses-permission android:name="android.permission.REQUEST_DELETE_PACKAGES"/>
    <uses-permission android:name="android.permission.BLUETOOTH" android:required="false" android:maxSdkVersion="30"/>
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" android:required="false" android:maxSdkVersion="30"/>
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" android:required="false"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION"/>
    <uses-permission android:name="com.mediatek.permission.CTA_ENABLE_WIFI"/>
    <uses-permission android:name="com.mediatek.permission.CTA_ENABLE_BT"/>
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"
        tools:ignore="QueryAllPackagesPermission"/>
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SYSTEM_EXEMPTED" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_LOCATION" />
    <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
    <uses-permission android:name="android.permission.REQUEST_PASSWORD_COMPLEXITY" />
    <uses-permission android:name="android.permission.MASTER_CLEAR"
        tools:ignore="ProtectedPermissions"/>
    <uses-permission android:name="android.permission.WRITE_SETTINGS"
        tools:ignore="ProtectedPermissions"/>

    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_AIRPLANE_MODE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_APPS_CONTROL" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_AUDIO_OUTPUT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_BLUETOOTH" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_CALLS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_CERTIFICATES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_DEBUGGING_FEATURES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_DISPLAY" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_FACTORY_RESET" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_FUN" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_INSTALL_UNKNOWN_SOURCES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCALE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCATION" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_LOCK_CREDENTIALS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MICROPHONE" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MOBILE_NETWORK" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_MODIFY_USERS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_NEARBY_COMMUNICATION" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_OVERRIDE_APN" />  <!-- for com.hmdm.apn plugin -->
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_PHYSICAL_MEDIA" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_PRINTING" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_RESET_PASSWORD" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_RESTRICT_PRIVATE_DNS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SAFE_BOOT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SCREEN_CONTENT" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SMS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SYSTEM_UPDATES" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_SYSTEM_DIALOGS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_TIME" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_USB_FILE_TRANSFER" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_VPN" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WALLPAPER" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WIFI" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WINDOWS" />
    <uses-permission android:name="android.permission.MANAGE_DEVICE_POLICY_WIPE_DATA" />

    <uses-sdk tools:overrideLibrary="com.google.zxing.client.android" />

    <uses-feature android:name="android.hardware.telephony" android:required="false" />
    <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
    <uses-feature android:name="android.software.leanback" android:required="false" />

    <application
        android:icon="@mipmap/ic_launcher"
        android:label="@string/white_app_name"
        android:supportsRtl="true"
        android:requestLegacyExternalStorage="true"
        android:usesCleartextTraffic="true"
        android:networkSecurityConfig="@xml/network_security_config"
        android:theme="@style/AppTheme"
        android:name=".App"
        android:hardwareAccelerated="true"
        tools:ignore="GoogleAppIndexingWarning">

        <activity
            android:name=".ui.MainActivity"
            android:launchMode="singleInstance"
            android:banner="@drawable/banner"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <action android:name="android.app.action.PROVISIONING_SUCCESSFUL"/>

                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.HOME" />
            </intent-filter>
        </activity>
        <activity
            android:name="io.flutter.embedding.android.FlutterActivity"
            android:theme="@style/AppTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize"
            />
        <activity 
            android:name=".ui.AdminActivity"
            android:excludeFromRecents="true" 
            android:exported="false"
        />
        <activity
            android:name=".ui.AdminModeRequestActivity"
            android:excludeFromRecents="true"
            android:exported="false"
            />

        <activity
            android:name="com.journeyapps.barcodescanner.CaptureActivity"
            android:screenOrientation="fullSensor"
            tools:replace="screenOrientation" 
            android:exported="false"/>

        <activity
            android:name=".ui.InitialSetupActivity"
            android:theme="@style/SetupWizardTheme"
            android:permission="android.permission.BIND_DEVICE_ADMIN"
            android:exported="true">
            <intent-filter>
                <action android:name="android.app.action.ADMIN_POLICY_COMPLIANCE" />
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.MdmChoiceSetupActivity"
            android:theme="@style/SetupWizardTheme"
            android:permission="android.permission.BIND_DEVICE_ADMIN"
            android:exported="true">
            <intent-filter>
                <action android:name="android.app.action.GET_PROVISIONING_MODE" />
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </activity>

        <activity
            android:name=".ui.ErrorDetailsActivity"
            android:theme="@style/SetupWizardTheme" 
            android:exported="false"/>

        <receiver
            android:name="com.hmdm.launcher.AdminReceiver"
            android:label="@string/white_app_name"
            android:exported="true"
            android:permission="android.permission.BIND_DEVICE_ADMIN">
            <meta-data
                android:name="android.app.device_admin"
                android:resource="@xml/device_admin" />

            <intent-filter>
                <action android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
                <action android:name="android.app.action.PROFILE_PROVISIONING_COMPLETE" />
            </intent-filter>
        </receiver>

        <receiver android:name="com.hmdm.launcher.receiver.SimChangedReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.SIM_STATE_CHANGED"/>
            </intent-filter>
        </receiver>

        <receiver android:name="com.hmdm.launcher.receiver.ShutdownReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.ACTION_SHUTDOWN" />
                <action android:name="android.intent.action.QUICKBOOT_POWEROFF" />
            </intent-filter>
        </receiver>

        <receiver
            android:name="com.hmdm.launcher.receiver.BootReceiver"
            android:label="BootReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter>
                <category android:name="android.intent.category.DEFAULT"/>
                <action android:name="android.intent.action.BOOT_COMPLETED"/>
                <action android:name="android.intent.action.QUICKBOOT_POWERON"/>
                <!--For HTC devices-->
                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON"/>
            </intent-filter>
        </receiver>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths"/>
        </provider>

        <service android:name=".pro.service.CheckForegroundApplicationService"
            android:exported="true"/>

        <service android:name=".service.PluginApiService" android:enabled="true" android:exported="true">
            <intent-filter>
                <action android:name="com.hmdm.action.Connect" />
            </intent-filter>
        </service>
        <service
            android:name="id.flutter.flutter_background_service.BackgroundService"
            android:foregroundServiceType="location" />

        <!-- Stub -->
        <service android:name=".pro.service.CheckForegroundAppAccessibilityService"
                 android:exported="false"/>

        <service android:name="org.eclipse.paho.android.service.MqttService"
            android:foregroundServiceType="specialUse|systemExempted"
            android:exported="false">
            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="Push notification service"/>
        </service>

        <service android:name=".service.LocationService"
            android:foregroundServiceType="location"
            android:exported="false"/>

        <service android:name=".service.StatusControlService"
            android:exported="false"/>

        <service android:name=".service.PushLongPollingService"
            android:foregroundServiceType="specialUse|systemExempted"
            android:exported="false">
            <property android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="Push notification service"/>
        </service>

    </application>

</manifest>
</file>

<file path="app/src/main/java/com/hmdm/launcher/json/ServerConfig.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.json;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.LinkedList;
import java.util.List;

@JsonIgnoreProperties( ignoreUnknown = true )
public class ServerConfig {

    private String newNumber;

    private String backgroundColor;
    private String textColor;
    private String backgroundImageUrl;
    private String password;
    private String phone;
    private String imei;
    private Integer iconSize;
    private String title;
    private boolean displayStatus;

    private Boolean gps;
    private Boolean bluetooth;
    private Boolean wifi;
    private Boolean mobileData;

    private Boolean kioskMode;
    private String mainApp;

    private Boolean lockStatusBar;
    private Integer systemUpdateType;
    private String systemUpdateFrom;
    private String systemUpdateTo;
    private String appUpdateFrom;
    private String appUpdateTo;
    private String downloadUpdates;

    private Boolean factoryReset;
    private Boolean reboot;
    private Boolean lock;
    private String lockMessage;
    private String passwordReset;

    private String pushOptions;
    private Integer keepaliveTime;
    private String requestUpdates;
    private Boolean disableLocation;
    private String appPermissions;

    private Boolean usbStorage;
    private Boolean autoBrightness;
    private Integer brightness;
    private Boolean manageTimeout;
    private Integer timeout;
    private Boolean lockVolume;
    private Boolean manageVolume;
    private Integer volume;
    private String passwordMode;
    private String timeZone;
    private String allowedClasses;

    private Integer orientation;
    private Boolean kioskHome;
    private Boolean kioskRecents;
    private Boolean kioskNotifications;
    private Boolean kioskSystemInfo;
    private Boolean kioskKeyguard;
    private Boolean kioskLockButtons;
    private String restrictions;

    private String description;
    private String custom1;
    private String custom2;
    private String custom3;

    private Boolean runDefaultLauncher;

    private String newServerUrl;

    private boolean lockSafeSettings;
    private boolean permissive;
    private boolean kioskExit;
    private boolean disableScreenshots;
    private boolean autostartForeground;

    private boolean showWifi;

    private String appName;
    private String vendor;

    private List<Application> applications = new LinkedList();

    private List<ApplicationSetting> applicationSettings = new LinkedList();

    private List<RemoteFile> files = new LinkedList();

    private List<Action> actions = new LinkedList();

    public static final String TITLE_NONE = "none";
    public static final String TITLE_DEVICE_ID = "deviceId";
    public static final String TITLE_DESCRIPTION = "description";
    public static final String TITLE_CUSTOM1 = "custom1";
    public static final String TITLE_CUSTOM2 = "custom2";
    public static final String TITLE_CUSTOM3 = "custom3";
    public static final String TITLE_IMEI = "imei";
    public static final String TITLE_SERIAL = "serialNumber";
    public static final String TITLE_EXTERNAL_IP = "externalIp";
    public static final int DEFAULT_ICON_SIZE = 100;

    public static final int SYSTEM_UPDATE_DEFAULT = 0;
    public static final int SYSTEM_UPDATE_INSTANT = 1;
    public static final int SYSTEM_UPDATE_SCHEDULE = 2;
    public static final int SYSTEM_UPDATE_MANUAL = 3;

    public static final String PUSH_OPTIONS_MQTT_WORKER = "mqttWorker";
    public static final String PUSH_OPTIONS_MQTT_ALARM = "mqttAlarm";
    public static final String PUSH_OPTIONS_POLLING = "polling";

    public static final String APP_PERMISSIONS_ASK_LOCATION = "asklocation";
    public static final String APP_PERMISSIONS_DENY_LOCATION = "denylocation";
    public static final String APP_PERMISSIONS_ASK_ALL = "askall";

    public ServerConfig() {}

    public String getNewNumber() {
        return newNumber;
    }

    public void setNewNumber(String newNumber) {
        this.newNumber = newNumber;
    }

    public String getBackgroundColor() {
        return backgroundColor;
    }

    public void setBackgroundColor( String backgroundColor ) {
        this.backgroundColor = backgroundColor;
    }

    public String getTextColor() {
        return textColor;
    }

    public void setTextColor( String textColor ) {
        this.textColor = textColor;
    }

    public String getBackgroundImageUrl() {
        return backgroundImageUrl;
    }

    public void setBackgroundImageUrl( String backgroundImageUrl ) {
        this.backgroundImageUrl = backgroundImageUrl;
    }

    public List< Application > getApplications() {
        return applications;
    }

    public void setApplications( List< Application > applications ) {
        this.applications = applications;
    }

    public List< ApplicationSetting > getApplicationSettings() {
        return applicationSettings;
    }

    public void setApplicationSettings( List< ApplicationSetting > applicationSettings ) {
        this.applicationSettings = applicationSettings;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword( String password ) {
        this.password = password;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getImei() {
        return imei;
    }

    public void setImei(String imei) {
        this.imei = imei;
    }

    public Integer getIconSize() {
        return iconSize;
    }

    public void setIconSize(Integer iconSize) {
        this.iconSize = iconSize;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public boolean isDisplayStatus() {
        return displayStatus;
    }

    public void setDisplayStatus(boolean displayStatus) {
        this.displayStatus = displayStatus;
    }

    public Boolean getGps() {
        return gps;
    }

    public void setGps(Boolean gps) {
        this.gps = gps;
    }

    public Boolean getBluetooth() {
        return bluetooth;
    }

    public void setBluetooth(Boolean bluetooth) {
        this.bluetooth = bluetooth;
    }

    public Boolean getWifi() {
        return wifi;
    }

    public void setWifi(Boolean wifi) {
        this.wifi = wifi;
    }

    public Boolean getMobileData() {
        return mobileData;
    }

    public void setMobileData(Boolean mobileData) {
        this.mobileData = mobileData;
    }

    public Boolean getKioskMode() {
        return kioskMode;
    }

    public boolean isKioskMode() {
        return kioskMode != null && kioskMode;
    }

    public void setKioskMode(Boolean kioskMode) {
        this.kioskMode = kioskMode;
    }

    public String getMainApp() {
        return mainApp;
    }

    public void setMainApp(String mainApp) {
        this.mainApp = mainApp;
    }

    public Boolean getLockStatusBar() {
        return lockStatusBar;
    }

    public void setLockStatusBar(Boolean lockStatusBar) {
        this.lockStatusBar = lockStatusBar;
    }

    public Integer getSystemUpdateType() {
        return systemUpdateType;
    }

    public void setSystemUpdateType(Integer systemUpdateType) {
        this.systemUpdateType = systemUpdateType;
    }

    public String getSystemUpdateFrom() {
        return systemUpdateFrom;
    }

    public void setSystemUpdateFrom(String systemUpdateFrom) {
        this.systemUpdateFrom = systemUpdateFrom;
    }

    public String getSystemUpdateTo() {
        return systemUpdateTo;
    }

    public void setSystemUpdateTo(String systemUpdateTo) {
        this.systemUpdateTo = systemUpdateTo;
    }

    public String getAppUpdateFrom() {
        return appUpdateFrom;
    }

    public void setAppUpdateFrom(String appUpdateFrom) {
        this.appUpdateFrom = appUpdateFrom;
    }

    public String getAppUpdateTo() {
        return appUpdateTo;
    }

    public void setAppUpdateTo(String appUpdateTo) {
        this.appUpdateTo = appUpdateTo;
    }

    public String getDownloadUpdates() {
        return downloadUpdates;
    }

    public void setDownloadUpdates(String downloadUpdates) {
        this.downloadUpdates = downloadUpdates;
    }

    public Boolean getFactoryReset() {
        return factoryReset;
    }

    public void setFactoryReset(Boolean factoryReset) {
        this.factoryReset = factoryReset;
    }

    public Boolean getReboot() {
        return reboot;
    }

    public void setReboot(Boolean reboot) {
        this.reboot = reboot;
    }

    public Boolean getLock() {
        return lock;
    }

    public void setLock(Boolean lock) {
        this.lock = lock;
    }

    public String getLockMessage() {
        return lockMessage;
    }

    public void setLockMessage(String lockMessage) {
        this.lockMessage = lockMessage;
    }

    public String getPasswordReset() {
        return passwordReset;
    }

    public void setPasswordReset(String passwordReset) {
        this.passwordReset = passwordReset;
    }

    public String getPushOptions() {
        return pushOptions;
    }

    public void setPushOptions(String pushOptions) {
        this.pushOptions = pushOptions;
    }

    public Integer getKeepaliveTime() {
        return keepaliveTime;
    }

    public void setKeepaliveTime(Integer keepaliveTime) {
        this.keepaliveTime = keepaliveTime;
    }

    public String getRequestUpdates() {
        return requestUpdates;
    }

    public void setRequestUpdates(String requestUpdates) {
        this.requestUpdates = requestUpdates;
    }

    public Boolean getDisableLocation() {
        return disableLocation;
    }

    public void setDisableLocation(Boolean disableLocation) {
        this.disableLocation = disableLocation;
    }

    public String getAppPermissions() {
        return appPermissions;
    }

    public void setAppPermissions(String appPermissions) {
        this.appPermissions = appPermissions;
    }

    public Boolean getUsbStorage() {
        return usbStorage;
    }

    public void setUsbStorage(Boolean usbStorage) {
        this.usbStorage = usbStorage;
    }

    public Boolean getAutoBrightness() {
        return autoBrightness;
    }

    public void setAutoBrightness(Boolean autoBrightness) {
        this.autoBrightness = autoBrightness;
    }

    public Integer getBrightness() {
        return brightness;
    }

    public void setBrightness(Integer brightness) {
        this.brightness = brightness;
    }

    public Boolean getManageTimeout() {
        return manageTimeout;
    }

    public void setManageTimeout(Boolean manageTimeout) {
        this.manageTimeout = manageTimeout;
    }

    public Integer getTimeout() {
        return timeout;
    }

    public void setTimeout(Integer timeout) {
        this.timeout = timeout;
    }

    public Boolean getLockVolume() {
        return lockVolume;
    }

    public void setLockVolume(Boolean lockVolume) {
        this.lockVolume = lockVolume;
    }

    public Boolean getManageVolume() {
        return manageVolume;
    }

    public void setManageVolume(Boolean manageVolume) {
        this.manageVolume = manageVolume;
    }

    public Integer getVolume() {
        return volume;
    }

    public void setVolume(Integer volume) {
        this.volume = volume;
    }

    public String getPasswordMode() {
        return passwordMode;
    }

    public void setPasswordMode(String passwordMode) {
        this.passwordMode = passwordMode;
    }

    public String getTimeZone() {
        return timeZone;
    }

    public void setTimeZone(String timeZone) {
        this.timeZone = timeZone;
    }

    public String getAllowedClasses() {
        return allowedClasses;
    }

    public void setAllowedClasses(String allowedClasses) {
        this.allowedClasses = allowedClasses;
    }

    public Integer getOrientation() {
        return orientation;
    }

    public void setOrientation(Integer orientation) {
        this.orientation = orientation;
    }

    public Boolean getKioskHome() {
        return kioskHome;
    }

    public void setKioskHome(Boolean kioskHome) {
        this.kioskHome = kioskHome;
    }

    public Boolean getKioskRecents() {
        return kioskRecents;
    }

    public void setKioskRecents(Boolean kioskRecents) {
        this.kioskRecents = kioskRecents;
    }

    public Boolean getKioskNotifications() {
        return kioskNotifications;
    }

    public void setKioskNotifications(Boolean kioskNotifications) {
        this.kioskNotifications = kioskNotifications;
    }

    public Boolean getKioskSystemInfo() {
        return kioskSystemInfo;
    }

    public void setKioskSystemInfo(Boolean kioskSystemInfo) {
        this.kioskSystemInfo = kioskSystemInfo;
    }

    public Boolean getKioskKeyguard() {
        return kioskKeyguard;
    }

    public void setKioskKeyguard(Boolean kioskKeyguard) {
        this.kioskKeyguard = kioskKeyguard;
    }

    public Boolean getKioskLockButtons() {
        return kioskLockButtons;
    }

    public void setKioskLockButtons(Boolean kioskLockButtons) {
        this.kioskLockButtons = kioskLockButtons;
    }

    public Boolean getRunDefaultLauncher() {
        return runDefaultLauncher;
    }

    public void setRunDefaultLauncher(Boolean runDefaultLauncher) {
        this.runDefaultLauncher = runDefaultLauncher;
    }

    public String getNewServerUrl() {
        return newServerUrl;
    }

    public void setNewServerUrl(String newServerUrl) {
        this.newServerUrl = newServerUrl;
    }

    public boolean isLockSafeSettings() {
        return lockSafeSettings;
    }

    public void setLockSafeSettings(boolean lockSafeSettings) {
        this.lockSafeSettings = lockSafeSettings;
    }

    public boolean isPermissive() {
        return permissive;
    }

    public void setPermissive(boolean permissive) {
        this.permissive = permissive;
    }

    public boolean isKioskExit() {
        return kioskExit;
    }

    public void setKioskExit(boolean kioskExit) {
        this.kioskExit = kioskExit;
    }

    public boolean isDisableScreenshots() {
        return disableScreenshots;
    }

    public void setDisableScreenshots(boolean disableScreenshots) {
        this.disableScreenshots = disableScreenshots;
    }

    public boolean isAutostartForeground() {
        return autostartForeground;
    }

    public void setAutostartForeground(boolean autostartForeground) {
        this.autostartForeground = autostartForeground;
    }

    public boolean isShowWifi() {
        return showWifi;
    }

    public void setShowWifi(boolean showWifi) {
        this.showWifi = showWifi;
    }

    public String getAppName() {
        return appName;
    }

    public void setAppName(String appName) {
        this.appName = appName;
    }

    public String getVendor() {
        return vendor;
    }

    public void setVendor(String vendor) {
        this.vendor = vendor;
    }

    public String getRestrictions() {
        return restrictions;
    }

    public void setRestrictions(String restrictions) {
        this.restrictions = restrictions;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getCustom1() {
        return custom1;
    }

    public void setCustom1(String custom1) {
        this.custom1 = custom1;
    }

    public String getCustom2() {
        return custom2;
    }

    public void setCustom2(String custom2) {
        this.custom2 = custom2;
    }

    public String getCustom3() {
        return custom3;
    }

    public void setCustom3(String custom3) {
        this.custom3 = custom3;
    }

    public List<RemoteFile> getFiles() {
        return files;
    }

    public void setFiles(List<RemoteFile> files) {
        this.files = files;
    }

    public List<Action> getActions() {
        return actions;
    }

    public void setActions(List<Action> actions) {
        this.actions = actions;
    }
}
</file>

<file path="app/src/main/res/values-pt/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrador</string>
    <string name="install_error">Erro na Instalação </string>
    <string name="file_create_error">Erro ao criar ficheiro</string>
    <string name="dialog_enter_device_id_error">O ID não está registrado em %s. Verifique o ID na aba \"Dispositivos\" do painel de controle.</string>
    <string name="dialog_enter_device_id_qrcode">QR code</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Salvar</string>
    <string name="dialog_enter_device_id_exit">Sair</string>
    <string name="dialog_enter_device_id_title">Digite o ID do Dispositivo em %s</string>
    <string name="main_start_preparations">Preparar para iniciar</string>
    <string name="main_downloading_configuration">Atualizando arquivo de configuração</string>
    <string name="main_downloading_content">Atualizando</string>
    <string name="main_update_applications">Instalando e atualizando aplicativos</string>
    <string name="dialog_root_message">Você precisa do acesso ROOT</string>
    <string name="main_application_start">Iniciando Aplicativo</string>
    <string name="main_app_installing">Instalando Aplicativo</string>
    <string name="main_app_downloading">Efetuando Download do Aplicativo</string>
    <string name="main_app_downloading_error">Falha ao efetuar o download do aplicativo</string>
    <string name="main_app_removing">Removendo Aplicativo</string>
    <string name="main_file_downloading">Efetuando Download do Arquivo</string>
    <string name="main_file_downloading_error">Falha ao efetuar o download do arquivo</string>
    <string name="main_activity_repeat">Repetir</string>
    <string name="main_activity_reset">Resetar</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancelar</string>
    <string name="main_activity_details">Detalhes</string>
    <string name="select_system_launcher">Selecione %s como o launcher padrão e marque a opção \'Sempre\':</string>
    <string name="dialog_network_error_title">Erro ao conectar em %s. Por favor verifique a conexão com a internet e tente novamente.</string>
    <string name="main_activity_update_config">Requisitando arquivo de configuração do servidor</string>
    <string name="main_activity_applications_update">Atualizar aplicativos</string>
    <string name="dialog_overlay_settings_title">Permita que o aplicativo desenhe sobre outras janelas.\n\nEsta opção ajuda a bloquear melhor os aplicativos indesejados e ativa o desbloqueio de emergência do modo quiosque.\n\nToque em \"Continuar\" para abrir uma página de configurações. Encontre o item \"%s\", conceda a permissão e toque em \"Voltar\".</string>
    <string name="dialog_manage_storage_title">Por favor, permita que a aplicação gerencie o armazenamento.\n\nEsta opção permite o Headwind MDM gerir ficheiros no seu dispositivo.</string>
    <string name="dialog_history_settings_title">Permita que o aplicativo acesse os dados de uso.\n\nEsta opção permite o controle de aplicativos e configurações.\n\nEsta opção pode causar um esgotamento mais rápido da bateria. Para economizar bateria, pule esta opção (use os serviços de acessibilidade ou o modo quiosque).\n\nToque em \"Continuar\" para abrir uma página de configurações. Encontre o item \"%s\", conceda a permissão e toque em \"Voltar\".</string>
    <string name="dialog_history_settings_continue">Continuar</string>
    <string name="dialog_history_settings_skip">Pular</string>
    <string name="dialog_unknown_sources_title">Por favor permita a instalação de aplicativos de fonte desconhecida. Uma tela de configurações vai ser aberta. Procure \"Fontes desconhecidas\", toque em permitir a instalação e toque em \"Voltar\".</string>
    <string name="dialog_unknown_sources_continue">Continuar</string>
    <string name="dialog_miui_permissions_title">MIUI requer uma configuração manual no seu device. A tela de permissões do aplicativo vai ser aberta. Toque em \"Outras permissões\", ative \"Mostrar Janelas pop-up enquanto está em segundo plano\" e toque em \"Voltar\".</string>
    <string name="dialog_miui_developer_title">MIUI requer uma configuração manual no seu device. Na tela de informações do dispositivo, TOQUE 7 VEZES EM \"NÚMERO DA VERSÃO\". Isso vai ativar as opções de desenvolvedor.</string>
    <string name="dialog_miui_optimization_title">MIUI requer uma configuração manual no seu device. Developer settings window will now open. Scroll the screen down and uncheck \"MIUI optimization\".</string>
    <string name="dialog_administrator_mode_message">Por favor permita que o aplicativo trabalhe no modo administrador do dispositivo. Uma tela de configurações vai ser aberta. Selecione \"Administrador do Dispositivo\", procure por \"%s\", ative como administrador, e toque em \"Voltar\".</string>
    <string name="dialog_administrator_mode_continue">Continuar</string>
    <string name="dialog_administrator_mode_skip">Pular</string>
    <string name="accessibility_service_description">Aplicativo ativo de monitoramento pela aplicação MDM</string>
    <string name="dialog_accessibility_service_message">Por favor permita o acesso aos serviços de acessibilidade. Uma tela de configurações vai ser aberta. Procure o item \"%s\", permita o acesso aos serviços de acessibilidade, e toque em \"Voltar\".</string>
    <string name="dialog_accessibility_service_continue">Continuar</string>
    <string name="dialog_accessibility_service_skip">Pular</string>
    <string name="access_to_app_denied">O pacote não é permitido:</string>
    <string name="access_to_app_denied_2">Por favor, peça ao seu administrador para ativar este pacote na configuração.\n\nClique em \'Fechar\' ou no botão Home para continuar.</string>
    <string name="package_id_copied">O ID do pacote é copiado para a área de transferência</string>
    <string name="dialog_app_not_allowed_close">Fechar</string>
    <string name="dialog_app_not_allowed_admin">Administrador</string>
    <string name="device_id">ID do Dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Número do Serial</string>
    <string name="phone_number">Número do Telefone</string>
    <string name="launcher_version">Versão do Launcher</string>
    <string name="close">Fechar</string>
    <string name="admin_change_device_id">Alterar ID do dispositivo</string>
    <string name="admin_change_server_url">Alterar URL do Servidor</string>
    <string name="admin_allow_settings">Abrir configurações</string>
    <string name="settings_allowed">Você pode alterar as permissões durante 3 minutos.</string>
    <string name="admin_clear_restrictions">Remover restrições</string>
    <string name="permissive_mode_enabled">Você tem permissão para executar todos os aplicativos em 3 minutos.</string>
    <string name="admin_refresh">Atualizar Configuração</string>
    <string name="admin_exit">Sair do Launcher do sistema</string>
    <string name="admin_reset_permissions">Resetar Permissões</string>
    <string name="admin_reset_network">Resetar políticas de rede</string>
    <string name="admin_reset_network_hint">Políticas de rede foram limpas. Você pode ativar a internet e reiniciar a configuração.</string>
    <string name="reboot">Reiniciar Dispositivo</string>
    <string name="reboot_failed">Você não tem permissões para reiniciar o dispositivo.</string>
    <string name="message_turn_on_gps">A Tela de configurações vai abrir. Por favor ATIVE o GPS na tela e toque em voltar.</string>
    <string name="message_turn_off_gps">A Tela de configurações vai abrir. Por favor DESLIGUE o GPS na tela e toque em voltar.</string>
    <string name="message_turn_on_mobile_data">Rede de Dados do Celular está desativada! Por favor abra a barra de status e ATIVE a rede de dados.</string>
    <string name="message_turn_off_mobile_data">Rede de Dados do Celular está ativada. Por favor abra a barra de status e DESATIVE a rede de dados.</string>
    <string name="message_set_password">Sua senha não está com uma senha de boa qualidade. A tela de configurações vai ser aberta. Por favor altere sua senha e toque em Voltar.</string>
    <string name="switch_off_blockings">Desligando Restrições...</string>
    <string name="kiosk_mode_requires_overlays">Modo Kiosk desativado: Sem permissões para sobrepor outros aplicativos. Por favor habilite %s para sobrepor os aplicativos.</string>
    <string name="enter_admin_password">Digite a senha do Administrador</string>
    <string name="wrong_password">Senha inválida</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Cancelar</string>
    <string name="internal_error">Ocorreu um erro interno no aplicativo. Por favor reinicie o dispositivo e tente novamente.</string>
    <string name="empty_configuration">Configuração não efetuada, tente buscar a configuração do servidor novamente!</string>
    <string name="permissions_reset_hint">Feche o painel administrador para verificar e buscar permissões.</string>
    <string name="dialog_enter_server_error">Por favor digite uma URL válida do servidor.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Digite a URL do servidor</string>
    <string name="critical_server_failure">Ocorreu um problema no servidor! Por favor corrija o erro e reinicie %s, ou remova completamente e reinstale.</string>
    <string name="dialog_permission_title">O Aplicativo requer permissões para iniciar. Por favor garanta as permissões necessárias.</string>
    <string name="main_activity_exit">Sair</string>
    <string name="browser_not_found">A página web não pode ser aberta porque um navegador não foi encontrado. Por favor adicione o navegador nas configurações do dispositivo.</string>
    <string name="invalid_web_link">Não é possível abrir o link da web porque não está bem formado. Entre em contato com seu administrador para obter detalhes.</string>
    <string name="activity_not_found">Não é possível executar a ação %s porque a atividade não foi encontrada.</string>
    <string name="location_service_text">Localização do dispositivo está ativa</string>
    <string name="qrcode_contents_error">QR code com conteúdo inválido. Por favor gere o QR Code de provisionamento no painel administrativo %s.</string>
    <string name="device_locked">Este dispositivo (%s) está bloqueado pelo administrador.</string>
    <string name="fault_loop_detected">Oops, ocorreu uma falha no launcher do seu dispositivo! Por favor contate o administrador do sistema.</string>
    <string name="mqtt_service_text">As notificações push estão ativas</string>
    <string name="background_location">%s requer permissão de localização em segundo plano. Clique em \'Continuar\' para abrir as permissões, clique em \'Local\' e permita determinar o local sempre.</string>
    <string name="location_disable">Desativar localização</string>
    <string name="background_location_continue">Continuar</string>
    <string name="initializing_mdm">Inicializando o aplicativo de gerenciamento de dispositivo móvel ...</string>
    <string name="dialog_server_error_title">O servidor MDM %s retornou uma resposta inválida. Entre em contato com o seu administrador.</string>
    <string name="mdm_choice_message">Este dispositivo será totalmente gerenciado por sua organização. Seus dados não serão privados e podem ser apagados ou revisados por seu administrador de TI a qualquer momento.</string>
    <string name="work_profile_message">Este dispositivo receberá um perfil de trabalho gerenciado pertencente à sua organização. O perfil de trabalho é separado do seu perfil privado e você pode alternar entre os perfis a qualquer momento.</string>
    <string name="overlays_not_supported">Infelizmente, as sobreposições não são suportadas pelo seu dispositivo.</string>
    <string name="admin_not_supported">Seu dispositivo não tem opção de administrador do dispositivo. Clique em Pular para continuar.</string>
    <string name="manage_storage_not_supported">O seu dispositivo não tem opção para gerir o armazenamento externo.</string>
</resources>
</file>

<file path="app/src/main/res/values-ru/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Администратор</string>
    <string name="install_error">Ошибка установки</string>
    <string name="file_create_error">Ошибка создания файла</string>
    <string name="dialog_enter_device_id_error">Этот ID не зарегистрирован на сервере %s, найдите ID на сервере в разделе \"Устройства\".</string>
    <string name="dialog_enter_device_id_qrcode">QR код</string>
    <string name="dialog_enter_device_id_variants">Варианты</string>
    <string name="dialog_enter_device_id_save">Сохранить</string>
    <string name="dialog_enter_device_id_exit">Выход</string>
    <string name="dialog_enter_device_id_title">Введите ID устройства на сервере %s</string>
    <string name="main_start_preparations">Подготовка к запуску</string>
    <string name="main_downloading_configuration">Обновляем файл конфигурации</string>
    <string name="main_downloading_content">Обновляем данные</string>
    <string name="main_update_applications">Устанавливаем и обновляем приложения</string>
    <string name="dialog_root_message">Для использования приложения необходимы ROOT права на устройстве</string>
    <string name="main_application_start">Запускаем приложение</string>
    <string name="main_app_installing">Устанавливаем приложение</string>
    <string name="main_app_downloading">Скачиваем приложение</string>
    <string name="main_app_downloading_error">Не удалось скачать приложение</string>
    <string name="main_app_removing">Удаляем приложение</string>
    <string name="main_file_downloading">Скачиваем файл</string>
    <string name="main_file_downloading_error">Не удалось скачать файл</string>
    <string name="main_activity_repeat">Повтор</string>
    <string name="main_activity_reset">Сброс</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Отмена</string>
    <string name="main_activity_details">Детали</string>
    <string name="select_system_launcher">Выберите %s в качестве лаунчера и укажите \'Всегда\':</string>
    <string name="dialog_network_error_title">Произошла ошибка подключения к серверу %s. Проверьте своё интернет подключение и попробуйте снова.</string>
    <string name="main_activity_update_config">Запрашиваем конфигурацию с сервера</string>
    <string name="main_activity_applications_update">Обновляем приложения</string>
    <string name="dialog_overlay_settings_title">Пожалуйста, разрешите наложение поверх других окон.\n\nЭтот параметр помогает лучше блокировать нежелательные приложения и включает аварийный выход из режима киоска.\n\nНажмите \"Продолжить\", чтобы открыть страницу настроек. Найдите элемент \"%s\", дайте разрешение и нажмите \"Назад\".</string>
    <string name="dialog_manage_storage_title">Пожалуйста, разрешите приложению управлять хранилищем.\n\nЭта опция позволяет Headwind MDM управлять файлами на вашем устройстве.</string>
    <string name="dialog_history_settings_title">Пожалуйста, разрешите доступ к данным об использовании.\n\nЭта опция позволяет контролировать приложения и настройки.\n\nЭто может вызвать более быстрый разряд батареи. Чтобы сэкономить заряд батареи, пропустите этот параметр (вместо этого используйте специальные возможности или режим киоска).\n\nНажмите \"Продолжить\", чтобы открыть страницу настроек. Найдите элемент \"%s\", дайте разрешение и нажмите \"Назад\".</string>
    <string name="dialog_history_settings_continue">Продолжить</string>
    <string name="dialog_history_settings_skip">Без разрешения</string>
    <string name="dialog_unknown_sources_title">Пожалуйста, разрешите установку приложений из неизвестных источников. Сейчас откроется окно настроек Android, найдите \"Неизвестные источники\", включите разрешение и нажмите \"Назад\".</string>
    <string name="dialog_unknown_sources_continue">Продолжить</string>
    <string name="dialog_miui_permissions_title">MIUI требует ручной установки некоторых разрешений. Сейчас откроется окно разрешений. Нажмите \"Другие разрешения\", разрешите \"Отображать всплывающие окна, когда запущено в фоновом режиме\", и нажмите \"Назад\".</string>
    <string name="dialog_miui_developer_title">MIUI требует ручной настройки. Сейчас откроется экран, НАЖМИТЕ 7 РАЗ НА \"НОМЕР СБОРКИ\". Это откроет настройки разработчика.</string>
    <string name="dialog_miui_optimization_title">MIUI требует ручной настройки. Сейчас откроется экран настроек разработчика. Пролистайте экран вниз и выключите флаг \"Оптимизация MIUI\".</string>
    <string name="dialog_administrator_mode_message">Пожалуйста, разрешите установить приложение в качеcтве администратора устройства. Сейчас откроется окно настроек Android, выберите пункт \"Администраторы устройства\", в открывшемся списке найдите пункт \"%s\", активируйте приложение и нажмите \"Назад\".</string>
    <string name="dialog_administrator_mode_continue">Продолжить</string>
    <string name="dialog_administrator_mode_skip">Без разрешения</string>
    <string name="accessibility_service_description">Сервис мониторинга состояния рабочего стола</string>
    <string name="dialog_accessibility_service_message">Пожалуйста, разрешите приложению использовать специальные возможности. Сейчас откроется окно настроек Android, выберите пункт \"%s\", в открывшемся окне активируйте приложение и нажмите \"Назад\".</string>
    <string name="dialog_accessibility_service_continue">Продолжить</string>
    <string name="dialog_accessibility_service_skip">Без разрешения</string>
    <string name="access_to_app_denied">Пакет не разрешен:</string>
    <string name="access_to_app_denied_2">Пожалуйста, попросите администратора разрешить пакет в конфигурации.\n\nНажмите \'Закрыть\' или кнопку Home для продолжения.</string>
    <string name="package_id_copied">Идентификатор пакета скопирован в буфер обмена</string>
    <string name="dialog_app_not_allowed_close">Закрыть</string>
    <string name="dialog_app_not_allowed_admin">Администратор</string>
    <string name="device_id">ID устройства</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Серийный номер</string>
    <string name="phone_number">Номер телефона</string>
    <string name="launcher_version">Версия лаунчера</string>
    <string name="close">Закрыть</string>
    <string name="admin_change_device_id">Изменить ID устройства</string>
    <string name="admin_change_server_url">Изменить URL сервера</string>
    <string name="admin_allow_settings">Открыть настройки</string>
    <string name="settings_allowed">Изменение настроек разрешено в течение 3 минут</string>
    <string name="admin_clear_restrictions">Снять ограничения</string>
    <string name="permissive_mode_enabled">Вам разрешено запускать все приложения в течение 3 минут.</string>
    <string name="admin_refresh">Обновить конфигурацию</string>
    <string name="admin_reset_permissions">Проверить разрешения</string>
    <string name="admin_reset_network">Сброс политик сети</string>
    <string name="admin_reset_network_hint">Сетевые политики сброшены. Вы можете включить сеть и обновить конфигурацию устройства.</string>
    <string name="admin_exit">Выйти в системный лаунчер</string>
    <string name="reboot">Перезагрузка</string>
    <string name="reboot_failed">Не удалось перезагрузить устройство - не хватает прав.</string>
    <string name="message_turn_on_gps">Сейчас откроется экран настроек. Пожалуйста, включите на нем определение местоположения по GPS.</string>
    <string name="message_turn_off_gps">Сейчас откроется экран настроек. Пожалуйста, ВЫКЛЮЧИТЕ на нем определение местоположения по GPS.</string>
    <string name="message_turn_on_mobile_data">Мобильные данные выключены. Пожалуйста, откройте статус-бар и включите мобильные данные.</string>
    <string name="message_turn_off_mobile_data">Мобильные данные включены. Пожалуйста, откройте статус-бар и ВЫКЛЮЧИТЕ мобильные данные.</string>
    <string name="message_set_password">Качество вашего пароля недостаточно. Сейчас откроется экран настроек. Пожалуйста, измените пароль и нажмите Назад.</string>
    <string name="switch_off_blockings">Отключаем блокировку...</string>
    <string name="kiosk_mode_requires_overlays">Режим киоска не включен: не выдано разрешение на отображение поверх других окон приложению %s.</string>
    <string name="enter_admin_password">Введите пароль администратора</string>
    <string name="wrong_password">Неверный пароль</string>
    <string name="dialog_enter_password_login">Войти</string>
    <string name="dialog_enter_password_cancel">Отмена</string>
    <string name="internal_error">В оболочке возникла ошибка. Пожалуйста, перезагрузите устройство и повторите действие ещё раз.</string>
    <string name="empty_configuration">Конфигурация еще не получена, пытаемся скачать еще раз!</string>
    <string name="permissions_reset_hint">Чтобы проверить и заново запросить разрешения - закройте экран администратора.</string>
    <string name="dialog_enter_server_error">Пожалуйста, введите валидный URL сервера.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Введите URL сервера</string>
    <string name="critical_server_failure">Завершение работы из-за ошибки сервера! Исправьте ошибку и перезапустите %s, или удалите и установите лаунчер заново.</string>
    <string name="dialog_permission_title">Приложение требует разрешений для работы. Пожалуйста, предоставьте требуемые разрешения.</string>
    <string name="main_activity_exit">Выход</string>
    <string name="browser_not_found">Невозможно открыть веб-страницу: браузер не найден. Пожалуйста, добавьте приложение-браузер в конфигурацию устройства.</string>
    <string name="invalid_web_link">Не удается открыть веб-ссылку, поскольку она имеет неправильный формат. Пожалуйста, свяжитесь с вашим администратором для получения подробной информации.</string>
    <string name="activity_not_found">Невозможно выполнить действие %s, поскольку activity не найдена.</string>
    <string name="location_service_text">Местоположение устройства передается на сервер</string>
    <string name="qrcode_contents_error">Неверное содержимое QR кода. Пожалуйста, сформируйте QR код на сервере %s.</string>
    <string name="device_locked">Это устройство (%s) заблокировано администратором.</string>
    <string name="fault_loop_detected">Лаунчер сломался и его не восстановить! Пожалуйста, сообщите об этой проблеме администратору.</string>
    <string name="mqtt_service_text">Push-уведомления активны</string>
    <string name="background_location">%s требует разрешения на определение местоположения в фоне. Нажмите \'Далее\', чтобы открыть разрешения. Выберите \'Местоположение\', и разрешите определение местоположения всегда.</string>
    <string name="location_disable">Отключить местоположение</string>
    <string name="background_location_continue">Далее</string>
    <string name="initializing_mdm">Инициализация приложения, управляющего мобильным устройством...</string>
    <string name="dialog_server_error_title">MDM сервер %s вернул неверный ответ. Пожалуйста, свяжитесь с администратором.</string>
    <string name="mdm_choice_message">Это устройство будет полностью управляться вашей организацией. Ваши данные не будут конфиденциальными и могут быть удалены или просмотрены вашим ИТ-администратором в любое время.</string>
    <string name="work_profile_message">Это устройство получит управляемый рабочий профиль, принадлежащий вашей организации. Рабочий профиль отделен от вашего личного профиля, и вы можете переключаться между профилями в любое время.</string>
    <string name="overlays_not_supported">К сожалению, наложение окон не поддерживается вашим устройством.</string>
    <string name="admin_not_supported">На вашем устройстве нет возможности администратора устройства. Нажмите Пропустить, чтобы продолжить.</string>
    <string name="manage_storage_not_supported">Ваше устройство не имеет возможности управления внешним хранилищем.</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rCN/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理员</string>
	<string name="install_error">安装错误</string>
	<string name="file_create_error">创建文件错误</string>
	<string name="dialog_enter_device_id_error">该ID未在%s处註册。从控制面板的“设备”标籤中获取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二维码</string>
	<string name="dialog_enter_device_id_variants">变体</string>
	<string name="dialog_enter_device_id_save">储存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s输入设备ID</string>
	<string name="main_start_preparations">準备开始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新数据</string>
	<string name="main_update_applications">安装和更新应用程序</string>
	<string name="dialog_root_message">您需要ROOT权限</string>
	<string name="main_application_start">开始申请</string>
	<string name="main_app_installing">安装应用程序</string>
	<string name="main_app_downloading">下载申请书</string>
	<string name="main_app_downloading_error">无法下载软件包</string>
	<string name="main_app_removing">卸载应用程序</string>
	<string name="main_file_downloading">下载文件</string>
	<string name="main_file_downloading_error">下载文件失败</string>
	<string name="main_activity_repeat">重试</string>
	<string name="main_activity_reset">重启</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">细节</string>
	<string name="select_system_launcher">选择%s作为默认启动器，然後选中“始终”：</string>
	<string name="dialog_network_error_title">连接到%s时出错。请检查互联网连接，然後重试。</string>
	<string name="main_activity_update_config">从服务器请求配置文件</string>
	<string name="main_activity_applications_update">更新应用程序</string>
	<string name="dialog_overlay_settings_title">请允许应用程序在其他窗口上绘制。\n\n此选项有助于更好地阻止不需要的应用程序，并启用自助服务终端模式的紧急解锁。\n\n点按“继续”以打开设置表。 找到 \"%s\" 项目，授予权限，然后点击 \"Back\"。</string>
	<string name="dialog_manage_storage_title">请允许该应用管理存储。\n\n此选项允许 Headwind MDM 管理您设备上的文件。</string>
	<string name="dialog_history_settings_title">请允许该应用访问使用数据。\n\n此选项启用对应用程序和设置的控制。\n\n此选项可能会导致更快的电池消耗。 要节省电池电量，请跳过此选项（改用无障碍服务或信息亭模式）。\n\n点按“继续”以打开设置表。 找到 \"%s\" 项目，授予权限，然后点击 \"Back\"。</string>
	<string name="dialog_history_settings_continue">继续</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">请允许从未知来源进行安装。现在将打开一个设置表。找到“未知来源”，允许安装，然後单击“上一步”。</string>
	<string name="dialog_unknown_sources_continue">继续</string>
	<string name="dialog_miui_permissions_title">MIUI要求手动设置自定义权限。现在将打开“应用程序权限”窗口。轻按\"其他权限\"，允许\"在後台运行时显示弹出窗口\"，然後单击\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手动设置设备。在信息屏幕上，点击TAP 7 TIMES \" BUILD NUMBER \"。这将启用开发人员设置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手动设置设备。开发人员设置窗口现在将打开。向下滚动屏幕，然後取消选中“ MIUI优化”。</string>
	<string name="dialog_administrator_mode_message">请允许该应用在设备管理员模式下运行。现在将打开一个设置表。选择\"设备管理员\"，找到\"%s\"项目，激活（Activate）管理员，然後点击\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">继续</string>
	<string name="dialog_administrator_mode_skip">跳跃</string>
	<string name="accessibility_service_description">通过MDM应用程序进行活动的应用程序监视</string>
	<string name="dialog_accessibility_service_message">请允许该应用使用辅助功能。现在将打开一个设置表。找到\"%s\"项，允许使用辅助功能，然後点击\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">继续</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允许使用以下包裹：</string>
	<string name="access_to_app_denied_2">请请求管理员在配置中启用此程序包。\n\n单击“关闭”或“主页”按钮继续。</string>
	<string name="package_id_copied">包 ID 已复制到剪贴板</string>
	<string name="dialog_app_not_allowed_close">关闭</string>
	<string name="dialog_app_not_allowed_admin">管理员</string>
	<string name="device_id">设备编号</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列号</string>
	<string name="phone_number">电话号码</string>
	<string name="launcher_version">启动器版本</string>
	<string name="close">关闭</string>
	<string name="admin_change_device_id">更改设备ID</string>
	<string name="admin_change_server_url">更改服务器URL</string>
	<string name="admin_allow_settings">打开设置</string>
	<string name="settings_allowed">您可以在3分钟内更改设置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分钟内运行所有应用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系统启动器</string>
	<string name="admin_reset_permissions">检查权限</string>
	<string name="admin_reset_network">重置网络策略</string>
	<string name="admin_reset_network_hint">清除网络策略。现在，您可以启用网络并重新加载配置。</string>
	<string name="reboot">重启设备</string>
	<string name="reboot_failed">没有足够的权限来重新启动设备。</string>
	<string name="message_turn_on_gps">设置屏幕将打开。请在此屏幕上打开GPS位置，然後单击返回。</string>
	<string name="message_turn_off_gps">设置屏幕将打开。请在此屏幕上关闭GPS位置，然後单击返回。</string>
	<string name="message_turn_on_mobile_data">移动数据已禁用！请打开状态栏，然後打开移动数据。</string>
	<string name="message_turn_off_mobile_data">启用了移动数据。请打开状态栏，然後关闭移动数据。</string>
	<string name="message_set_password">您的密码质量不够好。设置屏幕将打开。请更改密码，然後单击“上一步”。</string>
	<string name="switch_off_blockings">关闭限制...</string>
	<string name="kiosk_mode_requires_overlays">单一模式已禁用：没有权限绘製其他窗口。请允许%s在其他窗口上绘製。</string>
	<string name="enter_admin_password">输入管理员密码</string>
	<string name="wrong_password">密码错误</string>
	<string name="dialog_enter_password_login">登录</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">该应用程序遇到内部错误。请重新启动设备，然後重试该操作。</string>
	<string name="empty_configuration">未设置配置，请尝试从服务器获取！</string>
	<string name="permissions_reset_hint">关闭管理面板以检查并请求权限。</string>
	<string name="dialog_enter_server_error">请输入有效的服务器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">请输入服务器网址</string>
	<string name="critical_server_failure">由於服务器故障而退出！请解决此问题，然後重新启动%s，或将其完全删除并重新安装。</string>
	<string name="dialog_permission_title">该应用需要权限才能运行。请授予请求的权限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到浏览器，因此无法打开网页。请在设备配置中添加浏览器应用。</string>
	<string name="invalid_web_link">无法打开 Web 链接，因为它的格式不正确。 有关详细信息，请联系您的管理员。</string>
	<string name="activity_not_found">无法执行操作 %s，因为未找到该活动。</string>
	<string name="location_service_text">设备位置受到监控</string>
	<string name="qrcode_contents_error">无效的QR码内容。请在%s Web面板中生成预配置QR码。</string>
	<string name="device_locked">此设备 (%s) 已被管理员锁定。</string>
	<string name="fault_loop_detected">启动器发生了无法恢复的故障！请与系统管理员联繫。</string>
	<string name="mqtt_service_text">推送通知处于活动状态</string>
	<string name="background_location">%s 需要后台位置权限。 单击\'继续\' 打开权限，单击\'位置\' 并允许始终确定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">继续</string>
	<string name="initializing_mdm">正在初始化移动设备管理应用程序...</string>
	<string name="dialog_server_error_title">MDM 服务器 %s 返回无效响应。 请联系您的管理员。</string>
	<string name="mdm_choice_message">此设备将由您的组织完全管理。 您的数据不会是私密的，您的 IT 管理员可以随时删除或查看您的数据。</string>
	<string name="work_profile_message">此设备将获得属于您的组织的受管理工作配置文件。 工作资料与您的私人资料分开，您可以随时在资料之间切换。</string>
	<string name="overlays_not_supported">不幸的是，您的设备不支持覆盖。</string>
	<string name="admin_not_supported">您的设备没有设备管理员选项。 单击跳过以继续。</string>
	<string name="manage_storage_not_supported">您的设备没有管理外部存储的选项。</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rHK/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理員</string>
	<string name="install_error">安裝錯誤</string>
	<string name="file_create_error">建立文件時出錯</string>
	<string name="dialog_enter_device_id_error">該ID未在%s處註冊。從控制面板的“設備”標籤中獲取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二維碼</string>
	<string name="dialog_enter_device_id_variants">變體</string>
	<string name="dialog_enter_device_id_save">儲存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s輸入設備ID</string>
	<string name="main_start_preparations">準備開始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新數據</string>
	<string name="main_update_applications">安裝和更新應用程序</string>
	<string name="dialog_root_message">您需要ROOT權限</string>
	<string name="main_application_start">開始申請</string>
	<string name="main_app_installing">安裝應用程序</string>
	<string name="main_app_downloading">下載申請書</string>
	<string name="main_app_downloading_error">無法下載軟件包</string>
	<string name="main_app_removing">卸載應用程序</string>
	<string name="main_file_downloading">下載文件</string>
	<string name="main_file_downloading_error">下載文件失敗</string>
	<string name="main_activity_repeat">重試</string>
	<string name="main_activity_reset">重啟</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">細節</string>
	<string name="select_system_launcher">選擇%s作為默認啟動器，然後選中“始終”：</string>
	<string name="dialog_network_error_title">連接到%s時出錯。請檢查互聯網連接，然後重試。</string>
	<string name="main_activity_update_config">從服務器請求配置文件</string>
	<string name="main_activity_applications_update">更新應用程序</string>
	<string name="dialog_overlay_settings_title">請允許應用程序在其他窗口上繪製。\n\n此選項有助於更好地阻止不需要的應用程序，並啟用自助服務終端模式的緊急解鎖。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_manage_storage_title">請允許應用程式管理儲存。\n\n此選項可讓 Headwind MDM 管理您裝置上的檔案。</string>
	<string name="dialog_history_settings_title">請允許該應用訪問使用數據。\n\n此選項啟用對應用程序和設置的控制。\n\n此選項可能會導致更快的電池消耗。 要節省電池電量，請跳過此選項（改用無障礙服務或信息亭模式）。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_history_settings_continue">繼續</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">請允許從未知來源進行安裝。現在將打開一個設置表。找到“未知來源”，允許安裝，然後單擊“上一步”。</string>
	<string name="dialog_unknown_sources_continue">繼續</string>
	<string name="dialog_miui_permissions_title">MIUI要求手動設置自定義權限。現在將打開“應用程序權限”窗口。輕按\"其他權限\"，允許\"在後台運行時顯示彈出窗口\"，然後單擊\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手動設置設備。在信息屏幕上，點擊TAP 7 TIMES \" BUILD NUMBER \"。這將啟用開發人員設置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手動設置設備。開發人員設置窗口現在將打開。向下滾動屏幕，然後取消選中“ MIUI優化”。</string>
	<string name="dialog_administrator_mode_message">請允許該應用在設備管理員模式下運行。現在將打開一個設置表。選擇\"設備管理員\"，找到\"%s\"項目，激活（Activate）管理員，然後點擊\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">繼續</string>
	<string name="dialog_administrator_mode_skip">跳躍</string>
	<string name="accessibility_service_description">通過MDM應用程序進行活動的應用程序監視</string>
	<string name="dialog_accessibility_service_message">請允許該應用使用輔助功能。現在將打開一個設置表。找到\"%s\"項，允許使用輔助功能，然後點擊\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">繼續</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允許使用以下包裹：</string>
	<string name="access_to_app_denied_2">請請求管理員在設定中啟用此程式包。\n\n按一下「關閉」或「首頁」按鈕繼續。</string>
	<string name="package_id_copied">包 ID 已複製到剪貼簿</string>
	<string name="dialog_app_not_allowed_close">關閉</string>
	<string name="dialog_app_not_allowed_admin">管理員</string>
	<string name="device_id">設備編號</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列號</string>
	<string name="phone_number">電話號碼</string>
	<string name="launcher_version">啟動器版本</string>
	<string name="close">關閉</string>
	<string name="admin_change_device_id">更改設備ID</string>
	<string name="admin_change_server_url">更改服務器URL</string>
	<string name="admin_allow_settings">打開設置</string>
	<string name="settings_allowed">您可以在3分鐘內更改設置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分鐘內運行所有應用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系統啟動器</string>
	<string name="admin_reset_permissions">檢查權限</string>
	<string name="admin_reset_network">重置網絡策略</string>
	<string name="admin_reset_network_hint">清除網絡策略。現在，您可以啟用網絡並重新加載配置。</string>
	<string name="reboot">重啟設備</string>
	<string name="reboot_failed">沒有足夠的權限來重新啟動設備。</string>
	<string name="message_turn_on_gps">設置屏幕將打開。請在此屏幕上打開GPS位置，然後單擊返回。</string>
	<string name="message_turn_off_gps">設置屏幕將打開。請在此屏幕上關閉GPS位置，然後單擊返回。</string>
	<string name="message_turn_on_mobile_data">移動數據已禁用！請打開狀態欄，然後打開移動數據。</string>
	<string name="message_turn_off_mobile_data">啟用了移動數據。請打開狀態欄，然後關閉移動數據。</string>
	<string name="message_set_password">您的密碼質量不夠好。設置屏幕將打開。請更改密碼，然後單擊“上一步”。</string>
	<string name="switch_off_blockings">關閉限制...</string>
	<string name="kiosk_mode_requires_overlays">單一模式已禁用：沒有權限繪製其他窗口。請允許%s在其他窗口上繪製。</string>
	<string name="enter_admin_password">輸入管理員密碼</string>
	<string name="wrong_password">密碼錯誤</string>
	<string name="dialog_enter_password_login">登錄</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">該應用程序遇到內部錯誤。請重新啟動設備，然後重試該操作。</string>
	<string name="empty_configuration">未設置配置，請嘗試從服務器獲取！</string>
	<string name="permissions_reset_hint">關閉管理面板以檢查並請求權限。</string>
	<string name="dialog_enter_server_error">請輸入有效的服務器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">請輸入服務器網址</string>
	<string name="critical_server_failure">由於服務器故障而退出！請解決此問題，然後重新啟動%s，或將其完全刪除並重新安裝。</string>
	<string name="dialog_permission_title">該應用需要權限才能運行。請授予請求的權限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到瀏覽器，因此無法打開網頁。請在設備配置中添加瀏覽器應用。</string>
	<string name="invalid_web_link">無法打開 Web 鏈接，因為它的格式不正確。 有關詳細信息，請聯繫您的管理員。</string>
	<string name="activity_not_found">無法執行操作 %s，因為未找到該活動。</string>
	<string name="location_service_text">設備位置受到監控</string>
	<string name="qrcode_contents_error">無效的QR碼內容。請在%s Web面板中生成預配置QR碼。</string>
	<string name="device_locked">此設備 (%s) 已被管理員鎖定。</string>
	<string name="fault_loop_detected">糟糕，啟動器發生了無法恢復的故障！請與系統管理員聯繫。</string>
	<string name="mqtt_service_text">推送通知處於活動狀態</string>
	<string name="background_location">%s 需要後台位置權限。 單擊\'繼續\' 打開權限，單擊\'位置\' 並允許始終確定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">繼續</string>
	<string name="initializing_mdm">正在初始化移動設備管理應用程序...</string>
	<string name="dialog_server_error_title">MDM 服務器 %s 返回無效響應。 請聯繫您的管理員。</string>
	<string name="mdm_choice_message">此設備將由您的組織完全管理。 您的數據不會是私密的，您的 IT 管理員可以隨時刪除或查看您的數據。</string>
	<string name="work_profile_message">此設備將獲得屬於您的組織的受管理工作配置文件。 工作資料與您的私人資料分開，您可以隨時在資料之間切換。</string>
	<string name="overlays_not_supported">不幸的是，您的設備不支持覆蓋。</string>
	<string name="admin_not_supported">您的設備沒有設備管理員選項。 單擊跳過以繼續。</string>
	<string name="manage_storage_not_supported">您的裝置沒有管理外部儲存的選項。</string>
</resources>
</file>

<file path="app/src/main/res/values-zh-rTW/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
	<string name="admin_title">管理員</string>
	<string name="install_error">安裝錯誤</string>
	<string name="file_create_error">建立文件時出錯</string>
	<string name="dialog_enter_device_id_error">該ID未在%s處註冊。從控制面板的“設備”標籤中獲取ID。</string>
	<string name="dialog_enter_device_id_qrcode">二維碼</string>
	<string name="dialog_enter_device_id_variants">變體</string>
	<string name="dialog_enter_device_id_save">儲存</string>
	<string name="dialog_enter_device_id_exit">退出</string>
	<string name="dialog_enter_device_id_title">在%s輸入設備ID</string>
	<string name="main_start_preparations">準備開始</string>
	<string name="main_downloading_configuration">更新配置文件</string>
	<string name="main_downloading_content">更新數據</string>
	<string name="main_update_applications">安裝和更新應用程序</string>
	<string name="dialog_root_message">您需要ROOT權限</string>
	<string name="main_application_start">開始申請</string>
	<string name="main_app_installing">安裝應用程序</string>
	<string name="main_app_downloading">下載申請書</string>
	<string name="main_app_downloading_error">無法下載軟件包</string>
	<string name="main_app_removing">卸載應用程序</string>
	<string name="main_file_downloading">下載文件</string>
	<string name="main_file_downloading_error">下載文件失敗</string>
	<string name="main_activity_repeat">重試</string>
	<string name="main_activity_reset">重啟</string>
	<string name="main_activity_wifi">WiFi</string>
	<string name="main_activity_cancel">取消</string>
	<string name="main_activity_details">細節</string>
	<string name="select_system_launcher">選擇%s作為默認啟動器，然後選中“始終”：</string>
	<string name="dialog_network_error_title">連接到%s時出錯。請檢查互聯網連接，然後重試。</string>
	<string name="main_activity_update_config">從服務器請求配置文件</string>
	<string name="main_activity_applications_update">更新應用程序</string>
	<string name="dialog_overlay_settings_title">請允許應用程序在其他窗口上繪製。\n\n此選項有助於更好地阻止不需要的應用程序，並啟用自助服務終端模式的緊急解鎖。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_manage_storage_title">請允許應用程式管理儲存。\n\n此選項可讓 Headwind MDM 管理您裝置上的檔案。</string>
	<string name="dialog_history_settings_title">請允許該應用訪問使用數據。\n\n此選項啟用對應用程序和設置的控制。\n\n此選項可能會導致更快的電池消耗。 要節省電池電量，請跳過此選項（改用無障礙服務或信息亭模式）。\n\n點按“繼續”以打開設置表。 找到\"%s\" 項，授予權限，然後點擊\"返回\"。</string>
	<string name="dialog_history_settings_continue">繼續</string>
	<string name="dialog_history_settings_skip">跳下一步</string>
	<string name="dialog_unknown_sources_title">請允許從未知來源進行安裝。現在將打開一個設置表。找到“未知來源”，允許安裝，然後單擊“上一步”。</string>
	<string name="dialog_unknown_sources_continue">繼續</string>
	<string name="dialog_miui_permissions_title">MIUI要求手動設置自定義權限。現在將打開“應用程序權限”窗口。輕按\"其他權限\"，允許\"在後台運行時顯示彈出窗口\"，然後單擊\"返回\"。</string>
	<string name="dialog_miui_developer_title">MIUI需要手動設置設備。在信息屏幕上，點擊TAP 7 TIMES \" BUILD NUMBER \"。這將啟用開發人員設置。</string>
	<string name="dialog_miui_optimization_title">MIUI需要手動設置設備。開發人員設置窗口現在將打開。向下滾動屏幕，然後取消選中“ MIUI優化”。</string>
	<string name="dialog_administrator_mode_message">請允許該應用在設備管理員模式下運行。現在將打開一個設置表。選擇\"設備管理員\"，找到\"%s\"項目，激活（Activate）管理員，然後點擊\"返回\"。</string>
	<string name="dialog_administrator_mode_continue">繼續</string>
	<string name="dialog_administrator_mode_skip">跳躍</string>
	<string name="accessibility_service_description">通過MDM應用程序進行活動的應用程序監視</string>
	<string name="dialog_accessibility_service_message">請允許該應用使用輔助功能。現在將打開一個設置表。找到\"%s\"項，允許使用輔助功能，然後點擊\" Back \"。</string>
	<string name="dialog_accessibility_service_continue">繼續</string>
	<string name="dialog_accessibility_service_skip">跳下一步</string>
	<string name="access_to_app_denied">不允許使用以下包裹：</string>
	<string name="access_to_app_denied_2">請請求管理員在設定中啟用此程式包。\n\n按一下「關閉」或「首頁」按鈕繼續。</string>
	<string name="package_id_copied">包 ID 已複製到剪貼簿</string>
	<string name="dialog_app_not_allowed_close">關閉</string>
	<string name="dialog_app_not_allowed_admin">管理員</string>
	<string name="device_id">設備編號</string>
	<string name="imei">IMEI</string>
	<string name="serial_number">序列號</string>
	<string name="phone_number">電話號碼</string>
	<string name="launcher_version">啟動器版本</string>
	<string name="close">關閉</string>
	<string name="admin_change_device_id">更改設備ID</string>
	<string name="admin_change_server_url">更改服務器URL</string>
	<string name="admin_allow_settings">打開設置</string>
	<string name="settings_allowed">您可以在3分鐘內更改設置。</string>
	<string name="admin_clear_restrictions">移除限制</string>
	<string name="permissive_mode_enabled">您可以在 3 分鐘內運行所有應用程序。</string>
	<string name="admin_refresh">更新配置</string>
	<string name="admin_exit">退出系統啟動器</string>
	<string name="admin_reset_permissions">檢查權限</string>
	<string name="admin_reset_network">重置網絡策略</string>
	<string name="admin_reset_network_hint">清除網絡策略。現在，您可以啟用網絡並重新加載配置。</string>
	<string name="reboot">重啟設備</string>
	<string name="reboot_failed">沒有足夠的權限來重新啟動設備。</string>
	<string name="message_turn_on_gps">設置屏幕將打開。請在此屏幕上打開GPS位置，然後單擊返回。</string>
	<string name="message_turn_off_gps">設置屏幕將打開。請在此屏幕上關閉GPS位置，然後單擊返回。</string>
	<string name="message_turn_on_mobile_data">移動數據已禁用！請打開狀態欄，然後打開移動數據。</string>
	<string name="message_turn_off_mobile_data">啟用了移動數據。請打開狀態欄，然後關閉移動數據。</string>
	<string name="message_set_password">您的密碼質量不夠好。設置屏幕將打開。請更改密碼，然後單擊“上一步”。</string>
	<string name="switch_off_blockings">關閉限制...</string>
	<string name="kiosk_mode_requires_overlays">單一模式已禁用：沒有權限繪製其他窗口。請允許%s在其他窗口上繪製。</string>
	<string name="enter_admin_password">輸入管理員密碼</string>
	<string name="wrong_password">密碼錯誤</string>
	<string name="dialog_enter_password_login">登錄</string>
	<string name="dialog_enter_password_cancel">取消</string>
	<string name="internal_error">該應用程序遇到內部錯誤。請重新啟動設備，然後重試該操作。</string>
	<string name="empty_configuration">未設置配置，請嘗試從服務器獲取！</string>
	<string name="permissions_reset_hint">關閉管理面板以檢查並請求權限。</string>
	<string name="dialog_enter_server_error">請輸入有效的服務器URL。</string>
	<string name="dialog_enter_server_ok">OK</string>
	<string name="dialog_enter_server_title">請輸入服務器網址</string>
	<string name="critical_server_failure">由於服務器故障而退出！請解決此問題，然後重新啟動%s，或將其完全刪除並重新安裝。</string>
	<string name="dialog_permission_title">該應用需要權限才能運行。請授予請求的權限。</string>
	<string name="main_activity_exit">退出</string>
	<string name="browser_not_found">由於找不到瀏覽器，因此無法打開網頁。請在設備配置中添加瀏覽器應用。</string>
	<string name="invalid_web_link">無法打開 Web 鏈接，因為它的格式不正確。 有關詳細信息，請聯繫您的管理員。</string>
	<string name="activity_not_found">無法執行操作 %s，因為未找到該活動。</string>
	<string name="location_service_text">設備位置受到監控</string>
	<string name="qrcode_contents_error">無效的QR碼內容。請在%s Web面板中生成預配置QR碼。</string>
	<string name="device_locked">此設備 (%s) 已被管理員鎖定。</string>
	<string name="fault_loop_detected">糟糕，啟動器發生了無法恢復的故障！請與系統管理員聯繫。</string>
	<string name="mqtt_service_text">推送通知處於活動狀態</string>
	<string name="background_location">%s 需要後台位置權限。 單擊\'繼續\' 打開權限，單擊\'位置\' 並允許始終確定位置。</string>
	<string name="location_disable">禁用位置</string>
	<string name="background_location_continue">繼續</string>
	<string name="initializing_mdm">正在初始化移動設備管理應用程序...</string>
	<string name="dialog_server_error_title">MDM 服務器 %s 返回無效響應。 請聯繫您的管理員。</string>
	<string name="mdm_choice_message">此設備將由您的組織完全管理。 您的數據不會是私密的，您的 IT 管理員可以隨時刪除或查看您的數據。</string>
	<string name="work_profile_message">此設備將獲得屬於您的組織的受管理工作配置文件。 工作資料與您的私人資料分開，您可以隨時在資料之間切換。</string>
	<string name="overlays_not_supported">不幸的是，您的設備不支持覆蓋。</string>
	<string name="admin_not_supported">您的設備沒有設備管理員選項。 單擊跳過以繼續。</string>
	<string name="manage_storage_not_supported">您的裝置沒有管理外部儲存的選項。</string>
</resources>
</file>

<file path="app/src/main/res/values/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="white_app_name" translatable="false">MDM Agent</string>
    <string name="app_name" translatable="false">Headwind MDM</string>
    <string name="admin_title">Administrator</string>
    <string name="vendor" translatable="false">h-mdm.com</string>
    <string name="install_error">Error installing</string>
    <string name="file_create_error">Error creating file</string>
    <string name="dialog_enter_device_id_error">This ID is not registered at %s. Get the ID from \"Devices\" tab of the control panel.</string>
    <string name="dialog_enter_device_id_qrcode">QR code</string>
    <string name="dialog_enter_device_id_variants">Variants</string>
    <string name="dialog_enter_device_id_save">Save</string>
    <string name="dialog_enter_device_id_exit">Exit</string>
    <string name="dialog_enter_device_id_title">Enter the device ID at %s</string>
    <string name="main_start_preparations">Preparing to start</string>
    <string name="main_downloading_configuration">Updating configuration file</string>
    <string name="main_downloading_content">Updating data</string>
    <string name="main_update_applications">Installing and updating applications</string>
    <string name="dialog_root_message">You need ROOT access</string>
    <string name="main_application_start">Starting application</string>
    <string name="main_app_installing">Installing application</string>
    <string name="main_app_downloading">Downloading application</string>
    <string name="main_app_downloading_error">Failed to download the package</string>
    <string name="main_app_removing">Uninstalling application</string>
    <string name="main_file_downloading">Downloading file</string>
    <string name="main_file_downloading_error">Failed to download the file</string>
    <string name="main_activity_repeat">Retry</string>
    <string name="main_activity_reset">Reset</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancel</string>
    <string name="main_activity_details">Details</string>
    <string name="select_system_launcher">Select %s as a default launcher and check \'Always\':</string>
    <string name="dialog_network_error_title">Error connecting to %s. Please check the Internet connection and try again.</string>
    <string name="main_activity_update_config">Requesting configuration file from server</string>
    <string name="main_activity_applications_update">Updating applications</string>
    <string name="dialog_overlay_settings_title">Please allow the app to draw over other windows.\n\nThis option aids the blocking of unwanted apps, and enables emergency unlocking of the kiosk mode.\n\nTap \"Continue\" to open the settings. Find the \"%s\" item, grant the permission, then tap \"Back\".</string>
    <string name="dialog_manage_storage_title">Please allow the app to manage storage.\n\nThis option allows Headwind MDM to manage files on your device.</string>
    <string name="dialog_history_settings_title">Please allow the app to access usage data.\n\nThis option enables control of apps and settings.\n\nThis option may cause faster battery drain. To save battery, skip this option (use accessibility services or kiosk mode instead).\n\nTap \"Continue\" to open the settings. Find the \"%s\" item, grant the permission, then tap \"Back\".</string>
    <string name="dialog_history_settings_continue">Continue</string>
    <string name="dialog_history_settings_skip">Skip</string>
    <string name="dialog_unknown_sources_title">Please allow installation from unknown sources. A settings sheet will now open. Find \"Unknown sources\", allow the installation and click \"Back\".</string>
    <string name="dialog_unknown_sources_continue">Continue</string>
    <string name="dialog_miui_permissions_title">MIUI requires manual setup of custom permissions. App permissions window will now open. Tap \"Other permissions\", allow \"Display pop-up windows while running in the background\" and click \"Back\".</string>
    <string name="dialog_miui_developer_title">MIUI requires manual setup of your device. On the info screen, TAP 7 TIMES ON \"BUILD NUMBER\". This will enable developer settings.</string>
    <string name="dialog_miui_optimization_title">MIUI requires manual setup of your device. Developer settings window will now open. Scroll the screen down and uncheck \"MIUI optimization\".</string>
    <string name="dialog_administrator_mode_message">Please allow the app to work in the device administrator mode. A Settings sheet will now open. Select \"Device administrators\", find the \"%s\" item, activate the administrator, and tap \"Back\".</string>
    <string name="dialog_administrator_mode_continue">Continue</string>
    <string name="dialog_administrator_mode_skip">Skip</string>
    <string name="accessibility_service_description">Active app monitoring by the MDM application</string>
    <string name="dialog_accessibility_service_message">Please allow the app to use accessibility services. A Settings sheet will now open. Find the \"%s\" item, allow to use accessibility services, and tap \"Back\".</string>
    <string name="dialog_accessibility_service_continue">Continue</string>
    <string name="dialog_accessibility_service_skip">Skip</string>
    <string name="access_to_app_denied">The package is not allowed:</string>
    <string name="access_to_app_denied_2">Please ask your administrator to enable this package in the configuration.\n\nClick \'Close\' or Home button to proceed.</string>
    <string name="package_id_copied">The package ID is copied to the clipboard</string>
    <string name="dialog_app_not_allowed_close">Close</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">Device ID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Serial number</string>
    <string name="phone_number">Phone number</string>
    <string name="launcher_version">Launcher version</string>
    <string name="close">Close</string>
    <string name="admin_change_device_id">Change device ID</string>
    <string name="admin_change_server_url">Change server URL</string>
    <string name="admin_allow_settings">Open settings</string>
    <string name="settings_allowed">You are allowed to change settings for 3 minutes.</string>
    <string name="admin_clear_restrictions">Clear restrictions</string>
    <string name="permissive_mode_enabled">You are allowed to run all apps for 3 minutes.</string>
    <string name="admin_refresh">Update configuration</string>
    <string name="admin_exit">Exit to system launcher</string>
    <string name="admin_reset_permissions">Check permissions</string>
    <string name="admin_reset_network">Reset network policy</string>
    <string name="admin_reset_network_hint">Network policies are cleared. You can now enable the network and reload the configuration.</string>
    <string name="reboot">Reboot device</string>
    <string name="reboot_failed">Not enough rights to reboot the device.</string>
    <string name="message_turn_on_gps">The settings screen will open. Please turn on GPS location on this screen and click Back.</string>
    <string name="message_turn_off_gps">The settings screen will open. Please TURN OFF GPS location on this screen and click Back.</string>
    <string name="message_turn_on_mobile_data">Mobile data is disabled! Please open the status bar and turn on mobile data.</string>
    <string name="message_turn_off_mobile_data">Mobile data is enabled. Please open the status bar and TURN OFF mobile data.</string>
    <string name="message_set_password">Your password quality is not good enough. The settings screen will open. Please change the password and click Back.</string>
    <string name="switch_off_blockings">Switching off restrictions...</string>
    <string name="kiosk_mode_requires_overlays">Kiosk mode disabled: no permission to draw over other windows. Please allow %s to draw over other windows.</string>
    <string name="enter_admin_password">Enter administrator password</string>
    <string name="wrong_password">Wrong password</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Cancel</string>
    <string name="internal_error">The app encountered an internal error. Please reboot the device and retry the action.</string>
    <string name="empty_configuration">The configuration is not set, retrying to get from the server!</string>
    <string name="permissions_reset_hint">Close the admin panel to check and request permissions.</string>
    <string name="dialog_enter_server_error">Please enter a valid server URL.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Please enter the server URL</string>
    <string name="dialog_enter_server_hint" translatable="false">http://hmdm.example.com:8080/hmdm/</string>
    <string name="critical_server_failure">Quit due to server fault! Please fix the issue and restart %s, or remove it completely and reinstall.</string>
    <string name="dialog_permission_title">The app requires the permissions to run. Please grant the requested permissions.</string>
    <string name="main_activity_exit">Exit</string>
    <string name="browser_not_found">Cannot open the webpage because the browser is not found. Please add a browser app to the device configuration.</string>
    <string name="invalid_web_link">Cannot open the web link because it is not well-formed. Please contact your administrator for details.</string>
    <string name="activity_not_found">Cannot perform the action %s because the activity is not found.</string>
    <string name="location_service_text">Device location is monitored</string>
    <string name="qrcode_contents_error">Invalid QR code contents. Please generate the provisioning QR code in the %s web panel.</string>
    <string name="device_locked">This device (%s) has been locked by the administrator.</string>
    <string name="fault_loop_detected">Oops, the launcher got an unrecoverable fault! Please contact your system administrator.</string>
    <string name="mqtt_service_text">Push notifications are active</string>
    <string name="background_location">%s requires the background location permission. Click \'Continue\' to open permissions, click \'Location\' and allow to determine location always.</string>
    <string name="location_disable">Disable location</string>
    <string name="background_location_continue">Continue</string>
    <string name="initializing_mdm">Initializing the mobile device management application...</string>
    <string name="dialog_server_error_title">MDM server %s returned an invalid response. Please contact your administrator.</string>
    <string name="mdm_choice_message">This device will be fully managed by your organization. Your data won\'t be private and can be erased or reviewed by your IT admin at any time.</string>
    <string name="work_profile_message">This device will get a managed work profile belonging to your organization. The work profile is separated from your private profile and you may switch between profiles at any time.</string>
    <string name="overlays_not_supported">Unfortunately overlays are not supported by your device.</string>
    <string name="admin_not_supported">Your device has no device administrator option. Click Skip to continue.</string>
    <string name="manage_storage_not_supported">Your device has no option to manage the external storage.</string>

    <string-array name="certificates" translatable="false">
        <!-- If you want to install custom SSL certificates, place them in assets folder
             in the PEM format and list the file names here in the <item> tag. -->
        <!--
        <item>custom_ca.cer</item>
        -->
        <item>isrg_root_x1.pem</item>
    </string-array>
</resources>
</file>

<file path="app/src/main/res/values-ar/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">مسؤول</string>
    <string name="install_error">خطأ في التثبيت</string>
    <string name="file_create_error">خطأ في إنشاء الملف</string>
    <string name="dialog_enter_device_id_error">هذا ID غير مسجل في %s. احصل على ID من علامة التبويب \"الأجهزة\" بلوحة التحكم.</string>
    <string name="dialog_enter_device_id_qrcode">QR رمز</string>
    <string name="dialog_enter_device_id_variants">المتغيرات</string>
    <string name="dialog_enter_device_id_save">حفظ</string>
    <string name="dialog_enter_device_id_exit">خروج</string>
    <string name="dialog_enter_device_id_title">أدخل ID الجهاز في %s</string>
    <string name="main_start_preparations">تستعد للبدء</string>
    <string name="main_downloading_configuration">تحديث ملف الاعدادات</string>
    <string name="main_downloading_content">تحديث البيانات</string>
    <string name="main_update_applications">تثبيت وتحديث التطبيقات</string>
    <string name="dialog_root_message">أنت بحاجة إلى الوصول إلى ROOT</string>
    <string name="main_application_start">بدء التطبيق</string>
    <string name="main_app_installing">تثبيت التطبيق</string>
    <string name="main_app_downloading">تحميل التطبيق</string>
    <string name="main_app_downloading_error">فشل تحميل الحزمة</string>
    <string name="main_app_removing">إلغاء تثبيت التطبيق</string>
    <string name="main_activity_repeat">أعد المحاولة</string>
    <string name="main_activity_reset">إعادة تعيين</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">إلغاء</string>
    <string name="main_activity_details">تفاصيل</string>
    <string name="select_system_launcher">حدد %s كمشغل افتراضي وحدد \"دائمًا\":</string>
    <string name="dialog_network_error_title">خطأ في الاتصال بالخادم %s. يرجى التحقق من الاتصال بالإنترنت وحاول مرة أخرى.</string>
    <string name="main_activity_update_config">طلب ملف الاعدادات من الخادم</string>
    <string name="main_activity_applications_update">تحديث التطبيقات</string>
    <string name="dialog_overlay_settings_title">يرجى السماح للتطبيق بالرسم فوق النوافذ الأخرى.\n\nيساعد هذا الخيار في حظر التطبيقات غير المرغوب فيها بشكل أفضل ، ويتيح فتح وضع الكشك في حالات الطوارئ.\n\nانقر فوق متابعة لفتح ورقة الإعدادات. ابحث عن عنصر %s ، وامنح الإذن ، ثم انقر فوق رجوع.</string>
    <string name="dialog_manage_storage_title">يرجى السماح للتطبيق بإدارة التخزين.\n\n يسمح هذا الخيار لتطبيق Headwind MDM بإدارة الملفات على جهازك.</string>
    <string name="dialog_history_settings_title">يرجى السماح للتطبيق بالوصول إلى بيانات الاستخدام.\n\n يتيح هذا الخيار التحكم في التطبيقات والإعدادات.\n\nقد يتسبب هذا الخيار في استنزاف أسرع للبطارية. لحفظ البطارية ، تخطي هذا الخيار (استخدم خدمات إمكانية الوصول أو وضع الكشك بدلاً من ذلك).\n\nانقر فوق متابعة لفتح ورقة الإعدادات. ابحث عن عنصر %s ، وامنح الإذن ، ثم انقر فوق رجوع.\n\n</string>
    <string name="dialog_history_settings_continue">استمر</string>
    <string name="dialog_history_settings_skip">تخطى</string>
    <string name="dialog_unknown_sources_title">الرجاء السماح بالتثبيت من مصادر غير معروفة. سيتم الآن فتح ورقة الإعدادات. ابحث عن \"مصادر غير معروفة\" ، واسمح بالتثبيت وانقر على \"رجوع\".</string>
    <string name="dialog_unknown_sources_continue">استمر</string>
    <string name="dialog_miui_permissions_title">تتطلب MIUI الإعداد اليدوي للأذونات المخصصة. سيتم فتح نافذة أذونات التطبيق الآن. انقر على \"أذونات أخرى\" ، واسمح ب \"عرض النوافذ المنبثقة أثناء التشغيل في الخلفية\" وانقر على \"رجوع\".</string>
    <string name="dialog_administrator_mode_message">يرجى السماح للتطبيق بالعمل في وضع مشرف الجهاز. سيتم فتح ورقة الإعدادات الآن. حدد \"مشرفو الأجهزة\" ، وابحث عن عنصر \"%s\" ، وقم بتنشيط المشرف ، ثم انقر فوق \"رجوع\".</string>
    <string name="dialog_administrator_mode_continue">استمر</string>
    <string name="dialog_administrator_mode_skip">تخطى</string>
    <string name="accessibility_service_description">مراقبة نشطة للتطبيق بواسطة تطبيق MDM</string>
    <string name="dialog_accessibility_service_message">يرجى السماح للتطبيق باستخدام خدمات إمكانية الوصول. سيتم فتح ورقة الإعدادات الآن. ابحث عن عنصر \"%s\" ، واسمح باستخدام خدمات إمكانية الوصول ، وانقر على \"رجوع\".</string>
    <string name="dialog_accessibility_service_continue">استمر</string>
    <string name="dialog_accessibility_service_skip">تخطى</string>
    <string name="access_to_app_denied">الحزمة غير مسموح بها:</string>
    <string name="access_to_app_denied_2">الرجاء مطالبة المسؤول بتمكين هذه الحزمة في التكوين.\n\nانقر فوق \'إغلاق\' أو زر الصفحة الرئيسية للمتابعة.</string>
    <string name="package_id_copied">يتم نسخ معرف الحزمة إلى الحافظة</string>
    <string name="dialog_app_not_allowed_close">أغلق</string>
    <string name="dialog_app_not_allowed_admin">مسؤول</string>
    <string name="device_id">ID الجهاز</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">رقم متسلسل</string>
    <string name="phone_number">رقم الهاتف</string>
    <string name="launcher_version">نسخة مشغل</string>
    <string name="close">أغلق</string>
    <string name="admin_change_device_id">تغيير ID الجهاز</string>
    <string name="admin_change_server_url">تغيير عنوان URL للخادم</string>
    <string name="admin_allow_settings">أفتح الإعدادات</string>
    <string name="settings_allowed">يُسمح لك بتغيير الإعدادات في غضون 3 دقائق.</string>
    <string name="admin_clear_restrictions">قيود واضحة</string>
    <string name="permissive_mode_enabled">يُسمح لك بتشغيل جميع التطبيقات في غضون 3 دقائق.</string>
    <string name="admin_refresh">تحديث التكوين</string>
    <string name="admin_exit">الخروج إلى مشغل النظام</string>
    <string name="admin_reset_permissions">تحقق من الأذونات</string>
    <string name="admin_reset_network">إعادة تعيين سياسة الشبكة</string>
    <string name="admin_reset_network_hint">تم مسح سياسات الشبكة. يمكنك الآن تمكين الشبكة وإعادة تحميل التكوين.</string>
    <string name="reboot">"    جهاز إعادة التشغيل "</string>
    <string name="reboot_failed">لا توجد حقوق كافية لإعادة تشغيل الجهاز.</string>
    <string name="message_turn_on_gps">ستفتح شاشة الإعدادات. يرجى تشغيل موقع GPS على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="message_turn_off_gps">ستفتح شاشة الإعدادات. يرجى إيقاف تشغيل موقع GPS على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="message_turn_on_mobile_data">ستفتح شاشة الإعدادات. الرجاء تشغيل بيانات الجوال على هذه الشاشة والنقر فوق \"رجوع\".</string>
    <string name="message_turn_off_mobile_data">ستفتح شاشة الإعدادات. يرجى إيقاف تشغيل بيانات الجوال على هذه الشاشة والنقر فوق رجوع.</string>
    <string name="switch_off_blockings">جارٍ إطفاء القيود ...</string>
    <string name="kiosk_mode_requires_overlays">تم تعطيل وضع Kiosk: لا يوجد إذن للرسم فوق النوافذ الأخرى. يُرجى السماح لـ %s بالرسم فوق النوافذ الأخرى.</string>
    <string name="enter_admin_password">أدخل كلمة مرور المسؤول</string>
    <string name="wrong_password">كلمة مرور خاطئة</string>
    <string name="dialog_enter_password_login">تسجيل الدخول</string>
    <string name="dialog_enter_password_cancel">إلغاء</string>
    <string name="internal_error">واجه التطبيق خطأ داخليًا. يرجى إعادة تشغيل الجهاز وإعادة محاولة الإجراء.</string>
    <string name="empty_configuration">لم يتم تعيين الاعدادات ، إعادة محاولة الحصول عليه من الخادم!</string>
    <string name="permissions_reset_hint">أغلق لوحة الإدارة للتحقق وطلب الأذونات.</string>
    <string name="dialog_enter_server_error">الرجاء إدخال عنوان URL صالح للخادم.</string>
    <string name="dialog_enter_server_ok">حسنا</string>
    <string name="dialog_enter_server_title">يرجى إدخال عنوان URL للخادم</string>
    <string name="critical_server_failure">خروج بسبب خطأ في الخادم! يُرجى إصلاح المشكلة وإعادة تشغيل برنامج %s ، أو إزالته تمامًا وإعادة التثبيت.</string>
    <string name="dialog_permission_title">يتطلب التطبيق أذونات للتشغيل. يرجى منح الأذونات المطلوبة.</string>
    <string name="main_activity_exit">خروج</string>
    <string name="browser_not_found">لا يمكن فتح صفحة الويب لأن المستعرض غير موجود. الرجاء إضافة تطبيق متصفح إلى اعدادات الجهاز.</string>
    <string name="invalid_web_link">لا يمكن فتح رابط الويب لأنه غير منسق بشكل جيد. يرجى الاتصال بالمسؤول للحصول على التفاصيل.</string>
    <string name="activity_not_found">لا يمكن تنفيذ الإجراء %s لأنه لم يتم العثور على النشاط.</string>
    <string name="location_service_text">يتم مراقبة موقع الجهاز</string>
    <string name="qrcode_contents_error">محتويات رمز QR غير صالحة. يرجى إنشاء رمز الاستجابة السريعة التوفير في لوحة الويب %s.</string>
    <string name="main_file_downloading">تحميل الملف</string>
    <string name="main_file_downloading_error">فشل تحميل الملف</string>
    <string name="message_set_password">جودة كلمة المرور الخاصة بك غير كافية. ستفتح شاشة الإعدادات الآن. يرجى تغيير كلمة المرور الخاصة بك والنقر فوق \"رجوع\".</string>
    <string name="device_locked">تم قفل هذا الجهاز (%s) من قبل المسؤول.</string>
    <string name="fault_loop_detected">المشغل معطل ولا يمكن استعادته! الرجاء الإبلاغ عن هذه المشكلة إلى المسؤول.</string>
    <string name="dialog_miui_optimization_title">يتطلب MIUI التكوين اليدوي. سيتم الآن فتح شاشة إعدادات المطور. قم بالتمرير لأسفل الشاشة وإيقاف تشغيل علامة \"MIUI التحسين\".</string>
    <string name="dialog_miui_developer_title">يتطلب MIUI الاعدادات اليدوي. ستفتح الشاشة الآن ، اضغط على 7 مرات على \"رقم التجميع\". سيؤدي هذا إلى فتح إعدادات المطور.</string>
    <string name="mqtt_service_text">التنبيهات الفورية نشطة</string>
    <string name="background_location">يتطلب %s إذن موقع الخلفية. انقر فوق \"متابعة\" لفتح الأذونات ، وانقر فوق \"الموقع\" واسمح بتحديد الموقع دائمًا.</string>
    <string name="location_disable">تعطيل الموقع</string>
    <string name="background_location_continue">يكمل</string>
    <string name="initializing_mdm">جاري تهيئة تطبيق إدارة الجهاز المحمول ...</string>
    <string name="dialog_server_error_title">أرجع خادم MDM%s استجابة غير صالحة. الرجاء الاتصال بالمسؤول الخاص بك.</string>
    <string name="mdm_choice_message">ستتم إدارة هذا الجهاز بالكامل بواسطة مؤسستك. لن تكون بياناتك خاصة ويمكن مسحها أو مراجعتها بواسطة مسؤول تكنولوجيا المعلومات في أي وقت.</string>
    <string name="work_profile_message">سيحصل هذا الجهاز على ملف شخصي للعمل مُدار ينتمي إلى مؤسستك. يتم فصل الملف الشخصي للعمل عن ملفك الشخصي الخاص ويمكنك التبديل بين الملفات الشخصية في أي وقت.</string>
    <string name="overlays_not_supported">للأسف لا يدعم جهازك التراكبات.</string>
    <string name="admin_not_supported">جهازك ليس لديه خيار مسؤول الجهاز. انقر فوق تخطي للمتابعة.</string>
    <string name="manage_storage_not_supported">لا يتوفر لجهازك خيار لإدارة وحدة التخزين الخارجية.</string>
</resources>
</file>

<file path="app/src/main/res/values-es/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrador</string>
    <string name="install_error">Error instalando </string>
    <string name="file_create_error">Error al crear el archivo</string>
    <string name="dialog_enter_device_id_error">Esta ID no esta registrada en %s. Verifica la ID en la pestaña  \"Dispositivos\" del panel de control.</string>
    <string name="dialog_enter_device_id_qrcode">Codigo QR</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Guardar</string>
    <string name="dialog_enter_device_id_exit">Salir</string>
    <string name="dialog_enter_device_id_title">Ingresa la ID del dispositivo en %s</string>
    <string name="main_start_preparations">Preprarando para iniciar</string>
    <string name="main_downloading_configuration">Actualizando archivo de configuracion</string>
    <string name="main_downloading_content">Actualizando datos</string>
    <string name="main_update_applications">Instalando y actualizando aplicaciones</string>
    <string name="dialog_root_message">Usted necesita acceso ROOT</string>
    <string name="main_application_start">Iniciando aplicacion</string>
    <string name="main_app_installing">Instalando Aplicacion</string>
    <string name="main_app_downloading">Descargando aplicacion</string>
    <string name="main_app_downloading_error">Fallo la descarga del paquete</string>
    <string name="main_app_removing">Desinstalando aplicacion</string>
    <string name="main_file_downloading">Descargando archivo</string>
    <string name="main_file_downloading_error">Fallo la descarga del archivo</string>
    <string name="main_activity_repeat">Reintentar</string>
    <string name="main_activity_reset">Limpiar</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Cancelar</string>
    <string name="main_activity_details">Detalles</string>
    <string name="select_system_launcher">Seleccione %s como launcher por defecto y seleccione \'Siempre\':</string>
    <string name="dialog_network_error_title">Error conectando a %s. Por favor, verifique la coneccion a Internet y reintente.</string>
    <string name="main_activity_update_config">Solicitando archivo de configuracion desde el servidor</string>
    <string name="main_activity_applications_update">Actualizando aplicaciones</string>
    <string name="dialog_overlay_settings_title">Permita que la aplicación se dibuje sobre otras ventanas.\n\nEsta opción ayuda a bloquear mejor las aplicaciones no deseadas y habilita el desbloqueo de emergencia del modo quiosco.\n\nToca \"Continuar\" para abrir una hoja de configuración. Busque el elemento \"%s\", conceda el permiso y toque \"Atrás\".</string>
    <string name="dialog_manage_storage_title">Permita que la aplicación administre el almacenamiento.\n\nEsta opción permite que Headwind MDM administre archivos en su dispositivo.</string>
    <string name="dialog_history_settings_title">Permita que la aplicación acceda a los datos de uso.\n\nEsta opción habilita el control de aplicaciones y configuraciones.\n\nEsta opción puede hacer que la batería se agote más rápido. Para ahorrar batería, omita esta opción (utilice los servicios de accesibilidad o el modo quiosco).\n\nToca \"Continuar\" para abrir una hoja de configuración. Busque el elemento \"%s\", conceda el permiso y toque \"Atrás\".</string>
    <string name="dialog_history_settings_continue">Continuar</string>
    <string name="dialog_history_settings_skip">Omitir</string>
    <string name="dialog_unknown_sources_title">Por favor, permita la instalacion desde fuentes desconocidas. La pantalla de configuracion sera abierta ahora. Encuentre la opcion \"Fuentes Desconocidas\", permita la instalacion y presione \"Atras\".</string>
    <string name="dialog_unknown_sources_continue">Continuar</string>
    <string name="dialog_miui_permissions_title">MIUI requiere la configruacion manual de otros permisos. La pantalla de configuracion sera abierta ahora. Presione \"Otros permisos\", permita \"Mostrar ventanas emergentes ejecutandose en segundo plano\" y presione \"Atras\".</string>
    <string name="dialog_miui_developer_title">MIUI requiere la configruacion manual de otros permisos. En la pantalla de informacion, PRESIONE 7 VECES EN \"NUMERO DE COMPILACION\". Esto habilitara las opciones de desarrollador.</string>
    <string name="dialog_miui_optimization_title">MIUI requiere la configruacion manual de otros permisos. La pantalla de configuracion de desarrollador sera abierta ahora. Baje hacia abajo y destilde \"Optimizacion MIUI\".</string>
    <string name="dialog_administrator_mode_message">Por favor, permita a la aplicacion trabajar en modo Administrador. La pantalla de configuracion sera abierta ahora. Seleccione \"Administrador de Dispositivo\", encuentre la opcion \"%s\", active los permisos de administrador y presione \"Atras\".</string>
    <string name="dialog_administrator_mode_continue">Continuar</string>
    <string name="dialog_administrator_mode_skip">Omitir</string>
    <string name="accessibility_service_description">Monitoreo activo por la aplicación MDM</string>
    <string name="dialog_accessibility_service_message">Por favor, permita a la aplicacion trabajar con opciones de accesibilidad. La pantalla de configuracion sera abierta ahora. Encuentre la opcion \"%s\", permita el uso de servicios de accesibilidad, and presione \"Atras\".</string>
    <string name="dialog_accessibility_service_continue">Continuar</string>
    <string name="dialog_accessibility_service_skip">Omitir</string>
    <string name="access_to_app_denied">El paquete no está permitido:</string>
    <string name="access_to_app_denied_2">Pídale a su administrador que habilite este paquete en la configuración.\n\nHaga clic en el botón \'Cerrar\' o Inicio para continuar.</string>
    <string name="package_id_copied">El ID del paquete se copia al portapapeles.</string>
    <string name="dialog_app_not_allowed_close">Cerrar</string>
    <string name="dialog_app_not_allowed_admin">Administrador</string>
    <string name="device_id">ID Dispositivo</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numero de Serie</string>
    <string name="phone_number">Numero de Telefono</string>
    <string name="launcher_version">Version Launcher</string>
    <string name="close">Cerrar</string>
    <string name="admin_change_device_id">Cambiar ID Dispositivo</string>
    <string name="admin_change_server_url">Cambiar URL Servidor</string>
    <string name="admin_allow_settings">Abrir Configuracion</string>
    <string name="settings_allowed">Usted esta autorizado a cambiar la configuracion por 3 minutos.</string>
    <string name="admin_clear_restrictions">Eliminar restricciones</string>
    <string name="permissive_mode_enabled">Puede ejecutar todas las aplicaciones en 3 minutos.</string>
    <string name="admin_refresh">Actualizar configuracion</string>
    <string name="admin_exit">Salir al Inicio</string>
    <string name="admin_reset_permissions">Verificar permisos</string>
    <string name="admin_reset_network">Restablecer la política de red</string>
    <string name="admin_reset_network_hint">Se borran las políticas de red. Ahora puede habilitar la red y volver a cargar la configuración.</string>
    <string name="reboot">Reiniciar Dispositivo</string>
    <string name="reboot_failed">No posee suficientes permisos para reiniciar el dispositivo.</string>
    <string name="message_turn_on_gps">La pantalla de configuracion se abrira ahora. Por favor, habilite la localizacion por GPS y presione Atras.</string>
    <string name="message_turn_off_gps">La pantalla de configuracion se abrira ahora. Por favor, deshabilite la localizacion por GPS y presione Atras.</string>
    <string name="message_turn_on_mobile_data">Los datos moviles estan desactivados! Por favor, abra la barra de estado y habilite los mismos.</string>
    <string name="message_turn_off_mobile_data">Mobile data are enabled. Por favor, abra la barra de estado y deshabilite los mismos.</string>
    <string name="message_set_password">Tu contraseña no es suficientemente segura. La pantalla de configuracion se abrira ahora. Por favor, cambie la contraseña y presione Atras.</string>
    <string name="switch_off_blockings">Deshabilitando restricciones...</string>
    <string name="kiosk_mode_requires_overlays">Modo Kiosk deshabilitado: no se encontro permiso para sobreponerse a otras ventanas. Por favor, permita a %s sobreponerse a ventanas.</string>
    <string name="enter_admin_password">Ingrese la contraseña de Administrador</string>
    <string name="wrong_password">Contraseña invalida.</string>
    <string name="dialog_enter_password_login">Ingresar</string>
    <string name="dialog_enter_password_cancel">Cancelar</string>
    <string name="internal_error">La aplicacion encontro un error interno. Por favor, reincie el dispositivo y reintente esta accion.</string>
    <string name="empty_configuration">La configuracion no pudo ser descargada, reintentando descargarla del servidor.</string>
    <string name="permissions_reset_hint">Cierre el panel de administrador para verificar los permisos.</string>
    <string name="dialog_enter_server_error">Por favor, ingrese una URL valida.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Por favor, ingrese la URL del servidor</string>
    <string name="critical_server_failure">¡El servidor ha presentando una falla! Por favor, solucione el problema y reinicie %s, o realice una nueva instalacion.</string>
    <string name="dialog_permission_title">La aplicacion requiere permisos para ejecutarse. Por favor, conceda los permisos solicitados.</string>
    <string name="main_activity_exit">Salir</string>
    <string name="browser_not_found">No se pudo abrir la pagina web porque no se encontro el explorador web. Por favor, añada un explorador web a la configuracion del dispositivo.</string>
    <string name="invalid_web_link">No se puede abrir el enlace web porque no está bien formado. Póngase en contacto con su administrador para obtener más información.</string>
    <string name="activity_not_found">No se puede realizar la acción %s porque no se encuentra la actividad.</string>
    <string name="location_service_text">La localizacion del dispositivo esta siendo monitoreada</string>
    <string name="qrcode_contents_error">Codigo QR invalido. Por favor, genere un nuevo QR desde el panel de administrador de %s.</string>
    <string name="device_locked">Este dispositivo (%s) ha sido bloqueado por el administrador.</string>
    <string name="fault_loop_detected">Lo sentimos, la aplicacion encontro un error inrecuperable. Por favor, contacte con su administrador de sistemas.</string>
    <string name="mqtt_service_text">Las notificaciones push están activas</string>
    <string name="background_location">%s requiere el permiso de ubicación en segundo plano. Haga clic en \'Continuar\' para abrir los permisos, haga clic en \'Ubicación\' y permita determinar la ubicación siempre.</string>
    <string name="location_disable">Deshabilitar ubicación</string>
    <string name="background_location_continue">Continuar</string>
    <string name="initializing_mdm">Inicialización de la aplicación de gestión de dispositivos móviles ...</string>
    <string name="dialog_server_error_title">El servidor MDM %s devolvió una respuesta no válida. Comuníquese con su administrador.</string>
    <string name="mdm_choice_message">Este dispositivo será completamente administrado por su organización. Sus datos no serán privados y su administrador de TI puede borrarlos o revisarlos en cualquier momento.</string>
    <string name="work_profile_message">Este dispositivo obtendrá un perfil de trabajo administrado que pertenece a su organización. El perfil de trabajo está separado de su perfil privado y puede cambiar de perfil en cualquier momento.</string>
    <string name="overlays_not_supported">Lamentablemente, las superposiciones no son compatibles con su dispositivo.</string>
    <string name="admin_not_supported">Su dispositivo no tiene ninguna opción de administrador de dispositivos. Haga clic en Omitir para continuar.</string>
    <string name="manage_storage_not_supported">Su dispositivo no tiene ninguna opción para administrar el almacenamiento externo.</string>
</resources>
</file>

<file path="app/src/main/res/values-fr/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrateur</string>
    <string name="install_error">Erreur lors de l\'installation</string>
    <string name="file_create_error">Erreur lors de la création du fichier</string>
    <string name="dialog_enter_device_id_error">Ce ID n\'est pas enregistrée au %s. Obtenez ID dans \'onglet \"Appareils\" du panneau de contrôle.</string>
    <string name="dialog_enter_device_id_qrcode">Code QR</string>
    <string name="dialog_enter_device_id_variants">Variantes</string>
    <string name="dialog_enter_device_id_save">Sauvegarder</string>
    <string name="dialog_enter_device_id_exit">Sortir</string>
    <string name="dialog_enter_device_id_title">Entrer ID de l\'appareil à %s</string>
    <string name="main_start_preparations">Préparation du démarrage</string>
    <string name="main_downloading_configuration">Mise à jour du fichier de configuration</string>
    <string name="main_downloading_content">Mise à jour des données</string>
    <string name="main_update_applications">Installation et mise à jour des applications</string>
    <string name="dialog_root_message">Vous avez besoin d\'un accès ROOT</string>
    <string name="main_application_start">Démarrage de l\'application</string>
    <string name="main_app_installing">Installation de l\'application</string>
    <string name="main_app_downloading">Téléchargement de l\'application</string>
    <string name="main_app_downloading_error">Echec du téléchargement du package</string>
    <string name="main_app_removing">Désinstallation de l\'application</string>
    <string name="main_file_downloading">Téléchargement du fichier</string>
    <string name="main_file_downloading_error">Echec du téléchargement du fichier</string>
    <string name="main_activity_repeat">Recommencez</string>
    <string name="main_activity_reset">Effacer</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Annuler</string>
    <string name="main_activity_details">Détails</string>
    <string name="select_system_launcher">Choisissez %s comme lanceur par défaut et vérifiez \"Toujours\":</string>
    <string name="dialog_network_error_title">Erreur de connexion au serveur %s. Veuillez vérifier la connexion Internet et réessayer.</string>
    <string name="main_activity_update_config">Demander le fichier de configuration au serveur</string>
    <string name="main_activity_applications_update">Mise à jour des applications</string>
    <string name="dialog_overlay_settings_title">Veuillez autoriser l\'app à dessiner sur d\'autres fenêtres.\n\nCette option permet de mieux bloquer les applications indésirables et permet le déverrouillage d\'urgence du mode kiosque.\n\nAppuyez sur \"Continuer\" pour ouvrir une feuille de paramètres. Recherchez l\'élément \"%s\", accordez l\'autorisation et appuyez sur \"Retour\".</string>
    <string name="dialog_manage_storage_title">Veuillez autoriser l\'app à gérer le stockage.\n\nCette option permet à Headwind MDM de gérer les fichiers sur votre appareil.</string>
    <string name="dialog_history_settings_title">Veuillez autoriser l\'app à accéder aux données d\'utilisation.\n\nCette option permet de contrôler les apps et les paramètres.\n\nCette option peut entraîner une décharge plus rapide de la batterie. Pour économiser la batterie, ignorez cette option (utilisez plutôt les services d\'accessibilité ou le mode kiosque).\n\nAppuyez sur \"Continuer\" pour ouvrir une feuille de paramètres. Recherchez l\'élément \"%s\", accordez l\'autorisation et appuyez sur \"Retour\".</string>
    <string name="dialog_history_settings_continue">Continuer</string>
    <string name="dialog_history_settings_skip">Passer</string>
    <string name="dialog_unknown_sources_title">Veuillez autoriser l\'installation à partir de sources inconnues. Une fiche de paramètres s\'ouvrira. Trouvez \"Sources inconnues\", autorisez l\'installation et cliquez sur \"Retour\".</string>
    <string name="dialog_unknown_sources_continue">Continuer</string>
    <string name="dialog_miui_permissions_title">MIUI nécessite une configuration manuelle des autorisations personnalisées. La fenêtre des autorisations de l\'app s\'ouvrira. Appuyez sur \"Autres autorisations\", autorisez \"Afficher les fenêtres pop-up lors de l\'exécution en arrière-plan\" et cliquez sur \"Retour\".</string>
    <string name="dialog_miui_developer_title">MIUI nécessite une configuration manuelle de votre appareil. Sur l\'écran d\'informations, TAP 7 FOIS SUR \"NUMÉRO DE CONSTRUCTION\". Cela activera les paramètres du développeur.</string>
    <string name="dialog_miui_optimization_title">MIUI nécessite une configuration manuelle de votre appareil. La fenêtre des paramètres du développeur va maintenant s\'ouvrir. Faites défiler l\'écran vers le bas et décochez \"Optimisation MIUI\".</string>
    <string name="dialog_administrator_mode_message">Veuillez autoriser l\'app à fonctionner en mode administrateur de l\'appareil. Une fiche de paramètres s\'ouvrira. Sélectionnez \"Administrateurs de l\'appareil\", recherchez l\'élément \"%s\", activez l\'administrateur et appuyez sur \"Retour\".</string>
    <string name="dialog_administrator_mode_continue">Continuer</string>
    <string name="dialog_administrator_mode_skip">Passer</string>
    <string name="accessibility_service_description">Surveillance active des apps par l\'application MDM</string>
    <string name="dialog_accessibility_service_message">Veuillez autoriser \'app à utiliser les services d\'accessibilité. Une fiche de paramètres s\'ouvrira. Trouvez l\'élément \"%s\", autorisez l\'utilisation des services d\'accessibilité, et appuyez sur \"Retour\".</string>
    <string name="dialog_accessibility_service_continue">Continuer</string>
    <string name="dialog_accessibility_service_skip">Passer</string>
    <string name="access_to_app_denied">Le colis n\'est pas autorisé:</string>
    <string name="access_to_app_denied_2">Veuillez demander à votre administrateur d\'activer ce package dans la configuration.\n\nCliquez sur \'Fermer\' ou sur le bouton Accueil pour continuer.</string>
    <string name="package_id_copied">L\'ID du package est copié dans le presse-papiers</string>
    <string name="dialog_app_not_allowed_close">Fermer</string>
    <string name="dialog_app_not_allowed_admin">Administrateur</string>
    <string name="device_id">ID de l\'appareil</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Numéro de série</string>
    <string name="phone_number">Numéro de téléphone</string>
    <string name="launcher_version">Version du lanceur</string>
    <string name="close">Fermer</string>
    <string name="admin_change_device_id">Changer l\'ID de l\'appareil</string>
    <string name="admin_change_server_url">Changer URL du serveur</string>
    <string name="admin_allow_settings">Ouvrir les paramètres</string>
    <string name="settings_allowed">Vous avez 3 minutes pour modifier les paramètres.</string>
    <string name="admin_clear_restrictions">Supprimer les restrictions</string>
    <string name="permissive_mode_enabled">Vous êtes autorisé à exécuter toutes les applications dans les 3 minutes.</string>
    <string name="admin_refresh">Actualiser la configuration</string>
    <string name="admin_exit">Quitter vers le lanceur de système</string>
    <string name="admin_reset_permissions">Vérifier les autorisations</string>
    <string name="admin_reset_network">Effacer la politique de réseau</string>
    <string name="admin_reset_network_hint">Les stratégies réseau sont effacées. Vous pouvez maintenant activer le réseau et recharger la configuration.</string>
    <string name="reboot">Redémarrer l\'appareil</string>
    <string name="reboot_failed">Pas assez de droits pour redémarrer l\'appareil.</string>
    <string name="message_turn_on_gps">L\'écran des paramètres s\'ouvre. Veuillez activer la localisation GPS sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_off_gps">L\'écran des paramètres s\'ouvre. Veuillez DÉSACTIVER la localisation GPS sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_on_mobile_data">L\'écran des paramètres s\'ouvre. Veuillez activer les données mobiles sur cet écran et cliquez sur Retour.</string>
    <string name="message_turn_off_mobile_data">L\'écran des paramètres s\'ouvre. Veuillez désactiver les données mobiles sur cet écran et cliquez sur Retour.</string>
    <string name="message_set_password">La qualité de votre mot de passe n\'est pas suffisante. L\'écran des paramètres s\'ouvre. Veuillez changer le mot de passe et cliquez sur Retour.</string>
    <string name="switch_off_blockings">Désactiver les restrictions...</string>
    <string name="kiosk_mode_requires_overlays">Mode kiosk désactivé : pas de permission pour passer par-dessus d\'autres fenêtres. Veuillez permettre à %s de passer par-dessus d\'autres fenêtres.</string>
    <string name="enter_admin_password">Entrez le mot de passe administrateur</string>
    <string name="wrong_password">Mauvais mot de passe</string>
    <string name="dialog_enter_password_login">S\'identifier</string>
    <string name="dialog_enter_password_cancel">Annuler</string>
    <string name="internal_error">L\'app a rencontré une erreur interne. Veuillez redémarrer l\'appareil et réessayer l\'action.</string>
    <string name="empty_configuration">La configuration n\'est pas définie, essayant à nouveau de l\'obtenir du serveur!</string>
    <string name="permissions_reset_hint">Fermez le panneau d\'administration pour vérifier et demander des autorisations.</string>
    <string name="dialog_enter_server_error">Veuillez saisir une URL de serveur valide.</string>
    <string name="dialog_enter_server_ok">D\'accord</string>
    <string name="dialog_enter_server_title">Veuillez saisir URL du serveur</string>
   <string name="critical_server_failure">Quittez en raison d\'une panne du serveur! Veuillez résoudre le problème et redémarrer %s, ou supprimez-le complètement et réinstallez-le.</string>
    <string name="dialog_permission_title">L\'app nécessite les autorisations pour s\'exécuter. Veuillez accorder les autorisations demandées.</string>
    <string name="main_activity_exit">Sortie</string>
    <string name="browser_not_found">Impossible d\'ouvrir la page Web car le navigateur est introuvable. Veuillez ajouter une app de navigateur à la configuration de l\'appareil.</string>
    <string name="invalid_web_link">Impossible d\'ouvrir le lien Web car il n\'est pas bien formé. Veuillez contacter votre administrateur pour plus de détails.</string>
    <string name="activity_not_found">Impossible d\'effectuer l\'action %s car l\'activité est introuvable.</string>
    <string name="location_service_text">La localisation de l\'appareil est surveillée</string>
    <string name="qrcode_contents_error">Contenu du code QR non valide. Veuillez générer le code QR de provisionnement dans le panneau Web %s.</string>
    <string name="device_locked">Cet appareil (%s) a été verrouillé par l\'administrateur.</string>
    <string name="fault_loop_detected">Oups, le lanceur a eu une faute irrémédiable! Veuillez contacter votre administrateur système.</string>
    <string name="mqtt_service_text">Les notifications push sont actives</string>
    <string name="background_location">%s requiert l\'autorisation d\'emplacement en arrière-plan. Cliquez sur \'Continuer\' pour ouvrir les autorisations, cliquez sur \'Emplacement\' et autorisez toujours à déterminer l\'emplacement.</string>
    <string name="location_disable">Désactiver l\'emplacement</string>
    <string name="background_location_continue">Continuer</string>
    <string name="initializing_mdm">Initialisation de l\'application de gestion des appareils mobiles...</string>
    <string name="dialog_server_error_title">Le serveur MDM %s a renvoyé une réponse non valide. Veuillez contacter votre administrateur.</string>
    <string name="mdm_choice_message">Cet appareil sera entièrement géré par votre organisation. Vos données ne seront pas privées et pourront être effacées ou révisées par votre administrateur informatique à tout moment.</string>
    <string name="work_profile_message">Cet appareil recevra un profil professionnel géré appartenant à votre organisation. Le profil professionnel est séparé de votre profil privé et vous pouvez basculer entre les profils à tout moment.</string>
    <string name="overlays_not_supported">Malheureusement, les superpositions ne sont pas prises en charge par votre appareil.</string>
    <string name="admin_not_supported">Votre appareil n\'a pas d\'option d\'administrateur d\'appareil. Cliquez sur Ignorer pour continuer.</string>
    <string name="manage_storage_not_supported">Votre appareil n\'a aucune option pour gérer le stockage externe.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/InstallUtils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.annotation.TargetApi;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageInfo;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.util.Log;

import androidx.core.content.FileProvider;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.RemoteFile;

import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class InstallUtils {

    public static void generateApplicationsForInstallList(Context context, List<Application> applications,
                                                          List<Application> applicationsForInstall,
                                                          Map<String, File> pendingInstallations) {
        PackageManager packageManager = context.getPackageManager();

        // First handle apps to be removed, then apps to be installed
        // We process only applications of type "app" (default) and skip web links and others
        for (Application a : applications) {
            if ((a.getType() == null || a.getType().equals(Application.TYPE_APP)) && a.isRemove() &&
                !isInList(applicationsForInstall, a)) {
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): marking app " + a.getPkg() + " to remove");
                applicationsForInstall.add(a);
            }
        }
        for (Application a : applications) {
            if ((a.getType() == null || a.getType().equals(Application.TYPE_APP)) && !a.isRemove() &&
                    !pendingInstallations.containsKey(a.getPkg()) && !isInList(applicationsForInstall, a)) {
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): marking app " + a.getPkg() + " to install");
                applicationsForInstall.add(a);
            }
        }
        Iterator< Application > it = applicationsForInstall.iterator();

        while ( it.hasNext() ) {
            Application application = it.next();
            if ( (application.getUrl() == null || application.getUrl().trim().equals("")) && !application.isRemove() ) {
                // An app without URL is a system app which doesn't require installation
                Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " is system, skipping");
                it.remove();
                continue;
            }

            try {
                PackageInfo packageInfo = packageManager.getPackageInfo( application.getPkg(), 0 );

                if (application.isRemove() && !application.getVersion().equals("0") &&
                        !areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode())) {
                    // If a removal is required, but the app version doesn't match, do not remove
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " version not match: "
                            + application.getVersion() + " " + packageInfo.versionName + ", skipping");
                    it.remove();
                    continue;
                }

                if (!application.isRemove() && !upgradingHmdmFreeToFull(context, application, packageInfo) &&
                        (application.isSkipVersion() || application.getVersion().equals("0") ||
                                areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode()))) {
                    // If installation is required, but the app of the same version already installed, do not install
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " versions match: "
                            + application.getVersion() + " " + packageInfo.versionName + ", skipping");
                    it.remove();
                    continue;
                }

                if (!application.isRemove() &&
                        compareVersions(packageInfo.versionName, packageInfo.versionCode, application.getVersion(), application.getCode()) > 0) {
                    // Downgrade requested!
                    // It will only succeed if a higher version is marked as "Remove"
                    // Let's check that condition to avoid failed attempts to install and downloads of the lower version each time
                    RemoteLogger.log(context, Const.LOG_DEBUG, "Downgrade requested for " + application.getPkg() +
                            ": installed version " + packageInfo.versionName + ", required version " + application.getVersion());
                    boolean canDowngrade = false;
                    for (Application a : applications) {
                        if (a.getPkg().equalsIgnoreCase(application.getPkg()) && a.isRemove() &&
                                areVersionsEqual(packageInfo.versionName, packageInfo.versionCode, a.getVersion(), a.getCode())) {
                            // Current version will be removed
                            canDowngrade = true;
                            break;
                        }
                    }
                    if (canDowngrade) {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Current version of " + application.getPkg() + " will be removed, downgrade allowed");
                    } else {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Ignoring downgrade request for " + application.getPkg() + ": remove current version first!");
                        it.remove();
                        continue;
                    }
                }
            } catch ( PackageManager.NameNotFoundException e ) {
                // The app isn't installed, let's keep it in the "To be installed" list
                if (application.isRemove()) {
                    // The app requires removal but already removed, remove from the list so do nothing with the app
                    Log.d(Const.LOG_TAG, "checkAndUpdateApplications(): app " + application.getPkg() + " not found, nothing to remove");
                    it.remove();
                    continue;
                }
            }
        }
    }

    private static boolean isInList(List<Application> applicationsForInstall, Application a) {
        for (Application b : applicationsForInstall) {
            if (a.getPkg().equalsIgnoreCase(b.getPkg()) &&
                    a.getVersion().equalsIgnoreCase(b.getVersion()) &&
                    a.isRemove() == b.isRemove()) {
                return true;
            }
        }
        return false;
    }

    // Free and full versions of Headwind MDM launcher have the same version name but different version codes
    // This is a dirty hack determining the full version by the URL
    // It's however better to use different versions, for example 5.16.1 for free and 5.16.2 for full
    private static boolean upgradingHmdmFreeToFull(Context context, Application application, PackageInfo packageInfo) {
        if (!application.getPkg().equals(context.getPackageName())) {
            return false;
        }
        return Utils.getLauncherVariant().equals("opensource") && application.getUrl().endsWith("master.apk");
    }

    private static boolean areVersionsEqual(String v1, int c1, String v2, Integer c2) {
        if (c2 != null && c2 != 0) {
            // If version code is present, let's compare version codes instead of names
            return c1 == c2;
        }

        if (v1 == null || v2 == null) {
            // Exceptional case, we should never be here but this shouldn't crash the app with NPE
            return v1 == v2;
        }

        // Compare only digits (in Android 9 EMUI on Huawei Honor 8A, getPackageInfo doesn't get letters!)
        String v1d = v1.replaceAll("[^\\d.]", "");
        String v2d = v2.replaceAll("[^\\d.]", "");
        return v1d.equals(v2d);
    }

    // Returns -1 if v1 < v2, 0 if v1 == v2 and 1 if v1 > v2
    public static int compareVersions(String v1, int c1, String v2, Integer c2) {
        if (c2 != null && c2 != 0) {
            // If version code is present, let's compare version codes instead of names
            if (c1 < c2) {
                return -1;
            } else if (c1 > c2) {
                return 1;
            } else {
                return 0;
            }
        }

        // Exceptional cases: null values
        if (v1 == null && v2 == null) {
            return 0;
        }
        if (v1 == null) {
            return -1;
        }
        if (v2 == null) {
            return 1;
        }
        // Versions are numbers separated by a dot
        String v1d = v1.replaceAll("[^\\d.]", "");
        String v2d = v2.replaceAll("[^\\d.]", "");

        String[] v1n = v1d.split("\\.");
        String[] v2n = v2d.split("\\.");

        // One version could contain more digits than another
        int count = v1n.length < v2n.length ? v1n.length : v2n.length;

        for (int n = 0; n < count; n++) {
            try {
                int n1 = Integer.parseInt(v1n[n]);
                int n2 = Integer.parseInt(v2n[n]);
                if (n1 < n2) {
                    return -1;
                } else if (n1 > n2) {
                    return 1;
                }
                // If major version numbers are equals, continue to compare minor version numbers
            } catch (Exception e) {
                return 0;
            }
        }

        // Here we are if common parts are equal
        // Now we decide that if a version has more parts, it is considered as greater
        if (v1n.length < v2n.length) {
            return -1;
        } else if (v1n.length > v2n.length) {
            return 1;
        }
        return 0;
    }

    public static void generateFilesForInstallList(Context context, List<RemoteFile> files,
                                                          List<RemoteFile> filesForInstall) {
        for (RemoteFile remoteFile : files) {
            File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
            if (remoteFile.isRemove()) {
                if (file.exists()) {
                    filesForInstall.add(remoteFile);
                }
            } else {
                if (!file.exists()) {
                    filesForInstall.add(remoteFile);
                } else {
                    RemoteFile remoteFileDb = RemoteFileTable.selectByPath(DatabaseHelper.instance(context).getReadableDatabase(),
                            remoteFile.getPath());
                    if (remoteFileDb == null ||
                            // Entry not found in the database
                            // This means, a file was created by a third party
                            // We overwrite the file (and save the entry in the database after overwriting in ConfigUpdater.loadAndInstallFiles())
                            remoteFileDb.getLastUpdate() < remoteFile.getLastUpdate()) {
                        // File has been already downloaded by Headwind MDM,
                        // let's check lastUpdate (checksum is not reliable because of possible variable content)
                        // We only overwrite a file if the file on the server is newer than the file on the device
                        // (on the device, we save the lastUpdate from the server, we don't check the actual file update date)
                        // Which means, the file may be later changed by a third party app
                        filesForInstall.add(remoteFile);
                    }
                }
            }
        }
    }


        public interface DownloadProgress {
        void onDownloadProgress(final int progress, final long total, final long current);
    }

    public static String getAppTempPath(Context context, String strUrl) {
        File tempFile = new File(context.getExternalFilesDir(null), getFileName(strUrl));
        return tempFile.getAbsolutePath();
    }

    public static File downloadFile(Context context, String strUrl, DownloadProgress progressHandler ) throws Exception {
        File tempFile = new File(context.getExternalFilesDir(null), getFileName(strUrl));
        if (tempFile.exists()) {
            tempFile.delete();
        }

        try {
            try {
                tempFile.createNewFile();
            } catch (Exception e) {
                e.printStackTrace();

                tempFile = File.createTempFile(getFileName(strUrl), "temp");
            }

            URL url = new URL(strUrl);

            HttpURLConnection connection;
            if (BuildConfig.TRUST_ANY_CERTIFICATE && url.getProtocol().toLowerCase().equals("https")) {
                connection = (HttpsURLConnection) url.openConnection();
                ((HttpsURLConnection) connection).setHostnameVerifier(DO_NOT_VERIFY);
            } else {
                connection = (HttpURLConnection) url.openConnection();
            }
            connection.setRequestMethod("GET");
            connection.setRequestProperty("Accept-Encoding", "identity");
            connection.setConnectTimeout((int) Const.CONNECTION_TIMEOUT);
            connection.setReadTimeout((int) Const.CONNECTION_TIMEOUT);
            String signature = getRequestSignature(strUrl);
            if (signature != null) {
                connection.setRequestProperty("X-Request-Signature", signature);
            }
            connection.connect();

            if (connection.getResponseCode() != 200) {
                throw new Exception("Bad server response for " + strUrl + ": " + connection.getResponseCode());
            }

            int lengthOfFile = connection.getContentLength();

            progressHandler.onDownloadProgress(0, lengthOfFile, 0);

            InputStream is = connection.getInputStream();
            DataInputStream dis = new DataInputStream(is);

            byte[] buffer = new byte[1024];
            int length;
            long total = 0;

            FileOutputStream fos = new FileOutputStream(tempFile);
            while ((length = dis.read(buffer)) > 0) {
                total += length;
                progressHandler.onDownloadProgress(
                        (int) ((total * 100.0f) / lengthOfFile),
                        lengthOfFile,
                        total);
                fos.write(buffer, 0, length);
            }
            fos.flush();
            fos.close();

            dis.close();
        } catch (Exception e) {
            tempFile.delete();
            throw e;
        }

        return tempFile;
    }

    public static String getRequestSignature(String strUrl) {
        int index = strUrl.indexOf("/files/", 0);
        if (index == -1) {
            // Seems to be an external resource, do not add signature
            return null;
        }
        index += "/files/".length();
        String filepath = strUrl.substring(index);

        try {
            return CryptoHelper.getSHA1String(BuildConfig.REQUEST_SIGNATURE + filepath);
        } catch (Exception e) {
        }
        return null;
    }

    private static String getFileName(String strUrl) {
        int slashIndex = strUrl.lastIndexOf("/");
        return slashIndex >= 0 ? strUrl.substring(slashIndex) : strUrl;
    }

    public interface InstallErrorHandler {
        public void onInstallError(String msg);
    }

    public static void silentInstallApplication(Context context, File file, String packageName, InstallErrorHandler errorHandler) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        if (file.getName().endsWith(".xapk")) {
            List<File> files = XapkUtils.extract(context, file);
            XapkUtils.install(context, files, packageName, errorHandler);
            return;
        }

        try {
            Log.i(Const.LOG_TAG, "Installing " + packageName);
            FileInputStream in = new FileInputStream(file);
            PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
            PackageInstaller.SessionParams params = new PackageInstaller.SessionParams(
                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);
            params.setAppPackageName(packageName);
            // set params
            int sessionId = packageInstaller.createSession(params);
            PackageInstaller.Session session = packageInstaller.openSession(sessionId);
            OutputStream out = session.openWrite("COSU", 0, -1);
            byte[] buffer = new byte[65536];
            int c;
            while ((c = in.read(buffer)) != -1) {
                out.write(buffer, 0, c);
            }
            session.fsync(out);
            in.close();
            out.close();

            session.commit(createIntentSender(context, sessionId, packageName));
            Log.i(Const.LOG_TAG, "Installation session committed");

        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "PackageInstaller error: " + e.getMessage());
            e.printStackTrace();
            errorHandler.onInstallError(e.getMessage());
        }
    }

    public static IntentSender createIntentSender(Context context, int sessionId, String packageName) {
        Intent intent = new Intent(Const.ACTION_INSTALL_COMPLETE);
        if (packageName != null) {
            intent.putExtra(Const.PACKAGE_NAME, packageName);
        }
        PendingIntent pendingIntent = PendingIntent.getBroadcast(
                context,
                sessionId,
                intent,
                PendingIntent.FLAG_MUTABLE | PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT);
        return pendingIntent.getIntentSender();
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void silentUninstallApplication(Context context, String packageName) {
        PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller();
        try {
            packageInstaller.uninstall(packageName, createIntentSender(context, 0, null));
        } catch (Exception e) {
            // If we're trying to remove an unexistent app, it causes an exception so just ignore it
        }
    }

    public static void requestInstallApplication(Context context, File file, InstallErrorHandler errorHandler) {
        if (file.getName().endsWith(".xapk")) {
            XapkUtils.install(context, XapkUtils.extract(context, file), null, errorHandler);
            return;
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            Intent intent = new Intent(Intent.ACTION_VIEW);
            Uri uri = FileProvider.getUriForFile( context,
                    context.getApplicationContext().getPackageName() + ".provider",
                    file );
            intent.setDataAndType( uri, "application/vnd.android.package-archive" );
            // Let's set Intent.FLAG_ACTIVITY_NEW_TASK here
            // Some devices report:
            // android.util.AndroidRuntimeException
            // Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?
            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                context.startActivity(intent);
            } catch (Exception e) {
                e.printStackTrace();
            }
        } else {
            Uri apkUri = Uri.fromFile( file );
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.setDataAndType(apkUri, "application/vnd.android.package-archive");
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(intent);
        }
    }

    public static void requestUninstallApplication(Context context, String packageName) {
        Uri packageUri = Uri.parse("package:" + packageName);
        Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageUri);
        // Let's set Intent.FLAG_ACTIVITY_NEW_TASK here
        // Some devices report:
        // android.util.AndroidRuntimeException
        // Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
            context.startActivity(intent);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String getPackageInstallerStatusMessage(int status) {
        switch (status) {
            case PackageInstaller.STATUS_PENDING_USER_ACTION:
                return "PENDING_USER_ACTION";
            case PackageInstaller.STATUS_SUCCESS:
                return "SUCCESS";
            case PackageInstaller.STATUS_FAILURE:
                return "FAILURE_UNKNOWN";
            case PackageInstaller.STATUS_FAILURE_BLOCKED:
                return "BLOCKED";
            case PackageInstaller.STATUS_FAILURE_ABORTED:
                return "ABORTED";
            case PackageInstaller.STATUS_FAILURE_INVALID:
                return "INVALID";
            case PackageInstaller.STATUS_FAILURE_CONFLICT:
                return "CONFLICT";
            case PackageInstaller.STATUS_FAILURE_STORAGE:
                return "STORAGE";
            case PackageInstaller.STATUS_FAILURE_INCOMPATIBLE:
                return "INCOMPATIBLE";
        }
        return "UNKNOWN";
    }

    // always verify the host - dont check for certificate
    final static HostnameVerifier DO_NOT_VERIFY = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };

    /**
     * Trust every server - dont check for any certificate
     * This should be called at the app start if TRUST_ANY_CERTIFICATE is set to true
     */
    public static void initUnsafeTrustManager() {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return new java.security.cert.X509Certificate[] {};
            }

            public void checkClientTrusted(X509Certificate[] chain,
                                           String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain,
                                           String authType) throws CertificateException {
            }
        } };

        // Install the all-trusting trust manager
        try {
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection
                    .setDefaultSSLSocketFactory(sc.getSocketFactory());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void deleteTempApk(File file) {
        try {
            if (file.getName().endsWith(".xapk")) {
                // For XAPK, we need to remove the directory with the same name
                String path = file.getAbsolutePath();
                File directory = new File(path.substring(0, path.length() - 5));
                if (directory.exists()) {
                    deleteRecursive(directory);
                }
            }
            if (file.exists()) {
                file.delete();
            }
        } catch (Exception e) {
        }
    }

    private static void deleteRecursive(File fileOrDirectory) {
        if (fileOrDirectory.isDirectory())
            for (File child : fileOrDirectory.listFiles())
                deleteRecursive(child);

        fileOrDirectory.delete();
    }

    public static void clearTempFiles(Context context) {
        try {
            File filesDir = context.getExternalFilesDir(null);
            for (File child : filesDir.listFiles()) {
                if (child.getName().equalsIgnoreCase("MqttConnection")) {
                    // These are names which should be kept here
                    continue;
                }
                if (child.isDirectory()) {
                    deleteRecursive(child);
                } else {
                    child.delete();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</file>

<file path="app/src/main/res/values-de/strings.xml">
<!--
  ~ Headwind MDM: Open Source Android MDM Software
  ~ https://h-mdm.com
  ~
  ~ Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<resources>
    <string name="admin_title">Administrator</string>
    <string name="install_error">Fehler beim Installieren</string>
    <string name="file_create_error">Fehler beim Erstellen der Datei</string>
    <string name="dialog_enter_device_id_error">Diese ID ist bei %s nicht registriert. Rufen Sie die ID auf der Registerkarte \"Geräte\" des Bedienfelds ab.</string>
    <string name="dialog_enter_device_id_qrcode">QR-Code</string>
    <string name="dialog_enter_device_id_variants">Varianten</string>
    <string name="dialog_enter_device_id_save">Speichern</string>
    <string name="dialog_enter_device_id_exit">Beenden</string>
    <string name="dialog_enter_device_id_title">Geben Sie die Geräte-ID unter %s ein</string>
    <string name="main_start_preparations">Vorbereiten des Starts</string>
    <string name="main_downloading_configuration">Aktualisieren der Konfigurationsdatei</string>
    <string name="main_downloading_content">Aktualisieren von Daten</string>
    <string name="main_update_applications">Installieren und Aktualisieren von Anwendungen</string>
    <string name="dialog_root_message">Sie benötigen einen ROOT-Zugriff</string>
    <string name="main_application_start">Anwendung starten</string>
    <string name="main_app_installing">Installieren der Anwendung</string>
    <string name="main_app_downloading">Anwendung herunterladen</string>
    <string name="main_app_downloading_error">Fehler beim Herunterladen des Pakets</string>
    <string name="main_app_removing">Anwendung deinstallieren</string>
    <string name="main_file_downloading">Datei herunterladen</string>
    <string name="main_file_downloading_error">Fehler beim Herunterladen der Datei</string>
    <string name="main_activity_repeat">Wiederholen</string>
    <string name="main_activity_reset">Zurücksetzen</string>
    <string name="main_activity_wifi">WiFi</string>
    <string name="main_activity_cancel">Abbrechen</string>
    <string name="main_activity_details">Details</string>
    <string name="select_system_launcher">Wählen Sie %s als Standardstarter aus und aktivieren Sie \'Immer \':</string>
    <string name="dialog_network_error_title">Fehler beim Verbinden mit %s. Bitte überprüfen Sie die Internetverbindung und versuchen Sie es erneut.</string>
    <string name="main_activity_update_config">Konfigurationsdatei vom Server anfordern</string>
    <string name="main_activity_applications_update">Aktualisieren von Anwendungen</string>
    <string name="dialog_overlay_settings_title">Bitte erlauben Sie der App, über andere Fenster zu zeichnen.\n\nDiese Option hilft, unerwünschte Apps besser zu blockieren und ermöglicht die Notentsperrung des Kioskmodus.\n\nTippen Sie auf \"Weiter\", um ein Einstellungsblatt zu öffnen. Suchen Sie das Element \"%s\", erteilen Sie die Berechtigung und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_manage_storage_title">Bitte erlauben Sie der App, den Speicher zu verwalten.\n\nDiese Option ermöglicht Headwind MDM, Dateien auf Ihrem Gerät zu verwalten.</string>
    <string name="dialog_history_settings_title">Bitte erlauben Sie der App, auf Nutzungsdaten zuzugreifen.\n\nDiese Option ermöglicht die Steuerung von Apps und Einstellungen.\n\nDiese Option kann zu einer schnelleren Entladung der Batterie führen. Um Batterie zu sparen, überspringen Sie diese Option (verwenden Sie stattdessen die Bedienungshilfen oder den Kioskmodus).\n\nTippen Sie auf \"Weiter\", um ein Einstellungsblatt zu öffnen. Suchen Sie das Element \"%s\", erteilen Sie die Berechtigung und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_history_settings_continue">Weiter</string>
    <string name="dialog_history_settings_skip">Überspringen</string>
    <string name="dialog_unknown_sources_title">Bitte erlauben Sie die Installation aus unbekannten Quellen. Ein Einstellungsblatt wird nun geöffnet. Suchen Sie nach \"Unbekannten Quellen\", erlauben Sie die Installation und klicken Sie auf \"Zurück\".</string>
    <string name="dialog_unknown_sources_continue">Weiter</string>
    <string name="dialog_miui_permissions_title">MIUI erfordert die manuelle Einrichtung benutzerdefinierter Berechtigungen. Das Fenster mit den App-Berechtigungen wird jetzt geöffnet. Tippen Sie auf \"Andere Berechtigungen\", erlauben Sie \"Popup-Fenster anzeigen, während Sie im Hintergrund ausgeführt werden\" und klicken Sie auf \"Zurück\".</string>
    <string name="dialog_miui_developer_title">MIUI erfordert die manuelle Einrichtung Ihres Geräts. Tippen Sie auf dem Infobildschirm 7 MAL AUF \"BUILD NUMBER\". Dadurch werden die Entwicklereinstellungen aktiviert.</string>
    <string name="dialog_miui_optimization_title">MIUI erfordert die manuelle Einrichtung Ihres Geräts. Das Fenster mit den Entwicklereinstellungen wird jetzt geöffnet. Scrollen Sie auf dem Bildschirm nach unten und deaktivieren Sie \"MIUI-Optimierung\".</string>
    <string name="dialog_administrator_mode_message">Bitte lassen Sie die App im Geräteadministratormodus arbeiten. Ein Einstellungsblatt wird jetzt geöffnet. Wählen Sie \"Geräteadministratoren\", suchen Sie das Element \"%s\", aktivieren Sie den Administrator und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_administrator_mode_continue">Weiter</string>
    <string name="dialog_administrator_mode_skip">Überspringen</string>
    <string name="accessibility_service_description">Aktive App-Überwachung durch MDM-Anwendung</string>
    <string name="dialog_accessibility_service_message">Bitte erlauben Sie der App, Eingabehilfedienste zu verwenden. Ein Einstellungsblatt wird jetzt geöffnet. Suchen Sie das Element \"%s\", erlauben Sie die Verwendung von Eingabehilfen und tippen Sie auf \"Zurück\".</string>
    <string name="dialog_accessibility_service_continue">Weiter</string>
    <string name="dialog_accessibility_service_skip">Überspringen</string>
    <string name="access_to_app_denied">Das Paket ist nicht erlaubt:</string>
    <string name="access_to_app_denied_2">Bitten Sie Ihren Administrator, dieses Paket in der Konfiguration zu aktivieren.\n\nKlicken Sie auf die Schaltfläche \'Schließen\' oder die Startseite, um fortzufahren.</string>
    <string name="package_id_copied">Die Paket-ID wird in die Zwischenablage kopiert</string>
    <string name="dialog_app_not_allowed_close">Schließen</string>
    <string name="dialog_app_not_allowed_admin">Administrator</string>
    <string name="device_id">Geräte-ID</string>
    <string name="imei">IMEI</string>
    <string name="serial_number">Seriennummer</string>
    <string name="phone_number">Telefonnummer</string>
    <string name="launcher_version">Launcher-Version</string>
    <string name="close">Schließen</string>
    <string name="admin_change_device_id">Geräte-ID ändern</string>
    <string name="admin_change_server_url">Server-URL ändern</string>
    <string name="admin_allow_settings">Öffnen Sie die Einstellungen</string>
    <string name="settings_allowed">Sie können die Einstellungen innerhalb von 3 Minuten ändern.</string>
    <string name="admin_clear_restrictions">Einschränkungen entfernen</string>
    <string name="permissive_mode_enabled">Sie dürfen alle Apps innerhalb von 3 Minuten ausführen.</string>
    <string name="admin_refresh">Konfiguration aktualisieren</string>
    <string name="admin_exit">Beenden Sie den Systemstarter</string>
    <string name="admin_reset_permissions">Berechtigungen prüfen</string>
    <string name="admin_reset_network">Netzwerkrichtlinie zurücksetzen</string>
    <string name="admin_reset_network_hint">Netzwerkrichtlinien werden gelöscht. Sie können jetzt das Netzwerk aktivieren und die Konfiguration neu laden.</string>
    <string name="reboot">Gerät neu starten</string>
    <string name="reboot_failed">Nicht genügend Rechte zum Neustart des Geräts.</string>
    <string name="message_turn_on_gps">Der Einstellungsbildschirm wird geöffnet. Bitte schalten Sie die GPS-Position auf diesem Bildschirm ein und klicken Sie auf Zurück.</string>
    <string name="message_turn_off_gps">Der Einstellungsbildschirm wird geöffnet. Bitte schalten Sie den GPS-Standort auf diesem Bildschirm aus und klicken Sie auf Zurück.</string>
    <string name="message_turn_on_mobile_data">Mobile Daten sind deaktiviert! Bitte öffnen Sie die Statusleiste und aktivieren Sie mobile Daten.</string>
    <string name="message_turn_off_mobile_data">Mobile Daten sind aktiviert. Bitte öffnen Sie die Statusleiste und schalten Sie die mobilen Daten aus.</string>
    <string name="message_set_password">Ihre Passwortqualität ist nicht gut genug. Der Einstellungsbildschirm wird geöffnet. Bitte ändern Sie das Passwort und klicken Sie auf Zurück.</string>
    <string name="switch_off_blockings">Einschränkungen ausschalten ...</string>
    <string name="kiosk_mode_requires_overlays">Kioskmodus deaktiviert: Keine Berechtigung zum Zeichnen über andere Fenster. Bitte erlauben Sie %s, über andere Fenster zu zeichnen.</string>
    <string name="enter_admin_password">Geben Sie das Administratorkennwort ein</string>
    <string name="wrong_password">Falsches Passwort</string>
    <string name="dialog_enter_password_login">Login</string>
    <string name="dialog_enter_password_cancel">Abbrechen</string>
    <string name="internal_error">Die App hat einen internen Fehler festgestellt. Bitte starten Sie das Gerät neu und wiederholen Sie die Aktion.</string>
    <string name="empty_configuration">Die Konfiguration ist nicht festgelegt und versucht erneut, vom Server abzurufen!</string>
    <string name="permissions_reset_hint">Schließen Sie das Admin-Fenster, um Berechtigungen zu überprüfen und anzufordern.</string>
    <string name="dialog_enter_server_error">Bitte geben Sie eine gültige Server-URL ein.</string>
    <string name="dialog_enter_server_ok">OK</string>
    <string name="dialog_enter_server_title">Bitte geben Sie die Server-URL ein</string>
    <string name="critical_server_failure">Beenden wegen Serverfehler! Bitte beheben Sie das Problem und starten Sie %s neu oder entfernen Sie es vollständig und installieren Sie es neu.</string>
    <string name="dialog_permission_title">Für die Ausführung der App sind die Berechtigungen erforderlich. Bitte erteilen Sie die angeforderten Berechtigungen.</string>
    <string name="main_activity_exit">Beenden Sie</string>
    <string name="browser_not_found">Die Webseite kann nicht geöffnet werden, da der Browser nicht gefunden wird. Bitte fügen Sie der Gerätekonfiguration eine Browser-App hinzu.</string>
    <string name="invalid_web_link">Der Weblink kann nicht geöffnet werden, da er nicht wohlgeformt ist. Wenden Sie sich für Einzelheiten bitte an Ihren Administrator.</string>
    <string name="activity_not_found">Die Aktion %s kann nicht ausgeführt werden, da die Aktivität nicht gefunden wurde.</string>
    <string name="location_service_text">Der Gerätestandort wird überwacht</string>
    <string name="qrcode_contents_error">Ungültiger Inhalt des QR-Codes. Bitte generieren Sie den Bereitstellungs-QR-Code im Webpanel von %s.</string>
    <string name="device_locked">Dieses Gerät (%s) wurde vom Administrator gesperrt.</string>
    <string name="fault_loop_detected">Hoppla, der Launcher hat einen nicht behebbaren Fehler! Bitte wenden Sie sich an Ihren Systemadministrator.</string>
    <string name="mqtt_service_text">Push-Benachrichtigungen sind aktiv</string>
    <string name="background_location">%s erfordert die Berechtigung zum Standort im Hintergrund. Klicken Sie auf \'Weiter\', um die Berechtigungen zu öffnen, klicken Sie auf \'Standort\' und erlauben Sie, den Standort immer zu bestimmen.</string>
    <string name="location_disable">Standort deaktivieren</string>
    <string name="background_location_continue">Weiter</string>
    <string name="initializing_mdm">Initialisieren der Anwendung zur Verwaltung mobiler Geräte...</string>
    <string name="dialog_server_error_title">MDM-Server %s hat eine ungültige Antwort zurückgegeben. Bitte wenden Sie sich an Ihren Administrator.</string>
    <string name="mdm_choice_message">Dieses Gerät wird vollständig von Ihrer Organisation verwaltet. Ihre Daten sind nicht privat und können jederzeit von Ihrem IT-Administrator gelöscht oder überprüft werden.</string>
    <string name="work_profile_message">Dieses Gerät erhält ein verwaltetes Arbeitsprofil, das Ihrer Organisation gehört. Das Arbeitsprofil ist von Ihrem privaten Profil getrennt und Sie können jederzeit zwischen den Profilen wechseln.</string>
    <string name="overlays_not_supported">Leider werden Overlays von Ihrem Gerät nicht unterstützt.</string>
    <string name="admin_not_supported">Ihr Gerät verfügt über keine Geräteadministratoroption. Klicken Sie auf Überspringen, um fortzufahren.</string>
    <string name="manage_storage_not_supported">Ihr Gerät verfügt nicht über die Möglichkeit, den externen Speicher zu verwalten.</string>
</resources>
</file>

<file path="app/src/main/java/com/hmdm/launcher/helper/ConfigUpdater.java">
package com.hmdm.launcher.helper;

import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInstaller;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.db.DatabaseHelper;
import com.hmdm.launcher.db.DownloadTable;
import com.hmdm.launcher.db.RemoteFileTable;
import com.hmdm.launcher.json.Action;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.Download;
import com.hmdm.launcher.json.PushMessage;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.worker.DetailedInfoWorker;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.service.PushLongPollingService;
import com.hmdm.launcher.task.ConfirmDeviceResetTask;
import com.hmdm.launcher.task.ConfirmPasswordResetTask;
import com.hmdm.launcher.task.ConfirmRebootTask;
import com.hmdm.launcher.task.GetRemoteLogConfigTask;
import com.hmdm.launcher.task.GetServerConfigTask;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.PushNotificationMqttWrapper;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class ConfigUpdater {

    public static interface UINotifier {
        void onConfigUpdateStart();
        void onConfigUpdateServerError(String errorText);
        void onConfigUpdateNetworkError(String errorText);
        void onConfigLoaded();
        void onPoliciesUpdated();
        void onFileDownloading(final RemoteFile remoteFile);
        void onDownloadProgress(final int progress, final long total, final long current);
        void onFileDownloadError(final RemoteFile remoteFile);
        void onFileInstallError(final RemoteFile remoteFile);
        void onAppUpdateStart();
        void onAppRemoving(final Application application);
        void onAppDownloading(final Application application);
        void onAppInstalling(final Application application);
        void onAppDownloadError(final Application application);
        void onAppInstallError(final String packageName);
        void onAppInstallComplete(final String packageName);
        void onConfigUpdateComplete();
        void onAllAppInstallComplete();
    };

    private boolean configInitializing;
    private Context context;
    private UINotifier uiNotifier;
    private SettingsHelper settingsHelper;
    private Handler handler = new Handler(Looper.getMainLooper());
    private List<RemoteFile> filesForInstall = new LinkedList();
    private List< Application > applicationsForInstall = new LinkedList();
    private List< Application > applicationsForRun = new LinkedList();
    private Map<String, File> pendingInstallations = new HashMap<String,File>();
    private BroadcastReceiver appInstallReceiver;
    private boolean retry = true;
    private boolean loadOnly = false;
    private boolean userInteraction;

    public List<Application> getApplicationsForRun() {
        return applicationsForRun;
    }

    public static void notifyConfigUpdate(final Context context) {
        if (SettingsHelper.getInstance(context).isMainActivityRunning()) {
            Log.d(Const.LOG_TAG, "Main activity is running, using activity updater");
            LocalBroadcastManager.getInstance(context).
                    sendBroadcast(new Intent(Const.ACTION_UPDATE_CONFIGURATION));
        } else {
            Log.d(Const.LOG_TAG, "Main activity is not running, creating a new ConfigUpdater");
            new ConfigUpdater().updateConfig(context, null, false);
        }
    }

    public static void forceConfigUpdate(final Context context) {
        forceConfigUpdate(context, null, false);
    }

    public static void forceConfigUpdate(final Context context, final UINotifier notifier, final boolean userInteraction) {
        new ConfigUpdater().updateConfig(context, notifier, userInteraction);
    }

    public void setLoadOnly(boolean loadOnly) {
        this.loadOnly = loadOnly;
    }

    public void updateConfig(final Context context, final UINotifier uiNotifier, final boolean userInteraction) {
        if ( configInitializing ) {
            Log.i(Const.LOG_TAG, "updateConfig(): configInitializing=true, exiting");
            return;
        }

        Log.i(Const.LOG_TAG, "updateConfig(): set configInitializing=true");
        configInitializing = true;
        DetailedInfoWorker.requestConfigUpdate(context);
        this.context = context;
        this.uiNotifier = uiNotifier;
        this.userInteraction = userInteraction;

        // Work around a strange bug with stale SettingsHelper instance: re-read its value
        settingsHelper = SettingsHelper.getInstance(context.getApplicationContext());

        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            Utils.releaseUserRestrictions(context, settingsHelper.getConfig().getRestrictions());
            // Explicitly release restrictions of installing/uninstalling apps
            Utils.releaseUserRestrictions(context, "no_install_apps,no_uninstall_apps");
        }

        if (uiNotifier != null) {
            uiNotifier.onConfigUpdateStart();
        }
        new GetServerConfigTask( context ) {
            @Override
            protected void onPostExecute( Integer result ) {
                super.onPostExecute( result );
                configInitializing = false;
                Log.i(Const.LOG_TAG, "updateConfig(): set configInitializing=false after getting config");

                switch ( result ) {
                    case Const.TASK_SUCCESS:
                        RemoteLogger.log(context, Const.LOG_INFO, "Configuration updated");
                        updateRemoteLogConfig();
                        break;
                    case Const.TASK_ERROR:
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to update config: server error");
                        if (uiNotifier != null) {
                            uiNotifier.onConfigUpdateServerError(getErrorText());
                        }
                        break;
                    case Const.TASK_NETWORK_ERROR:
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to update config: network error");
                        if (retry) {
                            // Retry the request once because WiFi may not yet be initialized
                            retry = false;
                            handler.postDelayed(new Runnable() {
                                @Override
                                public void run() {
                                    updateConfig(context, uiNotifier, userInteraction);
                                }
                            }, 15000);
                        } else {
                            if (settingsHelper.getConfig() != null && !userInteraction) {
                                if (uiNotifier != null && settingsHelper.getConfig().isShowWifi()) {
                                    // Show network error dialog with Wi-Fi settings
                                    // if it is required by the web panel
                                    // so the user can set up WiFi even in kiosk mode
                                    uiNotifier.onConfigUpdateNetworkError(getErrorText());
                                } else {
                                    updateRemoteLogConfig();
                                }
                            } else {
                                if (uiNotifier != null) {
                                    uiNotifier.onConfigUpdateNetworkError(getErrorText());
                                }
                            }
                        }
                        break;
                }
            }
        }.execute();
    }

    public void skipConfigLoad() {
        updateRemoteLogConfig();
    }

    private void updateRemoteLogConfig() {
        Log.i(Const.LOG_TAG, "updateRemoteLogConfig(): get logging configuration");

        GetRemoteLogConfigTask task = new GetRemoteLogConfigTask(context) {
            @Override
            protected void onPostExecute( Integer result ) {
                super.onPostExecute( result );
                Log.i(Const.LOG_TAG, "updateRemoteLogConfig(): result=" + result);
                boolean deviceOwner = Utils.isDeviceOwner(context);
                RemoteLogger.log(context, Const.LOG_INFO, "Device owner: " + deviceOwner);
                if (deviceOwner) {
                    setSelfPermissions(settingsHelper.getConfig() != null ? settingsHelper.getConfig().getAppPermissions() : null);
                }
                try {
                    if (settingsHelper.getConfig() != null && uiNotifier != null) {
                        uiNotifier.onConfigLoaded();
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                if (!loadOnly) {
                    checkServerMigration();
                } else {
                    Log.d(Const.LOG_TAG, "LoadOnly flag set, finishing the update flow");
                }
                // If loadOnly flag is set, we finish the flow here
            }
        };
        task.execute();
    }

    private void setSelfPermissions(String appPermissionStrategy) {
        Utils.autoGrantRequestedPermissions(context, context.getPackageName(),
                appPermissionStrategy, true);
    }

    private void checkServerMigration() {
        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getNewServerUrl() != null &&
                !settingsHelper.getConfig().getNewServerUrl().trim().equals("")) {
            try {
                final MigrationHelper migrationHelper = new MigrationHelper(settingsHelper.getConfig().getNewServerUrl().trim());
                if (migrationHelper.needMigrating(context)) {
                    // Before migration, test that new URL is working well
                    migrationHelper.tryNewServer(context, new MigrationHelper.CompletionHandler() {
                        @Override
                        public void onSuccess() {
                            // Everything is OK, migrate!
                            RemoteLogger.log(context, Const.LOG_INFO, "Migrated to " + settingsHelper.getConfig().getNewServerUrl().trim());
                            settingsHelper.setBaseUrl(migrationHelper.getBaseUrl());
                            settingsHelper.setSecondaryBaseUrl(migrationHelper.getBaseUrl());
                            settingsHelper.setServerProject(migrationHelper.getServerProject());
                            ServerServiceKeeper.resetServices();
                            configInitializing = false;
                            updateConfig(context, uiNotifier, false);
                        }

                        @Override
                        public void onError(String cause) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to migrate to " + settingsHelper.getConfig().getNewServerUrl().trim() + ": " + cause);
                            setupPushService();
                        }
                    });
                    return;
                }
            } catch (Exception e) {
                // Malformed URL
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to migrate to " + settingsHelper.getConfig().getNewServerUrl().trim() + ": malformed URL");
            }
        }
        setupPushService();
    }

    private void setupPushService() {
        Log.d(Const.LOG_TAG, "setupPushService() called");
        String pushOptions = null;
        int keepaliveTime = Const.DEFAULT_PUSH_ALARM_KEEPALIVE_TIME_SEC;
        if (settingsHelper != null && settingsHelper.getConfig() != null) {
            pushOptions = settingsHelper.getConfig().getPushOptions();
            Integer newKeepaliveTime = settingsHelper.getConfig().getKeepaliveTime();
            if (newKeepaliveTime != null && newKeepaliveTime >= 30) {
                keepaliveTime = newKeepaliveTime;
            }
        }
        if (BuildConfig.ENABLE_PUSH && pushOptions != null) {
            if (pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_WORKER)
                    || pushOptions.equals(ServerConfig.PUSH_OPTIONS_MQTT_ALARM)) {
                try {
                    URL url = new URL(settingsHelper.getBaseUrl());
                    Runnable nextRunnable = () -> {
                        checkFactoryReset();
                    };
                    PushNotificationMqttWrapper.getInstance().connect(context, url.getHost(), BuildConfig.MQTT_PORT,
                            pushOptions, keepaliveTime, settingsHelper.getDeviceId(), nextRunnable, nextRunnable);
                } catch (Exception e) {
                    e.printStackTrace();
                    checkFactoryReset();
                }
            } else {
                try {
                    Intent serviceStartIntent = new Intent(context, PushLongPollingService.class);
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                        context.startForegroundService(serviceStartIntent);
                    } else {
                        context.startService(serviceStartIntent);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }

                checkFactoryReset();
            }
        } else {
            checkFactoryReset();
        }
    }

    private void checkFactoryReset() {
        Log.d(Const.LOG_TAG, "checkFactoryReset() called");
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getFactoryReset() != null && config.getFactoryReset()) {
            // We got a factory reset request, let's confirm and erase everything!
            RemoteLogger.log(context, Const.LOG_INFO, "Device reset by server request");
            ConfirmDeviceResetTask confirmTask = new ConfirmDeviceResetTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    // Do a factory reset if we can
                    if (result == null || result != Const.TASK_SUCCESS ) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to confirm device reset on server");
                    } else if (Utils.checkAdminMode(context)) {
                        // no_factory_reset restriction doesn't prevent against admin's reset action
                        // So we do not need to release this restriction prior to resetting the device
                        if (!Utils.factoryReset(context)) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Device reset failed");
                        }
                    } else {
                        RemoteLogger.log(context, Const.LOG_WARN, "Device reset failed: no permissions");
                    }
                    // If we can't, proceed the initialization flow
                    checkRemoteReboot();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            deviceInfo.setFactoryReset(Utils.checkAdminMode(context));
            confirmTask.execute(deviceInfo);

        } else {
            checkRemoteReboot();
        }
    }

    private void checkRemoteReboot() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getReboot() != null && config.getReboot()) {
            // Log and confirm reboot before rebooting
            RemoteLogger.log(context, Const.LOG_INFO, "Rebooting by server request");
            ConfirmRebootTask confirmTask = new ConfirmRebootTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    if (result == null || result != Const.TASK_SUCCESS ) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to confirm reboot on server");
                    } else if (Utils.checkAdminMode(context)) {
                        if (!Utils.reboot(context)) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed");
                        }
                    } else {
                        RemoteLogger.log(context, Const.LOG_WARN, "Reboot failed: no permissions");
                    }
                    checkPasswordReset();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            confirmTask.execute(deviceInfo);

        } else {
            checkPasswordReset();
        }

    }

    private void checkPasswordReset() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (config != null && config.getPasswordReset() != null) {
            if (Utils.passwordReset(context, config.getPasswordReset())) {
                RemoteLogger.log(context, Const.LOG_INFO, "Password successfully changed");
            } else {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to reset password");
            }

            ConfirmPasswordResetTask confirmTask = new ConfirmPasswordResetTask(context) {
                @Override
                protected void onPostExecute( Integer result ) {
                    setDefaultLauncher();
                }
            };

            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(context, true, true);
            confirmTask.execute(deviceInfo);

        } else {
            setDefaultLauncher();
        }
    }

    private void setDefaultLauncher() {
        ServerConfig config = settingsHelper != null ? settingsHelper.getConfig() : null;
        if (Utils.isDeviceOwner(context) && config != null) {
            // "Run default launcher" means we should not set Headwind MDM as a default launcher
            // and clear the setting if it has been already set
            boolean needSetLauncher = (config.getRunDefaultLauncher() == null || !config.getRunDefaultLauncher());
            String defaultLauncher = Utils.getDefaultLauncher(context);

            // As per the documentation, setting the default preferred activity should not be done on the main thread
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    if (needSetLauncher && !context.getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.setDefaultLauncher(context);
                    } else if (!needSetLauncher && context.getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.clearDefaultLauncher(context);
                    }
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    updatePolicies();
                }
            }.execute();
            return;
        }
        updatePolicies();
    }

    private void updatePolicies() {
        // Update miscellaneous device policies here

        // Set up a proxy server
        SettingsHelper settingsHelper = SettingsHelper.getInstance(context);
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && Utils.isDeviceOwner(context)) {
            String proxyUrl = settingsHelper.getAppPreference(context.getPackageName(), "proxy");
            if (proxyUrl != null) {
                proxyUrl = proxyUrl.trim();
                if (proxyUrl.equals("0")) {
                    // null stays for "no changes" (most users won't even know about an option to set up a proxy)
                    // "0" stays for "clear the proxy previously set up"
                    proxyUrl = null;
                }
                Utils.setProxy(context, proxyUrl);
            }
        }

        if (uiNotifier != null) {
            uiNotifier.onPoliciesUpdated();
        }
        Log.d(Const.LOG_TAG, "updatePolicies(): proceed to updating files");
        checkAndUpdateFiles();
    }

    private void checkAndUpdateFiles() {
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                ServerConfig config = settingsHelper.getConfig();
                // This may be a long procedure due to checksum calculation so execute it in the background thread
                InstallUtils.generateFilesForInstallList(context, config.getFiles(), filesForInstall);
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                loadAndInstallFiles();
            }
        }.execute();
    }

    public static class RemoteFileStatus {
        public RemoteFile remoteFile;
        public boolean downloaded;
        public boolean installed;
    }

    private void loadAndInstallFiles() {
        boolean isGoodNetworkForUpdate = userInteraction || checkUpdateNetworkRestriction(settingsHelper.getConfig(), context);
        if (filesForInstall.size() > 0 && !isGoodNetworkForUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Updating files not enabled: waiting for WiFi connection");
        }
        if (filesForInstall.size() > 0 && isGoodNetworkForUpdate) {
            RemoteFile remoteFile = filesForInstall.remove(0);

            new AsyncTask<RemoteFile, Void, RemoteFileStatus>() {

                @Override
                protected RemoteFileStatus doInBackground(RemoteFile... remoteFiles) {
                    final RemoteFile remoteFile = remoteFiles[0];
                    RemoteFileStatus remoteFileStatus = null;

                    if (remoteFile.isRemove()) {
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Removing file: " + remoteFile.getPath());
                        File file = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                        try {
                            if (file.exists()) {
                                file.delete();
                            }
                            RemoteFileTable.deleteByPath(DatabaseHelper.instance(context).getWritableDatabase(), remoteFile.getPath());
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to remove file: " +
                                    remoteFile.getPath() + ": " + e.getMessage());
                            e.printStackTrace();
                        }

                    } else if (remoteFile.getUrl() != null) {
                        if (uiNotifier != null) {
                            uiNotifier.onFileDownloading(remoteFile);
                        }
                        // onFileDownloading() method contents
                        // updateMessageForFileDownloading(remoteFile.getPath());

                        remoteFileStatus = new RemoteFileStatus();
                        remoteFileStatus.remoteFile = remoteFile;

                        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
                        Download lastDownload = DownloadTable.selectByPath(dbHelper.getReadableDatabase(), remoteFile.getPath());
                        if (!canDownload(lastDownload, remoteFile.getPath())) {
                            // Do not make further attempts to download if there were earlier download or installation errors
                            return remoteFileStatus;
                        }

                        File file = null;
                        try {
                            RemoteLogger.log(context, Const.LOG_DEBUG, "Downloading file: " + remoteFile.getPath());
                            file = InstallUtils.downloadFile(context, remoteFile.getUrl(),
                                    new InstallUtils.DownloadProgress() {
                                        @Override
                                        public void onDownloadProgress(final int progress, final long total, final long current) {
                                            if (uiNotifier != null) {
                                                uiNotifier.onDownloadProgress(progress, total, current);
                                            }
                                            // onDownloadProgress() method contents
                                            /*handler.post(new Runnable() {
                                                @Override
                                                public void run() {
                                                    binding.progress.setMax(100);
                                                    binding.progress.setProgress(progress);

                                                    binding.setFileLength(total);
                                                    binding.setDownloadedLength(current);
                                                }
                                            });*/
                                        }
                                    });
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN,
                                    "Failed to download file " + remoteFile.getPath() + ": " + e.getMessage());
                            e.printStackTrace();
                            // Save the download attempt in the database
                            saveFailedAttempt(context, lastDownload, remoteFile.getUrl(), remoteFile.getPath(), false, false);
                        }

                        if (file != null) {
                            remoteFileStatus.downloaded = true;
                            File finalFile = new File(Environment.getExternalStorageDirectory(), remoteFile.getPath());
                            try {
                                if (finalFile.exists()) {
                                    finalFile.delete();
                                }
                                if (!remoteFile.isVarContent()) {
                                    FileUtils.moveFile(file, finalFile);
                                } else {
                                    String imei = DeviceInfoProvider.getImei(context, 0);
                                    if (imei == null || imei.equals("")) {
                                        imei = settingsHelper.getConfig().getImei();
                                    }
                                    createFileFromTemplate(file, finalFile, settingsHelper.getDeviceId(), imei, settingsHelper.getConfig());
                                }
                                RemoteFileTable.insert(dbHelper.getWritableDatabase(), remoteFile);
                                remoteFileStatus.installed = true;
                                if (lastDownload != null) {
                                    DownloadTable.deleteByPath(dbHelper.getWritableDatabase(), lastDownload.getPath());
                                }
                            } catch (Exception e) {
                                RemoteLogger.log(context, Const.LOG_WARN,
                                        "Failed to create file " + remoteFile.getPath() + ": " + e.getMessage());
                                e.printStackTrace();
                                // Remove initial file because we don't want to install this file any more
                                try {
                                    if (file.exists()) {
                                        file.delete();
                                    }
                                } catch (Exception e1) {
                                    e1.printStackTrace();
                                }
                                remoteFileStatus.installed = false;
                                // Save the install attempt in the database
                                saveFailedAttempt(context, lastDownload, remoteFile.getUrl(), remoteFile.getPath(), true, false);
                            }
                        } else {
                            remoteFileStatus.downloaded = false;
                            remoteFileStatus.installed = false;
                        }
                    }

                    return remoteFileStatus;
                }

                @Override
                protected void onPostExecute(RemoteFileStatus fileStatus) {
                    if (fileStatus != null) {
                        if (!fileStatus.installed) {
                            filesForInstall.add( 0, fileStatus.remoteFile );
                            if (uiNotifier != null) {
                                if (!fileStatus.downloaded) {
                                    uiNotifier.onFileDownloadError(fileStatus.remoteFile);
                                } else {
                                    uiNotifier.onFileInstallError(fileStatus.remoteFile);
                                }
                            }
                            // onFileDownloadError() method contents
                            /*
                            if (!ProUtils.kioskModeRequired(context)) {
                                // Notify the error dialog that we're downloading a file, not an app
                                downloadingFile = true;
                                createAndShowFileNotDownloadedDialog(fileStatus.remoteFile.getUrl());
                                binding.setDownloading( false );
                            } else {
                                // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
                                // Note: view is not used in this method so just pass null there
                                confirmDownloadFailureClicked(null);
                            }
                             */
                            return;
                        }
                    }
                    Log.i(Const.LOG_TAG, "loadAndInstallFiles(): proceed to next file");
                    loadAndInstallFiles();
                }

            }.execute(remoteFile);
        } else {
            Log.i(Const.LOG_TAG, "loadAndInstallFiles(): Proceed to certificate installation");
            installCertificates();
        }
    }

    // Save failed attempt to download or install a file or an app in the database to avoid infinite loops
    private void saveFailedAttempt(Context context, Download lastDownload, String url, String path, boolean downloaded, boolean installed) {
        if (lastDownload == null) {
            lastDownload = new Download();
            lastDownload.setUrl(url);
            lastDownload.setPath(path);
            lastDownload.setAttempts(0);
        }
        if (!downloaded) {
            lastDownload.setAttempts(lastDownload.getAttempts() + 1);
            lastDownload.setLastAttemptTime(System.currentTimeMillis());
        }
        lastDownload.setDownloaded(downloaded);
        lastDownload.setInstalled(installed);
        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
        DownloadTable.insert(dbHelper.getWritableDatabase(), lastDownload);
    }

    // In background mode, we do not attempt to download files or apps in two cases:
    // 1. Installation failed
    // 2. Downloading in a mobile network is limited
    private boolean canDownload(Download lastDownload, String objectId) {
        if (userInteraction || lastDownload == null) {
            return true;
        }
        if (lastDownload.isDownloaded() && !lastDownload.isInstalled()) {
            RemoteLogger.log(context, Const.LOG_INFO, "Skip download due to previous install failure: " + objectId);
            return false;
        }
        ServerConfig config = SettingsHelper.getInstance(context).getConfig();
        if ("limited".equals(config.getDownloadUpdates())) {
            ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
            if (activeNetwork == null) {
                RemoteLogger.log(context, Const.LOG_INFO, "Skip downloading " + objectId + ": no active network");
                return false;
            }
            Log.d(Const.LOG_TAG, "Active network; " + activeNetwork.getTypeName() + ", download attempts: " + lastDownload.getAttempts());
            if (activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE &&
            !lastDownload.isDownloaded() && lastDownload.getAttempts() > 3) {
                RemoteLogger.log(context, Const.LOG_INFO, "Skip download due to previous download failures: " + objectId);
                return false;
            }
        }
        return true;
    }

    private void installCertificates() {
        final String certPaths = settingsHelper.getAppPreference(context.getPackageName(), "certificates");
        if (certPaths != null) {
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    CertInstaller.installCertificatesFromFiles(context, certPaths.trim());
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    checkAndUpdateApplications();
                }
            }.execute();
        } else {
            checkAndUpdateApplications();
        }
    }

    private void checkAndUpdateApplications() {
        Log.i(Const.LOG_TAG, "checkAndUpdateApplications(): starting update applications");
        if (uiNotifier != null) {
            uiNotifier.onAppUpdateStart();
        }
        // onAppUpdateStart() method contents
        /*
        binding.setMessage( getString( R.string.main_activity_applications_update ) );
        configInitialized = true;
         */
        configInitializing = false;

        ServerConfig config = settingsHelper.getConfig();
        InstallUtils.generateApplicationsForInstallList(context, config.getApplications(), applicationsForInstall, pendingInstallations);

        Log.i(Const.LOG_TAG, "checkAndUpdateApplications(): list size=" + applicationsForInstall.size());

        registerAppInstallReceiver(config != null ? config.getAppPermissions() : null);
        loadAndInstallApplications();
    }

    private class ApplicationStatus {
        public Application application;
        public boolean installed;
    }

    // Here we avoid ConcurrentModificationException by executing all operations with applicationForInstall list in a main thread
    private void loadAndInstallApplications() {
        boolean isGoodTimeForAppUpdate = userInteraction || checkAppUpdateTimeRestriction(settingsHelper.getConfig());
        if (applicationsForInstall.size() > 0 && !isGoodTimeForAppUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Application update not enabled. Scheduled time: " + settingsHelper.getConfig().getAppUpdateFrom());
        }
        boolean isGoodNetworkForUpdate = userInteraction || checkUpdateNetworkRestriction(settingsHelper.getConfig(), context);
        if (applicationsForInstall.size() > 0 && !isGoodNetworkForUpdate) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Application update not enabled: waiting for WiFi connection");
        }
        if (applicationsForInstall.size() > 0 && isGoodTimeForAppUpdate && isGoodNetworkForUpdate) {
            Application application = applicationsForInstall.remove(0);

            new AsyncTask<Application, Void, ApplicationStatus>() {

                @Override
                protected ApplicationStatus doInBackground(Application... applications) {
                    final Application application = applications[0];
                    ApplicationStatus applicationStatus = null;

                    if (application.isRemove()) {
                        // Remove the app
                        RemoteLogger.log(context, Const.LOG_DEBUG, "Removing app: " + application.getPkg());
                        if (uiNotifier != null) {
                            uiNotifier.onAppRemoving(application);
                        }
                        // onAppRemoving() method contents
                        //updateMessageForApplicationRemoving( application.getName() );
                        uninstallApplication(application.getPkg());

                    } else if (application.getUrl() == null) {
                        handler.post( new Runnable() {
                            @Override
                            public void run() {
                                Log.i(Const.LOG_TAG, "loadAndInstallApplications(): proceed to next app");
                                loadAndInstallApplications();
                            }
                        } );

                    } else if (application.getUrl().startsWith("market://details")) {
                        RemoteLogger.log(context, Const.LOG_INFO, "Installing app " + application.getPkg() + " from Google Play");
                        installApplicationFromPlayMarket(application.getUrl(), application.getPkg());
                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;
                        applicationStatus.installed = true;

                    } else if (application.getUrl().startsWith("file:///")) {
                        RemoteLogger.log(context, Const.LOG_INFO, "Installing app " + application.getPkg() + " from SD card");
                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;
                        File file = null;
                        try {
                            Log.d(Const.LOG_TAG, "URL: " + application.getUrl());
                            file = new File(new URL(application.getUrl()).toURI());
                            if (file != null) {
                                Log.d(Const.LOG_TAG, "Path: " + file.getAbsolutePath());
                                if (uiNotifier != null) {
                                    uiNotifier.onAppInstalling(application);
                                }
                                // onAppInstalling() method contents
                                //updateMessageForApplicationInstalling(application.getName());
                                installApplication(file, application.getPkg(), application.getVersion());
                                applicationStatus.installed = true;
                            } else {
                                applicationStatus.installed = false;
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                            applicationStatus.installed = false;
                        }

                    } else {
                        if (uiNotifier != null) {
                            uiNotifier.onAppDownloading(application);
                        }
                        // onAppDownloading() method contents
                        //updateMessageForApplicationDownloading(application.getName());

                        applicationStatus = new ApplicationStatus();
                        applicationStatus.application = application;

                        DatabaseHelper dbHelper = DatabaseHelper.instance(context);
                        String tempPath = InstallUtils.getAppTempPath(context, application.getUrl());
                        Download lastDownload = DownloadTable.selectByPath(dbHelper.getReadableDatabase(), tempPath);
                        if (!canDownload(lastDownload, application.getPkg())) {
                            // Do not make further attempts to download if there were earlier download or installation errors
                            applicationStatus.installed = false;
                            return applicationStatus;
                        }

                        File file = null;
                        try {
                            RemoteLogger.log(context, Const.LOG_DEBUG, "Downloading app: " + application.getPkg());
                            file = InstallUtils.downloadFile(context, application.getUrl(),
                                    new InstallUtils.DownloadProgress() {
                                        @Override
                                        public void onDownloadProgress(final int progress, final long total, final long current) {
                                            if (uiNotifier != null) {
                                                uiNotifier.onDownloadProgress(progress, total, current);
                                            }
                                            /*
                                            handler.post(new Runnable() {
                                                @Override
                                                public void run() {
                                                    binding.progress.setMax(100);
                                                    binding.progress.setProgress(progress);

                                                    binding.setFileLength(total);
                                                    binding.setDownloadedLength(current);
                                                }
                                            });
                                             */
                                        }
                                    });
                        } catch (Exception e) {
                            RemoteLogger.log(context, Const.LOG_WARN, "Failed to download app " + application.getPkg() + ": " + e.getMessage());
                            e.printStackTrace();
                            // Save the download attempt in the database
                            saveFailedAttempt(context, lastDownload, application.getUrl(), tempPath, false, false);
                        }

                        if (file != null) {
                            if (uiNotifier != null) {
                                uiNotifier.onAppInstalling(application);
                            }
                            // onAppInstalling() method contents
                            //updateMessageForApplicationInstalling(application.getName());
                            installApplication(file, application.getPkg(), application.getVersion());
                            applicationStatus.installed = true;
                            // Here we remove app from pending downloads
                            // If it fails to install, we'll remember it and do not download any more
                            if (lastDownload != null) {
                                DownloadTable.deleteByPath(dbHelper.getWritableDatabase(), lastDownload.getPath());
                            }
                        } else {
                            applicationStatus.installed = false;
                        }
                    }

                    return applicationStatus;
                }

                @Override
                protected void onPostExecute(ApplicationStatus applicationStatus) {
                    if (applicationStatus != null) {
                        if (applicationStatus.installed) {
                            if (applicationStatus.application.isRunAfterInstall()) {
                                applicationsForRun.add(applicationStatus.application);
                            }
                        } else {
                            applicationsForInstall.add( 0, applicationStatus.application );
                            if (uiNotifier != null) {
                                uiNotifier.onAppDownloadError(applicationStatus.application);
                            }
                            // onAppDownloadError() method contents
                            /*
                            if (!ProUtils.kioskModeRequired(MainActivity.this)) {
                                // Notify the error dialog that we're downloading an app
                                downloadingFile = false;
                                createAndShowFileNotDownloadedDialog(applicationStatus.application.getName());
                                binding.setDownloading( false );
                            } else {
                                // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
                                // Note: view is not used in this method so just pass null there
                                confirmDownloadFailureClicked(null);
                            }
                             */
                        }
                    }
                }

            }.execute(application);
        } else {
            // App install receiver is unregistered after all apps are installed or a timeout happens
            //unregisterAppInstallReceiver();
            lockRestrictions();
        }
    }

    private void lockRestrictions() {
        if (settingsHelper.getConfig() != null && settingsHelper.getConfig().getRestrictions() != null) {
            Utils.lockUserRestrictions(context, settingsHelper.getConfig().getRestrictions());
        }
        notifyThreads();
    }

    private void notifyThreads() {
        ServerConfig config = settingsHelper.getConfig();
        if (config != null) {
            Intent intent = new Intent(Const.ACTION_TOGGLE_PERMISSIVE);
            intent.putExtra(Const.EXTRA_ENABLED, config.isPermissive() || config.isKioskMode());
            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);
        }
        setActions();
    }

    private void setActions() {
        final ServerConfig config = settingsHelper.getConfig();
        // As per the documentation, setting the default preferred activity should not be done on the main thread
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                // If kiosk browser is installed, make it a default browser
                // This is a temporary solution! Perhaps user wants only to open specific hosts / schemes
                if (Utils.isDeviceOwner(context)) {
                    if (config.getActions() != null && config.getActions().size() > 0) {
                        for (Action action : config.getActions()) {
                            Utils.setAction(context, action);
                        }
                    }
                }
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                if (uiNotifier != null) {
                    uiNotifier.onConfigUpdateComplete();
                }

                // Send notification about the configuration update to all plugins
                Intent intent = new Intent(Const.INTENT_PUSH_NOTIFICATION_PREFIX + PushMessage.TYPE_CONFIG_UPDATED);
                context.sendBroadcast(intent);

                RemoteLogger.log(context, Const.LOG_VERBOSE, "Update flow completed");
                if (pendingInstallations.size() > 0) {
                    // Some apps are still pending installation
                    // Let's wait until they're all installed
                    // Then notify UI about that so it could refresh the screen
                    waitForInstallComplete();
                } else {
                    unregisterAppInstallReceiver();
                }

                // onConfigUpdateComplete() method contents
                /*
                Log.i(Const.LOG_TAG, "Showing content from setActions()");
                showContent(settingsHelper.getConfig());
                 */
            }
        }.execute();
    }

    private void waitForInstallComplete() {
        new AsyncTask<Void, Void, Void>() {

            @Override
            protected Void doInBackground(Void... voids) {
                for (int n = 0; n < 60; n++) {
                    if (pendingInstallations.size() == 0) {
                        break;
                    }
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                unregisterAppInstallReceiver();
                if (uiNotifier != null) {
                    uiNotifier.onAllAppInstallComplete();
                }
                return null;
            }
        }.execute();
    }


    @SuppressLint("WrongConstant,UnspecifiedRegisterReceiverFlag")
    private void registerAppInstallReceiver(final String appPermissionStrategy) {
        // Here we handle the completion of the silent app installation in the device owner mode
        // These intents are not delivered to LocalBroadcastManager
        if (appInstallReceiver == null) {
            Log.d(Const.LOG_TAG, "Install completion receiver prepared");
            appInstallReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (intent.getAction().equals(Const.ACTION_INSTALL_COMPLETE)) {
                        int status = intent.getIntExtra(PackageInstaller.EXTRA_STATUS, 0);
                        switch (status) {
                            case PackageInstaller.STATUS_PENDING_USER_ACTION:
                                RemoteLogger.log(context, Const.LOG_INFO, "Request user confirmation to install");
                                Intent confirmationIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);

                                // Fix the Intent Redirection vulnerability
                                // https://support.google.com/faqs/answer/9267555
                                ComponentName name = confirmationIntent.resolveActivity(context.getPackageManager());
                                int flags = confirmationIntent.getFlags();
                                if (name != null && !name.getPackageName().equals(context.getPackageName()) &&
                                        (flags & Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0 &&
                                        (flags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == 0) {
                                    confirmationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                                    try {
                                        context.startActivity(confirmationIntent);
                                    } catch (Exception e) {
                                    }
                                } else {
                                    Log.e(Const.LOG_TAG, "Intent redirection detected, ignoring the fault intent!");
                                }
                                break;
                            case PackageInstaller.STATUS_SUCCESS:
                                String packageName = intent.getStringExtra(Const.PACKAGE_NAME);
                                if (packageName != null) {
                                    RemoteLogger.log(context, Const.LOG_DEBUG, "App " + packageName + " installed successfully");
                                    Log.i(Const.LOG_TAG, "Install complete: " + packageName);
                                    File file = pendingInstallations.get(packageName);
                                    if (file != null) {
                                        pendingInstallations.remove(packageName);
                                        InstallUtils.deleteTempApk(file);
                                    }
                                    if (BuildConfig.SYSTEM_PRIVILEGES || Utils.isDeviceOwner(context)) {
                                        // Always grant all dangerous rights to the app
                                        Utils.autoGrantRequestedPermissions(context, packageName,
                                                appPermissionStrategy, false);
                                        if (BuildConfig.SYSTEM_PRIVILEGES && packageName.equals(Const.APUPPET_PACKAGE_NAME)) {
                                            // Automatically grant required permissions to aPuppet if we can
                                            // Note: device owner can only grant permissions to self, not to other apps!
                                            try {
                                                SystemUtils.autoSetAccessibilityPermission(context,
                                                        Const.APUPPET_PACKAGE_NAME, Const.APUPPET_SERVICE_CLASS_NAME);
                                                SystemUtils.autoSetOverlayPermission(context,
                                                        Const.APUPPET_PACKAGE_NAME);
                                            } catch (Exception e) {
                                                e.printStackTrace();
                                            }
                                        }
                                    }
                                    if (uiNotifier != null) {
                                        uiNotifier.onAppInstallComplete(packageName);
                                    }
                                } else {
                                    RemoteLogger.log(context, Const.LOG_DEBUG, "App installed successfully");
                                }
                                break;
                            default:
                                // Installation failure
                                String extraMessage = intent.getStringExtra(PackageInstaller.EXTRA_STATUS_MESSAGE);
                                String statusMessage = InstallUtils.getPackageInstallerStatusMessage(status);
                                packageName = intent.getStringExtra(Const.PACKAGE_NAME);
                                String logRecord = "Install failed: " + statusMessage;
                                if (packageName != null) {
                                    logRecord = packageName + " " + logRecord;
                                }
                                if (extraMessage != null && extraMessage.length() > 0) {
                                    logRecord += ", extra: " + extraMessage;
                                }
                                RemoteLogger.log(context, Const.LOG_ERROR, logRecord);
                                if (packageName != null) {
                                    File file = pendingInstallations.get(packageName);
                                    if (file != null) {
                                        pendingInstallations.remove(packageName);
                                        InstallUtils.deleteTempApk(file);
                                        // Save failed install attempt to prevent next downloads
                                        saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                                    }
                                }

                                break;
                        }
                        loadAndInstallApplications();
                    }
                }
            };
        } else {
            // Renewed the configuration multiple times?
            unregisterAppInstallReceiver();
        }

        try {
            Log.d(Const.LOG_TAG, "Install completion receiver registered");
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.registerReceiver(appInstallReceiver, new IntentFilter(Const.ACTION_INSTALL_COMPLETE), Context.RECEIVER_EXPORTED);
            } else {
                context.registerReceiver(appInstallReceiver, new IntentFilter(Const.ACTION_INSTALL_COMPLETE));
            }
        } catch (Exception e) {
            // On earlier Android versions (4, 5):
            // Fatal Exception: android.content.ReceiverCallNotAllowedException
            // BroadcastReceiver components are not allowed to register to receive intents
            e.printStackTrace();
        }
    }

    private void unregisterAppInstallReceiver() {
        if (appInstallReceiver != null) {
            try {
                Log.d(Const.LOG_TAG, "Install completion receiver unregistered");
                context.unregisterReceiver(appInstallReceiver);
            } catch (Exception e) {
                // Receiver not registered
                e.printStackTrace();
            }
            appInstallReceiver = null;
        }
    }

    private void installApplicationFromPlayMarket(final String uri, final String packageName) {
        RemoteLogger.log(context, Const.LOG_DEBUG, "Asking user to install app " + packageName);
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(uri));
        try {
            context.startActivity(intent);
        } catch (Exception e) {
            RemoteLogger.log(context, Const.LOG_DEBUG, "Failed to run app install activity for " + packageName);
        }
    }

    // This function is called from a background thread
    private void installApplication( File file, final String packageName, final String version ) {
        if (packageName.equals(context.getPackageName()) &&
                context.getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID) != null) {
            // Restart self in EMUI: there's no auto restart after update in EMUI, we must use a helper app
            startLauncherRestarter();
        }
        String versionData = version == null || version.equals("0") ? "" : " " + version;
        if (Utils.isDeviceOwner(context) || BuildConfig.SYSTEM_PRIVILEGES) {
            pendingInstallations.put(packageName, file);
            RemoteLogger.log(context, Const.LOG_INFO, "Silently installing app " + packageName + versionData);
            InstallUtils.silentInstallApplication(context, file, packageName, new InstallUtils.InstallErrorHandler() {
                @Override
                public void onInstallError(String msg) {
                    Log.i(Const.LOG_TAG, "installApplication(): error installing app " + packageName);
                    pendingInstallations.remove(packageName);
                    if (file.exists()) {
                        file.delete();
                    }
                    if (uiNotifier != null) {
                        uiNotifier.onAppInstallError(packageName);
                    }
                    if (msg != null) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to install app " + packageName + ": " + msg);
                    }
                    // Save failed install attempt to prevent next downloads
                    saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                    /*
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            new AlertDialog.Builder(MainActivity.this)
                                    .setMessage(getString(R.string.install_error) + " " + packageName)
                                    .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {
                                            checkAndStartLauncher();
                                        }
                                    })
                                    .create()
                                    .show();
                        }
                    });
                     */
                }
            });
        } else {
            RemoteLogger.log(context, Const.LOG_INFO, "Asking user to install app " + packageName + versionData);
            InstallUtils.requestInstallApplication(context, file, new InstallUtils.InstallErrorHandler() {
                @Override
                public void onInstallError(String msg) {
                    pendingInstallations.remove(packageName);
                    if (file.exists()) {
                        file.delete();
                    }
                    if (msg != null) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Failed to install app " + packageName + ": " + msg);
                    }
                    // Save failed install attempt to prevent next downloads
                    saveFailedAttempt(context, null, "", file.getAbsolutePath(), true, false);
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            loadAndInstallApplications();
                        }
                    });
                }
            });
        }
    }

    private void uninstallApplication(final String packageName) {
        if (Utils.isDeviceOwner(context) || BuildConfig.SYSTEM_PRIVILEGES) {
            RemoteLogger.log(context, Const.LOG_INFO, "Silently uninstall app " + packageName);
            InstallUtils.silentUninstallApplication(context, packageName);
        } else {
            RemoteLogger.log(context, Const.LOG_INFO, "Asking user to uninstall app " + packageName);
            InstallUtils.requestUninstallApplication(context, packageName);
        }
    }

    // The following algorithm of launcher restart works in EMUI:
    // Run EMUI_LAUNCHER_RESTARTER activity once and send the old version number to it.
    // The restarter application will check the launcher version each second, and restart it
    // when it is changed.
    private void startLauncherRestarter() {
        // Sending an intent before updating, otherwise the launcher may be terminated at any time
        Intent intent = context.getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
        if (intent == null) {
            Log.i("LauncherRestarter", "No restarter app, please add it in the config!");
            return;
        }
        intent.putExtra(Const.LAUNCHER_RESTARTER_OLD_VERSION, BuildConfig.VERSION_NAME);
        context.startActivity(intent);
        Log.i("LauncherRestarter", "Calling launcher restarter from the launcher");
    }

    // Create a new file from the template file
    // (replace DEVICE_NUMBER, IMEI, CUSTOM* by their values)
    private void createFileFromTemplate(File srcFile, File dstFile, String deviceId, String imei, ServerConfig config) throws IOException {
        // We are supposed to process only small text files
        // So here we are reading the whole file, replacing variables, and save the content
        // It is not optimal for large files - it would be better to replace in a stream (how?)
        String content = FileUtils.readFileToString(srcFile);
        content = content.replace("DEVICE_NUMBER", deviceId)
                .replace("IMEI", imei != null ? imei : "")
                .replace("CUSTOM1", config.getCustom1() != null ? config.getCustom1() : "")
                .replace("CUSTOM2", config.getCustom2() != null ? config.getCustom2() : "")
                .replace("CUSTOM3", config.getCustom3() != null ? config.getCustom3() : "");
        FileUtils.writeStringToFile(dstFile, content);
    }

    public boolean isPendingAppInstall() {
        return applicationsForInstall.size() > 0;
    }

    public void repeatDownloadFiles() {
        loadAndInstallFiles();
    }

    public void repeatDownloadApps() {
        loadAndInstallApplications();
    }

    public void skipDownloadFiles() {
        Log.d(Const.LOG_TAG, "File download skipped, continue updating files");
        if (filesForInstall.size() > 0) {
            RemoteFile remoteFile = filesForInstall.remove(0);
            settingsHelper.removeRemoteFile(remoteFile);
        }
        loadAndInstallFiles();
    }

    public void skipDownloadApps() {
        Log.d(Const.LOG_TAG, "App download skipped, continue updating applications");
        if (applicationsForInstall.size() > 0) {
            Application application = applicationsForInstall.remove(0);
            // Mark this app not to download any more until the config is refreshed
            // But we should not remove the app from a list because it may be
            // already installed!
            settingsHelper.removeApplicationUrl(application);
        }
        loadAndInstallApplications();
    }

    public static boolean checkUpdateNetworkRestriction(ServerConfig config, Context context) {
        if (!"wifi".equals(config.getDownloadUpdates())) {
            return true;
        }
        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
        NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
        return activeNetwork != null && activeNetwork.getType() != ConnectivityManager.TYPE_MOBILE;
    }

    public static boolean checkAppUpdateTimeRestriction(ServerConfig config) {
        if (config.getAppUpdateFrom() == null || config.getAppUpdateTo() == null) {
            return true;
        }

        Date date = new Date();
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.setTime(date);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int minute = calendar.get(Calendar.MINUTE);

        int appUpdateFromHour = 0;
        try {
            appUpdateFromHour = Integer.parseInt(config.getAppUpdateFrom().substring(0, 2));
        } catch (Exception e) {
            e.printStackTrace();
        }
        int appUpdateFromMinute = 0;
        try {
            appUpdateFromMinute = Integer.parseInt(config.getAppUpdateFrom().substring(3));
        } catch (Exception e) {
            e.printStackTrace();
        }

        int appUpdateToHour = 0;
        try {
            appUpdateToHour = Integer.parseInt(config.getAppUpdateTo().substring(0, 2));
        } catch (Exception e) {
            e.printStackTrace();
        }
        int appUpdateToMinute = 0;
        try {
            appUpdateToMinute = Integer.parseInt(config.getAppUpdateTo().substring(3));
        } catch (Exception e) {
            e.printStackTrace();
        }

        minute += 60 * hour;
        appUpdateFromMinute += 60 * appUpdateFromHour;
        appUpdateToMinute += 60 * appUpdateToHour;

        if (appUpdateFromMinute == appUpdateToMinute) {
            // This is incorrect. Perhaps the admin meant "24 hours" so return true
            return true;
        }

        if (appUpdateFromMinute < appUpdateToMinute) {
            // Midnight not included
            return appUpdateFromMinute <= minute && minute <= appUpdateToMinute;
        }

        // Midnight included
        return minute >= appUpdateFromMinute || minute <= appUpdateToMinute;
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/util/Utils.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.util;

import android.Manifest;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.Service;
import android.app.admin.DevicePolicyManager;
import android.app.admin.SystemUpdatePolicy;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.ServiceInfo;
import android.graphics.Color;
import android.media.AudioManager;
import android.net.ConnectivityManager;
import android.net.ProxyInfo;
import android.os.Build;
import android.os.UserManager;
import android.provider.Settings;
import android.util.Log;
import android.view.WindowManager;

import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;

import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.json.Action;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.ui.MainActivity;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

public class Utils {
    public static boolean isDeviceOwner(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        return dpm != null && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && dpm.isDeviceOwnerApp(context.getPackageName());
    }

    // In the open source variant, there are no flavors, so by default it's "opensource"
    public static String getLauncherVariant() {
        return BuildConfig.FLAVOR == null || BuildConfig.FLAVOR.equals("") ? "opensource" : BuildConfig.FLAVOR;
    }

    // Automatically grant permission to get phone state (for IMEI and serial)
    @TargetApi(Build.VERSION_CODES.M)
    public static boolean autoGrantPhonePermission(Context context) {
        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                    context.getPackageName(), Manifest.permission.READ_PHONE_STATE) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
                boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                        context.getPackageName(), Manifest.permission.READ_PHONE_STATE, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
                if (!success) {
                    return false;
                }
            }
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                        context.getPackageName(), Manifest.permission.READ_PHONE_NUMBERS) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                            context.getPackageName(), Manifest.permission.READ_PHONE_NUMBERS, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
                    if (!success) {
                        return false;
                    }
                }
                // This permission is dangerous and causes blocking by Play Protect in some countries.
                //     In fact, this permission is currently never used by Headwind MDM.
//                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
//                        context.getPackageName(), Manifest.permission.READ_SMS) != DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED) {
//                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
//                            context.getPackageName(), Manifest.permission.READ_SMS, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);
//                    if (!success) {
//                        return false;
//                    }
//                }
            }
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            e.printStackTrace();
            return false;
        } catch (/* SecurityException */ Exception e) {
            // No active admin ComponentInfo (not sure why could that happen)
            e.printStackTrace();
            return false;
        }
        Log.i(Const.LOG_TAG, "READ_PHONE_STATE automatically granted");
        return true;
    }

    // Automatically get dangerous permissions
    // Notice: default (null) app permission strategy is "Grant all"
    @TargetApi(Build.VERSION_CODES.M)
    public static boolean autoGrantRequestedPermissions(Context context, String packageName,
                                                        @Nullable String appPermissionStrategy,
                                                        boolean forceSdCardPermissions) {
        int locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;
        int otherPermissionsState = DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;

        // Determine the app permission strategy
        if (ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
        } else if (ServerConfig.APP_PERMISSIONS_DENY_LOCATION.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;
        } else if (ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(appPermissionStrategy)) {
            locationPermissionState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
            if (!packageName.equals(context.getPackageName())) {
                otherPermissionsState = DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
            }
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            List<String> permissions = getRuntimePermissions(context.getPackageManager(), packageName);

            // Some devices do not include SD card permissions in the list of runtime permissions
            // So the files could not be read or written.
            // Here we add SD card permissions manually (device owner can grant them!)
            // This is done for the Headwind MDM launcher only
            if (forceSdCardPermissions) {
                boolean hasReadExtStorage = false;
                boolean hasWriteExtStorage = false;
                for (String s : permissions) {
                    if (s.equals(Manifest.permission.READ_EXTERNAL_STORAGE)) {
                        hasReadExtStorage = true;
                    }
                    if (s.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE)) {
                        hasWriteExtStorage = true;
                    }
                }
                if (!hasReadExtStorage) {
                    permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
                }
                if (!hasWriteExtStorage) {
                    permissions.add(Manifest.permission.WRITE_EXTERNAL_STORAGE);
                }
            }

            for (String permission : permissions) {
                int permissionState = isLocationPermission(permission) ? locationPermissionState : otherPermissionsState;
                if (devicePolicyManager.getPermissionGrantState(adminComponentName,
                        packageName, permission) != permissionState) {
                    boolean success = devicePolicyManager.setPermissionGrantState(adminComponentName,
                            packageName, permission, permissionState);
                    if (!success) {
                        Log.w(Const.LOG_TAG, "Failed to grant permission " + permission);
                        return false;
                    } else {
                        Log.d(Const.LOG_TAG, "Permission " + permission + " granted to package " + packageName);
                    }
                }
            }
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            e.printStackTrace();
            return false;
        } catch (/* SecurityException */ Exception e) {
            // No active admin ComponentInfo (not sure why could that happen)
            e.printStackTrace();
            return false;
        }
        Log.i(Const.LOG_TAG, "Permissions automatically granted");
        return true;
    }

    public static boolean isLocationPermission(String permission) {
        return Manifest.permission.ACCESS_COARSE_LOCATION.equals(permission) ||
               Manifest.permission.ACCESS_FINE_LOCATION.equals(permission) ||
               Manifest.permission.ACCESS_BACKGROUND_LOCATION.equals(permission);
    }

    private static List<String> getRuntimePermissions(PackageManager packageManager, String packageName) {
        List<String> permissions = new ArrayList<>();
        PackageInfo packageInfo;
        try {
            packageInfo =
                    packageManager.getPackageInfo(packageName, PackageManager.GET_PERMISSIONS);
        } catch (PackageManager.NameNotFoundException e) {
            return permissions;
        }

        boolean manageStorage = false;
        if (packageInfo != null && packageInfo.requestedPermissions != null) {
            for (String requestedPerm : packageInfo.requestedPermissions) {
                if (requestedPerm.equals(Manifest.permission.MANAGE_EXTERNAL_STORAGE)) {
                    manageStorage = true;
                }
                if (isRuntimePermission(packageManager, requestedPerm)) {
                    permissions.add(requestedPerm);
                }
            }
            // There's a bug in Android 11+: MANAGE_EXTERNAL_STORAGE can't be automatically granted
            // but if Headwind MDM is granting WRITE_EXTERNAL_STORAGE, then the app can't request
            // MANAGE_EXTERNAL_STORAGE, it's locked!
            // So the workaround is do not request WRITE_EXTERNAL_STORAGE in this case
            if (manageStorage && Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                permissions.removeIf(s -> (s.equals(Manifest.permission.WRITE_EXTERNAL_STORAGE) ||
                        s.equals(Manifest.permission.READ_EXTERNAL_STORAGE)));
            }
        }
        return permissions;
    }

    private static boolean isRuntimePermission(PackageManager packageManager, String permission) {
        try {
            PermissionInfo pInfo = packageManager.getPermissionInfo(permission, 0);
            if (pInfo != null) {
                if ((pInfo.protectionLevel & PermissionInfo.PROTECTION_MASK_BASE)
                        == PermissionInfo.PROTECTION_DANGEROUS) {
                    return true;
                }
            }
        } catch (PackageManager.NameNotFoundException e) {
        }
        return false;
    }

    public static int OverlayWindowType() {
        // https://stackoverflow.com/questions/45867533/system-alert-window-permission-on-api-26-not-working-as-expected-permission-den
        if (  Build.VERSION.SDK_INT >= Build.VERSION_CODES.O ) {
            return WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
        } else {
            return WindowManager.LayoutParams.TYPE_SYSTEM_ERROR;
        }
    }

    public static boolean isLightColor(int color) {
        final int THRESHOLD = 0xA0;
        int red = Color.red(color);
        int green = Color.green(color);
        int blue = Color.blue(color);
        return red >= THRESHOLD && green >= THRESHOLD && blue >= THRESHOLD;
    }

    @TargetApi(Build.VERSION_CODES.M)
    public static void setSystemUpdatePolicy(Context context, int systemUpdateType, String scheduledFrom, String scheduledTo) {
        DevicePolicyManager devicePolicyManager = (DevicePolicyManager)context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName deviceAdmin = LegacyUtils.getAdminComponentName(context);

        SystemUpdatePolicy currentPolicy = null;
        try {
            currentPolicy = devicePolicyManager.getSystemUpdatePolicy();
        } catch (NoSuchMethodError e) {
            // This exception is raised on Android 5.1
            Log.e(Const.LOG_TAG, "Failed to set system update policy: " + e.getMessage());
            return;
        }
        if (currentPolicy != null) {
            // Check if policy type shouldn't be changed
            if (systemUpdateType == ServerConfig.SYSTEM_UPDATE_INSTANT && currentPolicy.getPolicyType() == SystemUpdatePolicy.TYPE_INSTALL_AUTOMATIC ||
                systemUpdateType == ServerConfig.SYSTEM_UPDATE_MANUAL && currentPolicy.getPolicyType() == SystemUpdatePolicy.TYPE_POSTPONE) {
                return;
            }
        }
        SystemUpdatePolicy newPolicy = null;
        switch (systemUpdateType) {
            case ServerConfig.SYSTEM_UPDATE_INSTANT:
                newPolicy = SystemUpdatePolicy.createAutomaticInstallPolicy();
                break;
            case ServerConfig.SYSTEM_UPDATE_SCHEDULE:
                // Here we use update window times
                if (scheduledFrom != null && scheduledTo != null) {
                    int windowStart = getMinutesFromString(scheduledFrom);
                    int windowEnd = getMinutesFromString(scheduledTo);
                    if (windowStart == -1) {
                        Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: wrong start time: " + scheduledFrom);
                        return;
                    }
                    if (windowEnd == -1) {
                        Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: wrong end time: " + scheduledFrom);
                        return;
                    }
                    newPolicy = SystemUpdatePolicy.createWindowedInstallPolicy(windowStart, windowEnd);
                } else {
                    Log.e(Const.LOG_TAG, "Ignoring scheduled system update policy: update window is not set on server");
                    return;
                }
                break;
            case ServerConfig.SYSTEM_UPDATE_MANUAL:
                newPolicy = SystemUpdatePolicy.createPostponeInstallPolicy();
                break;
        }
        try {
            devicePolicyManager.setSystemUpdatePolicy(deviceAdmin, newPolicy);
        } catch (Exception e) {
            Log.e(Const.LOG_TAG, "Failed to set system update policy: " + e.getMessage());
        }
    }

    private static int getMinutesFromString(String s) {
        try {
            // s has a fixed format: hh:mm with heading zeroes
            String hours = s.substring(0, 2);
            String minutes = s.substring(3, 5);
            int h = Integer.parseInt(hours);
            int m = Integer.parseInt(minutes);
            return h * 60 + m;
        } catch (Exception e) {
            return -1;
        }
    }

    public static boolean canInstallPackages(Context context) {
        if (BuildConfig.SYSTEM_PRIVILEGES) {
            return true;
        }
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            // Global setting works for Android 7 and below
            try {
                return Settings.Secure.getInt(context.getContentResolver(), Settings.Secure.INSTALL_NON_MARKET_APPS) == 1;
            } catch (Settings.SettingNotFoundException e) {
                return true;
            }
        } else {
            return context.getPackageManager().canRequestPackageInstalls();
        }
    }

    public static boolean canDrawOverlays(Context context) {
        return Build.VERSION.SDK_INT < Build.VERSION_CODES.M ||
                Settings.canDrawOverlays(context);
    }

    public static boolean checkAdminMode(Context context) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            boolean isAdminActive = dpm.isAdminActive(adminComponentName);
//            RemoteLogger.log(context, Const.LOG_DEBUG, "Admin component active: " + isAdminActive);
            return isAdminActive;
        } catch (Exception e) {
//            RemoteLogger.log(context, Const.LOG_WARN, "Failed to get device administrator status: " + e.getMessage());
            return true;
        }
    }

    public static boolean factoryReset(Context context) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                dpm.wipeData(0);
            } else {
                dpm.wipeDevice(0);
            }
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean reboot(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N) {
            return false;
        }
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
            dpm.reboot(adminComponentName);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    private static String getDataToken(Context context) {
        String token = context.getSharedPreferences(Const.PREFERENCES, Context.MODE_PRIVATE).getString(Const.PREFERENCES_DATA_TOKEN, null);
        if (token == null) {
            token = java.util.UUID.randomUUID().toString();
            context.getSharedPreferences(Const.PREFERENCES, Context.MODE_PRIVATE)
                    .edit()
                    .putString(Const.PREFERENCES_DATA_TOKEN, token)
                    .commit();
        }
        return token;
    }

    public static void initPasswordReset(Context context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            try {
                String token = getDataToken(context);
                DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
                ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
                if (dpm.setResetPasswordToken(adminComponentName, token.getBytes())) {
                    if (!dpm.isResetPasswordTokenActive(adminComponentName)) {
                        RemoteLogger.log(context, Const.LOG_WARN, "Password reset token will be activated once the user enters the current password next time.");
                    }
                } else {
                    RemoteLogger.log(context, Const.LOG_WARN, "Failed to setup password reset token, password reset requests will fail");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static boolean passwordReset(Context context, String password) {
        try {
            DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
                boolean tokenActive = dpm.isResetPasswordTokenActive(adminComponentName);
                if (!tokenActive) {
                    return false;
                }
                return dpm.resetPasswordWithToken(adminComponentName, password, getDataToken(context).getBytes(), 0);
            } else {
                return dpm.resetPassword(password, 0);
            }
        } catch (Exception e) {
            return false;
        }
    }

    public static boolean isMobileDataEnabled(Context context) {
        ConnectivityManager cm = (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
        // A hack: use private API
        // https://stackoverflow.com/questions/12686899/test-if-background-data-and-packet-data-is-enabled-or-not?rq=1
        try {
            Class clazz = Class.forName(cm.getClass().getName());
            Method method = clazz.getDeclaredMethod("getMobileDataEnabled");
            method.setAccessible(true); // Make the method callable
            // get the setting for "mobile data"
            return (Boolean) method.invoke(cm);
        } catch (Exception e) {
            // Let it will be true by default
            return true;
        }

    }

    public static boolean isPackageInstalled(Context context, String targetPackage){
        PackageManager pm = context.getPackageManager();
        try {
            PackageInfo info = pm.getPackageInfo(targetPackage,PackageManager.GET_META_DATA);
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
        return true;
    }

    public static boolean isMiui(Context context) {
        return isPackageInstalled(context, "com.miui.home") ||
                isPackageInstalled(context, "com.miui.securitycenter");
    }

    public static boolean lockSafeBoot(Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_SAFE_BOOT);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean lockUsbStorage(boolean lock, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            try {
                // Deprecated way to lock USB
                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1) {
                    Settings.Secure.putInt(context.getContentResolver(), Settings.Secure.USB_MASS_STORAGE_ENABLED, 0);
                } else {
                    Settings.Global.putInt(context.getContentResolver(), Settings.Global.USB_MASS_STORAGE_ENABLED, 0);
                }
            } catch (Exception e) {
                return false;
            }
            return true;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock) {
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_USB_FILE_TRANSFER);
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA);
            } else {
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_USB_FILE_TRANSFER);
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setBrightnessPolicy(Boolean auto, Integer brightness, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (auto == null) {
                // This means we should unlock brightness
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_BRIGHTNESS);
            } else {
                // Managed brightness
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_BRIGHTNESS);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
                    // This option is available in Android 9 and above
                    if (auto) {
                        devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS_MODE, "1");
                    } else {
                        devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS_MODE, "0");
                        if (brightness != null) {
                            devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_BRIGHTNESS, "" + brightness);
                        }
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setScreenTimeoutPolicy(Boolean lock, Integer timeout, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock == null || !lock) {
                // This means we should unlock screen timeout
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT);
            } else {
                // Managed screen timeout
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_CONFIG_SCREEN_TIMEOUT);
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P && timeout != null) {
                    // This option is available in Android 9 and above
                    devicePolicyManager.setSystemSetting(adminComponentName, Settings.System.SCREEN_OFF_TIMEOUT, "" + (timeout * 1000));
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean lockVolume(Boolean lock, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            if (lock == null || !lock) {
                Log.d(Const.LOG_TAG, "Unlocking volume");
                devicePolicyManager.clearUserRestriction(adminComponentName, UserManager.DISALLOW_ADJUST_VOLUME);
            } else {
                Log.d(Const.LOG_TAG, "Locking volume");
                devicePolicyManager.addUserRestriction(adminComponentName, UserManager.DISALLOW_ADJUST_VOLUME);
            }
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to lock/unlock volume: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
        return true;
    }

    public static boolean setVolume(int percent, Context context) {
        int[] streams = {
            AudioManager.STREAM_VOICE_CALL,
            AudioManager.STREAM_SYSTEM,
            AudioManager.STREAM_RING,
            AudioManager.STREAM_MUSIC,
            AudioManager.STREAM_ALARM
        };
        try {
            AudioManager audioManager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);
            for (int s : streams) {
                setVolumeInternal(audioManager, s, percent);

                int v = audioManager.getStreamVolume(s);
                if (v == 0) {
                    v = 1;
                }
            }
            return true;
        } catch (Exception e) {
            Log.w(Const.LOG_TAG, "Failed to set volume: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    private static void setVolumeInternal(AudioManager audioManager, int stream, int percent) throws Exception {
        int maxVolume = audioManager.getStreamMaxVolume(stream);
        int volume = (maxVolume * percent) / 100;
        audioManager.setStreamVolume(stream, volume, 0);
    }

    public static boolean disableScreenshots(Boolean disabled, Context context) {
        if (!isDeviceOwner(context) || Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return false;
        }

        DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

        try {
            devicePolicyManager.setScreenCaptureDisabled(adminComponentName, disabled);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    // Returns true if the current password is good enough, or false elsewhere
    public static boolean setPasswordMode(String passwordMode, Context context) {
        // This function works with a (deprecated) device admin as well
        // So we don't check that it has device owner rights!
        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (passwordMode == null) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_PRESENT)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 1);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_EASY)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 6);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_MODERATE)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 8);
            } else if (passwordMode.equals(Const.PASSWORD_QUALITY_STRONG)) {
                devicePolicyManager.setPasswordQuality(adminComponentName, DevicePolicyManager.PASSWORD_QUALITY_COMPLEX);
                devicePolicyManager.setPasswordMinimumLowerCase(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumUpperCase(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumNumeric(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumSymbols(adminComponentName, 1);
                devicePolicyManager.setPasswordMinimumLength(adminComponentName, 8);
            }
            boolean result = devicePolicyManager.isActivePasswordSufficient();
            if (passwordMode != null) {
                RemoteLogger.log(context, Const.LOG_DEBUG, "Active password quality sufficient: " + result);
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            // If the app doesn't have enough rights, let's leave password quality as is
            if (passwordMode != null) {
                RemoteLogger.log(context, Const.LOG_WARN, "Failed to update password quality: " + e.getMessage());
            }
            return true;
        }
    }

    public static boolean setTimeZone(String timeZone, Context context) {
        if (!Utils.isDeviceOwner(context) || timeZone == null || Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
            return true;
        }

        try {
            DevicePolicyManager devicePolicyManager = (DevicePolicyManager) context.getSystemService(
                    Context.DEVICE_POLICY_SERVICE);
            ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);

            if (timeZone.equals("auto")) {
                // Note: in Android 11, there is a special method for setting auto time zone
                devicePolicyManager.setGlobalSetting(adminComponentName, Settings.Global.AUTO_TIME_ZONE, "1");
            } else {
                devicePolicyManager.setGlobalSetting(adminComponentName, Settings.Global.AUTO_TIME_ZONE, "0");
                return devicePolicyManager.setTimeZone(adminComponentName, timeZone);
            }
        } catch (Exception e) {
            e.printStackTrace();
            return true;
        }
        return true;
    }

    @SuppressLint("SourceLockedOrientationActivity")
    public static void setOrientation(Activity activity, ServerConfig config) {
        String loggedOrientation = "unspecified";
        if (config.getOrientation() != null && config.getOrientation() != 0) {
            switch (config.getOrientation()) {
                case Const.SCREEN_ORIENTATION_PORTRAIT:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
                    loggedOrientation = "portrait";
                    break;
                case Const.SCREEN_ORIENTATION_LANDSCAPE:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
                    loggedOrientation = "landscape";
                    break;
                default:
                    activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
                    break;
            }
        } else {
            activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
        }
        Log.i(Const.LOG_TAG, "Set orientation: " + loggedOrientation);
    }

    public static boolean isLauncherIntent(Intent intent) {
        if (intent == null) {
            return false;
        }
        Set<String> categories = intent.getCategories();
        if (categories == null) {
            return false;
        }
        for (String c : categories) {
            if (c.equals(Intent.CATEGORY_LAUNCHER)) {
                return true;
            }
        }
        return false;
    }

    public static String getDefaultLauncher(Context context) {
        ActivityInfo defaultLauncherInfo = getDefaultLauncherInfo(context);
        if (defaultLauncherInfo != null) {
            return defaultLauncherInfo.packageName;
        } else {
            return null;
        }
    }

    public static ActivityInfo getDefaultLauncherInfo(Context context) {
        PackageManager localPackageManager = context.getPackageManager();
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        ResolveInfo info = localPackageManager.resolveActivity(intent,
                PackageManager.MATCH_DEFAULT_ONLY);
        if (info == null || info.activityInfo == null) {
            return null;
        }
        return info.activityInfo;
    }

    public static boolean isServiceRunning(Context context, Class<?> serviceClass) {
        try {
            ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            List<ActivityManager.RunningServiceInfo> runningServices = manager.getRunningServices(Integer.MAX_VALUE);
            for (ActivityManager.RunningServiceInfo service : runningServices) {
                if (serviceClass.getName().equals(service.service.getClassName())) {
                    return true;
                }
            }
        } catch (Exception e) {
            return false;
        }
        return false;
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void setDefaultLauncher(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        IntentFilter filter = new IntentFilter(Intent.ACTION_MAIN);
        filter.addCategory(Intent.CATEGORY_HOME);
        filter.addCategory(Intent.CATEGORY_DEFAULT);

        ComponentName activity = new ComponentName(context, MainActivity.class);
        setPreferredActivity(context, filter, activity, "Set Headwind MDM as default launcher");
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void clearDefaultLauncher(Context context) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        IntentFilter filter = new IntentFilter(Intent.ACTION_MAIN);
        filter.addCategory(Intent.CATEGORY_HOME);
        filter.addCategory(Intent.CATEGORY_DEFAULT);

        setPreferredActivity(context, filter, null, "Reset default launcher");
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void setAction(Context context, Action action) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }
        try {
            IntentFilter filter = new IntentFilter("android.intent.action." + action.getAction());

            if (action.getCategories() != null && action.getCategories().length() > 0) {
                String[] categories = action.getCategories().split(",");
                for (String category : categories) {
                    filter.addCategory("android.intent.category." + category);
                }
            }

            if (action.getMimeTypes() != null && action.getMimeTypes().length() > 0) {
                String[] mimeTypes = action.getMimeTypes().split(",");
                for (String mimeType : mimeTypes) {
                    try {
                        filter.addDataType(mimeType);
                    } catch (IntentFilter.MalformedMimeTypeException e) {
                    }
                }
            }

            if (action.getSchemes() != null && action.getSchemes().length() > 0) {
                String[] schemes = action.getSchemes().split(",");
                for (String scheme : schemes) {
                    filter.addDataScheme(scheme);
                }

                if (action.getHosts() != null && action.getHosts().length() > 0) {
                    String[] hosts = action.getHosts().split(",");
                    for (String host : hosts) {
                        String[] hostport = host.split(":");
                        switch (hostport.length) {
                            case 0:
                                break;
                            case 1:
                                filter.addDataAuthority(hostport[0], null);
                                break;
                            case 2:
                                filter.addDataAuthority(hostport[0], hostport[1]);
                                break;
                        }
                    }
                }
            }

            ComponentName activity = new ComponentName(action.getPackageId(), action.getActivity());
            if (activity != null) {
                setPreferredActivity(context, filter, activity, "Set " + action.getPackageId() + "/" + action.getActivity() + " as default for " + action.getAction());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    private static void setPreferredActivity(Context context, IntentFilter filter, ComponentName activity, String logMessage) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        // Set the activity as the preferred option for the device.
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm =
                (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        try {
            if (activity != null) {
                dpm.addPersistentPreferredActivity(adminComponentName, filter, activity);
            } else {
                dpm.clearPackagePersistentPreferredActivities(adminComponentName, context.getPackageName());
            }
            RemoteLogger.log(context, Const.LOG_DEBUG, logMessage + " - success");
        } catch (Exception e) {
            e.printStackTrace();
            RemoteLogger.log(context, Const.LOG_WARN, logMessage + " - failure: " + e.getMessage());
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void releaseUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.clearUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void lockUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.addUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
    public static void unlockUserRestrictions(Context context, String restrictions) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            return;
        }

        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        if (dpm == null || !dpm.isDeviceOwnerApp(context.getPackageName())) {
            return;
        }

        String[] restrictionList = restrictions.split(",");
        for (String r : restrictionList) {
            try {
                dpm.clearUserRestriction(adminComponentName, r.trim());
            } catch (Exception e) {
            }
        }
    }

    // Setting proxyUrl=null clears the proxy previously set up
    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public static boolean setProxy(Context context, String proxyUrl) {
        ComponentName adminComponentName = LegacyUtils.getAdminComponentName(context);
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        try {
            ProxyInfo proxyInfo = null;
            if (proxyUrl != null) {
                String[] parts = proxyUrl.split(":");
                if (parts.length != 2) {
                    Log.d(Const.LOG_TAG, "Invalid proxy URL: " + proxyUrl);
                    return false;
                }
                int port = Integer.parseInt(parts[1]);
                proxyInfo = ProxyInfo.buildDirectProxy(parts[0], port);
            }
            dpm.setRecommendedGlobalProxy(adminComponentName, proxyInfo);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Load file content to String
     */
    public static String loadFileAsString(String filePath) throws java.io.IOException {
        StringBuffer fileData = new StringBuffer();
        BufferedReader reader = new BufferedReader(new FileReader(filePath));
        char[] buf = new char[1024];
        int numRead = 0;
        while((numRead = reader.read(buf)) != -1){
            String readData = String.valueOf(buf, 0, numRead);
            fileData.append(readData);
        }
        reader.close();
        return fileData.toString();
    }


    /**
     * Load input stream as String
     */
    public static String loadStreamAsString(InputStreamReader inputStreamReader) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(inputStreamReader);
            StringBuilder sb = new StringBuilder();
            String s;
            while ((s = reader.readLine()) != null) {
                sb.append(s + "\n");
            }
            return sb.toString();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }

    /**
     * Write String to file
     */
    public static boolean writeStringToFile(String fileName, String fileContent, boolean overwrite) {
        try {
            File file = new File(fileName);
            if (file.exists()) {
                if (overwrite) {
                    file.delete();
                } else {
                    return false;
                }
            }

            file.createNewFile();
            FileOutputStream fos = new FileOutputStream(file);
            OutputStreamWriter writer = new OutputStreamWriter(fos);
            writer.append(fileContent);
            writer.close();
            fos.close();
            return true;
        } catch (Exception e) {
            return false;
        }

    }

    /**
     * Starting foreground service of special use
     */
    public static void startStableForegroundService(Service service, int notificationId, Notification notification) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            int serviceType = Utils.isDeviceOwner(service) ?
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_SYSTEM_EXEMPTED :
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE;
            try {
                service.startForeground(notificationId, notification, serviceType);
            } catch (/* ForegroundServiceTypeNotAllowed*/Exception e) {
                service.startForeground(notificationId, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_SPECIAL_USE);
            }
        } else {
            service.startForeground(notificationId, notification);
        }
    }
}
</file>

<file path="app/src/main/java/com/hmdm/launcher/ui/MainActivity.java">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.hmdm.launcher.ui;

import android.Manifest;
import android.app.Dialog;
import android.app.admin.DevicePolicyManager;
import android.bluetooth.BluetoothAdapter;
import android.content.BroadcastReceiver;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.graphics.drawable.GradientDrawable;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.SystemClock;
import android.provider.Settings;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Surface;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AlertDialog;
import androidx.databinding.DataBindingUtil;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import androidx.recyclerview.widget.GridLayoutManager;

import com.github.anrwatchdog.ANRWatchDog;
import com.hmdm.launcher.BuildConfig;
import com.hmdm.launcher.Const;
import com.hmdm.launcher.R;
import com.hmdm.launcher.databinding.ActivityMainBinding;
import com.hmdm.launcher.databinding.DialogAccessibilityServiceBinding;
import com.hmdm.launcher.databinding.DialogAdministratorModeBinding;
import com.hmdm.launcher.databinding.DialogEnterPasswordBinding;
import com.hmdm.launcher.databinding.DialogFileDownloadingFailedBinding;
import com.hmdm.launcher.databinding.DialogHistorySettingsBinding;
import com.hmdm.launcher.databinding.DialogManageStorageBinding;
import com.hmdm.launcher.databinding.DialogMiuiPermissionsBinding;
import com.hmdm.launcher.databinding.DialogOverlaySettingsBinding;
import com.hmdm.launcher.databinding.DialogPermissionsBinding;
import com.hmdm.launcher.databinding.DialogSystemSettingsBinding;
import com.hmdm.launcher.databinding.DialogUnknownSourcesBinding;
import com.hmdm.launcher.helper.ConfigUpdater;
import com.hmdm.launcher.helper.CryptoHelper;
import com.hmdm.launcher.helper.Initializer;
import com.hmdm.launcher.helper.SettingsHelper;
import com.hmdm.launcher.json.Application;
import com.hmdm.launcher.json.DeviceInfo;
import com.hmdm.launcher.json.RemoteFile;
import com.hmdm.launcher.json.ServerConfig;
import com.hmdm.launcher.pro.ProUtils;
import com.hmdm.launcher.pro.service.CheckForegroundAppAccessibilityService;
import com.hmdm.launcher.pro.service.CheckForegroundApplicationService;
import com.hmdm.launcher.server.ServerServiceKeeper;
import com.hmdm.launcher.server.UnsafeOkHttpClient;
import com.hmdm.launcher.service.LocationService;
import com.hmdm.launcher.service.PluginApiService;
import com.hmdm.launcher.service.StatusControlService;
import com.hmdm.launcher.task.GetServerConfigTask;
import com.hmdm.launcher.task.SendDeviceInfoTask;
import com.hmdm.launcher.ui.custom.StatusBarUpdater;
import com.hmdm.launcher.util.AppInfo;
import com.hmdm.launcher.util.CrashLoopProtection;
import com.hmdm.launcher.util.DeviceInfoProvider;
import com.hmdm.launcher.util.InstallUtils;
import com.hmdm.launcher.util.PreferenceLogger;
import com.hmdm.launcher.util.RemoteLogger;
import com.hmdm.launcher.util.SystemUtils;
import com.hmdm.launcher.util.Utils;
import com.hmdm.launcher.worker.SendDeviceInfoWorker;
import com.jakewharton.picasso.OkHttp3Downloader;
import com.squareup.picasso.NetworkPolicy;
import com.squareup.picasso.Picasso;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import io.flutter.embedding.android.FlutterActivity;
import okhttp3.Cache;
import okhttp3.OkHttpClient;

import io.flutter.embedding.android.FlutterFragment;
import io.flutter.embedding.engine.FlutterEngine;
import io.flutter.embedding.engine.FlutterEngineCache;
import io.flutter.embedding.engine.dart.DartExecutor;
import io.flutter.plugin.common.MethodChannel;
public class MainActivity
        extends BaseActivity
        implements View.OnLongClickListener, BaseAppListAdapter.OnAppChooseListener,
        BaseAppListAdapter.SwitchAdapterListener, View.OnClickListener,
        ConfigUpdater.UINotifier {

    private static final String CHANNEL = "com.hmdm.flutter/location"; // Add this line

    private static final int PERMISSIONS_REQUEST = 1000;

    private ActivityMainBinding binding;
    private SettingsHelper settingsHelper;

    private Dialog fileNotDownloadedDialog;
    private DialogFileDownloadingFailedBinding dialogFileDownloadingFailedBinding;

    private Dialog enterPasswordDialog;
    private DialogEnterPasswordBinding dialogEnterPasswordBinding;

    private Dialog overlaySettingsDialog;
    private DialogOverlaySettingsBinding dialogOverlaySettingsBinding;

    private Dialog historySettingsDialog;
    private DialogHistorySettingsBinding dialogHistorySettingsBinding;

    private Dialog manageStorageDialog;
    private DialogManageStorageBinding dialogManageStorageBinding;

    private Dialog miuiPermissionsDialog;
    private DialogMiuiPermissionsBinding dialogMiuiPermissionsBinding;

    private Dialog unknownSourcesDialog;
    private DialogUnknownSourcesBinding dialogUnknownSourcesBinding;

    private Dialog administratorModeDialog;
    private DialogAdministratorModeBinding dialogAdministratorModeBinding;

    private Dialog accessibilityServiceDialog;
    private DialogAccessibilityServiceBinding dialogAccessibilityServiceBinding;

    private Dialog systemSettingsDialog;
    private DialogSystemSettingsBinding dialogSystemSettingsBinding;

    private Dialog permissionsDialog;
    private DialogPermissionsBinding dialogPermissionsBinding;

    private Handler handler = new Handler();
    private View applicationNotAllowed;
    private View lockScreen;

    private SharedPreferences preferences;

    private MainAppListAdapter mainAppListAdapter;
    private BottomAppListAdapter bottomAppListAdapter;
    private int spanCount;
    private StatusBarUpdater statusBarUpdater = new StatusBarUpdater();

    private static boolean configInitialized = false;
    // This flag is used to exit kiosk to avoid looping in onResume()
    private static boolean interruptResumeFlow = false;
    private static final int BOOT_DURATION_SEC = 120;
    private static final int PAUSE_BETWEEN_AUTORUNS_SEC = 5;
    private boolean sendDeviceInfoScheduled = false;
    // This flag notifies "download error" dialog what we're downloading: application or file
    // We cannot send this flag as the method parameter because dialog calls MainActivity methods
    private boolean downloadingFile = false;

    private int kioskUnlockCounter = 0;

    private boolean configFault = false;

    private boolean needSendDeviceInfoAfterReconfigure = false;
    private boolean needRedrawContentAfterReconfigure = false;
    private boolean orientationLocked = false;

    private int REQUEST_CODE_GPS_STATE_CHANGE = 1;

    // This flag is used by the broadcast receiver to determine what to do if it gets a policy violation report
    private boolean isBackground;

    private ANRWatchDog anrWatchDog;

    private int lastNetworkType;

    private ConfigUpdater configUpdater = new ConfigUpdater();

    private Picasso picasso = null;

    private BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive( Context context, Intent intent ) {
            switch ( intent.getAction() ) {
                case Const.ACTION_UPDATE_CONFIGURATION:
                    RemoteLogger.log(context, Const.LOG_DEBUG, "Update configuration by MainActivity");
                    updateConfig(false);
                    break;
                case Const.ACTION_HIDE_SCREEN:
                    ServerConfig serverConfig = SettingsHelper.getInstance(MainActivity.this).getConfig();
                    if (serverConfig.getLock() != null && serverConfig.getLock()) {
                        // Device is locked by the server administrator!
                        showLockScreen();
                    } else if ( applicationNotAllowed != null &&
                            (!ProUtils.kioskModeRequired(MainActivity.this) || !ProUtils.isKioskAppInstalled(MainActivity.this)) ) {
                        TextView textView = ( TextView ) applicationNotAllowed.findViewById( R.id.package_id );
                        textView.setText(intent.getStringExtra(Const.PACKAGE_NAME));

                        applicationNotAllowed.setVisibility( View.VISIBLE );
                        // This ensures requestFocus() happens after layout, when it's safe and guaranteed to work.
                        applicationNotAllowed.post(() -> {
                            View button = applicationNotAllowed.findViewById(R.id.layout_application_not_allowed_continue);
                            button.requestFocus();
                        });
                        handler.postDelayed( new Runnable() {
                            @Override
                            public void run() {
                                applicationNotAllowed.setVisibility( View.GONE );
                            }
                        }, 20000 );
                    }
                    break;

                case Const.ACTION_DISABLE_BLOCK_WINDOW:
                    if ( applicationNotAllowed != null) {
                        applicationNotAllowed.setVisibility(View.GONE);
                    }
                    break;

                case Const.ACTION_EXIT:
                    finish();
                    break;

                case Const.ACTION_POLICY_VIOLATION:
                    if (isBackground) {
                        // If we're in the background, let's bring Headwind MDM to top and the notification will be raised in onResume
                        Intent restoreLauncherIntent = new Intent(context, MainActivity.class);
                        restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivity(restoreLauncherIntent);
                    } else {
                        // Calling startActivity always calls onPause / onResume which is not what we want
                        // So just show dialog if it isn't already shown
                        if (systemSettingsDialog == null || !systemSettingsDialog.isShowing()) {
                            notifyPolicyViolation(intent.getIntExtra(Const.POLICY_VIOLATION_CAUSE, 0));
                        }
                    }
                    break;

                case Const.ACTION_EXIT_KIOSK:
                    ServerConfig config = settingsHelper.getConfig();
                    if (config != null) {
                        config.setKioskMode(false);
                        RemoteLogger.log(MainActivity.this, Const.LOG_INFO, "Exit kiosk by admin command");
                        showContent(config);
                    }
                    break;

                case Const.ACTION_ADMIN_PANEL:
                    openAdminPanel();
                    break;
            }

        }
    };

    private final BroadcastReceiver stateChangeReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            // Log new connection type
            if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
                ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                if (null != activeNetwork) {
                    if (lastNetworkType != activeNetwork.getType()) {
                        lastNetworkType = activeNetwork.getType();
                        RemoteLogger.log(MainActivity.this, Const.LOG_DEBUG, "Network type changed: " + activeNetwork.getTypeName());
                    }
                } else {
                    if (lastNetworkType != -1) {
                        lastNetworkType = -1;
                        RemoteLogger.log(MainActivity.this, Const.LOG_DEBUG, "Network connection lost");
                    }
                }
            }

            try {
                applyEarlyPolicies(settingsHelper.getConfig());
            } catch (Exception e) {
            }
        }
    };


    private GradientDrawable selectedManageButtonBorder = new GradientDrawable();
    private ImageView exitView;
    private long exitFirstTapTime = 0;
    private int exitTapCount = 0;
    private ImageView infoView;
    private ImageView updateView;

    private View statusBarView;
    private View rightToolbarView;

    private boolean firstStartAfterProvisioning = false;


    @Override
    protected void onCreate( Bundle savedInstanceState ) {
        Log.d("messi scored", "onCreate: ");
        super.onCreate( savedInstanceState );


        Intent intent = getIntent();
        Log.d(Const.LOG_TAG, "MainActivity started" + (intent != null && intent.getAction() != null ?
                ", action: " + intent.getAction() : ""));
        if (intent != null && "android.app.action.PROVISIONING_SUCCESSFUL".equalsIgnoreCase(intent.getAction())) {
            firstStartAfterProvisioning = true;
        }

        if (CrashLoopProtection.isCrashLoopDetected(this)) {
            Toast.makeText(MainActivity.this, R.string.fault_loop_detected, Toast.LENGTH_LONG).show();
            return;
        }

        // Disable crashes to avoid "select a launcher" popup
        // Crashlytics will show an exception anyway!
        Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            @Override
            public void uncaughtException(Thread t, Throwable e) {
                e.printStackTrace();

                ProUtils.sendExceptionToCrashlytics(e);

                CrashLoopProtection.registerFault(MainActivity.this);
                // Restart launcher if there's a launcher restarter (and we're not in a crash loop)
                if (!CrashLoopProtection.isCrashLoopDetected(MainActivity.this)) {
                    Intent intent = getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
                    if (intent != null) {
                        startActivity(intent);
                    }
                }
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
                    finishAffinity();
                }
                System.exit(0);
            }
        });


        if (BuildConfig.ANR_WATCHDOG) {
            anrWatchDog = new ANRWatchDog();
            anrWatchDog.start();
        }

        // Prevent showing the lock screen during the app download/installation
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

        binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        binding.setMessage(getString( R.string.main_start_preparations));
        binding.loading.setVisibility(View.VISIBLE);

        settingsHelper = SettingsHelper.getInstance(this);
        preferences = getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);

        settingsHelper.setAppStartTime(System.currentTimeMillis());

        Initializer.init(this, () -> {

            // Try to start services in onCreate(), this may fail, we will try again on each onResume.
            startServicesWithRetry();

            initReceiver();

            IntentFilter intentFilter = new IntentFilter();
            intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
            intentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
            intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                registerReceiver(stateChangeReceiver, intentFilter, Context.RECEIVER_EXPORTED);
            } else {
                registerReceiver(stateChangeReceiver, intentFilter);
            }

            if (!getIntent().getBooleanExtra(Const.RESTORED_ACTIVITY, false)) {
                startAppsAtBoot();
            }

            settingsHelper.setMainActivityRunning(true);
        });
        try {
            // Instantiate a FlutterEngine.
            FlutterEngine flutterEngine = new FlutterEngine(this);

            // Start executing Dart code to kick off the background service.
            flutterEngine.getDartExecutor().executeDartEntrypoint(
                    DartExecutor.DartEntrypoint.createDefault()
            );

            // Cache the FlutterEngine to be used by FlutterActivity or other parts of the app.
            FlutterEngineCache
                    .getInstance()
                    .put("my_flutter_engine", flutterEngine);

            Log.d("FLUTTER_SERVICE", "Headless Flutter engine started successfully.");

        } catch (Exception e) {
            Log.e("FLUTTER_SERVICE", "Failed to start headless Flutter engine.", e);
        }
    }

    // On some Android firmwares, onResume is called before onCreate, so the fields are not initialized
    // Here we initialize all required fields to avoid crash at startup
    private void reinitApp() {
        if (binding == null) {
            binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
            binding.setMessage(getString(R.string.main_start_preparations));
            binding.loading.setVisibility(View.VISIBLE);
        }

        if (settingsHelper == null) {
            settingsHelper = SettingsHelper.getInstance(this);
        }
        if (preferences == null) {
            preferences = getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == REQUEST_CODE_GPS_STATE_CHANGE) {
            // User changed GPS state, let's update location service
            startLocationServiceWithRetry();
        }
    }

    private void initReceiver() {
        IntentFilter intentFilter = new IntentFilter(Const.ACTION_UPDATE_CONFIGURATION);
        intentFilter.addAction(Const.ACTION_HIDE_SCREEN);
        intentFilter.addAction(Const.ACTION_EXIT);
        intentFilter.addAction(Const.ACTION_POLICY_VIOLATION);
        intentFilter.addAction(Const.ACTION_EXIT_KIOSK);
        intentFilter.addAction(Const.ACTION_ADMIN_PANEL);
        LocalBroadcastManager.getInstance(this).registerReceiver(receiver, intentFilter);
    }

    @Override
    protected void onResume() {
        super.onResume();

        isBackground = false;

        // On some Android firmwares, onResume is called before onCreate, so the fields are not initialized
        // Here we initialize all required fields to avoid crash at startup
        reinitApp();

        statusBarUpdater.startUpdating(this, binding.clock, binding.batteryState);

        startServicesWithRetry();

        if (interruptResumeFlow) {
            interruptResumeFlow = false;
            return;
        }

        if (!BuildConfig.SYSTEM_PRIVILEGES) {
            if (firstStartAfterProvisioning) {
                firstStartAfterProvisioning = false;
                waitForProvisioning(10);
            } else {
                setDefaultLauncherEarly();
            }
        } else {
            setSelfAsDeviceOwner();
        }
    }

    private void lockOrientation() {
        int orientation = getResources().getConfiguration().orientation;
        int rotation = getWindowManager().getDefaultDisplay().getRotation();
        Log.d(Const.LOG_TAG, "Lock orientation: orientation=" + orientation + ", rotation=" + rotation);
        if (orientation == Configuration.ORIENTATION_PORTRAIT) {
            setRequestedOrientation(rotation < Surface.ROTATION_180 ? ActivityInfo.SCREEN_ORIENTATION_PORTRAIT : ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
        } else {
            setRequestedOrientation(rotation < Surface.ROTATION_180 ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
        }
    }

    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if (mainAppListAdapter != null && event.getAction() == KeyEvent.ACTION_UP) {
            if (!mainAppListAdapter.onKey(keyCode)) {
                if (bottomAppListAdapter != null) {
                    return bottomAppListAdapter.onKey(keyCode);
                }
            };
        }
        return super.onKeyUp(keyCode, event);
    }

    // Workaround against crash "App is in background" on Android 9: this is an Android OS bug
    // https://stackoverflow.com/questions/52013545/android-9-0-not-allowed-to-start-service-app-is-in-background-after-onresume
    private void startServicesWithRetry() {
        try {
            startServices();
        } catch (Exception e) {
            // Android OS bug!!!
            e.printStackTrace();

            // Repeat an attempt to start services after one second
            handler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        startServices();
                    } catch (Exception e) {
                        // Still failed, now give up!
                        // startService may fail after resuming, but the service may be already running (there's a WorkManager)
                        // So if we get an exception here, just ignore it and hope the app will work further
                        e.printStackTrace();
                    }
                }
            }, 1000);
        }
    }

    private void startAppsAtBoot() {
        // Let's assume that we start within two minutes after boot
        // This should work even for slow devices
        long uptimeMillis = SystemClock.uptimeMillis();
        if (uptimeMillis > BOOT_DURATION_SEC * 1000) {
            return;
        }
        final ServerConfig config = settingsHelper.getConfig();
        if (config == null || config.getApplications() == null) {
            // First start
            return;
        }

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                boolean appStarted = false;
                for (Application application : config.getApplications()) {
                    if (application.isRunAtBoot()) {
                        // Delay start of each application to 5 sec
                        try {
                            Thread.sleep(PAUSE_BETWEEN_AUTORUNS_SEC * 1000);
                        } catch (InterruptedException e) {
                        }
                        Intent launchIntent = getPackageManager().getLaunchIntentForPackage(application.getPkg());
                        if (launchIntent != null) {
                            startActivity(launchIntent);
                            appStarted = true;
                        }
                    }
                }
                // Hide apps after start to avoid users confusion
                if (appStarted && !config.isAutostartForeground()) {
                    try {
                        Thread.sleep(PAUSE_BETWEEN_AUTORUNS_SEC * 1000);
                    } catch (InterruptedException e) {
                    }
                    // Notice: if MainActivity will be destroyed after running multiple apps at startup,
                    // we can get the looping here, because startActivity will create a new instance!
                    // That's why we put a boolean extra preventing apps from start
                    Intent intent = new Intent(MainActivity.this, MainActivity.class);
                    intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
                    intent.putExtra(Const.RESTORED_ACTIVITY, true);
                    startActivity(intent);
                }

                return null;
            }
        }.execute();

    }

    // Does not seem to work, though. See the comment to SystemUtils.becomeDeviceOwner()
    private void setSelfAsDeviceOwner() {
        // We set self as device owner each time so we could trace errors if device owner setup fails
        if (Utils.isDeviceOwner(this)) {
            checkAndStartLauncher();
            return;
        }

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... voids) {
                if (!SystemUtils.becomeDeviceOwnerByCommand(MainActivity.this)) {
                    SystemUtils.becomeDeviceOwnerByXmlFile(MainActivity.this);
                };
                return null;
            }

            @Override
            protected void onPostExecute(Void v) {
                setDefaultLauncherEarly();
            }
        }.execute();
    }


    private void startServices() {
        // Foreground apps checks are not available in a free version: services are the stubs
        if (preferences.getInt(Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            startService(new Intent(MainActivity.this, CheckForegroundApplicationService.class));
        }
        if (BuildConfig.USE_ACCESSIBILITY &&
            preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            startService(new Intent(MainActivity.this, CheckForegroundAppAccessibilityService.class));
        }
        startService(new Intent(MainActivity.this, StatusControlService.class));

        // Moved to onResume!
        // https://stackoverflow.com/questions/51863600/java-lang-illegalstateexception-not-allowed-to-start-service-intent-from-activ
        startService(new Intent(MainActivity.this, PluginApiService.class));

        // Send pending logs to server
        RemoteLogger.resetState();
        RemoteLogger.sendLogsToServer(MainActivity.this);
    }

    @Override
    public void onRequestPermissionsResult(int requestCode,
                                           String[] permissions, int[] grantResults) {
        if (requestCode == PERMISSIONS_REQUEST) {
            if (Utils.isDeviceOwner(this)) {
                // Even in device owner mode, if "Ask for location" is requested by the admin,
                // let's ask permissions (so do nothing here, fall through)
                if (settingsHelper.getConfig() == null || !ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(settingsHelper.getConfig().getAppPermissions()) &&
                        !ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(settingsHelper.getConfig().getAppPermissions())) {
                    // This may be called on Android 10, not sure why; just continue the flow
                    Log.i(Const.LOG_TAG, "Called onRequestPermissionsResult: permissions=" + Arrays.toString(permissions) +
                            ", grantResults=" + Arrays.toString(grantResults));
                    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                    return;
                }
            }

            boolean locationDisabled = false;
            for (int n = 0; n < permissions.length; n++) {
                if (permissions[n].equals(Manifest.permission.ACCESS_FINE_LOCATION)) {
                    if (grantResults[n] != PackageManager.PERMISSION_GRANTED) {
                        // The user didn't allow to determine location, this is not critical, just ignore it
                        preferences.edit().putInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_ON).commit();
                        locationDisabled = true;
                    }
                }
            }

            boolean requestPermissions = false;
            for (int n = 0; n < permissions.length; n++) {
                if (grantResults[n] != PackageManager.PERMISSION_GRANTED) {
                    if (permissions[n].equals(Manifest.permission.ACCESS_BACKGROUND_LOCATION) &&
                            (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q || locationDisabled)) {
                        // Background location is not available on Android 9 and below
                        // Also we don't need to grant background location permission if we don't grant location at all
                        continue;
                    }

                    if (permissions[n].equals(Manifest.permission.ACCESS_FINE_LOCATION) &&
                            locationDisabled) {
                        // Skip fine location permission if user intentionally disabled it
                        continue;
                    }

                    // Let user know that he need to grant permissions
                     requestPermissions = true;
                }
            }

            if (requestPermissions) {
                createAndShowPermissionsDialog();
            }
        }
    }

    // AdminReceiver may be called later than onCreate() and onResume()
    // so the launcher setup and other methods requiring device owner permissions may fail
    // Here we wait up to 10 seconds until the app gets the device owner permissions
    private void waitForProvisioning(int attempts) {
        if (Utils.isDeviceOwner(this) || attempts <= 0) {
            setDefaultLauncherEarly();
        } else {
            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    waitForProvisioning(attempts - 1);
                }
            }, 1000);
        }
    }

    private void setDefaultLauncherEarly() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (BuildConfig.SET_DEFAULT_LAUNCHER_EARLY && config == null && Utils.isDeviceOwner(this)) {
            // At first start, temporarily set Headwind MDM as a default launcher
            // to prevent the user from clicking Home to stop running Headwind MDM
            String defaultLauncher = Utils.getDefaultLauncher(this);

            // As per the documentation, setting the default preferred activity should not be done on the main thread
            new AsyncTask<Void, Void, Void>() {
                @Override
                protected Void doInBackground(Void... voids) {
                    if (!getPackageName().equalsIgnoreCase(defaultLauncher)) {
                        Utils.setDefaultLauncher(MainActivity.this);
                    }
                    return null;
                }

                @Override
                protected void onPostExecute(Void v) {
                    checkAndStartLauncher();
                }
            }.execute();
            return;
        }
        checkAndStartLauncher();
    }


    private void checkAndStartLauncher() {

        boolean deviceOwner = Utils.isDeviceOwner(this);
        preferences.edit().putInt(Const.PREFERENCES_DEVICE_OWNER, deviceOwner ?
            Const.PREFERENCES_ON : Const.PREFERENCES_OFF).commit();

        int miuiPermissionMode = preferences.getInt(Const.PREFERENCES_MIUI_PERMISSIONS, -1);
        if (miuiPermissionMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_PERMISSIONS, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_PERMISSIONS)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int miuiDeveloperMode = preferences.getInt(Const.PREFERENCES_MIUI_DEVELOPER, -1);
        if (miuiDeveloperMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_DEVELOPER, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_DEVELOPER)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int miuiOptimizationMode = preferences.getInt(Const.PREFERENCES_MIUI_OPTIMIZATION, -1);
        if (miuiOptimizationMode == -1) {
            preferences.
                    edit().
                    putInt( Const.PREFERENCES_MIUI_OPTIMIZATION, Const.PREFERENCES_ON ).
                    commit();
            if (checkMiuiPermissions(Const.MIUI_OPTIMIZATION)) {
                // Permissions dialog opened, break the flow!
                return;
            }
        }

        int unknownSourceMode = preferences.getInt(Const.PREFERENCES_UNKNOWN_SOURCES, -1);
        if (!deviceOwner && unknownSourceMode == -1) {
            if (checkUnknownSources()) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_UNKNOWN_SOURCES, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int administratorMode = preferences.getInt( Const.PREFERENCES_ADMINISTRATOR, - 1 );
//        RemoteLogger.log(this, Const.LOG_DEBUG, "Saved device admin state: " + administratorMode);
        if ( administratorMode == -1 ) {
            if (checkAdminMode()) {
                RemoteLogger.log(this, Const.LOG_DEBUG, "Saving device admin state as 1 (TRUE)");
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int overlayMode = preferences.getInt( Const.PREFERENCES_OVERLAY, - 1 );
        if (ProUtils.isPro() && overlayMode == -1 && needRequestOverlay()) {
            if ( checkAlarmWindow() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_OVERLAY, Const.PREFERENCES_ON ).
                        commit();
            } else {
                return;
            }
        }

        int usageStatisticsMode = preferences.getInt( Const.PREFERENCES_USAGE_STATISTICS, - 1 );
        if (ProUtils.isPro() && usageStatisticsMode == -1 && needRequestUsageStats()) {
            if ( checkUsageStatistics() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_ON ).
                        commit();

                // If usage statistics is on, there's no need to turn on accessibility services
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF ).
                        commit();
            } else {
                return;
            }
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            int manageStorageMode = preferences.getInt(Const.PREFERENCES_MANAGE_STORAGE, -1);
            if (manageStorageMode == -1) {
                if (checkManageStorage()) {
                    preferences.
                            edit().
                            putInt(Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_ON).
                            commit();
                } else {
                    return;
                }
            }
        }

        int accessibilityService = preferences.getInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, - 1 );
        // Check the same condition as for usage stats here
        // because accessibility is used as a secondary condition when usage stats is not available
        if (ProUtils.isPro() && BuildConfig.USE_ACCESSIBILITY && accessibilityService == -1 && needRequestUsageStats()) {
            if ( checkAccessibilityService() ) {
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_ON ).
                        commit();
            } else {
                createAndShowAccessibilityServiceDialog();
                return;
            }
        }

        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getLockStatusBar() != null && settingsHelper.getConfig().getLockStatusBar()) {
            // If the admin requested status bar lock (may be required for some early Samsung devices), block the status bar and right bar (App list) expansion
            statusBarView = ProUtils.preventStatusBarExpansion(this);
            rightToolbarView = ProUtils.preventApplicationsList(this);
        }

        createApplicationNotAllowedScreen();
        createLockScreen();
        startLauncher();
    }

    private void createAndShowPermissionsDialog() {
        dismissDialog(permissionsDialog);
        permissionsDialog = new Dialog( this );
        dialogPermissionsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_permissions,
                null,
                false );
        permissionsDialog.setCancelable( false );
        permissionsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        permissionsDialog.setContentView( dialogPermissionsBinding.getRoot() );
        permissionsDialog.show();
    }

    public void permissionsRetryClicked(View view) {
        dismissDialog(permissionsDialog);
        startLauncher();
    }

    public void permissionsExitClicked(View view) {
        dismissDialog(permissionsDialog);
        finish();
    }

    private void createAndShowAccessibilityServiceDialog() {
        dismissDialog(accessibilityServiceDialog);
        accessibilityServiceDialog = new Dialog( this );
        dialogAccessibilityServiceBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_accessibility_service,
                null,
                false );
        dialogAccessibilityServiceBinding.hint.setText(
                getString(R.string.dialog_accessibility_service_message, getString(R.string.white_app_name)));
        accessibilityServiceDialog.setCancelable( false );
        accessibilityServiceDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        accessibilityServiceDialog.setContentView( dialogAccessibilityServiceBinding.getRoot() );
        accessibilityServiceDialog.show();
    }

    public void skipAccessibilityService( View view ) {
        try { accessibilityServiceDialog.dismiss(); }
        catch ( Exception e ) { e.printStackTrace(); }
        accessibilityServiceDialog = null;

        preferences.
                edit().
                putInt( Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF ).
                commit();

        checkAndStartLauncher();
    }

    public void setAccessibilityService( View view ) {
        try { accessibilityServiceDialog.dismiss(); }
        catch ( Exception e ) { e.printStackTrace(); }
        accessibilityServiceDialog = null;

        Intent intent = new Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS);
        startActivityForResult(intent, 0);
    }

    // Accessibility services are needed in the Pro-version only
    private boolean checkAccessibilityService() {
        return ProUtils.checkAccessibilityService(this);
    }

    private void createLauncherButtons() {
        createExitButton();
        createInfoButton();
        createUpdateButton();
    }

    private void createButtons() {
        ServerConfig config = settingsHelper.getConfig();
        if (ProUtils.kioskModeRequired(this) && !getPackageName().equals(settingsHelper.getConfig().getMainApp())) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
                    !Settings.canDrawOverlays( this ) &&
                    !BuildConfig.ENABLE_KIOSK_WITHOUT_OVERLAYS) {
                RemoteLogger.log(this, Const.LOG_WARN, "Kiosk mode disabled: no permission to draw over other windows.");
                Toast.makeText(this, getString(R.string.kiosk_mode_requires_overlays,
                        getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
                config.setKioskMode(false);
                settingsHelper.updateConfig(config);
                createLauncherButtons();
                return;
            }
            View kioskUnlockButton = null;
            if (config.isKioskExit()) {     // Should be true by default, but false on older web panel versions
                kioskUnlockButton = ProUtils.createKioskUnlockButton(this);
            }
            if (kioskUnlockButton != null) {
                kioskUnlockButton.setOnClickListener(new View.OnClickListener() {
                    @Override
                    public void onClick(View v) {
                        kioskUnlockCounter++;
                        if (kioskUnlockCounter >= Const.KIOSK_UNLOCK_CLICK_COUNT) {
                            // We are in the main app: let's open launcher activity
                            interruptResumeFlow = true;
                            Intent restoreLauncherIntent = new Intent(MainActivity.this, MainActivity.class);
                            restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
                            startActivity(restoreLauncherIntent);
                            createAndShowEnterPasswordDialog();
                            kioskUnlockCounter = 0;
                        }
                    }
                });
            }
        } else {
            createLauncherButtons();
        }
    }

    private void startLauncher() {
        createButtons();

        if (configUpdater.isPendingAppInstall()) {
            // Here we go after completing the user confirmed app installation
            configUpdater.repeatDownloadApps();
        } else if ( !checkPermissions(true)) {
            // Permissions are requested inside checkPermissions, so do nothing here
            Log.i(Const.LOG_TAG, "startLauncher: requesting permissions");
        } else if (!settingsHelper.isBaseUrlSet() && BuildConfig.REQUEST_SERVER_URL) {
            // For common public version, here's an option to change the server
            createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
        } else if ( settingsHelper.getDeviceId().length() == 0 ) {
            Log.d(Const.LOG_TAG, "Device ID is empty");
            Utils.autoGrantPhonePermission(this);
            if (!SystemUtils.autoSetDeviceId(this)) {
                createAndShowEnterDeviceIdDialog(false, null);
            } else {
                // Retry after automatical setting of device ID
                // We shouldn't get looping here because autoSetDeviceId cannot return true if deviceId.length == 0
                startLauncher();
            }
        } else if (!configInitialized) {
            Log.i(Const.LOG_TAG, "Updating configuration in startLauncher()");
            boolean userInteraction = true;
            boolean integratedProvisioningFlow = settingsHelper.isIntegratedProvisioningFlow();
            if (integratedProvisioningFlow) {
                // InitialSetupActivity just started and this is the first start after
                // the admin integrated provisioning flow, we need to show the process of loading apps
                // Notice the config is not null because it's preloaded in InitialSetupActivity
                settingsHelper.setIntegratedProvisioningFlow(false);
            }
            if (settingsHelper.getConfig() != null && !integratedProvisioningFlow) {
                // If it's not the first start, let's update in the background, show the content first!
                showContent(settingsHelper.getConfig());
                userInteraction = false;
            }
            updateConfig(userInteraction);
        } else {
            showContent(settingsHelper.getConfig());
        }
    }

    private boolean checkAdminMode() {
        if (!Utils.checkAdminMode(this)) {
            createAndShowAdministratorDialog();
            return false;
        }
        return true;
    }

    private boolean needRequestUsageStats() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (config == null) {
            // The app hasn't been properly provisioned because
            // config should be initialized in a setup activity.
            // So we request permissions anyway.
            return true;
        }
        // Usage stats is only required to detect unwanted apps
        // when permissive mode is off and kiosk mode is also off
        return !config.isPermissive() && !config.isKioskMode();
    }

    // Access to usage statistics is required in the Pro-version only
    private boolean checkUsageStatistics() {
        if (!ProUtils.checkUsageStatistics(this)) {
            if (SystemUtils.autoSetUsageStatsPermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (ProUtils.checkUsageStatistics(this)) {
                    return true;
                }
            }
            createAndShowHistorySettingsDialog();
            return false;
        }
        return true;
    }

    @RequiresApi(api = Build.VERSION_CODES.R)
    private boolean checkManageStorage() {
        if (!Environment.isExternalStorageManager()) {
            if (SystemUtils.autoSetStoragePermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (Environment.isExternalStorageManager()) {
                    return true;
                }
            }
            createAndShowManageStorageDialog();
            return false;
        }
        return true;
    }

    private boolean needRequestOverlay() {
        ServerConfig config = SettingsHelper.getInstance(this).getConfig();
        if (config == null) {
            // The app hasn't been properly provisioned because
            // config should be initialized in a setup activity.
            // So we request permissions anyway.
            return true;
        }
        if (config.isKioskMode() && config.isKioskExit()) {
            // We need to draw the kiosk exit button
            return true;
        }
        if (!config.isKioskMode() && !config.isPermissive()) {
            // Overlay window is required to block unwanted apps
            return true;
        }
        return false;
    }

    private boolean checkAlarmWindow() {
        if (ProUtils.isPro() && !Utils.canDrawOverlays(this)) {
            if (SystemUtils.autoSetOverlayPermission(this, getPackageName())) {
                // Permission auto granted, but we double check
                if (Utils.canDrawOverlays(this)) {
                    return true;
                }
            }
            createAndShowOverlaySettingsDialog();
            return false;
        } else {
            return true;
        }
    }

    private boolean checkMiuiPermissions(int screen) {
        // Permissions to open popup from background first appears in MIUI 11 (Android 9)
        // Also a workaround against https://qa.h-mdm.com/3119/
        if (Utils.isMiui(this) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
            LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
            createAndShowMiuiPermissionsDialog(screen);
            // It is not known how to check this setting programmatically, so return true
            return true;
        }
        return false;
    }

    private boolean checkUnknownSources() {
        if ( !Utils.canInstallPackages(this) ) {
            createAndShowUnknownSourcesDialog();
            return false;
        } else {
            return true;
        }
    }

    private WindowManager.LayoutParams overlayLockScreenParams() {
        WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = Utils.OverlayWindowType();
        layoutParams.gravity = Gravity.RIGHT;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL|WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;

        layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.format = PixelFormat.TRANSPARENT;

        return layoutParams;
    }

    private void createApplicationNotAllowedScreen() {
        if ( applicationNotAllowed != null ) {
            return;
        }
        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));

        applicationNotAllowed = LayoutInflater.from( this ).inflate( R.layout.layout_application_not_allowed, null );
        applicationNotAllowed.findViewById( R.id.layout_application_not_allowed_continue ).setOnClickListener( new View.OnClickListener() {
            @Override
            public void onClick( View v ) {
                applicationNotAllowed.setVisibility( View.GONE );
            }
        } );
        applicationNotAllowed.findViewById( R.id.layout_application_not_allowed_admin ).setOnClickListener( new View.OnClickListener() {
            @Override
            public void onClick( View v ) {
                applicationNotAllowed.setVisibility( View.GONE );
                createAndShowEnterPasswordDialog();
            }
        } );
        final TextView tvPackageId = applicationNotAllowed.findViewById(R.id.package_id);
        tvPackageId.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    ClipboardManager clipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
                    ClipData clip = ClipData.newPlainText("Package ID", tvPackageId.getText().toString());
                    clipboard.setPrimaryClip(clip);
                    Toast.makeText(MainActivity.this, R.string.package_id_copied, Toast.LENGTH_LONG).show();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        applicationNotAllowed.setVisibility( View.GONE );

        try {
            manager.addView( applicationNotAllowed, overlayLockScreenParams() );
        } catch ( Exception e ) {
            // No permission to show overlays; let's try to add view to main view
            try {
                RelativeLayout root = findViewById(R.id.activity_main);
                root.addView(applicationNotAllowed);
            } catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }
    }

    private void createLockScreen() {
        if ( lockScreen != null ) {
            return;
        }

        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));

        // Reuse existing "Application not allowed" screen but hide buttons
        lockScreen = LayoutInflater.from( this ).inflate( R.layout.layout_application_not_allowed, null );
        lockScreen.findViewById( R.id.layout_application_not_allowed_continue ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.layout_application_not_allowed_admin ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.package_id ).setVisibility(View.GONE);
        lockScreen.findViewById( R.id.message2 ).setVisibility(View.GONE);
        TextView textView = lockScreen.findViewById( R.id.message );
        textView.setText(getString(R.string.device_locked, SettingsHelper.getInstance(this).getDeviceId()));

        lockScreen.setVisibility( View.GONE );

        try {
            manager.addView( lockScreen, overlayLockScreenParams() );
        } catch ( Exception e ) {
            // No permission to show overlays; let's try to add view to main view
            try {
                RelativeLayout root = findViewById(R.id.activity_main);
                root.addView(lockScreen);
            } catch ( Exception e1 ) {
                e1.printStackTrace();
            }
        }
    }

    private boolean isDarkBackground() {
        try {
            ServerConfig config = settingsHelper.getConfig();
            if (config.getBackgroundColor() != null) {
                int color = Color.parseColor(config.getBackgroundColor());
                return !Utils.isLightColor(color);
            }
        } catch (Exception e) {
        }
        return true;
    }

    private ImageView createManageButton(int imageResource, int imageResourceBlack, int offset) {
        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        layoutParams.addRule(RelativeLayout.CENTER_VERTICAL);
        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_RIGHT);

        int offsetRight = 0;
        if (settingsHelper != null && settingsHelper.getConfig() != null && settingsHelper.getConfig().getLockStatusBar() != null && settingsHelper.getConfig().getLockStatusBar()) {
            // If we lock the right bar, let's shift buttons to avoid overlapping
            offsetRight = getResources().getDimensionPixelOffset(R.dimen.prevent_applications_list_width);
        }

        RelativeLayout view = new RelativeLayout(this);
        // Offset is multiplied by 2 because the view is centered. Yeah I know its an Induism)
        view.setPadding(0, offset * 2, offsetRight, 0);
        view.setLayoutParams(layoutParams);

        ImageView manageButton = new ImageView( this );
        manageButton.setImageResource(isDarkBackground() ? imageResource : imageResourceBlack);
        view.addView(manageButton);

        selectedManageButtonBorder.setColor(0); // transparent background
        selectedManageButtonBorder.setStroke(2, isDarkBackground() ? 0xa0ffffff : 0xa0000000); // white or black border with some transparency
        manageButton.setOnFocusChangeListener((v, hasFocus) -> {
            v.setBackground(hasFocus ? selectedManageButtonBorder : null);
        });

        try {
            RelativeLayout root = findViewById(R.id.activity_main);
            root.addView(view);
        } catch ( Exception e ) { e.printStackTrace(); }
        return manageButton;
    }

    private void createExitButton() {
        if ( exitView != null ) {
            return;
        }
        exitView = createManageButton(R.drawable.ic_vpn_key_opaque_24dp, R.drawable.ic_vpn_key_black_24dp, 0);
        exitView.setOnClickListener(view -> {
            if (view.hasFocus()) {
                // 6 subsequent taps within 3 secs open the hidden password view
                long now = System.currentTimeMillis();
                if (exitFirstTapTime < now - 3000) {
                    exitFirstTapTime = now;
                    exitTapCount = 1;
                } else {
                    exitTapCount++;
                    if (exitTapCount >= 6) {
                        exitFirstTapTime = 0;
                        exitTapCount = 0;
                        createAndShowEnterPasswordDialog();
                    }
                }
            }
        });
        exitView.setOnLongClickListener(this);
    }
    private void createFlutterButton() {
        if ( exitView != null ) {
            return;
        }
        exitView = createManageButton(R.drawable.ic_bg_service_small, R.drawable.ic_bg_service_small, 0);
        exitView.setOnClickListener(view -> {
            if (view.hasFocus()) {
                // 6 subsequent taps within 3 secs open the hidden password view
                long now = System.currentTimeMillis();
                if (exitFirstTapTime < now - 3000) {
                    exitFirstTapTime = now;
                    exitTapCount = 1;
                } else {
                    exitTapCount++;
                    if (exitTapCount >= 6) {
                        exitFirstTapTime = 0;
                        exitTapCount = 0;
                        createAndShowEnterPasswordDialog();
                    }
                }
            }
        });
        exitView.setOnLongClickListener(this);
    }
    private void createInfoButton() {
        if ( infoView != null ) {
            return;
        }
        infoView = createManageButton(R.drawable.ic_info_opaque_24dp, R.drawable.ic_info_black_24dp,
                getResources().getDimensionPixelOffset(R.dimen.info_icon_margin));
        infoView.setOnClickListener(this);
    }

    private void createUpdateButton() {
        if ( updateView != null ) {
            return;
        }
        updateView = createManageButton(R.drawable.ic_system_update_opaque_24dp, R.drawable.ic_system_update_black_24dp,
                (int)(2.05f * getResources().getDimensionPixelOffset(R.dimen.info_icon_margin)));
        updateView.setOnClickListener(this);
    }

    // The userInteraction flag denotes whether the config has been updated from the UI or in the background
    // If this flag is set to true, network error dialog is displayed, and app update schedule is ignored
    private void updateConfig( final boolean userInteraction ) {
        needSendDeviceInfoAfterReconfigure = true;
        needRedrawContentAfterReconfigure = true;
        if (!orientationLocked && !BuildConfig.DISABLE_ORIENTATION_LOCK) {
            lockOrientation();
            orientationLocked = true;
        }
        configUpdater.updateConfig(this, this, userInteraction);
    }

    // Workaround against crash "App is in background" on Android 9: this is an Android OS bug
    // https://stackoverflow.com/questions/52013545/android-9-0-not-allowed-to-start-service-app-is-in-background-after-onresume
    private void startLocationServiceWithRetry() {
        try {
            startLocationService();
        } catch (Exception e) {
            // Android OS bug!!!
            e.printStackTrace();

            // Repeat an attempt to start service after one second
            handler.postDelayed(new Runnable() {
                public void run() {
                    try {
                        startLocationService();
                    } catch (Exception e) {
                        // Still failed, now give up!
                        e.printStackTrace();
                    }
                }
            }, 1000);
        }
    }

    private void startLocationService() {
        ServerConfig config = settingsHelper.getConfig();
        Intent intent = new Intent(this, LocationService.class);
        intent.setAction(config.getRequestUpdates() != null ? config.getRequestUpdates() : LocationService.ACTION_STOP);
        startService(intent);
    }

    @Override
    public void onConfigUpdateStart() {
        binding.setMessage( getString( R.string.main_activity_update_config ) );
    }

    @Override
    public void onConfigUpdateServerError(String errorText) {
        if ( enterDeviceIdDialog != null ) {
            enterDeviceIdDialogBinding.setError( true );
            enterDeviceIdDialog.show();
        } else {
            networkErrorDetails = errorText;
            createAndShowEnterDeviceIdDialog( true, settingsHelper.getDeviceId() );
        }
    }

    @Override
    public void onConfigUpdateNetworkError(String errorText) {
        if (ProUtils.isKioskModeRunning(this) && settingsHelper.getConfig() != null &&
                !getPackageName().equals(settingsHelper.getConfig().getMainApp())) {
            interruptResumeFlow = true;
            Intent restoreLauncherIntent = new Intent(MainActivity.this, MainActivity.class);
            restoreLauncherIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
            startActivity(restoreLauncherIntent);
        }
        // Do not show the reset button if the launcher is installed by scanning a QR code
        // Only show the reset button on manual setup at first start (when config is not yet loaded)
        createAndShowNetworkErrorDialog(settingsHelper.getBaseUrl(), settingsHelper.getServerProject(), errorText,
                settingsHelper.getConfig() == null && !settingsHelper.isQrProvisioning(),
                settingsHelper.getConfig() == null || (settingsHelper.getConfig() != null && settingsHelper.getConfig().isShowWifi()));
    }

    @Override
    public void onConfigLoaded() {
        applyEarlyPolicies(settingsHelper.getConfig());
    }

    @Override
    public void onPoliciesUpdated() {
        startLocationServiceWithRetry();
    }

    @Override
    public void onFileDownloading(RemoteFile remoteFile) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_file_downloading) + " " + remoteFile.getPath());
                binding.setDownloading( true );
            }
        } );
    }

    @Override
    public void onDownloadProgress(final int progress, final long total, final long current) {
        handler.post(new Runnable() {
            @Override
            public void run() {
                binding.progress.setMax(100);
                binding.progress.setProgress(progress);

                binding.setFileLength(total);
                binding.setDownloadedLength(current);
            }
        });
    }

    @Override
    public void onFileDownloadError(RemoteFile remoteFile) {
        if (!ProUtils.kioskModeRequired(this) && !isContentShown()) {
            // Notify the error dialog that we're downloading a file, not an app
            downloadingFile = true;
            createAndShowFileNotDownloadedDialog(remoteFile.getUrl());
            binding.setDownloading( false );
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadFiles();
        }
    }

    @Override
    public void onFileInstallError(RemoteFile remoteFile) {
        if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {
            try {
                new AlertDialog.Builder(MainActivity.this)
                        .setMessage(getString(R.string.file_create_error) + " " + remoteFile.getPath())
                        .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                configUpdater.skipDownloadFiles();
                            }
                        })
                        .create()
                        .show();
            } catch (Exception e) {
                // Activity closed before showing a dialog, just ignore this exception
                e.printStackTrace();
            }
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadFiles();
        }
    }

    @Override
    public void onAppUpdateStart() {
        binding.setMessage( getString( R.string.main_activity_applications_update ) );
        configInitialized = true;
    }

    @Override
    public void onAppInstalling(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_installing) + " " + application.getName());
                binding.setDownloading( false );
            }
        } );
    }

    @Override
    public void onAppDownloadError(Application application) {
        if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {
            // Notify the error dialog that we're downloading an app
            downloadingFile = false;
            createAndShowFileNotDownloadedDialog(application.getName());
            binding.setDownloading( false );
        } else {
            // Avoid user interaction in kiosk mode, just ignore download error and keep the old version
            // Also, avoid unexpected messages when the user is seeing the desktop
            configUpdater.skipDownloadApps();
        }
    }

    @Override
    public void onAppInstallError(String packageName) {
        handler.post(new Runnable() {
            @Override
            public void run() {
                if (!ProUtils.kioskModeRequired(MainActivity.this) && !isContentShown()) {

                    try {
                        new AlertDialog.Builder(MainActivity.this)
                                .setMessage(getString(R.string.install_error) + " " + packageName)
                                .setPositiveButton(R.string.dialog_administrator_mode_continue, new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialog, int which) {
                                        configUpdater.repeatDownloadApps();
                                    }
                                })
                                .create()
                                .show();
                    } catch (Exception e) {
                        // Activity closed before showing a dialog, just ignore this exception
                        e.printStackTrace();
                    }
                } else {
                    // Avoid unexpected messages when the config is updated "silently"
                    // (in kiosk mode or when user is seeing the desktop
                    configUpdater.repeatDownloadApps();
                }
            }
        });
    }

    @Override
    public void onAppInstallComplete(String packageName) {

    }

    @Override
    public void onConfigUpdateComplete() {
        SharedPreferences preferences = getApplicationContext().getSharedPreferences(Const.PREFERENCES, MODE_PRIVATE);
        String deviceAdminLog = PreferenceLogger.getLogString(preferences);
        if (deviceAdminLog != null && !deviceAdminLog.equals("")) {
            RemoteLogger.log(this, Const.LOG_DEBUG, deviceAdminLog);
            PreferenceLogger.clearLogString(preferences);
        }
        Log.i(Const.LOG_TAG, "Showing content from setActions()");
        settingsHelper.refreshConfig(this);         // Avoid NPE in showContent()
        showContent(settingsHelper.getConfig());
    }

    @Override
    public void onAllAppInstallComplete() {
        Log.i(Const.LOG_TAG, "Refreshing content - new apps installed");
        settingsHelper.refreshConfig(this);         // Avoid NPE in showContent()
        handler.post(new Runnable() {
            @Override
            public void run() {
                showContent(settingsHelper.getConfig());
            }
        });
    }

    @Override
    public void onAppDownloading(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_downloading) + " " + application.getName());
                binding.setDownloading(true);
            }
        } );
    }

    @Override
    public void onAppRemoving(final Application application) {
        handler.post( new Runnable() {
            @Override
            public void run() {
                binding.setMessage(getString(R.string.main_app_removing) + " " + application.getName());
                binding.setDownloading(false);
            }
        } );
    }

    private boolean applyEarlyPolicies(ServerConfig config) {
        Initializer.applyEarlyNonInteractivePolicies(this, config);
        return true;
    }

    // Network policies are applied after getting all applications
    // These are interactive policies so can't be used when in background mode
    private boolean applyLatePolicies(ServerConfig config) {
        // To delay opening the settings activity
        boolean dialogWillShow = false;

        if (config.getGps() != null) {
            LocationManager lm = (LocationManager)getSystemService(Context.LOCATION_SERVICE);
            if (lm != null) {
                boolean enabled = lm.isProviderEnabled(LocationManager.GPS_PROVIDER);
                if (config.getGps() && !enabled) {
                    dialogWillShow = true;
                    // System settings dialog should return result so we could re-initialize location service
                    postDelayedSystemSettingDialog(getString(R.string.message_turn_on_gps),
                            new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);

                } else if (!config.getGps() && enabled) {
                    dialogWillShow = true;
                    postDelayedSystemSettingDialog(getString(R.string.message_turn_off_gps),
                            new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                }
            }
        }

        if (config.getMobileData() != null) {
            ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm != null && !dialogWillShow) {
                try {
                    boolean enabled = Utils.isMobileDataEnabled(this);
                    //final Intent mobileDataSettingsIntent = new Intent();
                    // One more hack: open the data transport activity
                    // https://stackoverflow.com/questions/31700842/which-intent-should-open-data-usage-screen-from-settings
                    //mobileDataSettingsIntent.setComponent(new ComponentName("com.android.settings",
                    //        "com.android.settings.Settings$DataUsageSummaryActivity"));
                    //Intent mobileDataSettingsIntent = new Intent(Intent.ACTION_MAIN);
                    //mobileDataSettingsIntent.setClassName("com.android.phone", "com.android.phone.NetworkSetting");
                    Intent mobileDataSettingsIntent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);
                    // Mobile data are turned on/off in the status bar! No settings (as the user can go back in settings and do something nasty)
                    if (config.getMobileData() && !enabled) {
                        postDelayedSystemSettingDialog(getString(R.string.message_turn_on_mobile_data), /*mobileDataSettingsIntent*/null);
                    } else if (!config.getMobileData() && enabled) {
                        postDelayedSystemSettingDialog(getString(R.string.message_turn_off_mobile_data), /*mobileDataSettingsIntent*/null);
                    }
                } catch (Exception e) {
                    // Some problem accessible private API
                }
            }
        }

        if (!Utils.setPasswordMode(config.getPasswordMode(), this)) {
            Intent updatePasswordIntent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);
            // Different Android versions/builds use different activities to setup password
            // So we have to enable temporary access to settings here (and only here!)
            postDelayedSystemSettingDialog(getString(R.string.message_set_password), updatePasswordIntent, null, true);
        }
        return true;
    }

    private boolean isContentShown() {
        if (binding != null) {
            return binding.getShowContent() != null && binding.getShowContent();
        }
        return false;
    }

    private void showContent(ServerConfig config ) {
        if (!applyEarlyPolicies(config)) {
            // Here we go when the settings window is opened;
            // Next time we're here after we returned from the Android settings through onResume()
            return;
        }

        applyLatePolicies(config);

        sendDeviceInfoAfterReconfigure();
        scheduleDeviceInfoSending();
        scheduleInstalledAppsRun();

        if (config.getLock() != null && config.getLock()) {
            showLockScreen();
            return;
        } else {
            hideLockScreen();
        }

        // Run default launcher option
        if (config.getRunDefaultLauncher() != null && config.getRunDefaultLauncher() &&
            !getPackageName().equals(Utils.getDefaultLauncher(this)) && !Utils.isLauncherIntent(getIntent())) {
            openDefaultLauncher();
            return;
        }

        if (orientationLocked && !BuildConfig.DISABLE_ORIENTATION_LOCK) {
            Utils.setOrientation(this, config);
            orientationLocked = false;
        }

        if (ProUtils.kioskModeRequired(this)) {
            String kioskApp = settingsHelper.getConfig().getMainApp();
            if (kioskApp != null && kioskApp.trim().length() > 0 &&
                    // If Headwind MDM itself is set as kiosk app, the kiosk mode is already turned on;
                    // So here we just proceed to drawing the content
                    (!kioskApp.equals(getPackageName()) || !ProUtils.isKioskModeRunning(this))) {
                if (ProUtils.getKioskAppIntent(kioskApp, this) != null && startKiosk(kioskApp)) {
                    getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                    return;
                } else {
                    Log.e(Const.LOG_TAG, "Kiosk mode failed, proceed with the default flow");
                }
            } else {
                if (kioskApp != null && kioskApp.equals(getPackageName()) && ProUtils.isKioskModeRunning(this)) {
                    // Here we go if the configuration is changed when launcher is in the kiosk mode
                    ProUtils.updateKioskAllowedApps(kioskApp, this, false);
                    ProUtils.updateKioskOptions(this);
                } else {
                    Log.e(Const.LOG_TAG, "Kiosk mode disabled: please setup the main app!");
                }
            }
        } else {
            if (ProUtils.isKioskModeRunning(this)) {
                // Turn off kiosk and show desktop if it is turned off in the configuration
                ProUtils.unlockKiosk(this);
                openDefaultLauncher();
            }
        }

        // TODO: Somehow binding is null here which causes a crash. Not sure why this could happen.
        if ( config.getBackgroundColor() != null ) {
            try {
                binding.activityMainContentWrapper.setBackgroundColor(Color.parseColor(config.getBackgroundColor()));
            } catch (Exception e) {
                // Invalid color
                e.printStackTrace();
                binding.activityMainContentWrapper.setBackgroundColor( getResources().getColor(R.color.defaultBackground));
            }
        } else {
            binding.activityMainContentWrapper.setBackgroundColor( getResources().getColor(R.color.defaultBackground));
        }
        updateTitle(config);

        statusBarUpdater.updateControlsState(config.isDisplayStatus(), isDarkBackground());

        if (mainAppListAdapter == null || needRedrawContentAfterReconfigure) {
            needRedrawContentAfterReconfigure = false;

            if ( config.getBackgroundImageUrl() != null && config.getBackgroundImageUrl().length() > 0 ) {
                if (picasso == null) {
                    // Initialize it once because otherwise it doesn't work offline
                    Picasso.Builder builder = new Picasso.Builder(this);
                    if (BuildConfig.TRUST_ANY_CERTIFICATE) {
                        builder.downloader(new OkHttp3Downloader(UnsafeOkHttpClient.getUnsafeOkHttpClient()));
                    } else {
                        // Add signature to all requests to protect against unauthorized API calls
                        // For TRUST_ANY_CERTIFICATE, we won't add signatures because it's unsafe anyway
                        // and is just a workaround to use Headwind MDM on the LAN
                        OkHttpClient clientWithSignature = new OkHttpClient.Builder()
                                .cache(new Cache(new File(getApplication().getCacheDir(), "image_cache"), 1000000L))
                                .addInterceptor(chain -> {
                                    okhttp3.Request.Builder requestBuilder = chain.request().newBuilder();
                                    String signature = InstallUtils.getRequestSignature(chain.request().url().toString());
                                    if (signature != null) {
                                        requestBuilder.addHeader("X-Request-Signature", signature);
                                    }
                                    return chain.proceed(requestBuilder.build());

                                })
                                .build();
                        builder.downloader(new OkHttp3Downloader(clientWithSignature));
                    }
                    builder.listener(new Picasso.Listener()
                    {
                        @Override
                        public void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception)
                        {
                            // On fault, get the background image from the cache
                            // This is a workaround against a bug in Picasso: it doesn't display cached images by default!
                            picasso.load(config.getBackgroundImageUrl())
                                    .networkPolicy(NetworkPolicy.OFFLINE)
                                    .fit()
                                    .centerCrop()
                                    .into(binding.activityMainBackground);
                        }
                    });
                    picasso = builder.build();
                }

                picasso.load(config.getBackgroundImageUrl())
                    // fit and centerCrop is a workaround against a crash on too large images on some devices
                    .fit()
                    .centerCrop()
                    .into(binding.activityMainBackground);

            } else {
                binding.activityMainBackground.setImageDrawable(null);
            }

            Display display = getWindowManager().getDefaultDisplay();
            Point size = new Point();
            display.getSize(size);

            int width = size.x;
            int itemWidth = getResources().getDimensionPixelSize(R.dimen.app_list_item_size);

            spanCount = (int) (width * 1.0f / itemWidth);
            mainAppListAdapter = new MainAppListAdapter(this, this, this);
            mainAppListAdapter.setSpanCount(spanCount);

            binding.activityMainContent.setLayoutManager(new GridLayoutManager(this, spanCount));
            binding.activityMainContent.setAdapter(mainAppListAdapter);
            mainAppListAdapter.notifyDataSetChanged();

            int bottomAppCount = AppShortcutManager.getInstance().getInstalledAppCount(this, true);
            if (bottomAppCount > 0) {
                bottomAppListAdapter = new BottomAppListAdapter(this, this, this);
                bottomAppListAdapter.setSpanCount(spanCount);

                binding.activityBottomLayout.setVisibility(View.VISIBLE);
                binding.activityBottomLine.setLayoutManager(new GridLayoutManager(this, bottomAppCount < spanCount ? bottomAppCount : spanCount));
                binding.activityBottomLine.setAdapter(bottomAppListAdapter);
                bottomAppListAdapter.notifyDataSetChanged();
            } else {
                bottomAppListAdapter = null;
                binding.activityBottomLayout.setVisibility(View.GONE);
            }
        }
        binding.loading.setVisibility(View.GONE);
        binding.setShowContent(true);
        // We can now sleep, uh
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        Log.d("FLUTTER_LAUNCHER", "showContent() is complete. Finding the Flutter button.");
        Button flutterButton = findViewById(R.id.openFlutterButton);

        if (flutterButton == null) {
            Log.e("FLUTTER_LAUNCHER", "ERROR: The Flutter button is NULL even in showContent(). Check the XML file and ID.");
        } else {
            Log.d("FLUTTER_LAUNCHER", "Flutter button found successfully! Setting the listener.");
            flutterButton.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    Log.d("FLUTTER_LAUNCHER", "Button clicked! Launching FlutterActivity.");
                    startActivity(
                            FlutterActivity.createDefaultIntent(MainActivity.this)
                    );
                }
            });
        }
    }

    // Added an option to delay restarting the kiosk app
    // Because some apps need time to finish their work
    private boolean startKiosk(String kioskApp) {
        String kioskDelayStr = settingsHelper.getAppPreference(getPackageName(), "kiosk_restart_delay_ms");
        int kioskDelay = 0;
        try {
            if (kioskDelayStr != null) {
                kioskDelay = Integer.parseInt(kioskDelayStr);
            }
        } catch (/*NumberFormat*/Exception e) {
        }
        if (kioskDelay == 0) {
            // Standard flow: no delay as earlier
            return ProUtils.startCosuKioskMode(kioskApp, MainActivity.this, false);
        } else {
            // Delayed kiosk start
            handler.postDelayed(() -> ProUtils.startCosuKioskMode(kioskApp, MainActivity.this, false), kioskDelay);
            return true;
        }
    }

    private void showLockScreen() {
        if (lockScreen == null) {
            createLockScreen();
            if (lockScreen == null) {
                // Why cannot we create the lock screen? Give up and return
                // The locked device will show the launcher, but still cannot run any application
                return;
            }
        }
        String lockAdminMessage = settingsHelper.getConfig().getLockMessage();
        String lockMessage = getString(R.string.device_locked, SettingsHelper.getInstance(this).getDeviceId());
        if (lockAdminMessage != null) {
            lockMessage += " " + lockAdminMessage;
        }
        TextView textView = lockScreen.findViewById( R.id.message );
        textView.setText(lockMessage);
        lockScreen.setVisibility(View.VISIBLE);
    }

    private void hideLockScreen() {
        if (lockScreen != null && lockScreen.getVisibility() == View.VISIBLE) {
            lockScreen.setVisibility(View.GONE);
        }
    }

    private void notifyPolicyViolation(int cause) {
        switch (cause) {
            case Const.GPS_ON_REQUIRED:
                postDelayedSystemSettingDialog(getString(R.string.message_turn_on_gps),
                        new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                break;
            case Const.GPS_OFF_REQUIRED:
                postDelayedSystemSettingDialog(getString(R.string.message_turn_off_gps),
                        new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS), REQUEST_CODE_GPS_STATE_CHANGE);
                break;
            case Const.MOBILE_DATA_ON_REQUIRED:
                createAndShowSystemSettingDialog(getString(R.string.message_turn_on_mobile_data), null, 0);
                break;
            case Const.MOBILE_DATA_OFF_REQUIRED:
                createAndShowSystemSettingDialog(getString(R.string.message_turn_off_mobile_data), null, 0);
                break;
        }
    }

    // Run default launcher (Headwind MDM) as if the user clicked Home button
    private void openDefaultLauncher() {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(intent);
    }

    // If we updated the configuration, let's send the final state to the server
    private void sendDeviceInfoAfterReconfigure() {
        if (needSendDeviceInfoAfterReconfigure) {
            needSendDeviceInfoAfterReconfigure = false;
            SendDeviceInfoTask sendDeviceInfoTask = new SendDeviceInfoTask(this);
            DeviceInfo deviceInfo = DeviceInfoProvider.getDeviceInfo(this, true, true);
            sendDeviceInfoTask.execute(deviceInfo);
        }
    }

    private void scheduleDeviceInfoSending() {
        if (sendDeviceInfoScheduled) {
            return;
        }
        sendDeviceInfoScheduled = true;
        SendDeviceInfoWorker.scheduleDeviceInfoSending(this);
    }

    private void scheduleInstalledAppsRun() {
        List<Application> applicationsForRun = configUpdater.getApplicationsForRun();

        if (applicationsForRun.size() == 0) {
            return;
        }
        int pause = PAUSE_BETWEEN_AUTORUNS_SEC;
        while (applicationsForRun.size() > 0) {
            final Application application = applicationsForRun.get(0);
            applicationsForRun.remove(0);
            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    Intent launchIntent = getPackageManager().getLaunchIntentForPackage(application.getPkg());
                    if (launchIntent != null) {
                        startActivity(launchIntent);
                    }
                }
            }, pause * 1000);
            pause += PAUSE_BETWEEN_AUTORUNS_SEC;
        }
    }

    private void updateTitle(ServerConfig config) {
        String titleType = config.getTitle();
        if (titleType != null) {
            if (titleType.equals(ServerConfig.TITLE_NONE)) {
                binding.activityMainTitle.setVisibility(View.GONE);
                return;
            }
            if (config.getTextColor() != null) {
                try {
                    binding.activityMainTitle.setTextColor(Color.parseColor(settingsHelper.getConfig().getTextColor()));
                } catch (Exception e) {
                    // Invalid color
                    e.printStackTrace();
                }
            }
            binding.activityMainTitle.setVisibility(View.VISIBLE);
            String imei = DeviceInfoProvider.getImei(this);
            if (imei == null) {
                imei = "";
            }
            String serial = DeviceInfoProvider.getSerialNumber();
            if (serial == null) {
                serial = "";
            }
            String ip = SettingsHelper.getInstance(this).getExternalIp();
            if (ip == null) {
                ip = "";
            }
            String titleText = titleType
                    .replace(ServerConfig.TITLE_DEVICE_ID, SettingsHelper.getInstance(this).getDeviceId())
                    .replace(ServerConfig.TITLE_DESCRIPTION, config.getDescription() != null ? config.getDescription() : "")
                    .replace(ServerConfig.TITLE_CUSTOM1, config.getCustom1() != null ? config.getCustom1() : "")
                    .replace(ServerConfig.TITLE_CUSTOM2, config.getCustom2() != null ? config.getCustom2() : "")
                    .replace(ServerConfig.TITLE_CUSTOM3, config.getCustom3() != null ? config.getCustom3() : "")
                    .replace(ServerConfig.TITLE_IMEI, imei)
                    .replace(ServerConfig.TITLE_SERIAL, serial)
                    .replace(ServerConfig.TITLE_EXTERNAL_IP, ip)
                    .replace("\\n", "\n");
            binding.activityMainTitle.setText(titleText);
        } else {
            binding.activityMainTitle.setVisibility(View.GONE);
        }

    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        settingsHelper.setMainActivityRunning(false);

        WindowManager manager = ((WindowManager)getApplicationContext().getSystemService(Context.WINDOW_SERVICE));
        if ( applicationNotAllowed != null ) {
            try { manager.removeView( applicationNotAllowed ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( statusBarView != null ) {
            try { manager.removeView( statusBarView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( rightToolbarView != null ) {
            try { manager.removeView( rightToolbarView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( exitView != null ) {
            try { manager.removeView( exitView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( infoView != null ) {
            try { manager.removeView( infoView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        if ( updateView != null ) {
            try { manager.removeView( updateView ); }
            catch ( Exception e ) { e.printStackTrace(); }
        }

        try {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);
            unregisterReceiver(stateChangeReceiver);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void onPause() {
        super.onPause();

        isBackground = true;

        statusBarUpdater.stopUpdating();

        dismissDialog(fileNotDownloadedDialog);
        dismissDialog(enterServerDialog);
        dismissDialog(enterDeviceIdDialog);
        dismissDialog(networkErrorDialog);
        dismissDialog(enterPasswordDialog);
        dismissDialog(historySettingsDialog);
        dismissDialog(unknownSourcesDialog);
        dismissDialog(overlaySettingsDialog);
        dismissDialog(administratorModeDialog);
        dismissDialog(deviceInfoDialog);
        dismissDialog(accessibilityServiceDialog);
        dismissDialog(systemSettingsDialog);
        dismissDialog(permissionsDialog);

        LocalBroadcastManager.getInstance( this ).sendBroadcast( new Intent( Const.ACTION_SHOW_LAUNCHER ) );
    }

    private void createAndShowAdministratorDialog() {
        dismissDialog(administratorModeDialog);
        administratorModeDialog = new Dialog( this );
        dialogAdministratorModeBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_administrator_mode,
                null,
                false );
        dialogAdministratorModeBinding.hint.setText(
                getString(R.string.dialog_administrator_mode_message, getString(R.string.white_app_name)));
        administratorModeDialog.setCancelable( false );
        administratorModeDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        administratorModeDialog.setContentView( dialogAdministratorModeBinding.getRoot() );
        administratorModeDialog.show();
    }

    public void skipAdminMode( View view ) {
        dismissDialog(administratorModeDialog);

        RemoteLogger.log(this, Const.LOG_INFO, "Manually skipped the device admin permissions setup");
        preferences.
                edit().
                putInt( Const.PREFERENCES_ADMINISTRATOR, Const.PREFERENCES_OFF ).
                commit();

        checkAndStartLauncher();
    }

    public void setAdminMode( View view ) {
        dismissDialog(administratorModeDialog);
        // Use a proxy activity because of an Android bug (see comment to AdminModeRequestActivity!)
        startActivity( new Intent( MainActivity.this, AdminModeRequestActivity.class ) );
    }

    private void createAndShowFileNotDownloadedDialog(String fileName) {
        dismissDialog(fileNotDownloadedDialog);
        fileNotDownloadedDialog = new Dialog( this );
        dialogFileDownloadingFailedBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_file_downloading_failed,
                null,
                false );
        int errorTextResource = this.downloadingFile ? R.string.main_file_downloading_error : R.string.main_app_downloading_error;
        dialogFileDownloadingFailedBinding.title.setText( getString(errorTextResource) + " " + fileName );
        fileNotDownloadedDialog.setCancelable( false );
        fileNotDownloadedDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        fileNotDownloadedDialog.setContentView( dialogFileDownloadingFailedBinding.getRoot() );
        try {
            fileNotDownloadedDialog.show();
        } catch (Exception e) {
            // BadTokenException ignored
        }
    }

    public void repeatDownloadClicked( View view ) {
        dismissDialog(fileNotDownloadedDialog);
        if (downloadingFile) {
            configUpdater.repeatDownloadFiles();
        } else {
            configUpdater.repeatDownloadApps();
        }
    }

    public void confirmDownloadFailureClicked( View view ) {
        dismissDialog(fileNotDownloadedDialog);

        if (downloadingFile) {
            configUpdater.skipDownloadFiles();
        } else {
            configUpdater.skipDownloadApps();
        }
    }

    private void createAndShowHistorySettingsDialog() {
        dismissDialog(historySettingsDialog);
        historySettingsDialog = new Dialog( this );
        dialogHistorySettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_history_settings,
                null,
                false );
        dialogHistorySettingsBinding.hint.setText(
                getString(R.string.dialog_history_settings_title, getString(R.string.white_app_name)));
        historySettingsDialog.setCancelable( false );
        historySettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        historySettingsDialog.setContentView( dialogHistorySettingsBinding.getRoot() );
        historySettingsDialog.show();
    }

    public void historyWithoutPermission( View view ) {
        dismissDialog(historySettingsDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_USAGE_STATISTICS, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueHistory( View view ) {
        dismissDialog(historySettingsDialog);

        startActivity( new Intent( Settings.ACTION_USAGE_ACCESS_SETTINGS ) );
    }

    private void createAndShowManageStorageDialog() {
        dismissDialog(manageStorageDialog);
        manageStorageDialog = new Dialog( this );
        dialogManageStorageBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_manage_storage,
                null,
                false );
        manageStorageDialog.setCancelable( false );
        manageStorageDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        manageStorageDialog.setContentView( dialogManageStorageBinding.getRoot() );
        manageStorageDialog.show();
    }

    public void storageWithoutPermission(View view) {
        dismissDialog(manageStorageDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueStorage(View view) {
        dismissDialog(manageStorageDialog);
        try {
            Intent intent = new Intent();
            intent.setAction(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
            Uri uri = Uri.fromParts("package", this.getPackageName(), null);
            intent.setData(uri);
            startActivity(intent);
        } catch (Exception e) {
            try {
                Intent intent = new Intent();
                intent.setAction(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION);
                startActivity(intent);
            } catch (Exception e1) {
                Toast.makeText(this, R.string.manage_storage_not_supported, Toast.LENGTH_LONG).show();
                preferences.
                        edit().
                        putInt( Const.PREFERENCES_MANAGE_STORAGE, Const.PREFERENCES_OFF ).
                        commit();
                checkAndStartLauncher();
            }
        }
    }

    private void createAndShowOverlaySettingsDialog() {
        dismissDialog(overlaySettingsDialog);
        overlaySettingsDialog = new Dialog( this );
        dialogOverlaySettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_overlay_settings,
                null,
                false );
        dialogOverlaySettingsBinding.hint.setText(
                getString(R.string.dialog_overlay_settings_title, getString(R.string.white_app_name)));
        overlaySettingsDialog.setCancelable( false );
        overlaySettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        overlaySettingsDialog.setContentView( dialogOverlaySettingsBinding.getRoot() );
        overlaySettingsDialog.show();
    }

    public void overlayWithoutPermission( View view ) {
        dismissDialog(overlaySettingsDialog);

        preferences.
                edit().
                putInt( Const.PREFERENCES_OVERLAY, Const.PREFERENCES_OFF ).
                commit();
        checkAndStartLauncher();
    }

    public void continueOverlay( View view ) {
        dismissDialog(overlaySettingsDialog);

        Intent intent = new Intent( Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                Uri.parse( "package:" + getPackageName() ) );
        try {
            startActivityForResult(intent, 1001);
        } catch (/* ActivityNotFound*/Exception e) {
            Toast.makeText(this, R.string.overlays_not_supported, Toast.LENGTH_LONG).show();
            overlayWithoutPermission(view);
        }
    }


    public void saveDeviceId( View view ) {
        String deviceId = enterDeviceIdDialogBinding.deviceId.getText().toString();
        if ( "".equals( deviceId ) ) {
            return;
        } else {
            settingsHelper.setDeviceId( deviceId );
            enterDeviceIdDialogBinding.setError( false );

            dismissDialog(enterDeviceIdDialog);

            if ( checkPermissions( true ) ) {
                Log.i(Const.LOG_TAG, "saveDeviceId(): calling updateConfig()");
                updateConfig( true );
            }
        }
    }


    public void saveServerUrl( View view ) {
        if (saveServerUrlBase()) {
            ServerServiceKeeper.resetServices();
            checkAndStartLauncher();
        }
    }


    public void networkErrorRepeatClicked( View view ) {
        dismissDialog(networkErrorDialog);

        Log.i(Const.LOG_TAG, "networkErrorRepeatClicked(): calling updateConfig()");
        updateConfig( true );
    }

    public void networkErrorResetClicked( View view ) {
        dismissDialog(networkErrorDialog);

        Log.i(Const.LOG_TAG, "networkErrorResetClicked(): calling updateConfig()");
        settingsHelper.setDeviceId("");
        settingsHelper.setBaseUrl("");
        settingsHelper.setSecondaryBaseUrl("");
        settingsHelper.setServerProject("");
        createAndShowServerDialog(false, settingsHelper.getBaseUrl(), settingsHelper.getServerProject());
    }

    public void networkErrorWifiClicked( View view ) {
        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        if (ProUtils.kioskModeRequired(this) && ProUtils.isKioskModeRunning(this)) {
            String kioskApp = settingsHelper.getConfig().getMainApp();
            ProUtils.startCosuKioskMode(kioskApp, this, true);
        }
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));
            }
        }, 500);
    }

    public void networkErrorCancelClicked(View view) {
        dismissDialog(networkErrorDialog);

        if (configFault) {
            Log.i(Const.LOG_TAG, "networkErrorCancelClicked(): no configuration available, quit");
            Toast.makeText(this, getString(R.string.critical_server_failure,
                    getString(R.string.white_app_name)), Toast.LENGTH_LONG).show();
            finish();
            return;
        }

        Log.i(Const.LOG_TAG, "networkErrorCancelClicked()");
        if ( settingsHelper.getConfig() != null ) {
            showContent( settingsHelper.getConfig() );
            configUpdater.skipConfigLoad();
        } else {
            Log.i(Const.LOG_TAG, "networkErrorCancelClicked(): no configuration available, retrying");
            Toast.makeText(this, R.string.empty_configuration, Toast.LENGTH_LONG).show();
            configFault = true;
            updateConfig( false );
        }
    }

    public void networkErrorDetailsClicked(View view) {
        ErrorDetailsActivity.display(this, networkErrorDetails, false);
    }

    private boolean checkPermissions( boolean startSettings ) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
            return true;
        }

        // If the user didn't grant permissions, let him know and do not request until he confirms he want to retry
        if (permissionsDialog != null && permissionsDialog.isShowing()) {
            return false;
        }

        if (Utils.isDeviceOwner(this)) {
            if (settingsHelper.getConfig() != null && (ServerConfig.APP_PERMISSIONS_ASK_ALL.equals(settingsHelper.getConfig().getAppPermissions()) ||
                    ServerConfig.APP_PERMISSIONS_ASK_LOCATION.equals(settingsHelper.getConfig().getAppPermissions()))) {
                // Even in device owner mode, if "Ask for location" is requested by the admin,
                // let's ask permissions (so do nothing here, fall through)
            } else {
                // Do not request permissions if we're the device owner
                // They are added automatically
                return true;
            }
        }

        if (preferences.getInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON) {
            if ((Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                (Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                    checkSelfPermission(Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {

                if (startSettings) {
                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_EXTERNAL_STORAGE,
                                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    } else {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    }
                }
                return false;
            } else {
                return true;
            }
        } else {
            return checkLocationPermissions(startSettings);
        }
    }

    // Location permissions request on Android 10 and above is rather tricky (shame on Google for their stupid logic!!!)
    // So it's implemented in a separate method
    @RequiresApi(api = Build.VERSION_CODES.M)
    private boolean checkLocationPermissions(boolean startSettings) {
        if ((Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                (Build.VERSION.SDK_INT < Build.VERSION_CODES.R && checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) ||
                checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED ||
                (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED) ||
                checkSelfPermission(Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) {

            if (startSettings) {
                boolean activeModeLocation = false;
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    try {
                        activeModeLocation = checkSelfPermission(Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED &&
                                checkSelfPermission(Manifest.permission.ACCESS_BACKGROUND_LOCATION) != PackageManager.PERMISSION_GRANTED /* &&
                                !ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.ACCESS_BACKGROUND_LOCATION)*/;
                    } catch (Exception e) {
                        // On some older models:
                        // java.lang.IllegalArgumentException
                        // Unknown permission: android.permission.ACCESS_BACKGROUND_LOCATION
                        // Update: since there's the Android version check, we should never be here!
                        e.printStackTrace();
                    }
                }

                if (activeModeLocation) {
                    // The following flow happened
                    // The user has enabled locations, but when the app prompted for the background location,
                    // the user clicked "Locations only in active mode".
                    // In this case, requestPermissions won't show dialog any more!
                    // So we need to open the general permissions dialog
                    // Let's confirm with the user once again, then display the settings sheet
                    try {
                        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
                        new AlertDialog.Builder(MainActivity.this)
                                .setMessage(getString(R.string.background_location, getString(R.string.white_app_name)))
                                .setPositiveButton(R.string.background_location_continue, (dialog, which) -> {
                                    startActivity(new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS,
                                            Uri.fromParts("package", getPackageName(), null)));
                                })
                                .setNegativeButton(R.string.location_disable, (dialog, which) -> {
                                    preferences.edit().putInt(Const.PREFERENCES_DISABLE_LOCATION, Const.PREFERENCES_ON).commit();
                                    // Continue the main flow!
                                    startLauncher();
                                })
                                .create()
                                .show();
                    } catch (Exception e) {
                        // Activity closed before showing a dialog, just ignore this exception
                        e.printStackTrace();
                    }
                } else {
                    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.R) {
                        requestPermissions(new String[]{
                                Manifest.permission.READ_EXTERNAL_STORAGE,
                                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                                Manifest.permission.ACCESS_FINE_LOCATION,
                                Manifest.permission.ACCESS_BACKGROUND_LOCATION,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    } else {
                        requestPermissions(new String[]{
                                Manifest.permission.ACCESS_FINE_LOCATION,
// This location can't be requested here: the dialog fails to show when we use SDK 30+
// https://developer.android.com/develop/sensors-and-location/location/permissions#request-location-access-runtime
//                                Manifest.permission.ACCESS_BACKGROUND_LOCATION,
                                Manifest.permission.READ_PHONE_STATE
                        }, PERMISSIONS_REQUEST);
                    }
                }
            }
            return false;
        } else {
            return true;
        }

    }

    private void createAndShowEnterPasswordDialog() {
        dismissDialog(enterPasswordDialog);
        enterPasswordDialog = new Dialog( this );
        dialogEnterPasswordBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_enter_password,
                null,
                false );
        enterPasswordDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        enterPasswordDialog.setCancelable( false );

        enterPasswordDialog.setContentView( dialogEnterPasswordBinding.getRoot() );
        dialogEnterPasswordBinding.setLoading( false );
        try {
            enterPasswordDialog.show();
        } catch (Exception e) {
            // Sometimes here we get a Fatal Exception: android.view.WindowManager$BadTokenException
            // Unable to add window -- token android.os.BinderProxy@f307de for displayid = 0 is not valid; is your activity running?
            Toast.makeText(getApplicationContext(), R.string.internal_error, Toast.LENGTH_LONG).show();
        }
    }

    public void closeEnterPasswordDialog( View view ) {
        dismissDialog(enterPasswordDialog);
        if (ProUtils.kioskModeRequired(this)) {
            checkAndStartLauncher();
            updateConfig(false);
        }
    }

    public void checkAdministratorPassword( View view ) {
        dialogEnterPasswordBinding.setLoading( true );
        GetServerConfigTask task = new GetServerConfigTask( this ) {
            @Override
            protected void onPostExecute( Integer result ) {
                dialogEnterPasswordBinding.setLoading( false );

                String masterPassword = CryptoHelper.getMD5String( "12345678" );
                if ( settingsHelper.getConfig() != null && settingsHelper.getConfig().getPassword() != null ) {
                    masterPassword = settingsHelper.getConfig().getPassword();
                }

                if ( CryptoHelper.getMD5String( dialogEnterPasswordBinding.password.getText().toString() ).
                        equals( masterPassword ) ) {
                    dismissDialog(enterPasswordDialog);
                    dialogEnterPasswordBinding.setError( false );
                    openAdminPanel();
                } else {
                    dialogEnterPasswordBinding.setError( true );
                }
            }
        };
        task.execute();
    }

    private void openAdminPanel() {
        if (ProUtils.kioskModeRequired(MainActivity.this)) {
            ProUtils.unlockKiosk(MainActivity.this);
        }
        RemoteLogger.log(MainActivity.this, Const.LOG_INFO, "Administrator panel opened");
        startActivity( new Intent( MainActivity.this, AdminActivity.class ) );
    }

    private void createAndShowUnknownSourcesDialog() {
        dismissDialog(unknownSourcesDialog);
        unknownSourcesDialog = new Dialog( this );
        dialogUnknownSourcesBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_unknown_sources,
                null,
                false );
        unknownSourcesDialog.setCancelable( false );
        unknownSourcesDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        unknownSourcesDialog.setContentView( dialogUnknownSourcesBinding.getRoot() );
        unknownSourcesDialog.show();
    }

    public void continueUnknownSources( View view ) {
        dismissDialog(unknownSourcesDialog);
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
            startActivity(new Intent(android.provider.Settings.ACTION_SECURITY_SETTINGS));
        } else {
            // In Android Oreo and above, permission to install packages are set per each app
            startActivity(new Intent(android.provider.Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, Uri.parse("package:" + getPackageName())));
        }
    }

    private void createAndShowMiuiPermissionsDialog(int screen) {
        dismissDialog(miuiPermissionsDialog);
        miuiPermissionsDialog = new Dialog( this );
        dialogMiuiPermissionsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_miui_permissions,
                null,
                false );
        miuiPermissionsDialog.setCancelable( false );
        miuiPermissionsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );

        switch (screen) {
            case Const.MIUI_PERMISSIONS:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_permissions_title);
                break;
            case Const.MIUI_DEVELOPER:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_developer_title);
                break;
            case Const.MIUI_OPTIMIZATION:
                dialogMiuiPermissionsBinding.title.setText(R.string.dialog_miui_optimization_title);
                break;
        }

        miuiPermissionsDialog.setContentView( dialogMiuiPermissionsBinding.getRoot() );
        miuiPermissionsDialog.show();
    }

    public void continueMiuiPermissions( View view ) {
        String titleText = dialogMiuiPermissionsBinding.title.getText().toString();
        dismissDialog(miuiPermissionsDialog);

        LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
        Intent intent;
        if (titleText.equals(getString(R.string.dialog_miui_permissions_title))) {
            intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
            Uri uri = Uri.fromParts("package", getPackageName(), null);
            intent.setData(uri);
        } else if (titleText.equals(getString(R.string.dialog_miui_developer_title))) {
            intent = new Intent(Settings.ACTION_DEVICE_INFO_SETTINGS);
        } else {
            // if (titleText.equals(getString(R.string.dialog_miui_optimization_title))
            intent = new Intent(Settings.ACTION_APPLICATION_DEVELOPMENT_SETTINGS);
        }
        try {
            startActivity(intent);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onBackPressed() {}

    @Override
    public void onAppChoose( @NonNull AppInfo resolveInfo ) {

    }

    @Override
    public boolean switchAppListAdapter(BaseAppListAdapter adapter, int direction) {
        if (adapter == mainAppListAdapter && bottomAppListAdapter != null &&
                (direction == Const.DIRECTION_RIGHT || direction == Const.DIRECTION_DOWN)) {
            bottomAppListAdapter.setFocused(true);
            return true;
        } else if (adapter == bottomAppListAdapter &&
                (direction == Const.DIRECTION_LEFT || direction == Const.DIRECTION_UP)) {
            mainAppListAdapter.setFocused(true);
            return true;
        }
        return false;
    }

    @Override
    public boolean onLongClick( View v ) {
        createAndShowEnterPasswordDialog();
        return true;
    }

    @Override
    public void onClick( View v ) {
        if (v.equals(infoView)) {
            createAndShowInfoDialog();
        } else if (v.equals(updateView)) {
            if (enterDeviceIdDialog != null && enterDeviceIdDialog.isShowing()) {
                Log.i(Const.LOG_TAG, "Occasional update request when device info is entered, ignoring!");
                return;
            }
            Log.i(Const.LOG_TAG, "updating config on request");
            binding.loading.setVisibility(View.VISIBLE);
            binding.setShowContent(false);
            getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
            updateConfig(true);
        }
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent) {
        postDelayedSystemSettingDialog(message, settingsIntent, null);
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode) {
        postDelayedSystemSettingDialog(message, settingsIntent, requestCode, false);
    }

    private void postDelayedSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode, final boolean forceEnableSettings) {
        if (settingsIntent != null) {
            // If settings are controlled by usage stats, safe settings are allowed, so we need to enable settings in accessibility mode only
            // Accessibility mode is only enabled when usage stats is off
            if (preferences.getInt(Const.PREFERENCES_ACCESSIBILITY_SERVICE, Const.PREFERENCES_OFF) == Const.PREFERENCES_ON || forceEnableSettings) {
                LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_ENABLE_SETTINGS));
            }
            LocalBroadcastManager.getInstance(this).sendBroadcast(new Intent(Const.ACTION_STOP_CONTROL));
        }
        // Delayed start prevents the race of ENABLE_SETTINGS handle and tapping "Next" button
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                createAndShowSystemSettingDialog(message, settingsIntent, requestCode);
            }
        }, 5000);
    }

    private void createAndShowSystemSettingDialog(final String message, final Intent settingsIntent, final Integer requestCode) {
        dismissDialog(systemSettingsDialog);
        systemSettingsDialog = new Dialog( this );
        dialogSystemSettingsBinding = DataBindingUtil.inflate(
                LayoutInflater.from( this ),
                R.layout.dialog_system_settings,
                null,
                false );
        systemSettingsDialog.requestWindowFeature( Window.FEATURE_NO_TITLE );
        systemSettingsDialog.setCancelable( false );

        systemSettingsDialog.setContentView( dialogSystemSettingsBinding.getRoot() );

        dialogSystemSettingsBinding.setMessage(message);

        // Since we need to send Intent to the listener, here we don't use "event" attribute in XML resource as everywhere else
        systemSettingsDialog.findViewById(R.id.continueButton).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                dismissDialog(systemSettingsDialog);
                if (settingsIntent == null) {
                    return;
                }
                // Enable settings once again, because the dialog may be shown more than 3 minutes
                // This is not necessary: the problem is resolved by clicking "Continue" in a popup window
                /*LocalBroadcastManager.getInstance( MainActivity.this ).sendBroadcast( new Intent( Const.ACTION_ENABLE_SETTINGS ) );
                // Open settings with a slight delay so Broadcast would certainly be handled
                handler.postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        startActivity(settingsIntent);
                    }
                }, 300);*/
                try {
                    startActivityOptionalResult(settingsIntent, requestCode);
                } catch (/*ActivityNotFound*/Exception e) {
                    // Open settings by default
                    startActivityOptionalResult(new Intent(android.provider.Settings.ACTION_SETTINGS), requestCode);
                }
            }
        });

        try {
            systemSettingsDialog.show();
        } catch (Exception e) {
            // BadTokenException: activity closed before dialog is shown
            RemoteLogger.log(this, Const.LOG_WARN, "Failed to open a popup system dialog! " + e.getMessage());
            e.printStackTrace();
            systemSettingsDialog = null;
        }
    }

    private void startActivityOptionalResult(Intent intent, Integer requestCode) {
        if (requestCode != null) {
            startActivityForResult(intent, requestCode);
        } else {
            startActivity(intent);
        }
    }

    // The following algorithm of launcher restart works in EMUI:
    // Run EMUI_LAUNCHER_RESTARTER activity once and send the old version number to it.
    // The restarter application will check the launcher version each second, and restart it
    // when it is changed.
    private void startLauncherRestarter() {
        // Sending an intent before updating, otherwise the launcher may be terminated at any time
        Intent intent = getPackageManager().getLaunchIntentForPackage(Const.LAUNCHER_RESTARTER_PACKAGE_ID);
        if (intent == null) {
            Log.i("LauncherRestarter", "No restarter app, please add it in the config!");
            return;
        }
        intent.putExtra(Const.LAUNCHER_RESTARTER_OLD_VERSION, BuildConfig.VERSION_NAME);
        startActivity(intent);
        Log.i("LauncherRestarter", "Calling launcher restarter from the launcher");
    }

    // Create a new file from the template file
    // (replace DEVICE_NUMBER, IMEI, CUSTOM* by their values)
    private void createFileFromTemplate(File srcFile, File dstFile, String deviceId, ServerConfig config) throws IOException {
        // We are supposed to process only small text files
        // So here we are reading the whole file, replacing variables, and save the content
        // It is not optimal for large files - it would be better to replace in a stream (how?)
        String content = FileUtils.readFileToString(srcFile);
        content = content.replace("DEVICE_NUMBER", deviceId)
                .replace("CUSTOM1", config.getCustom1() != null ? config.getCustom1() : "")
                .replace("CUSTOM2", config.getCustom2() != null ? config.getCustom2() : "")
                .replace("CUSTOM3", config.getCustom3() != null ? config.getCustom3() : "");
        FileUtils.writeStringToFile(dstFile, content);
    }
}
</file>

<file path="app/build.gradle">
/*
 * Headwind MDM: Open Source Android MDM Software
 * https://h-mdm.com
 *
 * Copyright (C) 2019 Headwind Solutions LLC (http://h-sms.com)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

buildscript {
    repositories {
        jcenter()
    }
}
apply plugin: 'com.android.application'

repositories {
    jcenter()
    mavenCentral()
}

android {
    compileSdkVersion 34
    defaultConfig {
        applicationId "com.hmdm.launcher"
        minSdkVersion 24
        targetSdkVersion 34
        versionCode 15250
        versionName "6.26"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        dataBinding {
            enabled = true
        }
        buildFeatures {
            aidl true
            buildConfig = true
        }
        namespace 'com.hmdm.launcher'
        multiDexEnabled true

        // Default URL of the web panel (scheme + host!)
        buildConfigField("String", "BASE_URL", "\"https://app.h-mdm.com\"")
        // URL of the secondary address of your web panel, called when the primary host is not available.
        // Could be equal to the BASE_URL parameter
        buildConfigField("String", "SECONDARY_BASE_URL", "\"https://app.h-mdm.com\"")
        // Relative path of the web panel on the server. Keep it empty if installed in the root
        buildConfigField("String", "SERVER_PROJECT", "\"\"")
        // This parameter manages how the device ID should be set up at first start
        // "user" - user enters it manually
        // "suggest" - user can select among few predefined values (IMEI, serial, MAC)
        // "imei", "serial", "mac" - set the selected parameter as device ID without user interaction
        buildConfigField("String", "DEVICE_ID_CHOICE", "\"user\"")
        // Enables Push notifications. Setting it to false will stop automatic configuration updates after changing it on the server.
        buildConfigField("Boolean", "ENABLE_PUSH", "true")
        // MQTT port for Push notifications
        buildConfigField("Integer", "MQTT_PORT", "31000")
        // Set this parameter to true if you'll grant system privileges to Headwind MDM (signing it by system keys).
        // This will enable silent installation and the launcher will try to get the device owner rights by updating system files.
        // This may be useful, for example, when your device doesn't have QR code provisioning capability.
        buildConfigField("Boolean", "SYSTEM_PRIVILEGES", "false")
        // Set this parameter to true if you'd like to trust every certificate, for example, self-signed
        // Not recommended for security purposes!
        buildConfigField("Boolean", "TRUST_ANY_CERTIFICATE", "false")
        // A shared secret to sign server config requests and MQTT (Push) messages
        buildConfigField("String", "REQUEST_SIGNATURE", "\"changeme-C3z9vi54\"")
        // Set this parameter to true if the server signature should be checked
        // (additional protection against Man-In-The-Middle attacks)
        buildConfigField("Boolean", "CHECK_SIGNATURE", "false")
        // ANR watchdog flag (for testing purposes only as this watchdog may drain the resources!)
        buildConfigField("Boolean", "ANR_WATCHDOG", "false")
        // If set to true, the server URL will be requested in UI in non-MDM mode even if it is hardcoded in build.gradle
        // See the related "if" statement in MainActivity.java
        buildConfigField("Boolean", "REQUEST_SERVER_URL", "true")
        // Set to true to debug admin receiver via remote logging
        buildConfigField("Boolean", "DEVICE_ADMIN_DEBUG", "false")
        // Set to true to enable kiosk mode even if the app can't draw over other windows
        // This may be required for weak devices where drawing over other windows is disabled by OS
        buildConfigField("Boolean", "ENABLE_KIOSK_WITHOUT_OVERLAYS", "false")
        // Foreground service for MQTT: prevents OS from killing MQTT service on weak devices
        buildConfigField("Boolean", "MQTT_SERVICE_FOREGROUND", "true")
        // Set Headwind MDM to default launcher at early time of the first start
        // to prevent the user from clicking Home and stop initializing Headwind MDM
        buildConfigField("Boolean", "SET_DEFAULT_LAUNCHER_EARLY", "false")
        // Adjust application selection on TV boxes
        buildConfigField("Boolean", "SELECTED_ITEM_BY_CLICK", "false")
        // Adjust application selection on TV boxes
        buildConfigField("Boolean", "DISABLE_ORIENTATION_LOCK", "false")
        // API key for the authorization of privileged library requests
        buildConfigField("String", "LIBRARY_API_KEY", "\"changeme-8gzk321W\"")
        // Use accessibility services to control unwanted apps
        // (this option is banned by Play Protect in some countries!)
        buildConfigField("Boolean", "USE_ACCESSIBILITY", "false")
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            debuggable false
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    packagingOptions {
        exclude 'META-INF/DEPENDENCIES.txt'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/NOTICE.md'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.md'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/notice.txt'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/dependencies.txt'
        exclude 'META-INF/LGPL2.1'
    }

    flavorDimensions "all"

    productFlavors {
        opensource { }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    androidTestImplementation('androidx.test.espresso:espresso-core:3.1.0', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    implementation 'androidx.appcompat:appcompat:1.1.0'
    testImplementation 'junit:junit:4.12'
    implementation 'androidx.recyclerview:recyclerview:1.1.0'
    implementation 'com.google.android.material:material:1.1.0'
    implementation 'androidx.localbroadcastmanager:localbroadcastmanager:1.0.0'

    // MQTT messaging
    implementation 'org.eclipse.paho:org.eclipse.paho.client.mqttv3:1.2.0'

    // Picassomk
    implementation 'com.squareup.picasso:picasso:2.5.2'
    implementation 'com.jakewharton.picasso:picasso2-okhttp3-downloader:1.1.0'

    // Retrofit
    implementation 'com.squareup.retrofit2:retrofit:2.3.0'
    implementation 'com.squareup.retrofit2:converter-jackson:2.3.0'
    implementation project(':flutter')
    // Jackson
    implementation 'com.fasterxml.jackson.core:jackson-core:2.9.4'
    implementation 'com.fasterxml.jackson.core:jackson-annotations:2.9.4'
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.4'

    // Worker
    implementation 'androidx.work:work-runtime:2.9.1'

    implementation('com.journeyapps:zxing-android-embedded:4.1.0') { transitive = false }
    implementation 'com.google.zxing:core:3.3.0'
    implementation group: 'commons-io', name: 'commons-io', version: '2.0.1'

    // JAX-B dependencies for JDK 9+
    implementation "jakarta.xml.bind:jakarta.xml.bind-api:2.3.2"
    implementation "org.glassfish.jaxb:jaxb-runtime:2.3.2"
}
</file>

</files>
